
//+
// C++ classes definitions for Bmad / C++ structure interface.
//
// This file is generated as part of the Bmad/C++ interface code generation.
// The code generation files can be found in cpp_bmad_interface.
//
// DO NOT EDIT THIS FILE DIRECTLY! 
//-

#ifndef CPP_BMAD_CLASSES

#include <string>
#include <valarray>
#include <complex>
#include "bmad_enums.h"

using namespace std;

typedef bool               Bool;
typedef complex<double>    Complex;
typedef double             Real;
typedef int                Int;
typedef char*              Char;

typedef const bool               c_Bool;
typedef const Complex            c_Complex;
typedef const double             c_Real;
typedef const int                c_Int;
typedef const string             c_String;
typedef const char*              c_Char;

typedef const bool*              c_BoolArr;
typedef const Complex*           c_ComplexArr;
typedef const double*            c_RealArr;
typedef const int*               c_IntArr;

typedef valarray<bool>           Bool_ARRAY;
typedef valarray<Complex>        Complex_ARRAY;
typedef valarray<double>         Real_ARRAY;
typedef valarray<int>            Int_ARRAY;
typedef valarray<string>         String_ARRAY;

typedef valarray<Bool_ARRAY>     Bool_MATRIX;
typedef valarray<Complex_ARRAY>  Complex_MATRIX;
typedef valarray<Real_ARRAY>     Real_MATRIX;
typedef valarray<Int_ARRAY>      Int_MATRIX;

typedef valarray<Bool_MATRIX>      Bool_TENSOR;
typedef valarray<Complex_MATRIX>   Complex_TENSOR;
typedef valarray<Real_MATRIX>      Real_TENSOR;
typedef valarray<Int_MATRIX>       Int_TENSOR;


class CPP_interval1_coef;
typedef valarray<CPP_interval1_coef>          CPP_interval1_coef_ARRAY;
typedef valarray<CPP_interval1_coef_ARRAY>    CPP_interval1_coef_MATRIX;
typedef valarray<CPP_interval1_coef_MATRIX>   CPP_interval1_coef_TENSOR;

class CPP_photon_reflect_table;
typedef valarray<CPP_photon_reflect_table>          CPP_photon_reflect_table_ARRAY;
typedef valarray<CPP_photon_reflect_table_ARRAY>    CPP_photon_reflect_table_MATRIX;
typedef valarray<CPP_photon_reflect_table_MATRIX>   CPP_photon_reflect_table_TENSOR;

class CPP_photon_reflect_surface;
typedef valarray<CPP_photon_reflect_surface>          CPP_photon_reflect_surface_ARRAY;
typedef valarray<CPP_photon_reflect_surface_ARRAY>    CPP_photon_reflect_surface_MATRIX;
typedef valarray<CPP_photon_reflect_surface_MATRIX>   CPP_photon_reflect_surface_TENSOR;

class CPP_coord;
typedef valarray<CPP_coord>          CPP_coord_ARRAY;
typedef valarray<CPP_coord_ARRAY>    CPP_coord_MATRIX;
typedef valarray<CPP_coord_MATRIX>   CPP_coord_TENSOR;

class CPP_coord_array;
typedef valarray<CPP_coord_array>          CPP_coord_array_ARRAY;
typedef valarray<CPP_coord_array_ARRAY>    CPP_coord_array_MATRIX;
typedef valarray<CPP_coord_array_MATRIX>   CPP_coord_array_TENSOR;

class CPP_bpm_phase_coupling;
typedef valarray<CPP_bpm_phase_coupling>          CPP_bpm_phase_coupling_ARRAY;
typedef valarray<CPP_bpm_phase_coupling_ARRAY>    CPP_bpm_phase_coupling_MATRIX;
typedef valarray<CPP_bpm_phase_coupling_MATRIX>   CPP_bpm_phase_coupling_TENSOR;

class CPP_wig_term;
typedef valarray<CPP_wig_term>          CPP_wig_term_ARRAY;
typedef valarray<CPP_wig_term_ARRAY>    CPP_wig_term_MATRIX;
typedef valarray<CPP_wig_term_MATRIX>   CPP_wig_term_TENSOR;

class CPP_wig;
typedef valarray<CPP_wig>          CPP_wig_ARRAY;
typedef valarray<CPP_wig_ARRAY>    CPP_wig_MATRIX;
typedef valarray<CPP_wig_MATRIX>   CPP_wig_TENSOR;

class CPP_wake_sr_mode;
typedef valarray<CPP_wake_sr_mode>          CPP_wake_sr_mode_ARRAY;
typedef valarray<CPP_wake_sr_mode_ARRAY>    CPP_wake_sr_mode_MATRIX;
typedef valarray<CPP_wake_sr_mode_MATRIX>   CPP_wake_sr_mode_TENSOR;

class CPP_wake_sr;
typedef valarray<CPP_wake_sr>          CPP_wake_sr_ARRAY;
typedef valarray<CPP_wake_sr_ARRAY>    CPP_wake_sr_MATRIX;
typedef valarray<CPP_wake_sr_MATRIX>   CPP_wake_sr_TENSOR;

class CPP_wake_lr;
typedef valarray<CPP_wake_lr>          CPP_wake_lr_ARRAY;
typedef valarray<CPP_wake_lr_ARRAY>    CPP_wake_lr_MATRIX;
typedef valarray<CPP_wake_lr_MATRIX>   CPP_wake_lr_TENSOR;

class CPP_lat_ele_loc;
typedef valarray<CPP_lat_ele_loc>          CPP_lat_ele_loc_ARRAY;
typedef valarray<CPP_lat_ele_loc_ARRAY>    CPP_lat_ele_loc_MATRIX;
typedef valarray<CPP_lat_ele_loc_MATRIX>   CPP_lat_ele_loc_TENSOR;

class CPP_wake;
typedef valarray<CPP_wake>          CPP_wake_ARRAY;
typedef valarray<CPP_wake_ARRAY>    CPP_wake_MATRIX;
typedef valarray<CPP_wake_MATRIX>   CPP_wake_TENSOR;

class CPP_em_field_map_term;
typedef valarray<CPP_em_field_map_term>          CPP_em_field_map_term_ARRAY;
typedef valarray<CPP_em_field_map_term_ARRAY>    CPP_em_field_map_term_MATRIX;
typedef valarray<CPP_em_field_map_term_MATRIX>   CPP_em_field_map_term_TENSOR;

class CPP_em_field_map;
typedef valarray<CPP_em_field_map>          CPP_em_field_map_ARRAY;
typedef valarray<CPP_em_field_map_ARRAY>    CPP_em_field_map_MATRIX;
typedef valarray<CPP_em_field_map_MATRIX>   CPP_em_field_map_TENSOR;

class CPP_em_field_grid_pt;
typedef valarray<CPP_em_field_grid_pt>          CPP_em_field_grid_pt_ARRAY;
typedef valarray<CPP_em_field_grid_pt_ARRAY>    CPP_em_field_grid_pt_MATRIX;
typedef valarray<CPP_em_field_grid_pt_MATRIX>   CPP_em_field_grid_pt_TENSOR;

class CPP_em_field_grid;
typedef valarray<CPP_em_field_grid>          CPP_em_field_grid_ARRAY;
typedef valarray<CPP_em_field_grid_ARRAY>    CPP_em_field_grid_MATRIX;
typedef valarray<CPP_em_field_grid_MATRIX>   CPP_em_field_grid_TENSOR;

class CPP_em_field_mode;
typedef valarray<CPP_em_field_mode>          CPP_em_field_mode_ARRAY;
typedef valarray<CPP_em_field_mode_ARRAY>    CPP_em_field_mode_MATRIX;
typedef valarray<CPP_em_field_mode_MATRIX>   CPP_em_field_mode_TENSOR;

class CPP_em_fields;
typedef valarray<CPP_em_fields>          CPP_em_fields_ARRAY;
typedef valarray<CPP_em_fields_ARRAY>    CPP_em_fields_MATRIX;
typedef valarray<CPP_em_fields_MATRIX>   CPP_em_fields_TENSOR;

class CPP_floor_position;
typedef valarray<CPP_floor_position>          CPP_floor_position_ARRAY;
typedef valarray<CPP_floor_position_ARRAY>    CPP_floor_position_MATRIX;
typedef valarray<CPP_floor_position_MATRIX>   CPP_floor_position_TENSOR;

class CPP_space_charge;
typedef valarray<CPP_space_charge>          CPP_space_charge_ARRAY;
typedef valarray<CPP_space_charge_ARRAY>    CPP_space_charge_MATRIX;
typedef valarray<CPP_space_charge_MATRIX>   CPP_space_charge_TENSOR;

class CPP_xy_disp;
typedef valarray<CPP_xy_disp>          CPP_xy_disp_ARRAY;
typedef valarray<CPP_xy_disp_ARRAY>    CPP_xy_disp_MATRIX;
typedef valarray<CPP_xy_disp_MATRIX>   CPP_xy_disp_TENSOR;

class CPP_twiss;
typedef valarray<CPP_twiss>          CPP_twiss_ARRAY;
typedef valarray<CPP_twiss_ARRAY>    CPP_twiss_MATRIX;
typedef valarray<CPP_twiss_MATRIX>   CPP_twiss_TENSOR;

class CPP_mode3;
typedef valarray<CPP_mode3>          CPP_mode3_ARRAY;
typedef valarray<CPP_mode3_ARRAY>    CPP_mode3_MATRIX;
typedef valarray<CPP_mode3_MATRIX>   CPP_mode3_TENSOR;

class CPP_bookkeeping_state;
typedef valarray<CPP_bookkeeping_state>          CPP_bookkeeping_state_ARRAY;
typedef valarray<CPP_bookkeeping_state_ARRAY>    CPP_bookkeeping_state_MATRIX;
typedef valarray<CPP_bookkeeping_state_MATRIX>   CPP_bookkeeping_state_TENSOR;

class CPP_rad_int_ele_cache;
typedef valarray<CPP_rad_int_ele_cache>          CPP_rad_int_ele_cache_ARRAY;
typedef valarray<CPP_rad_int_ele_cache_ARRAY>    CPP_rad_int_ele_cache_MATRIX;
typedef valarray<CPP_rad_int_ele_cache_MATRIX>   CPP_rad_int_ele_cache_TENSOR;

class CPP_surface_grid_pt;
typedef valarray<CPP_surface_grid_pt>          CPP_surface_grid_pt_ARRAY;
typedef valarray<CPP_surface_grid_pt_ARRAY>    CPP_surface_grid_pt_MATRIX;
typedef valarray<CPP_surface_grid_pt_MATRIX>   CPP_surface_grid_pt_TENSOR;

class CPP_surface_grid;
typedef valarray<CPP_surface_grid>          CPP_surface_grid_ARRAY;
typedef valarray<CPP_surface_grid_ARRAY>    CPP_surface_grid_MATRIX;
typedef valarray<CPP_surface_grid_MATRIX>   CPP_surface_grid_TENSOR;

class CPP_segmented_surface;
typedef valarray<CPP_segmented_surface>          CPP_segmented_surface_ARRAY;
typedef valarray<CPP_segmented_surface_ARRAY>    CPP_segmented_surface_MATRIX;
typedef valarray<CPP_segmented_surface_MATRIX>   CPP_segmented_surface_TENSOR;

class CPP_target_point;
typedef valarray<CPP_target_point>          CPP_target_point_ARRAY;
typedef valarray<CPP_target_point_ARRAY>    CPP_target_point_MATRIX;
typedef valarray<CPP_target_point_MATRIX>   CPP_target_point_TENSOR;

class CPP_photon_surface;
typedef valarray<CPP_photon_surface>          CPP_photon_surface_ARRAY;
typedef valarray<CPP_photon_surface_ARRAY>    CPP_photon_surface_MATRIX;
typedef valarray<CPP_photon_surface_MATRIX>   CPP_photon_surface_TENSOR;

class CPP_photon_target;
typedef valarray<CPP_photon_target>          CPP_photon_target_ARRAY;
typedef valarray<CPP_photon_target_ARRAY>    CPP_photon_target_MATRIX;
typedef valarray<CPP_photon_target_MATRIX>   CPP_photon_target_TENSOR;

class CPP_photon_material;
typedef valarray<CPP_photon_material>          CPP_photon_material_ARRAY;
typedef valarray<CPP_photon_material_ARRAY>    CPP_photon_material_MATRIX;
typedef valarray<CPP_photon_material_MATRIX>   CPP_photon_material_TENSOR;

class CPP_photon_element;
typedef valarray<CPP_photon_element>          CPP_photon_element_ARRAY;
typedef valarray<CPP_photon_element_ARRAY>    CPP_photon_element_MATRIX;
typedef valarray<CPP_photon_element_MATRIX>   CPP_photon_element_TENSOR;

class CPP_wall3d_vertex;
typedef valarray<CPP_wall3d_vertex>          CPP_wall3d_vertex_ARRAY;
typedef valarray<CPP_wall3d_vertex_ARRAY>    CPP_wall3d_vertex_MATRIX;
typedef valarray<CPP_wall3d_vertex_MATRIX>   CPP_wall3d_vertex_TENSOR;

class CPP_wall3d_section;
typedef valarray<CPP_wall3d_section>          CPP_wall3d_section_ARRAY;
typedef valarray<CPP_wall3d_section_ARRAY>    CPP_wall3d_section_MATRIX;
typedef valarray<CPP_wall3d_section_MATRIX>   CPP_wall3d_section_TENSOR;

class CPP_wall3d;
typedef valarray<CPP_wall3d>          CPP_wall3d_ARRAY;
typedef valarray<CPP_wall3d_ARRAY>    CPP_wall3d_MATRIX;
typedef valarray<CPP_wall3d_MATRIX>   CPP_wall3d_TENSOR;

class CPP_taylor_term;
typedef valarray<CPP_taylor_term>          CPP_taylor_term_ARRAY;
typedef valarray<CPP_taylor_term_ARRAY>    CPP_taylor_term_MATRIX;
typedef valarray<CPP_taylor_term_MATRIX>   CPP_taylor_term_TENSOR;

class CPP_taylor;
typedef valarray<CPP_taylor>          CPP_taylor_ARRAY;
typedef valarray<CPP_taylor_ARRAY>    CPP_taylor_MATRIX;
typedef valarray<CPP_taylor_MATRIX>   CPP_taylor_TENSOR;

class CPP_control;
typedef valarray<CPP_control>          CPP_control_ARRAY;
typedef valarray<CPP_control_ARRAY>    CPP_control_MATRIX;
typedef valarray<CPP_control_MATRIX>   CPP_control_TENSOR;

class CPP_lat_param;
typedef valarray<CPP_lat_param>          CPP_lat_param_ARRAY;
typedef valarray<CPP_lat_param_ARRAY>    CPP_lat_param_MATRIX;
typedef valarray<CPP_lat_param_MATRIX>   CPP_lat_param_TENSOR;

class CPP_mode_info;
typedef valarray<CPP_mode_info>          CPP_mode_info_ARRAY;
typedef valarray<CPP_mode_info_ARRAY>    CPP_mode_info_MATRIX;
typedef valarray<CPP_mode_info_MATRIX>   CPP_mode_info_TENSOR;

class CPP_pre_tracker;
typedef valarray<CPP_pre_tracker>          CPP_pre_tracker_ARRAY;
typedef valarray<CPP_pre_tracker_ARRAY>    CPP_pre_tracker_MATRIX;
typedef valarray<CPP_pre_tracker_MATRIX>   CPP_pre_tracker_TENSOR;

class CPP_anormal_mode;
typedef valarray<CPP_anormal_mode>          CPP_anormal_mode_ARRAY;
typedef valarray<CPP_anormal_mode_ARRAY>    CPP_anormal_mode_MATRIX;
typedef valarray<CPP_anormal_mode_MATRIX>   CPP_anormal_mode_TENSOR;

class CPP_linac_normal_mode;
typedef valarray<CPP_linac_normal_mode>          CPP_linac_normal_mode_ARRAY;
typedef valarray<CPP_linac_normal_mode_ARRAY>    CPP_linac_normal_mode_MATRIX;
typedef valarray<CPP_linac_normal_mode_MATRIX>   CPP_linac_normal_mode_TENSOR;

class CPP_normal_modes;
typedef valarray<CPP_normal_modes>          CPP_normal_modes_ARRAY;
typedef valarray<CPP_normal_modes_ARRAY>    CPP_normal_modes_MATRIX;
typedef valarray<CPP_normal_modes_MATRIX>   CPP_normal_modes_TENSOR;

class CPP_em_field;
typedef valarray<CPP_em_field>          CPP_em_field_ARRAY;
typedef valarray<CPP_em_field_ARRAY>    CPP_em_field_MATRIX;
typedef valarray<CPP_em_field_MATRIX>   CPP_em_field_TENSOR;

class CPP_track_map;
typedef valarray<CPP_track_map>          CPP_track_map_ARRAY;
typedef valarray<CPP_track_map_ARRAY>    CPP_track_map_MATRIX;
typedef valarray<CPP_track_map_MATRIX>   CPP_track_map_TENSOR;

class CPP_track;
typedef valarray<CPP_track>          CPP_track_ARRAY;
typedef valarray<CPP_track_ARRAY>    CPP_track_MATRIX;
typedef valarray<CPP_track_MATRIX>   CPP_track_TENSOR;

class CPP_synch_rad_common;
typedef valarray<CPP_synch_rad_common>          CPP_synch_rad_common_ARRAY;
typedef valarray<CPP_synch_rad_common_ARRAY>    CPP_synch_rad_common_MATRIX;
typedef valarray<CPP_synch_rad_common_MATRIX>   CPP_synch_rad_common_TENSOR;

class CPP_csr_parameter;
typedef valarray<CPP_csr_parameter>          CPP_csr_parameter_ARRAY;
typedef valarray<CPP_csr_parameter_ARRAY>    CPP_csr_parameter_MATRIX;
typedef valarray<CPP_csr_parameter_MATRIX>   CPP_csr_parameter_TENSOR;

class CPP_bmad_common;
typedef valarray<CPP_bmad_common>          CPP_bmad_common_ARRAY;
typedef valarray<CPP_bmad_common_ARRAY>    CPP_bmad_common_MATRIX;
typedef valarray<CPP_bmad_common_MATRIX>   CPP_bmad_common_TENSOR;

class CPP_rad_int1;
typedef valarray<CPP_rad_int1>          CPP_rad_int1_ARRAY;
typedef valarray<CPP_rad_int1_ARRAY>    CPP_rad_int1_MATRIX;
typedef valarray<CPP_rad_int1_MATRIX>   CPP_rad_int1_TENSOR;

class CPP_rad_int_all_ele;
typedef valarray<CPP_rad_int_all_ele>          CPP_rad_int_all_ele_ARRAY;
typedef valarray<CPP_rad_int_all_ele_ARRAY>    CPP_rad_int_all_ele_MATRIX;
typedef valarray<CPP_rad_int_all_ele_MATRIX>   CPP_rad_int_all_ele_TENSOR;

class CPP_ele;
typedef valarray<CPP_ele>          CPP_ele_ARRAY;
typedef valarray<CPP_ele_ARRAY>    CPP_ele_MATRIX;
typedef valarray<CPP_ele_MATRIX>   CPP_ele_TENSOR;

class CPP_complex_taylor_term;
typedef valarray<CPP_complex_taylor_term>          CPP_complex_taylor_term_ARRAY;
typedef valarray<CPP_complex_taylor_term_ARRAY>    CPP_complex_taylor_term_MATRIX;
typedef valarray<CPP_complex_taylor_term_MATRIX>   CPP_complex_taylor_term_TENSOR;

class CPP_complex_taylor;
typedef valarray<CPP_complex_taylor>          CPP_complex_taylor_ARRAY;
typedef valarray<CPP_complex_taylor_ARRAY>    CPP_complex_taylor_MATRIX;
typedef valarray<CPP_complex_taylor_MATRIX>   CPP_complex_taylor_TENSOR;

class CPP_normal_form;
typedef valarray<CPP_normal_form>          CPP_normal_form_ARRAY;
typedef valarray<CPP_normal_form_ARRAY>    CPP_normal_form_MATRIX;
typedef valarray<CPP_normal_form_MATRIX>   CPP_normal_form_TENSOR;

class CPP_branch;
typedef valarray<CPP_branch>          CPP_branch_ARRAY;
typedef valarray<CPP_branch_ARRAY>    CPP_branch_MATRIX;
typedef valarray<CPP_branch_MATRIX>   CPP_branch_TENSOR;

class CPP_lat;
typedef valarray<CPP_lat>          CPP_lat_ARRAY;
typedef valarray<CPP_lat_ARRAY>    CPP_lat_MATRIX;
typedef valarray<CPP_lat_MATRIX>   CPP_lat_TENSOR;

class CPP_bunch;
typedef valarray<CPP_bunch>          CPP_bunch_ARRAY;
typedef valarray<CPP_bunch_ARRAY>    CPP_bunch_MATRIX;
typedef valarray<CPP_bunch_MATRIX>   CPP_bunch_TENSOR;

class CPP_beam_spin;
typedef valarray<CPP_beam_spin>          CPP_beam_spin_ARRAY;
typedef valarray<CPP_beam_spin_ARRAY>    CPP_beam_spin_MATRIX;
typedef valarray<CPP_beam_spin_MATRIX>   CPP_beam_spin_TENSOR;

class CPP_bunch_params;
typedef valarray<CPP_bunch_params>          CPP_bunch_params_ARRAY;
typedef valarray<CPP_bunch_params_ARRAY>    CPP_bunch_params_MATRIX;
typedef valarray<CPP_bunch_params_MATRIX>   CPP_bunch_params_TENSOR;

class CPP_beam;
typedef valarray<CPP_beam>          CPP_beam_ARRAY;
typedef valarray<CPP_beam_ARRAY>    CPP_beam_MATRIX;
typedef valarray<CPP_beam_MATRIX>   CPP_beam_TENSOR;

//--------------------------------------------------------------------
// CPP_interval1_coef

class Bmad_interval1_coef_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_interval1_coef {
public:
  Real c0;
  Real c1;
  Real n_exp;

  CPP_interval1_coef() :
    c0(0.0),
    c1(0.0),
    n_exp(0.0)
    {}

  ~CPP_interval1_coef() {
  }

};   // End Class

extern "C" void interval1_coef_to_c (const Bmad_interval1_coef_class*, CPP_interval1_coef&);
extern "C" void interval1_coef_to_f (const CPP_interval1_coef&, Bmad_interval1_coef_class*);

bool operator== (const CPP_interval1_coef&, const CPP_interval1_coef&);


//--------------------------------------------------------------------
// CPP_photon_reflect_table

class Bmad_photon_reflect_table_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_reflect_table {
public:
  Real_ARRAY angle;
  Real_ARRAY energy;
  CPP_interval1_coef_ARRAY int1;
  Real_MATRIX p_reflect;
  Real max_energy;
  Real_ARRAY p_reflect_scratch;

  CPP_photon_reflect_table() :
    angle(0.0, 0),
    energy(0.0, 0),
    int1(CPP_interval1_coef_ARRAY(CPP_interval1_coef(), 0)),
    p_reflect(Real_ARRAY(0.0, 0), 0),
    max_energy(0.0),
    p_reflect_scratch(0.0, 0)
    {}

  ~CPP_photon_reflect_table() {
  }

};   // End Class

extern "C" void photon_reflect_table_to_c (const Bmad_photon_reflect_table_class*, CPP_photon_reflect_table&);
extern "C" void photon_reflect_table_to_f (const CPP_photon_reflect_table&, Bmad_photon_reflect_table_class*);

bool operator== (const CPP_photon_reflect_table&, const CPP_photon_reflect_table&);


//--------------------------------------------------------------------
// CPP_photon_reflect_surface

class Bmad_photon_reflect_surface_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_reflect_surface {
public:
  string descrip;
  string reflectivity_file;
  CPP_photon_reflect_table_ARRAY table;
  Real surface_roughness_rms;
  Real roughness_correlation_len;
  Bool initialized;
  Int ix_surface;

  CPP_photon_reflect_surface() :
    descrip(),
    reflectivity_file(),
    table(CPP_photon_reflect_table_ARRAY(CPP_photon_reflect_table(), 0)),
    surface_roughness_rms(0.0),
    roughness_correlation_len(0.0),
    initialized(false),
    ix_surface(0)
    {}

  ~CPP_photon_reflect_surface() {
  }

};   // End Class

extern "C" void photon_reflect_surface_to_c (const Bmad_photon_reflect_surface_class*, CPP_photon_reflect_surface&);
extern "C" void photon_reflect_surface_to_f (const CPP_photon_reflect_surface&, Bmad_photon_reflect_surface_class*);

bool operator== (const CPP_photon_reflect_surface&, const CPP_photon_reflect_surface&);


//--------------------------------------------------------------------
// CPP_coord

class Bmad_coord_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_coord {
public:
  Real_ARRAY vec;
  Real s;
  Real t;
  Complex_ARRAY spin;
  Real_ARRAY field;
  Real_ARRAY phase;
  Real charge;
  Real path_len;
  Real p0c;
  Real beta;
  Int ix_ele;
  Int state;
  Int direction;
  Int species;
  Int location;

  CPP_coord() :
    vec(0.0, 6),
    s(0.0),
    t(0.0),
    spin(0.0, 2),
    field(0.0, 2),
    phase(0.0, 2),
    charge(0.0),
    path_len(0.0),
    p0c(0.0),
    beta(-1),
    ix_ele(-1),
    state(Bmad::NOT_SET),
    direction(1),
    species(Bmad::NOT_SET),
    location(Bmad::UPSTREAM_END)
    {}

  ~CPP_coord() {
  }

};   // End Class

extern "C" void coord_to_c (const Bmad_coord_class*, CPP_coord&);
extern "C" void coord_to_f (const CPP_coord&, Bmad_coord_class*);

bool operator== (const CPP_coord&, const CPP_coord&);


//--------------------------------------------------------------------
// CPP_coord_array

class Bmad_coord_array_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_coord_array {
public:
  CPP_coord_ARRAY orb;

  CPP_coord_array() :
    orb(CPP_coord_ARRAY(CPP_coord(), 0))
    {}

  ~CPP_coord_array() {
  }

};   // End Class

extern "C" void coord_array_to_c (const Bmad_coord_array_class*, CPP_coord_array&);
extern "C" void coord_array_to_f (const CPP_coord_array&, Bmad_coord_array_class*);

bool operator== (const CPP_coord_array&, const CPP_coord_array&);


//--------------------------------------------------------------------
// CPP_bpm_phase_coupling

class Bmad_bpm_phase_coupling_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_bpm_phase_coupling {
public:
  Real k_22a;
  Real k_12a;
  Real k_11b;
  Real k_12b;
  Real cbar22_a;
  Real cbar12_a;
  Real cbar11_b;
  Real cbar12_b;
  Real phi_a;
  Real phi_b;

  CPP_bpm_phase_coupling() :
    k_22a(0.0),
    k_12a(0.0),
    k_11b(0.0),
    k_12b(0.0),
    cbar22_a(0.0),
    cbar12_a(0.0),
    cbar11_b(0.0),
    cbar12_b(0.0),
    phi_a(0.0),
    phi_b(0.0)
    {}

  ~CPP_bpm_phase_coupling() {
  }

};   // End Class

extern "C" void bpm_phase_coupling_to_c (const Bmad_bpm_phase_coupling_class*, CPP_bpm_phase_coupling&);
extern "C" void bpm_phase_coupling_to_f (const CPP_bpm_phase_coupling&, Bmad_bpm_phase_coupling_class*);

bool operator== (const CPP_bpm_phase_coupling&, const CPP_bpm_phase_coupling&);


//--------------------------------------------------------------------
// CPP_wig_term

class Bmad_wig_term_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wig_term {
public:
  Real coef;
  Real kx;
  Real ky;
  Real kz;
  Real phi_z;
  Int type;

  CPP_wig_term() :
    coef(0.0),
    kx(0.0),
    ky(0.0),
    kz(0.0),
    phi_z(0.0),
    type(0)
    {}

  ~CPP_wig_term() {
  }

};   // End Class

extern "C" void wig_term_to_c (const Bmad_wig_term_class*, CPP_wig_term&);
extern "C" void wig_term_to_f (const CPP_wig_term&, Bmad_wig_term_class*);

bool operator== (const CPP_wig_term&, const CPP_wig_term&);


//--------------------------------------------------------------------
// CPP_wig

class Bmad_wig_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wig {
public:
  Int n_link;
  CPP_wig_term_ARRAY term;

  CPP_wig() :
    n_link(1),
    term(CPP_wig_term_ARRAY(CPP_wig_term(), 0))
    {}

  ~CPP_wig() {
  }

};   // End Class

extern "C" void wig_to_c (const Bmad_wig_class*, CPP_wig&);
extern "C" void wig_to_f (const CPP_wig&, Bmad_wig_class*);

bool operator== (const CPP_wig&, const CPP_wig&);


//--------------------------------------------------------------------
// CPP_wake_sr_mode

class Bmad_wake_sr_mode_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wake_sr_mode {
public:
  Real amp;
  Real damp;
  Real k;
  Real phi;
  Real b_sin;
  Real b_cos;
  Real a_sin;
  Real a_cos;
  Int polarization;
  Int transverse_dependence;

  CPP_wake_sr_mode() :
    amp(0.0),
    damp(0.0),
    k(0.0),
    phi(0.0),
    b_sin(0.0),
    b_cos(0.0),
    a_sin(0.0),
    a_cos(0.0),
    polarization(Bmad::NONE),
    transverse_dependence(Bmad::NOT_SET)
    {}

  ~CPP_wake_sr_mode() {
  }

};   // End Class

extern "C" void wake_sr_mode_to_c (const Bmad_wake_sr_mode_class*, CPP_wake_sr_mode&);
extern "C" void wake_sr_mode_to_f (const CPP_wake_sr_mode&, Bmad_wake_sr_mode_class*);

bool operator== (const CPP_wake_sr_mode&, const CPP_wake_sr_mode&);


//--------------------------------------------------------------------
// CPP_wake_sr

class Bmad_wake_sr_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wake_sr {
public:
  CPP_wake_sr_mode_ARRAY mode;
  Real z_ref;

  CPP_wake_sr() :
    mode(CPP_wake_sr_mode_ARRAY(CPP_wake_sr_mode(), 0)),
    z_ref(0.0)
    {}

  ~CPP_wake_sr() {
  }

};   // End Class

extern "C" void wake_sr_to_c (const Bmad_wake_sr_class*, CPP_wake_sr&);
extern "C" void wake_sr_to_f (const CPP_wake_sr&, Bmad_wake_sr_class*);

bool operator== (const CPP_wake_sr&, const CPP_wake_sr&);


//--------------------------------------------------------------------
// CPP_wake_lr

class Bmad_wake_lr_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wake_lr {
public:
  Real freq;
  Real freq_in;
  Real r_over_q;
  Real q;
  Real angle;
  Real b_sin;
  Real b_cos;
  Real a_sin;
  Real a_cos;
  Real t_ref;
  Int m;
  Bool polarized;

  CPP_wake_lr() :
    freq(0.0),
    freq_in(0.0),
    r_over_q(0.0),
    q(0.0),
    angle(0.0),
    b_sin(0.0),
    b_cos(0.0),
    a_sin(0.0),
    a_cos(0.0),
    t_ref(0.0),
    m(0),
    polarized(false)
    {}

  ~CPP_wake_lr() {
  }

};   // End Class

extern "C" void wake_lr_to_c (const Bmad_wake_lr_class*, CPP_wake_lr&);
extern "C" void wake_lr_to_f (const CPP_wake_lr&, Bmad_wake_lr_class*);

bool operator== (const CPP_wake_lr&, const CPP_wake_lr&);


//--------------------------------------------------------------------
// CPP_lat_ele_loc

class Bmad_lat_ele_loc_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_lat_ele_loc {
public:
  Int ix_ele;
  Int ix_branch;

  CPP_lat_ele_loc() :
    ix_ele(-1),
    ix_branch(0)
    {}

  ~CPP_lat_ele_loc() {
  }

};   // End Class

extern "C" void lat_ele_loc_to_c (const Bmad_lat_ele_loc_class*, CPP_lat_ele_loc&);
extern "C" void lat_ele_loc_to_f (const CPP_lat_ele_loc&, Bmad_lat_ele_loc_class*);

bool operator== (const CPP_lat_ele_loc&, const CPP_lat_ele_loc&);


//--------------------------------------------------------------------
// CPP_wake

class Bmad_wake_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wake {
public:
  string sr_file;
  string lr_file;
  CPP_wake_sr sr_long;
  CPP_wake_sr sr_trans;
  CPP_wake_lr_ARRAY lr;
  Real z_sr_max;

  CPP_wake() :
    sr_file(),
    lr_file(),
    sr_long(),
    sr_trans(),
    lr(CPP_wake_lr_ARRAY(CPP_wake_lr(), 0)),
    z_sr_max(0.0)
    {}

  ~CPP_wake() {
  }

};   // End Class

extern "C" void wake_to_c (const Bmad_wake_class*, CPP_wake&);
extern "C" void wake_to_f (const CPP_wake&, Bmad_wake_class*);

bool operator== (const CPP_wake&, const CPP_wake&);


//--------------------------------------------------------------------
// CPP_em_field_map_term

class Bmad_em_field_map_term_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_em_field_map_term {
public:
  Complex e_coef;
  Complex b_coef;

  CPP_em_field_map_term() :
    e_coef(0.0),
    b_coef(0.0)
    {}

  ~CPP_em_field_map_term() {
  }

};   // End Class

extern "C" void em_field_map_term_to_c (const Bmad_em_field_map_term_class*, CPP_em_field_map_term&);
extern "C" void em_field_map_term_to_f (const CPP_em_field_map_term&, Bmad_em_field_map_term_class*);

bool operator== (const CPP_em_field_map_term&, const CPP_em_field_map_term&);


//--------------------------------------------------------------------
// CPP_em_field_map

class Bmad_em_field_map_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_em_field_map {
public:
  string file;
  Int n_link;
  Int ele_anchor_pt;
  Real dz;
  CPP_em_field_map_term_ARRAY term;

  CPP_em_field_map() :
    file(),
    n_link(1),
    ele_anchor_pt(Bmad::ANCHOR_BEGINNING),
    dz(0.0),
    term(CPP_em_field_map_term_ARRAY(CPP_em_field_map_term(), 0))
    {}

  ~CPP_em_field_map() {
  }

};   // End Class

extern "C" void em_field_map_to_c (const Bmad_em_field_map_class*, CPP_em_field_map&);
extern "C" void em_field_map_to_f (const CPP_em_field_map&, Bmad_em_field_map_class*);

bool operator== (const CPP_em_field_map&, const CPP_em_field_map&);


//--------------------------------------------------------------------
// CPP_em_field_grid_pt

class Bmad_em_field_grid_pt_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_em_field_grid_pt {
public:
  Complex_ARRAY e;
  Complex_ARRAY b;

  CPP_em_field_grid_pt() :
    e(0.0, 3),
    b(0.0, 3)
    {}

  ~CPP_em_field_grid_pt() {
  }

};   // End Class

extern "C" void em_field_grid_pt_to_c (const Bmad_em_field_grid_pt_class*, CPP_em_field_grid_pt&);
extern "C" void em_field_grid_pt_to_f (const CPP_em_field_grid_pt&, Bmad_em_field_grid_pt_class*);

bool operator== (const CPP_em_field_grid_pt&, const CPP_em_field_grid_pt&);


//--------------------------------------------------------------------
// CPP_em_field_grid

class Bmad_em_field_grid_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_em_field_grid {
public:
  string file;
  Int type;
  Int ele_anchor_pt;
  Int n_link;
  CPP_em_field_grid_pt_TENSOR pt;
  Real_ARRAY dr;
  Real_ARRAY r0;

  CPP_em_field_grid() :
    file(),
    type(0),
    ele_anchor_pt(Bmad::ANCHOR_BEGINNING),
    n_link(1),
    pt(CPP_em_field_grid_pt_MATRIX(CPP_em_field_grid_pt_ARRAY(CPP_em_field_grid_pt(), 0), 0), 0),
    dr(0.0, 3),
    r0(0.0, 3)
    {}

  ~CPP_em_field_grid() {
  }

};   // End Class

extern "C" void em_field_grid_to_c (const Bmad_em_field_grid_class*, CPP_em_field_grid&);
extern "C" void em_field_grid_to_f (const CPP_em_field_grid&, Bmad_em_field_grid_class*);

bool operator== (const CPP_em_field_grid&, const CPP_em_field_grid&);


//--------------------------------------------------------------------
// CPP_em_field_mode

class Bmad_em_field_mode_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_em_field_mode {
public:
  Int m;
  Int harmonic;
  Real f_damp;
  Real phi0_ref;
  Real stored_energy;
  Real phi0_azimuth;
  Real field_scale;
  Int master_scale;
  CPP_em_field_map* map;
  CPP_em_field_grid* grid;

  CPP_em_field_mode() :
    m(0),
    harmonic(0),
    f_damp(0.0),
    phi0_ref(0.0),
    stored_energy(0.0),
    phi0_azimuth(0.0),
    field_scale(1),
    master_scale(0),
    map(NULL),
    grid(NULL)
    {}

  ~CPP_em_field_mode() {
    delete map;
    delete grid;
  }

};   // End Class

extern "C" void em_field_mode_to_c (const Bmad_em_field_mode_class*, CPP_em_field_mode&);
extern "C" void em_field_mode_to_f (const CPP_em_field_mode&, Bmad_em_field_mode_class*);

bool operator== (const CPP_em_field_mode&, const CPP_em_field_mode&);


//--------------------------------------------------------------------
// CPP_em_fields

class Bmad_em_fields_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_em_fields {
public:
  CPP_em_field_mode_ARRAY mode;
  Int mode_to_autoscale;

  CPP_em_fields() :
    mode(CPP_em_field_mode_ARRAY(CPP_em_field_mode(), 0)),
    mode_to_autoscale(1)
    {}

  ~CPP_em_fields() {
  }

};   // End Class

extern "C" void em_fields_to_c (const Bmad_em_fields_class*, CPP_em_fields&);
extern "C" void em_fields_to_f (const CPP_em_fields&, Bmad_em_fields_class*);

bool operator== (const CPP_em_fields&, const CPP_em_fields&);


//--------------------------------------------------------------------
// CPP_floor_position

class Bmad_floor_position_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_floor_position {
public:
  Real_ARRAY r;
  Real theta;
  Real phi;
  Real psi;

  CPP_floor_position() :
    r(0.0, 3),
    theta(0.0),
    phi(0.0),
    psi(0.0)
    {}

  ~CPP_floor_position() {
  }

};   // End Class

extern "C" void floor_position_to_c (const Bmad_floor_position_class*, CPP_floor_position&);
extern "C" void floor_position_to_f (const CPP_floor_position&, Bmad_floor_position_class*);

bool operator== (const CPP_floor_position&, const CPP_floor_position&);


//--------------------------------------------------------------------
// CPP_space_charge

class Bmad_space_charge_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_space_charge {
public:
  CPP_coord closed_orb;
  Real kick_const;
  Real sig_x;
  Real sig_y;
  Real phi;
  Real sin_phi;
  Real cos_phi;
  Real sig_z;

  CPP_space_charge() :
    closed_orb(),
    kick_const(0.0),
    sig_x(0.0),
    sig_y(0.0),
    phi(0.0),
    sin_phi(0.0),
    cos_phi(0.0),
    sig_z(0.0)
    {}

  ~CPP_space_charge() {
  }

};   // End Class

extern "C" void space_charge_to_c (const Bmad_space_charge_class*, CPP_space_charge&);
extern "C" void space_charge_to_f (const CPP_space_charge&, Bmad_space_charge_class*);

bool operator== (const CPP_space_charge&, const CPP_space_charge&);


//--------------------------------------------------------------------
// CPP_xy_disp

class Bmad_xy_disp_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_xy_disp {
public:
  Real eta;
  Real etap;

  CPP_xy_disp() :
    eta(0.0),
    etap(0.0)
    {}

  ~CPP_xy_disp() {
  }

};   // End Class

extern "C" void xy_disp_to_c (const Bmad_xy_disp_class*, CPP_xy_disp&);
extern "C" void xy_disp_to_f (const CPP_xy_disp&, Bmad_xy_disp_class*);

bool operator== (const CPP_xy_disp&, const CPP_xy_disp&);


//--------------------------------------------------------------------
// CPP_twiss

class Bmad_twiss_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_twiss {
public:
  Real beta;
  Real alpha;
  Real gamma;
  Real phi;
  Real eta;
  Real etap;
  Real sigma;
  Real sigma_p;
  Real emit;
  Real norm_emit;

  CPP_twiss() :
    beta(0.0),
    alpha(0.0),
    gamma(0.0),
    phi(0.0),
    eta(0.0),
    etap(0.0),
    sigma(0.0),
    sigma_p(0.0),
    emit(0.0),
    norm_emit(0.0)
    {}

  ~CPP_twiss() {
  }

};   // End Class

extern "C" void twiss_to_c (const Bmad_twiss_class*, CPP_twiss&);
extern "C" void twiss_to_f (const CPP_twiss&, Bmad_twiss_class*);

bool operator== (const CPP_twiss&, const CPP_twiss&);


//--------------------------------------------------------------------
// CPP_mode3

class Bmad_mode3_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_mode3 {
public:
  Real_MATRIX v;
  CPP_twiss a;
  CPP_twiss b;
  CPP_twiss c;
  CPP_twiss x;
  CPP_twiss y;

  CPP_mode3() :
    v(Real_ARRAY(0.0, 6), 6),
    a(),
    b(),
    c(),
    x(),
    y()
    {}

  ~CPP_mode3() {
  }

};   // End Class

extern "C" void mode3_to_c (const Bmad_mode3_class*, CPP_mode3&);
extern "C" void mode3_to_f (const CPP_mode3&, Bmad_mode3_class*);

bool operator== (const CPP_mode3&, const CPP_mode3&);


//--------------------------------------------------------------------
// CPP_bookkeeping_state

class Bmad_bookkeeping_state_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_bookkeeping_state {
public:
  Int attributes;
  Int control;
  Int floor_position;
  Int s_position;
  Int ref_energy;
  Int mat6;
  Int rad_int;
  Int ptc;

  CPP_bookkeeping_state() :
    attributes(Bmad::STALE),
    control(Bmad::STALE),
    floor_position(Bmad::STALE),
    s_position(Bmad::STALE),
    ref_energy(Bmad::STALE),
    mat6(Bmad::STALE),
    rad_int(Bmad::STALE),
    ptc(Bmad::STALE)
    {}

  ~CPP_bookkeeping_state() {
  }

};   // End Class

extern "C" void bookkeeping_state_to_c (const Bmad_bookkeeping_state_class*, CPP_bookkeeping_state&);
extern "C" void bookkeeping_state_to_f (const CPP_bookkeeping_state&, Bmad_bookkeeping_state_class*);

bool operator== (const CPP_bookkeeping_state&, const CPP_bookkeeping_state&);


//--------------------------------------------------------------------
// CPP_rad_int_ele_cache

class Bmad_rad_int_ele_cache_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_rad_int_ele_cache {
public:
  Real_ARRAY orb0;
  Real g2_0;
  Real g3_0;
  Real_ARRAY dg2_dorb;
  Real_ARRAY dg3_dorb;
  Bool stale;

  CPP_rad_int_ele_cache() :
    orb0(0.0, 6),
    g2_0(0.0),
    g3_0(0.0),
    dg2_dorb(0.0, 6),
    dg3_dorb(0.0, 6),
    stale(true)
    {}

  ~CPP_rad_int_ele_cache() {
  }

};   // End Class

extern "C" void rad_int_ele_cache_to_c (const Bmad_rad_int_ele_cache_class*, CPP_rad_int_ele_cache&);
extern "C" void rad_int_ele_cache_to_f (const CPP_rad_int_ele_cache&, Bmad_rad_int_ele_cache_class*);

bool operator== (const CPP_rad_int_ele_cache&, const CPP_rad_int_ele_cache&);


//--------------------------------------------------------------------
// CPP_surface_grid_pt

class Bmad_surface_grid_pt_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_surface_grid_pt {
public:
  Real x_pitch;
  Real y_pitch;
  Real x_pitch_rms;
  Real y_pitch_rms;
  Real_ARRAY e_x;
  Real_ARRAY e_y;
  Real intensity_x;
  Real intensity_y;
  Real intensity;
  Int n_photon;
  Real energy_ave;
  Real energy_rms;

  CPP_surface_grid_pt() :
    x_pitch(0.0),
    y_pitch(0.0),
    x_pitch_rms(0.0),
    y_pitch_rms(0.0),
    e_x(0.0, 2),
    e_y(0.0, 2),
    intensity_x(0.0),
    intensity_y(0.0),
    intensity(0.0),
    n_photon(0),
    energy_ave(0.0),
    energy_rms(0.0)
    {}

  ~CPP_surface_grid_pt() {
  }

};   // End Class

extern "C" void surface_grid_pt_to_c (const Bmad_surface_grid_pt_class*, CPP_surface_grid_pt&);
extern "C" void surface_grid_pt_to_f (const CPP_surface_grid_pt&, Bmad_surface_grid_pt_class*);

bool operator== (const CPP_surface_grid_pt&, const CPP_surface_grid_pt&);


//--------------------------------------------------------------------
// CPP_surface_grid

class Bmad_surface_grid_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_surface_grid {
public:
  string file;
  Int type;
  Real_ARRAY dr;
  Real_ARRAY r0;
  CPP_surface_grid_pt_MATRIX pt;

  CPP_surface_grid() :
    file(),
    type(Bmad::OFF),
    dr(0.0, 2),
    r0(0.0, 2),
    pt(CPP_surface_grid_pt_ARRAY(CPP_surface_grid_pt(), 0), 0)
    {}

  ~CPP_surface_grid() {
  }

};   // End Class

extern "C" void surface_grid_to_c (const Bmad_surface_grid_class*, CPP_surface_grid&);
extern "C" void surface_grid_to_f (const CPP_surface_grid&, Bmad_surface_grid_class*);

bool operator== (const CPP_surface_grid&, const CPP_surface_grid&);


//--------------------------------------------------------------------
// CPP_segmented_surface

class Bmad_segmented_surface_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_segmented_surface {
public:
  Int ix;
  Int iy;
  Real x0;
  Real y0;
  Real z0;
  Real slope_x;
  Real slope_y;

  CPP_segmented_surface() :
    ix(Bmad::INT_GARBAGE),
    iy(Bmad::INT_GARBAGE),
    x0(0.0),
    y0(0.0),
    z0(0.0),
    slope_x(0.0),
    slope_y(0.0)
    {}

  ~CPP_segmented_surface() {
  }

};   // End Class

extern "C" void segmented_surface_to_c (const Bmad_segmented_surface_class*, CPP_segmented_surface&);
extern "C" void segmented_surface_to_f (const CPP_segmented_surface&, Bmad_segmented_surface_class*);

bool operator== (const CPP_segmented_surface&, const CPP_segmented_surface&);


//--------------------------------------------------------------------
// CPP_target_point

class Bmad_target_point_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_target_point {
public:
  Real_ARRAY r;

  CPP_target_point() :
    r(0.0, 3)
    {}

  ~CPP_target_point() {
  }

};   // End Class

extern "C" void target_point_to_c (const Bmad_target_point_class*, CPP_target_point&);
extern "C" void target_point_to_f (const CPP_target_point&, Bmad_target_point_class*);

bool operator== (const CPP_target_point&, const CPP_target_point&);


//--------------------------------------------------------------------
// CPP_photon_surface

class Bmad_photon_surface_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_surface {
public:
  CPP_surface_grid grid;
  CPP_segmented_surface segment;
  Real_MATRIX curvature_xy;
  Bool has_curvature;

  CPP_photon_surface() :
    grid(),
    segment(),
    curvature_xy(Real_ARRAY(0.0, 7), 7),
    has_curvature(false)
    {}

  ~CPP_photon_surface() {
  }

};   // End Class

extern "C" void photon_surface_to_c (const Bmad_photon_surface_class*, CPP_photon_surface&);
extern "C" void photon_surface_to_f (const CPP_photon_surface&, Bmad_photon_surface_class*);

bool operator== (const CPP_photon_surface&, const CPP_photon_surface&);


//--------------------------------------------------------------------
// CPP_photon_target

class Bmad_photon_target_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_target {
public:
  Bool deterministic_grid;
  Int ix_grid;
  Int iy_grid;
  Int type;
  Int n_corner;
  CPP_lat_ele_loc ele_loc;
  CPP_target_point_ARRAY corner;
  CPP_target_point center;

  CPP_photon_target() :
    deterministic_grid(false),
    ix_grid(0),
    iy_grid(0),
    type(Bmad::OFF),
    n_corner(0),
    ele_loc(),
    corner(CPP_target_point_ARRAY(CPP_target_point(), 8)),
    center()
    {}

  ~CPP_photon_target() {
  }

};   // End Class

extern "C" void photon_target_to_c (const Bmad_photon_target_class*, CPP_photon_target&);
extern "C" void photon_target_to_f (const CPP_photon_target&, Bmad_photon_target_class*);

bool operator== (const CPP_photon_target&, const CPP_photon_target&);


//--------------------------------------------------------------------
// CPP_photon_material

class Bmad_photon_material_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_material {
public:
  Complex f0_m1;
  Complex f0_m2;
  Complex f_0;
  Complex f_h;
  Complex f_hbar;
  Complex f_hkl;
  Real_ARRAY h_norm;
  Real_ARRAY l_ref;

  CPP_photon_material() :
    f0_m1(0.0),
    f0_m2(0.0),
    f_0(0.0),
    f_h(0.0),
    f_hbar(0.0),
    f_hkl(0.0),
    h_norm(0.0, 3),
    l_ref(0.0, 3)
    {}

  ~CPP_photon_material() {
  }

};   // End Class

extern "C" void photon_material_to_c (const Bmad_photon_material_class*, CPP_photon_material&);
extern "C" void photon_material_to_f (const CPP_photon_material&, Bmad_photon_material_class*);

bool operator== (const CPP_photon_material&, const CPP_photon_material&);


//--------------------------------------------------------------------
// CPP_photon_element

class Bmad_photon_element_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_element {
public:
  CPP_photon_surface surface;
  CPP_photon_target target;
  CPP_photon_material material;

  CPP_photon_element() :
    surface(),
    target(),
    material()
    {}

  ~CPP_photon_element() {
  }

};   // End Class

extern "C" void photon_element_to_c (const Bmad_photon_element_class*, CPP_photon_element&);
extern "C" void photon_element_to_f (const CPP_photon_element&, Bmad_photon_element_class*);

bool operator== (const CPP_photon_element&, const CPP_photon_element&);


//--------------------------------------------------------------------
// CPP_wall3d_vertex

class Bmad_wall3d_vertex_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wall3d_vertex {
public:
  Real x;
  Real y;
  Real radius_x;
  Real radius_y;
  Real tilt;
  Real angle;
  Real x0;
  Real y0;
  Int type;

  CPP_wall3d_vertex() :
    x(0.0),
    y(0.0),
    radius_x(0.0),
    radius_y(0.0),
    tilt(0.0),
    angle(0.0),
    x0(0.0),
    y0(0.0),
    type(Bmad::NORMAL)
    {}

  ~CPP_wall3d_vertex() {
  }

};   // End Class

extern "C" void wall3d_vertex_to_c (const Bmad_wall3d_vertex_class*, CPP_wall3d_vertex&);
extern "C" void wall3d_vertex_to_f (const CPP_wall3d_vertex&, Bmad_wall3d_vertex_class*);

bool operator== (const CPP_wall3d_vertex&, const CPP_wall3d_vertex&);


//--------------------------------------------------------------------
// CPP_wall3d_section

class Bmad_wall3d_section_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wall3d_section {
public:
  string name;
  string material;
  CPP_wall3d_vertex_ARRAY v;
  CPP_photon_reflect_surface* surface;
  Int type;
  Int n_vertex_input;
  Int ix_ele;
  Int ix_branch;
  Bool patch_in_region;
  Real thickness;
  Real s;
  Real x0;
  Real y0;
  Real x_safe;
  Real y_safe;
  Real dx0_ds;
  Real dy0_ds;
  Real_ARRAY x0_coef;
  Real_ARRAY y0_coef;
  Real dr_ds;
  Real_ARRAY p1_coef;
  Real_ARRAY p2_coef;

  CPP_wall3d_section() :
    name(),
    material(),
    v(CPP_wall3d_vertex_ARRAY(CPP_wall3d_vertex(), 0)),
    surface(NULL),
    type(Bmad::NORMAL),
    n_vertex_input(0),
    ix_ele(0),
    ix_branch(0),
    patch_in_region(false),
    thickness(-1),
    s(0.0),
    x0(0.0),
    y0(0.0),
    x_safe(0.0),
    y_safe(0.0),
    dx0_ds(0.0),
    dy0_ds(0.0),
    x0_coef(0.0, 4),
    y0_coef(0.0, 4),
    dr_ds(Bmad::REAL_GARBAGE),
    p1_coef(0.0, 3),
    p2_coef(0.0, 3)
    {}

  ~CPP_wall3d_section() {
    delete surface;
  }

};   // End Class

extern "C" void wall3d_section_to_c (const Bmad_wall3d_section_class*, CPP_wall3d_section&);
extern "C" void wall3d_section_to_f (const CPP_wall3d_section&, Bmad_wall3d_section_class*);

bool operator== (const CPP_wall3d_section&, const CPP_wall3d_section&);


//--------------------------------------------------------------------
// CPP_wall3d

class Bmad_wall3d_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wall3d {
public:
  Int n_link;
  Real thickness;
  string clear_material;
  string opaque_material;
  Bool superimpose;
  Int ele_anchor_pt;
  CPP_wall3d_section_ARRAY section;

  CPP_wall3d() :
    n_link(1),
    thickness(-1),
    clear_material(),
    opaque_material(),
    superimpose(false),
    ele_anchor_pt(Bmad::ANCHOR_BEGINNING),
    section(CPP_wall3d_section_ARRAY(CPP_wall3d_section(), 0))
    {}

  ~CPP_wall3d() {
  }

};   // End Class

extern "C" void wall3d_to_c (const Bmad_wall3d_class*, CPP_wall3d&);
extern "C" void wall3d_to_f (const CPP_wall3d&, Bmad_wall3d_class*);

bool operator== (const CPP_wall3d&, const CPP_wall3d&);


//--------------------------------------------------------------------
// CPP_taylor_term

class Bmad_taylor_term_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_taylor_term {
public:
  Real coef;
  Int_ARRAY expn;

  CPP_taylor_term() :
    coef(0.0),
    expn(0, 6)
    {}

  ~CPP_taylor_term() {
  }

};   // End Class

extern "C" void taylor_term_to_c (const Bmad_taylor_term_class*, CPP_taylor_term&);
extern "C" void taylor_term_to_f (const CPP_taylor_term&, Bmad_taylor_term_class*);

bool operator== (const CPP_taylor_term&, const CPP_taylor_term&);


//--------------------------------------------------------------------
// CPP_taylor

class Bmad_taylor_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_taylor {
public:
  Real ref;
  CPP_taylor_term_ARRAY term;

  CPP_taylor() :
    ref(0.0),
    term(CPP_taylor_term_ARRAY(CPP_taylor_term(), 0))
    {}

  ~CPP_taylor() {
  }

};   // End Class

extern "C" void taylor_to_c (const Bmad_taylor_class*, CPP_taylor&);
extern "C" void taylor_to_f (const CPP_taylor&, Bmad_taylor_class*);

bool operator== (const CPP_taylor&, const CPP_taylor&);


//--------------------------------------------------------------------
// CPP_control

class Bmad_control_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_control {
public:
  Real coef;
  Int ix_lord;
  Int ix_slave;
  Int ix_branch;
  Int ix_attrib;

  CPP_control() :
    coef(0.0),
    ix_lord(-1),
    ix_slave(-1),
    ix_branch(0),
    ix_attrib(0)
    {}

  ~CPP_control() {
  }

};   // End Class

extern "C" void control_to_c (const Bmad_control_class*, CPP_control&);
extern "C" void control_to_f (const CPP_control&, Bmad_control_class*);

bool operator== (const CPP_control&, const CPP_control&);


//--------------------------------------------------------------------
// CPP_lat_param

class Bmad_lat_param_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_lat_param {
public:
  Real n_part;
  Real total_length;
  Real unstable_factor;
  Real_MATRIX t1_with_rf;
  Real_MATRIX t1_no_rf;
  Int particle;
  Int default_tracking_species;
  Int geometry;
  Int ixx;
  Bool stable;
  Bool aperture_limit_on;
  Bool backwards_time_tracking;
  CPP_bookkeeping_state bookkeeping_state;

  CPP_lat_param() :
    n_part(0.0),
    total_length(0.0),
    unstable_factor(0.0),
    t1_with_rf(Real_ARRAY(0.0, 6), 6),
    t1_no_rf(Real_ARRAY(0.0, 6), 6),
    particle(Bmad::POSITRON),
    default_tracking_species(Bmad::REF_PARTICLE),
    geometry(0),
    ixx(0),
    stable(false),
    aperture_limit_on(true),
    backwards_time_tracking(false),
    bookkeeping_state()
    {}

  ~CPP_lat_param() {
  }

};   // End Class

extern "C" void lat_param_to_c (const Bmad_lat_param_class*, CPP_lat_param&);
extern "C" void lat_param_to_f (const CPP_lat_param&, Bmad_lat_param_class*);

bool operator== (const CPP_lat_param&, const CPP_lat_param&);


//--------------------------------------------------------------------
// CPP_mode_info

class Bmad_mode_info_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_mode_info {
public:
  Real tune;
  Real emit;
  Real chrom;
  Real sigma;
  Real sigmap;

  CPP_mode_info() :
    tune(0.0),
    emit(0.0),
    chrom(0.0),
    sigma(0.0),
    sigmap(0.0)
    {}

  ~CPP_mode_info() {
  }

};   // End Class

extern "C" void mode_info_to_c (const Bmad_mode_info_class*, CPP_mode_info&);
extern "C" void mode_info_to_f (const CPP_mode_info&, Bmad_mode_info_class*);

bool operator== (const CPP_mode_info&, const CPP_mode_info&);


//--------------------------------------------------------------------
// CPP_pre_tracker

class Bmad_pre_tracker_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_pre_tracker {
public:
  Int who;
  Int ix_ele_start;
  Int ix_ele_end;
  string input_file;

  CPP_pre_tracker() :
    who(0),
    ix_ele_start(0),
    ix_ele_end(0),
    input_file()
    {}

  ~CPP_pre_tracker() {
  }

};   // End Class

extern "C" void pre_tracker_to_c (const Bmad_pre_tracker_class*, CPP_pre_tracker&);
extern "C" void pre_tracker_to_f (const CPP_pre_tracker&, Bmad_pre_tracker_class*);

bool operator== (const CPP_pre_tracker&, const CPP_pre_tracker&);


//--------------------------------------------------------------------
// CPP_anormal_mode

class Bmad_anormal_mode_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_anormal_mode {
public:
  Real emittance;
  Real_ARRAY synch_int;
  Real j_damp;
  Real alpha_damp;
  Real chrom;
  Real tune;

  CPP_anormal_mode() :
    emittance(0.0),
    synch_int(0.0, 3),
    j_damp(0.0),
    alpha_damp(0.0),
    chrom(0.0),
    tune(0.0)
    {}

  ~CPP_anormal_mode() {
  }

};   // End Class

extern "C" void anormal_mode_to_c (const Bmad_anormal_mode_class*, CPP_anormal_mode&);
extern "C" void anormal_mode_to_f (const CPP_anormal_mode&, Bmad_anormal_mode_class*);

bool operator== (const CPP_anormal_mode&, const CPP_anormal_mode&);


//--------------------------------------------------------------------
// CPP_linac_normal_mode

class Bmad_linac_normal_mode_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_linac_normal_mode {
public:
  Real i2_e4;
  Real i3_e7;
  Real i5a_e6;
  Real i5b_e6;
  Real sig_e1;
  Real a_emittance_end;
  Real b_emittance_end;

  CPP_linac_normal_mode() :
    i2_e4(0.0),
    i3_e7(0.0),
    i5a_e6(0.0),
    i5b_e6(0.0),
    sig_e1(0.0),
    a_emittance_end(0.0),
    b_emittance_end(0.0)
    {}

  ~CPP_linac_normal_mode() {
  }

};   // End Class

extern "C" void linac_normal_mode_to_c (const Bmad_linac_normal_mode_class*, CPP_linac_normal_mode&);
extern "C" void linac_normal_mode_to_f (const CPP_linac_normal_mode&, Bmad_linac_normal_mode_class*);

bool operator== (const CPP_linac_normal_mode&, const CPP_linac_normal_mode&);


//--------------------------------------------------------------------
// CPP_normal_modes

class Bmad_normal_modes_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_normal_modes {
public:
  Real_ARRAY synch_int;
  Real sige_e;
  Real sig_z;
  Real e_loss;
  Real rf_voltage;
  Real pz_aperture;
  CPP_anormal_mode a;
  CPP_anormal_mode b;
  CPP_anormal_mode z;
  CPP_linac_normal_mode lin;

  CPP_normal_modes() :
    synch_int(0.0, 4),
    sige_e(0.0),
    sig_z(0.0),
    e_loss(0.0),
    rf_voltage(0.0),
    pz_aperture(0.0),
    a(),
    b(),
    z(),
    lin()
    {}

  ~CPP_normal_modes() {
  }

};   // End Class

extern "C" void normal_modes_to_c (const Bmad_normal_modes_class*, CPP_normal_modes&);
extern "C" void normal_modes_to_f (const CPP_normal_modes&, Bmad_normal_modes_class*);

bool operator== (const CPP_normal_modes&, const CPP_normal_modes&);


//--------------------------------------------------------------------
// CPP_em_field

class Bmad_em_field_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_em_field {
public:
  Real_ARRAY e;
  Real_ARRAY b;
  Real_MATRIX de;
  Real_MATRIX db;

  CPP_em_field() :
    e(0.0, 3),
    b(0.0, 3),
    de(Real_ARRAY(0.0, 3), 3),
    db(Real_ARRAY(0.0, 3), 3)
    {}

  ~CPP_em_field() {
  }

};   // End Class

extern "C" void em_field_to_c (const Bmad_em_field_class*, CPP_em_field&);
extern "C" void em_field_to_f (const CPP_em_field&, Bmad_em_field_class*);

bool operator== (const CPP_em_field&, const CPP_em_field&);


//--------------------------------------------------------------------
// CPP_track_map

class Bmad_track_map_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_track_map {
public:
  Real_ARRAY vec0;
  Real_MATRIX mat6;

  CPP_track_map() :
    vec0(0.0, 6),
    mat6(Real_ARRAY(0.0, 6), 6)
    {}

  ~CPP_track_map() {
  }

};   // End Class

extern "C" void track_map_to_c (const Bmad_track_map_class*, CPP_track_map&);
extern "C" void track_map_to_f (const CPP_track_map&, Bmad_track_map_class*);

bool operator== (const CPP_track_map&, const CPP_track_map&);


//--------------------------------------------------------------------
// CPP_track

class Bmad_track_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_track {
public:
  CPP_coord_ARRAY orb;
  CPP_em_field_ARRAY field;
  CPP_track_map_ARRAY map;
  Real ds_save;
  Int n_pt;
  Int n_bad;
  Int n_ok;

  CPP_track() :
    orb(CPP_coord_ARRAY(CPP_coord(), 0)),
    field(CPP_em_field_ARRAY(CPP_em_field(), 0)),
    map(CPP_track_map_ARRAY(CPP_track_map(), 0)),
    ds_save(1e-3),
    n_pt(-1),
    n_bad(0),
    n_ok(0)
    {}

  ~CPP_track() {
  }

};   // End Class

extern "C" void track_to_c (const Bmad_track_class*, CPP_track&);
extern "C" void track_to_f (const CPP_track&, Bmad_track_class*);

bool operator== (const CPP_track&, const CPP_track&);


//--------------------------------------------------------------------
// CPP_synch_rad_common

class Bmad_synch_rad_common_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_synch_rad_common {
public:
  Real scale;
  Real i2;
  Real i3;
  Real i5a;
  Real i5b;
  Bool i_calc_on;

  CPP_synch_rad_common() :
    scale(1.0),
    i2(0.0),
    i3(0.0),
    i5a(0.0),
    i5b(0.0),
    i_calc_on(false)
    {}

  ~CPP_synch_rad_common() {
  }

};   // End Class

extern "C" void synch_rad_common_to_c (const Bmad_synch_rad_common_class*, CPP_synch_rad_common&);
extern "C" void synch_rad_common_to_f (const CPP_synch_rad_common&, Bmad_synch_rad_common_class*);

bool operator== (const CPP_synch_rad_common&, const CPP_synch_rad_common&);


//--------------------------------------------------------------------
// CPP_csr_parameter

class Bmad_csr_parameter_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_csr_parameter {
public:
  Real ds_track_step;
  Real beam_chamber_height;
  Real sigma_cutoff;
  Int n_bin;
  Int particle_bin_span;
  Int n_shield_images;
  Int ix1_ele_csr;
  Int ix2_ele_csr;
  Bool lcsr_component_on;
  Bool lsc_component_on;
  Bool tsc_component_on;
  Bool small_angle_approx;
  Bool print_taylor_warning;

  CPP_csr_parameter() :
    ds_track_step(0.0),
    beam_chamber_height(0.0),
    sigma_cutoff(0.1),
    n_bin(0),
    particle_bin_span(2),
    n_shield_images(0),
    ix1_ele_csr(-1),
    ix2_ele_csr(-1),
    lcsr_component_on(true),
    lsc_component_on(true),
    tsc_component_on(false),
    small_angle_approx(true),
    print_taylor_warning(true)
    {}

  ~CPP_csr_parameter() {
  }

};   // End Class

extern "C" void csr_parameter_to_c (const Bmad_csr_parameter_class*, CPP_csr_parameter&);
extern "C" void csr_parameter_to_f (const CPP_csr_parameter&, Bmad_csr_parameter_class*);

bool operator== (const CPP_csr_parameter&, const CPP_csr_parameter&);


//--------------------------------------------------------------------
// CPP_bmad_common

class Bmad_bmad_common_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_bmad_common {
public:
  Real max_aperture_limit;
  Real_ARRAY d_orb;
  Real default_ds_step;
  Real significant_length;
  Real rel_tol_tracking;
  Real abs_tol_tracking;
  Real rel_tol_adaptive_tracking;
  Real abs_tol_adaptive_tracking;
  Real init_ds_adaptive_tracking;
  Real min_ds_adaptive_tracking;
  Real fatal_ds_adaptive_tracking;
  Int taylor_order;
  Int default_integ_order;
  Int ptc_max_fringe_order;
  Bool use_hard_edge_drifts;
  Bool sr_wakes_on;
  Bool lr_wakes_on;
  Bool mat6_track_symmetric;
  Bool auto_bookkeeper;
  Bool space_charge_on;
  Bool coherent_synch_rad_on;
  Bool spin_tracking_on;
  Bool radiation_damping_on;
  Bool radiation_fluctuations_on;
  Bool conserve_taylor_maps;
  Bool absolute_time_tracking_default;
  Bool auto_scale_field_phase_default;
  Bool auto_scale_field_amp_default;
  Bool debug;

  CPP_bmad_common() :
    max_aperture_limit(1e3),
    d_orb(1e-5, 6),
    default_ds_step(0.0),
    significant_length(1e-10),
    rel_tol_tracking(1e-8),
    abs_tol_tracking(1e-10),
    rel_tol_adaptive_tracking(1e-8),
    abs_tol_adaptive_tracking(1e-10),
    init_ds_adaptive_tracking(1e-3),
    min_ds_adaptive_tracking(0.0),
    fatal_ds_adaptive_tracking(1e-8),
    taylor_order(0),
    default_integ_order(2),
    ptc_max_fringe_order(2),
    use_hard_edge_drifts(true),
    sr_wakes_on(true),
    lr_wakes_on(true),
    mat6_track_symmetric(true),
    auto_bookkeeper(true),
    space_charge_on(false),
    coherent_synch_rad_on(false),
    spin_tracking_on(false),
    radiation_damping_on(false),
    radiation_fluctuations_on(false),
    conserve_taylor_maps(true),
    absolute_time_tracking_default(false),
    auto_scale_field_phase_default(true),
    auto_scale_field_amp_default(true),
    debug(false)
    {}

  ~CPP_bmad_common() {
  }

};   // End Class

extern "C" void bmad_common_to_c (const Bmad_bmad_common_class*, CPP_bmad_common&);
extern "C" void bmad_common_to_f (const CPP_bmad_common&, Bmad_bmad_common_class*);

bool operator== (const CPP_bmad_common&, const CPP_bmad_common&);


//--------------------------------------------------------------------
// CPP_rad_int1

class Bmad_rad_int1_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_rad_int1 {
public:
  Real i0;
  Real i1;
  Real i2;
  Real i3;
  Real i4a;
  Real i4b;
  Real i4z;
  Real i5a;
  Real i5b;
  Real i6b;
  Real lin_i2_e4;
  Real lin_i3_e7;
  Real lin_i5a_e6;
  Real lin_i5b_e6;
  Real lin_norm_emit_a;
  Real lin_norm_emit_b;
  Real n_steps;

  CPP_rad_int1() :
    i0(0.0),
    i1(0.0),
    i2(0.0),
    i3(0.0),
    i4a(0.0),
    i4b(0.0),
    i4z(0.0),
    i5a(0.0),
    i5b(0.0),
    i6b(0.0),
    lin_i2_e4(0.0),
    lin_i3_e7(0.0),
    lin_i5a_e6(0.0),
    lin_i5b_e6(0.0),
    lin_norm_emit_a(0.0),
    lin_norm_emit_b(0.0),
    n_steps(0.0)
    {}

  ~CPP_rad_int1() {
  }

};   // End Class

extern "C" void rad_int1_to_c (const Bmad_rad_int1_class*, CPP_rad_int1&);
extern "C" void rad_int1_to_f (const CPP_rad_int1&, Bmad_rad_int1_class*);

bool operator== (const CPP_rad_int1&, const CPP_rad_int1&);


//--------------------------------------------------------------------
// CPP_rad_int_all_ele

class Bmad_rad_int_all_ele_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_rad_int_all_ele {
public:
  CPP_rad_int1_ARRAY ele;

  CPP_rad_int_all_ele() :
    ele(CPP_rad_int1_ARRAY(CPP_rad_int1(), 0))
    {}

  ~CPP_rad_int_all_ele() {
  }

};   // End Class

extern "C" void rad_int_all_ele_to_c (const Bmad_rad_int_all_ele_class*, CPP_rad_int_all_ele&);
extern "C" void rad_int_all_ele_to_f (const CPP_rad_int_all_ele&, Bmad_rad_int_all_ele_class*);

bool operator== (const CPP_rad_int_all_ele&, const CPP_rad_int_all_ele&);


//--------------------------------------------------------------------
// CPP_ele

class Bmad_ele_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_ele {
public:
  string name;
  string type;
  string alias;
  string component_name;
  string* descrip;
  CPP_twiss a;
  CPP_twiss b;
  CPP_twiss z;
  CPP_xy_disp x;
  CPP_xy_disp y;
  CPP_bookkeeping_state bookkeeping_state;
  CPP_em_fields* em_field;
  CPP_floor_position floor;
  CPP_mode3* mode3;
  CPP_photon_element* photon;
  CPP_rad_int_ele_cache* rad_int_cache;
  CPP_space_charge* space_charge;
  CPP_taylor_ARRAY taylor;
  CPP_wake* wake;
  CPP_wall3d* wall3d;
  CPP_wig* wig;
  CPP_coord map_ref_orb_in;
  CPP_coord map_ref_orb_out;
  CPP_coord time_ref_orb_in;
  CPP_coord time_ref_orb_out;
  Real_ARRAY value;
  Real_ARRAY old_value;
  Real_ARRAY gen0;
  Real_ARRAY vec0;
  Real_MATRIX mat6;
  Real_MATRIX c_mat;
  Real gamma_c;
  Real s;
  Real ref_time;
  Real_TENSOR r;
  Real_ARRAY a_pole;
  Real_ARRAY b_pole;
  Int key;
  Int sub_key;
  Int ix_ele;
  Int ix_branch;
  Int ix_value;
  Int slave_status;
  Int n_slave;
  Int ix1_slave;
  Int ix2_slave;
  Int lord_status;
  Int n_lord;
  Int ic1_lord;
  Int ic2_lord;
  Int ix_pointer;
  Int ixx;
  Int iyy;
  Int mat6_calc_method;
  Int tracking_method;
  Int spin_tracking_method;
  Int ptc_integration_type;
  Int field_calc;
  Int aperture_at;
  Int aperture_type;
  Int orientation;
  Bool symplectify;
  Bool mode_flip;
  Bool multipoles_on;
  Bool scale_multipoles;
  Bool taylor_map_includes_offsets;
  Bool field_master;
  Bool is_on;
  Bool old_is_on;
  Bool logic;
  Bool bmad_logic;
  Bool csr_calc_on;
  Bool offset_moves_aperture;

  void class_init (const int key_) {
    key = key_;

    if (key == Bmad::LCAVITY) {
      value[Bmad::COUPLER_AT] = Bmad::DOWNSTREAM_END;
      value[Bmad::FIELD_FACTOR] = 1;
      value[Bmad::N_CELL] = 1;
    }

    if (key == Bmad::RFCAVITY) {
      value[Bmad::COUPLER_AT] = Bmad::DOWNSTREAM_END;
      value[Bmad::FIELD_FACTOR] = 1;
      value[Bmad::N_CELL] = 1;
    }

    if (key == Bmad::RBEND || key == Bmad::SBEND) {
      value[Bmad::FRINGE_AT] = Bmad::BOTH_ENDS;
      value[Bmad::FRINGE_TYPE] = Bmad::BASIC_BEND;
      value[Bmad::PTC_FIELD_GEOMETRY] = Bmad::SECTOR;
    }
  }

  CPP_ele(const int key_ = 0) :
    name(),
    type(),
    alias(),
    component_name(),
    descrip(NULL),
    a(),
    b(),
    z(),
    x(),
    y(),
    bookkeeping_state(),
    em_field(NULL),
    floor(),
    mode3(NULL),
    photon(NULL),
    rad_int_cache(NULL),
    space_charge(NULL),
    taylor(CPP_taylor_ARRAY(CPP_taylor(), 6)),
    wake(NULL),
    wall3d(NULL),
    wig(NULL),
    map_ref_orb_in(),
    map_ref_orb_out(),
    time_ref_orb_in(),
    time_ref_orb_out(),
    value(double(0), Bmad::NUM_ELE_ATTRIB+1),
    old_value(double(0), Bmad::NUM_ELE_ATTRIB+1),
    gen0(0.0, 6),
    vec0(0.0, 6),
    mat6(Real_ARRAY(0.0, 6), 6),
    c_mat(Real_ARRAY(0.0, 2), 2),
    gamma_c(0.0),
    s(0.0),
    ref_time(0.0),
    r(Real_MATRIX(Real_ARRAY(0.0, 0), 0), 0),
    a_pole(0.0, 0),
    b_pole(0.0, 0),
    key(key_),
    sub_key(0),
    ix_ele(-1),
    ix_branch(0),
    ix_value(0),
    slave_status(Bmad::FREE),
    n_slave(0),
    ix1_slave(0),
    ix2_slave(-1),
    lord_status(Bmad::NOT_A_LORD),
    n_lord(0),
    ic1_lord(0),
    ic2_lord(-1),
    ix_pointer(0),
    ixx(0),
    iyy(0),
    mat6_calc_method(Bmad::BMAD_STANDARD),
    tracking_method(Bmad::BMAD_STANDARD),
    spin_tracking_method(Bmad::BMAD_STANDARD),
    ptc_integration_type(Bmad::MATRIX_KICK),
    field_calc(Bmad::BMAD_STANDARD),
    aperture_at(Bmad::DOWNSTREAM_END),
    aperture_type(Bmad::RECTANGULAR),
    orientation(1),
    symplectify(false),
    mode_flip(false),
    multipoles_on(true),
    scale_multipoles(true),
    taylor_map_includes_offsets(true),
    field_master(false),
    is_on(true),
    old_is_on(true),
    logic(false),
    bmad_logic(false),
    csr_calc_on(true),
    offset_moves_aperture(false)
        {
      class_init(key);
    }


  ~CPP_ele() {
    delete descrip;
    delete em_field;
    delete mode3;
    delete photon;
    delete rad_int_cache;
    delete space_charge;
    delete wake;
    delete wall3d;
    delete wig;
  }

};   // End Class

extern "C" void ele_to_c (const Bmad_ele_class*, CPP_ele&);
extern "C" void ele_to_f (const CPP_ele&, Bmad_ele_class*);

bool operator== (const CPP_ele&, const CPP_ele&);


//--------------------------------------------------------------------
// CPP_complex_taylor_term

class Bmad_complex_taylor_term_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_complex_taylor_term {
public:
  Complex coef;
  Int_ARRAY expn;

  CPP_complex_taylor_term() :
    coef(0.0),
    expn(0, 6)
    {}

  ~CPP_complex_taylor_term() {
  }

};   // End Class

extern "C" void complex_taylor_term_to_c (const Bmad_complex_taylor_term_class*, CPP_complex_taylor_term&);
extern "C" void complex_taylor_term_to_f (const CPP_complex_taylor_term&, Bmad_complex_taylor_term_class*);

bool operator== (const CPP_complex_taylor_term&, const CPP_complex_taylor_term&);


//--------------------------------------------------------------------
// CPP_complex_taylor

class Bmad_complex_taylor_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_complex_taylor {
public:
  Complex ref;
  CPP_complex_taylor_term_ARRAY term;

  CPP_complex_taylor() :
    ref(0.0),
    term(CPP_complex_taylor_term_ARRAY(CPP_complex_taylor_term(), 0))
    {}

  ~CPP_complex_taylor() {
  }

};   // End Class

extern "C" void complex_taylor_to_c (const Bmad_complex_taylor_class*, CPP_complex_taylor&);
extern "C" void complex_taylor_to_f (const CPP_complex_taylor&, Bmad_complex_taylor_class*);

bool operator== (const CPP_complex_taylor&, const CPP_complex_taylor&);


//--------------------------------------------------------------------
// CPP_normal_form

class Bmad_normal_form_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_normal_form {
public:
  CPP_taylor_ARRAY m;
  CPP_taylor_ARRAY a;
  CPP_taylor_ARRAY a_inv;
  CPP_taylor_ARRAY dhdj;
  CPP_complex_taylor_ARRAY f;
  CPP_complex_taylor_ARRAY l;
  CPP_ele* ele_origin;

  CPP_normal_form() :
    m(CPP_taylor_ARRAY(CPP_taylor(), 6)),
    a(CPP_taylor_ARRAY(CPP_taylor(), 6)),
    a_inv(CPP_taylor_ARRAY(CPP_taylor(), 6)),
    dhdj(CPP_taylor_ARRAY(CPP_taylor(), 6)),
    f(CPP_complex_taylor_ARRAY(CPP_complex_taylor(), 6)),
    l(CPP_complex_taylor_ARRAY(CPP_complex_taylor(), 6)),
    ele_origin(NULL)
    {}

  ~CPP_normal_form() {
    delete ele_origin;
  }

};   // End Class

extern "C" void normal_form_to_c (const Bmad_normal_form_class*, CPP_normal_form&);
extern "C" void normal_form_to_f (const CPP_normal_form&, Bmad_normal_form_class*);

bool operator== (const CPP_normal_form&, const CPP_normal_form&);


//--------------------------------------------------------------------
// CPP_branch

class Bmad_branch_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_branch {
public:
  string name;
  Int ix_branch;
  Int ix_from_branch;
  Int ix_from_ele;
  Int* n_ele_track;
  Int* n_ele_max;
  CPP_mode_info* a;
  CPP_mode_info* b;
  CPP_mode_info* z;
  CPP_ele_ARRAY ele;
  CPP_lat_param* param;
  CPP_wall3d* wall3d;
  CPP_normal_form normal_form_with_rf;
  CPP_normal_form normal_form_no_rf;

  CPP_branch() :
    name(),
    ix_branch(-1),
    ix_from_branch(-1),
    ix_from_ele(-1),
    n_ele_track(NULL),
    n_ele_max(NULL),
    a(NULL),
    b(NULL),
    z(NULL),
    ele(CPP_ele_ARRAY(CPP_ele(), 0)),
    param(NULL),
    wall3d(NULL),
    normal_form_with_rf(),
    normal_form_no_rf()
    {}

  ~CPP_branch() {
    delete n_ele_track;
    delete n_ele_max;
    delete a;
    delete b;
    delete z;
    delete param;
    delete wall3d;
  }

};   // End Class

extern "C" void branch_to_c (const Bmad_branch_class*, CPP_branch&);
extern "C" void branch_to_f (const CPP_branch&, Bmad_branch_class*);

bool operator== (const CPP_branch&, const CPP_branch&);


//--------------------------------------------------------------------
// CPP_lat

class Bmad_lat_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_lat {
public:
  string use_name;
  string lattice;
  string input_file_name;
  string title;
  String_ARRAY attribute_alias;
  CPP_mode_info a;
  CPP_mode_info b;
  CPP_mode_info z;
  CPP_lat_param param;
  CPP_bookkeeping_state lord_state;
  CPP_ele ele_init;
  CPP_ele beam_start_ele;
  CPP_ele_ARRAY ele;
  CPP_branch_ARRAY branch;
  CPP_control_ARRAY control;
  CPP_photon_reflect_surface_ARRAY surface;
  CPP_coord beam_start;
  CPP_pre_tracker pre_tracker;
  Int version;
  Int n_ele_track;
  Int n_ele_max;
  Int n_control_max;
  Int n_ic_max;
  Int input_taylor_order;
  Int_ARRAY ic;
  Int photon_type;
  Bool absolute_time_tracking;
  Bool auto_scale_field_phase;
  Bool auto_scale_field_amp;
  Bool ptc_uses_hard_edge_drifts;

  CPP_lat() :
    use_name(),
    lattice(),
    input_file_name(),
    title(),
    attribute_alias(String_ARRAY(string(), 0)),
    a(),
    b(),
    z(),
    param(),
    lord_state(),
    ele_init(),
    beam_start_ele(),
    ele(CPP_ele_ARRAY(CPP_ele(), 0)),
    branch(CPP_branch_ARRAY(CPP_branch(), 0)),
    control(CPP_control_ARRAY(CPP_control(), 0)),
    surface(CPP_photon_reflect_surface_ARRAY(CPP_photon_reflect_surface(), 0)),
    beam_start(),
    pre_tracker(),
    version(0),
    n_ele_track(0),
    n_ele_max(0),
    n_control_max(0),
    n_ic_max(0),
    input_taylor_order(0),
    ic(0, 0),
    photon_type(Bmad::INCOHERENT),
    absolute_time_tracking(false),
    auto_scale_field_phase(false),
    auto_scale_field_amp(false),
    ptc_uses_hard_edge_drifts(false)
    {}

  ~CPP_lat() {
  }

};   // End Class

extern "C" void lat_to_c (const Bmad_lat_class*, CPP_lat&);
extern "C" void lat_to_f (const CPP_lat&, Bmad_lat_class*);

bool operator== (const CPP_lat&, const CPP_lat&);


//--------------------------------------------------------------------
// CPP_bunch

class Bmad_bunch_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_bunch {
public:
  CPP_coord_ARRAY particle;
  Int_ARRAY ix_z;
  Real charge_tot;
  Real charge_live;
  Real z_center;
  Real t_center;
  Int ix_ele;
  Int ix_bunch;

  CPP_bunch() :
    particle(CPP_coord_ARRAY(CPP_coord(), 0)),
    ix_z(0, 0),
    charge_tot(0.0),
    charge_live(0.0),
    z_center(0.0),
    t_center(0.0),
    ix_ele(0),
    ix_bunch(0)
    {}

  ~CPP_bunch() {
  }

};   // End Class

extern "C" void bunch_to_c (const Bmad_bunch_class*, CPP_bunch&);
extern "C" void bunch_to_f (const CPP_bunch&, Bmad_bunch_class*);

bool operator== (const CPP_bunch&, const CPP_bunch&);


//--------------------------------------------------------------------
// CPP_beam_spin

class Bmad_beam_spin_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_beam_spin {
public:
  Real polarization;
  Real theta;
  Real phi;

  CPP_beam_spin() :
    polarization(1.0),
    theta(0.0),
    phi(0.0)
    {}

  ~CPP_beam_spin() {
  }

};   // End Class

extern "C" void beam_spin_to_c (const Bmad_beam_spin_class*, CPP_beam_spin&);
extern "C" void beam_spin_to_f (const CPP_beam_spin&, Bmad_beam_spin_class*);

bool operator== (const CPP_beam_spin&, const CPP_beam_spin&);


//--------------------------------------------------------------------
// CPP_bunch_params

class Bmad_bunch_params_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_bunch_params {
public:
  CPP_twiss x;
  CPP_twiss y;
  CPP_twiss z;
  CPP_twiss a;
  CPP_twiss b;
  CPP_twiss c;
  CPP_coord centroid;
  CPP_beam_spin spin;
  Real_MATRIX sigma;
  Real s;
  Real charge_live;
  Int n_particle_tot;
  Int n_particle_live;
  Int n_particle_lost_in_ele;

  CPP_bunch_params() :
    x(),
    y(),
    z(),
    a(),
    b(),
    c(),
    centroid(),
    spin(),
    sigma(Real_ARRAY(0.0, 6), 6),
    s(0.0),
    charge_live(0.0),
    n_particle_tot(0),
    n_particle_live(0),
    n_particle_lost_in_ele(0)
    {}

  ~CPP_bunch_params() {
  }

};   // End Class

extern "C" void bunch_params_to_c (const Bmad_bunch_params_class*, CPP_bunch_params&);
extern "C" void bunch_params_to_f (const CPP_bunch_params&, Bmad_bunch_params_class*);

bool operator== (const CPP_bunch_params&, const CPP_bunch_params&);


//--------------------------------------------------------------------
// CPP_beam

class Bmad_beam_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_beam {
public:
  CPP_bunch_ARRAY bunch;

  CPP_beam() :
    bunch(CPP_bunch_ARRAY(CPP_bunch(), 0))
    {}

  ~CPP_beam() {
  }

};   // End Class

extern "C" void beam_to_c (const Bmad_beam_class*, CPP_beam&);
extern "C" void beam_to_f (const CPP_beam&, Bmad_beam_class*);

bool operator== (const CPP_beam&, const CPP_beam&);


//--------------------------------------------------------------------

#define CPP_BMAD_CLASSES
#endif
