cartesian_map_fit program documentation:

This program finds the best Cartesian map fit to a lattice element field table.

This documentation and source code is in the directory
  util_programs/cartesian_map_fit

%-----------------------------------------------------------------
number.in Input File

There are four input files. The first file to be read in by the
program is:
  number.in
  
This file has only one line and this line just contains a number. The
program will read in this number and then open a file "fitnnnn.in"
where "nnnn" is the number read in. For example, if the number is
"132" then the program will look for the input file: "fit0132.in".

%-----------------------------------------------------------------
fitnnnn.in Input File

The program will read in "fitnnnn.in" which should look something
like:

    parameter[E_tot] = 5e9
    map:  wiggler, l = 1.6, cartesian_map = {term = {0.03, 3.0, 4.0, 5.0, 0, 0, 0.63, y}}

    l: line = (map)
    use, l
    end_file

   Chi2:       0.140916528215442     
   Chi2_coef:  1.443933309059283E-002
   B_diff (G):   1.94478176399389     
   dB_rms (G):   9.31438448020503     
   B_Merit   :  3.978451184747663E-004
   B_int:  3.533268607619795E-009
 
   &Parameters
     field_file = "binary_w8-20_37_144.table"
     z0_phase_ref = 0
     coef_weight = 
     n_loops =
     n_cycles = 
     fft_write = 
   /


The first part of the file before the "end_file" line specifies a bmad lattice with one element that contains
the starting cartesian map fit.

The stuff after the "end_file" and before the "&Parameters" line is just information about the
fit that was performed to create this file and is ignored on input
(see below for more info on this).

The "&Parameters" line to the slash "/" is a fortran namelist. This namelist specifies one parameter
which is the name of the file containing the field table.




The "Nz_ref" sets where the phase reference point is for phi_z. That is, 
the fit terms are of the form:
  B ~ sin(phi_z + kz * (z-z0))
and Nz_ref sets z0. Nz_ref = 1 means that z0 is at z index #1 in the table.
(see below for a description of the field table).


the "term(n) = " lines specifies the fit terms of the starting point of the fit.
Each term is of the form:
      term(n) = coef  kx  ky  kz  family phi_z
The coef is in Tesla.  There are different "forms" and "families" used for the Cartesian map
terms. See the documentation in the Bmad manual.

Note: phi_z is referenced from the center of the element and not the
element end.

%-----------------------------------------------------------------
Field Table File

The third input file used by the program is the element field file
whose name is given the program from the fitnnnn.in file. There are
two types of field files: ASCII and binary. The binary files are
created from the ascii files and their advantage is that they can be
read in much quicker. This is a significant advantage since these
files tend to be large. The binary files must have a name that starts
with "binary_". The program to convert from ASCII to binary is in
      write_binary_table/write_binary_table.f90

The first five lines in the field file gives
  Nx_min, Nx_max, del_x
  Ny_min, Ny_max, del_y
  Nz_min, Nz_max, del_z
  length_scale.
  field_scale.
where one th first line (Nx_min, Nx_max) are the minimum and maximum indexes of the field grid along
the x-axis and del_x is the spacing between points. The other two lines give corresponding
parameters for the y and z-axes. The length_scale gives the conversion factor between position
values in terms of meters. For example, a length_scale of 0.01 means that the positions in the file
are in cm. The field_scale gives the conversion factor between field in terms of Tesla. For example,
a field_scale of 1e-4 means that the field values in the file are in Gauss.

The next seciton of the file gives the field tabletable. This table should have
six columns:
      ! x_postion   y_position   z_position  Bx    By    Bz

%-----------------------------------------------------------------
fit.weight Input File

The third input file used by the program is named "fit.weight". 
This file has all the parameters needed by the program. It looks like:

    &wght
      Nx = 0                    ! restrict Nx
      Ny = 0                    ! restrict Ny
      iz1 = 0                   ! restrict z-range
      iz2 = 0                   ! restrict z-range
      vary_phi_z = .false.      ! vary phi_z in the fit
      n_loops =  200
      n_cycles =  5
      coef_weight_all =  3e-3
      phi_ref_pt = '1'
    /

The Nx and Ny values here can be used to restrict the region over
which the fit is done. "0" means use the full range. For example, if
in the field table there are 12 points horizontally, setting "Nx = 10"
would mean that only 10 points are used from 1 (which is at x = 0) to
10 (which is at x = 9*del_x where del_x is the grid spacing). iz1 and
iz2 restrict the longitudinal range from point iz1 to point iz2. iz1 =
0 means use the default starting longitudinal point (point #1) and iz2
= 0 means use the default ending longitudinal point (point #Nz).

vary_phi_z is a logical that if True alows the optimizer to very phi_z
in the optimiation. Generally if you know that the field has a symmetry
in z (true for CESR wigglers at least), you *don't* want to vary phi_z.
Conversely if there is no symmetry then you will want to vary phi_z.

The optimizer is run for n_cycles and then the program will add 1 to
the number it has from number.in. It will store this new number in
number.in and it will write out a new "fitmmmm.in" file where "mmmm"
is the updated number. It will do this n_loops times. Each time
incrementing the number it writes to number.in. The program will also
stop if it feels that it cannot make progress.

The merit function to be minimized is:
  M = sum: (Bx_fit - Bx_table)^2 + 
      sum: (By_fit - By_table)^2 + 
      sum: (Bz_fit - Bz_table)^2 + 
      sum: coef_weight * (coef_i)^2)
The last sum is over all terms in the fit. 

%-----------------------------------------------------------------
Running the program

Running the program is simple. It will run by itself until it
finishes.  When the program writes out a fitmmmm.in file it also
prints something like:

    Chi2:        391407.750877595     
    Chi2_coef:  1.890402000000000E-004
    B_diff (G):   4229.52984190201     
    dB_rms (G):   12894.8166488047     
    B_Merit   :   1.00384824152624     
    B_int:   -6.011840298555775E-002
    B_diff:     31.37  10752.85   1904.38  12688.59
    B_rms:      67.25  12474.38   3265.23  12894.82
    B_dat:      25.47  10710.09   1904.38  12639.95

Chi2 is the figure of merit (M).

Chi2_coef is the part of the figure of merit for the
coefficients. This will always be less than Chi2.

B_diff = Average: |Bx_fit - Bx_table| + |By_fit - By_table| + |Bz_fit - Bz_table| 

dB_rms = RMS average: (Bx_fit - Bx_table), (By_fit - By_table) & (Bz_fit - Bz_table) 

B_Merit = B_diff / [sum: abs(Bx_table) + abs(By_table) + abs(Bz_table)]

B_int = sum over z points: By_fit(x = 0, y = 0)

B_diff [x, y, z, tot] = B_diff for Bx, By, and Bz components. The 4th
number is just the sum of the first three.

B_rms [x, y, z, tot] = B_rms for Bx, By, and Bz components

B_dat: [x, y, z, tot] = Average |Bx_table|, |By_table|, and |Bz_table| 

The program also prints out lines like:
           1   391407.750877595        10.0000000000000     
           2   391407.750877595        100.000000000000     
           3   391393.714610333        100.000000000000     
           4   391357.721046570        100.000000000000     
           5   391357.721046570        1000.00000000000     
           6   391355.478001373        1000.00000000000     
           7   391352.133272867        1000.00000000000     
           8   391352.133272867        10000.0000000000     

The first column is n_cycles The second column is the merit function
The third column is something called "lambda" which is a measure of
how well the fitting is going. lambda decreases or remains roughly the
same when the optimizer is making progress and increases when the
optimizer is stuck.

%-----------------------------------------------------------------
FFT calculation

The fit will be very dependent upon the initial terms so choosing the
initial terms is important.

The general procedure for obtaining a good fit is as follows: 

First, start with a fitnnnn.in file with no terms. 

Second, Run wiggler_fitting/bin/fft_fit. This uses the same input files as wig_fit.
An example of what the output looks like is:

 Kx:  -50.0000000000000     
 Index       K_z       Amp_fft    Symmetric     Anti_sym
    25     15.79     0.305872     0.009402    -0.305727
    24     15.14     0.292969    -0.169035    -0.239286
    26     16.45     0.288817     0.184179    -0.222471
    23     14.49     0.238295    -0.224184    -0.080782
    27     17.10     0.229874     0.224383    -0.049942
    22     13.83     0.162141    -0.158195     0.035556
    28     17.76     0.147667     0.131929     0.066335
    21     13.18     0.076880    -0.059042     0.049240

 Kx:  0.000000000000000E+000
 Index       K_z       Amp_fft    Symmetric     Anti_sym
    25     15.79     1.514723     0.044730    -1.514062
    24     15.14     1.446352    -0.824673    -1.188212
    26     16.45     1.414771     0.891391    -1.098636
    23     14.49     1.167886    -1.096554    -0.401903


What the program does is set Kx to a few values and then steps through a
number of values for Kz and looks
to see what amplitude coefficient you would want to minimize |B_table - B_fit|
where B_fit is the fit function that it reads in from fitnnnn.in plus an extra
term with a given Kx and Kz. The columns are:

Index:        Ignore this
K_z:          Kz value
Amp_fft:      A measure of how much good the term would do with no symmetry. 
Symmetric:    What the coefficient you would want if the field was symmetric
                [with phi_z = 0]
Anti_sym:     What the coefficient you would want if the field was anti-symmetric 
                [with phi_z = -pi/2]

For example, with the above output, assuming the wiggler field was anti-symmetric, 
you would want to put a term in the fitnnnn.in file that looks like:
  term(  1) = 1.51   0.1  15.79   1.5707960
Note: This sets phi_z to pi/2 which is what you want for an anti-symmetric field. 
For a symmetric field you want phi_z to be 0.
Note: kx is set to something slightly nonzero (0.1) since there is a bug in the 
wig_fit program such that if kx is exactly 0 then the program bombs.

At this point you could put in more terms from the fft calculation if you want. 
After putting in the some terms run wig_fit to find the best local solution. 
After this, run fft_wig again to get further terms, etc., etc.
Eventually you get a fit that has the accuracy you want.

%-----------------------------------------------------------------
Converting to Bmad form.

The fit terms used by the programs in wiggler_fitting do not conform to the Bmad format.
Also the phi_z values must be changed since the reference point for the Bmad format
is at the beginning of the wiggler.
To convert you use the program wiggler_fitting/bin/to_bmad_format. This program will also
create some files that can be used for plotting results. The file with the Bmad 
coefficients has a ".bmad_coefs" suffix.

%-----------------------------------------------------------------
Under the Hood

Some details about the optimization: For a given family, the different forms for the field are
constructed such that they can be considered as one continuous function of (kx, ky, kz) such that
when kx passes through zero there is a transition between hyper_y and hyper_xy forms and when ky
passes through zero there is a transition between hyper_x and hyper_xy forms.  [Note: With the forms
as constructed, a transition between hyper_x and hyper_y when kz passes through zero is not
continuous.  This is not a problem since the constructed continuous function avoids direct
transitions between hyper_x and hyper_y.]

Since there are only two degrees of freedom for (kx, ky, kz) the field is considered to be a
function of kxy = kx + ky and kz. The reason why kxy is used instead of kx or ky is that the
optimizer needs the derivatives of the field with respect the independent variables and if kx or ky
is used, the derivatives can become infinite at the transition points between forms. Using kxy
avoids all infinities. With this, the correspondence between form and (kxy, kz) values is
                                                                                                      Sign of
  Condition          Form          kx                                  ky                             kx   ky
  ---------          --------  --------------------------------    --------------------------------   -------
  kxy > |kz|         hyper_y   (kxy^2 - kz^2) / (2kxy)             (kxy^2 + kz^2) / (2kxy)            +    + 
-|kz| < kxy < |kz|   hyper_xy  (kxy - sqrt(2 kz^2 - kxy^2)) / 2    (kxy + sqrt(2 kz^2 - kxy^2)) / 2   -    +
  kxy < -|kz|        hyper_x   (kxy^2 + kz^2) / (2kxy)             (kxy^2 - kz^2) / (2kxy)            -    -

When the (kx, ky, kz) parameters of a given term are readin from the input file, the form for the
term can determined by using the condition, for example, that ky^2 = kx^2 + kz^2 for the hyper_y
form, etc. The sign of the input kx and ky might not correspond to what is given in the above
table. This can be corrected by flipping signs as needed for kx and ky and then possibly flipping
the sign for the Coef coefficient to keep the caculated field invariant.
