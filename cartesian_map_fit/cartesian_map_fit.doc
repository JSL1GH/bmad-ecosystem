cartesian_map_fit program documentation:

This program finds the best Cartesian map fit to a lattice element field table.

This documentation and source code is in the directory
  util_programs/cartesian_map_fit

%-----------------------------------------------------------------
number.in Input File

There are four input files. The first file to be read in by the
program is:
  number.in
  
This file has only one line and this line just contains a number. The
program will read in this number and then open a file "fitnnnn.in"
where "nnnn" is the number read in. For example, if the number is
"132" then the program will look for the input file: "fit0132.in".

%-----------------------------------------------------------------
fitnnnn.in Input File

The program will read in "fitnnnn.in" which should look something
like:

     Chi2:       0.140916528215442     
     Chi2_coef:  1.443933309059283E-002
     B_diff (G):   1.94478176399389     
     dB_rms (G):   9.31438448020503     
     B_Merit   :  3.978451184747663E-004
     B_int:  3.533268607619795E-009
     Weight_coef:   3.000000000000000E-003
 
     &Parameters
       field_file = "binary_w8-20_37_144.table"
       Nz_ref = 1
       term(  1) =    0.0134634   42.1841705    1.9727237   -1.5707960
       term(  2) =   -0.0379654   34.2375794    5.9284662   -1.5707960
       term(  3) =   -0.0593513  -24.7150456    7.3399490   -1.5707960
       term(  4) =    0.0014459  -63.4099878    7.8424788   -1.5707960
        ... etc. ...
     /

The stuff before the "&Parameters" line is just information about the
fit that was performed to create this file and is ignored on input
(see below for more info on this). 

The "field_file = " line specifies the field table file 

The "Nz_ref = 1" sets where the phase reference point is for phi_z. That is, 
the fit terms are of the form:
  B ~ sin(phi_z + kz * (z-z0))
and Nz_ref sets z0. Nz_ref = 1 means that z0 is at z index #1 in the table.
(see below for a description of the field table).


the "term(n) = " lines specifies the fit terms of the starting point of the fit.
Each term is of the form:
      term(n) = coef  kx  kz  phi_z
The coef is in Tesla.  There are different "forms" and "families" used for the Cartesian map
terms. See the documentation in the Bmad manual. Here ky is calculated from kx and kz via:
  If kx > 0:          ky = sqrt(kz^2 + kx^2)
  If 0 > Kx > -|kz|:  ky = sqrt(kz^2 - kx^2)
  Else:               ky = sqrt(kx^2 - kz^2)

Note: phi_z is referenced from the center of the element and not the
element end.

%-----------------------------------------------------------------
Element Field Table File

The third input file used by the program is the element field file
whose name is given the program from the fitnnnn.in file. There are
two types of field files: ASCII and binary. The binary files are
created from the ascii files and their advantage is that they can be
read in much quicker. This is a significant advantage since these
files tend to be large. The binary files must have a name that starts
with "binary_". The program to convert from ASCII to binary is in
      write_binary_table/write_binary_table.f90

The first line in the field file gives Nx, Ny and Nz where Nx
is the number of points in the table horizontally, Ny is the number of
points in the table vertically, and Nz is the number of points
longitudinally. The total number of points is, naturally: 
      Nx x Ny x Nz. 
The next lines give the columns of the table. This table should have
columns:
      x_postion   y_position   z_position  Bx    By    Bz
					(cm)     (cm)          (cm)     (G)   (G)   (G)   
The order of the lines in the table is important. For example, the
program assumes that in the first Nz data lines the x_position and
y_position are constant (with a value of 0) and the z_position is
increasing in fixed steps.

%-----------------------------------------------------------------
fit.weight Input File

The third input file used by the program is named "fit.weight". 
This file has all the parameters needed by the program. It looks like:

    &wght
      Nx = 0                    ! restrict Nx
      Ny = 0                    ! restrict Ny
      iz1 = 0                   ! restrict z-range
      iz2 = 0                   ! restrict z-range
      vary_phi_z = .false.      ! vary phi_z in the fit
      n_loops =  200
      n_cycles =  5
      weight_coef_all =  3e-3
      phi_ref_pt = '1'
    /

The Nx and Ny values here can be used to restrict the region over
which the fit is done. "0" means use the full range. For example, if
in the field table there are 12 points horizontally, setting "Nx = 10"
would mean that only 10 points are used from 1 (which is at x = 0) to
10 (which is at x = 9*del_x where del_x is the grid spacing). iz1 and
iz2 restrict the longitudinal range from point iz1 to point iz2. iz1 =
0 means use the default starting longitudinal point (point #1) and iz2
= 0 means use the default ending longitudinal point (point #Nz).

vary_phi_z is a logical that if True alows the optimizer to very phi_z
in the optimiation. Generally if you know that the field has a symmetry
in z (true for CESR wigglers at least), you *don't* want to vary phi_z.
Conversely if there is no symmetry then you will want to vary phi_z.

The optimizer is run for n_cycles and then the program will add 1 to
the number it has from number.in. It will store this new number in
number.in and it will write out a new "fitmmmm.in" file where "mmmm"
is the updated number. It will do this n_loops times. Each time
incrementing the number it writes to number.in. The program will also
stop if it feels that it cannot make progress.

The merit function to be minimized is:
  M = sum: (Bx_fit - Bx_table)^2 + 
      sum: (By_fit - By_table)^2 + 
      sum: (Bz_fit - Bz_table)^2 + 
      sum: weight_i * (coef_i)^2)
The last sum is over all terms in the fit.  weight_i is determined by
the weight_coef_all variable in the fit.weight file.

%-----------------------------------------------------------------
Running the program

Running the program is simple. It will run by itself until it
finishes.  When the program writes out a fitmmmm.in file it also
prints something like:

		Chi2:        391407.750877595     
		Chi2_coef:  1.890402000000000E-004
		B_diff (G):   4229.52984190201     
		dB_rms (G):   12894.8166488047     
		B_Merit   :   1.00384824152624     
		B_int:   -6.011840298555775E-002
		B_diff:     31.37  10752.85   1904.38  12688.59
		B_rms:      67.25  12474.38   3265.23  12894.82
		B_dat:      25.47  10710.09   1904.38  12639.95

Chi2 is the figure of merit (M).

Chi2_coef is the part of the figure of merit for the
coefficients. This will always be less than Chi2.

B_diff = Average: |Bx_fit - Bx_table| + |By_fit - By_table| + |Bz_fit - Bz_table| 

dB_rms = RMS average: (Bx_fit - Bx_table), (By_fit - By_table) & (Bz_fit - Bz_table) 

B_Merit = B_diff / [sum: abs(Bx_table) + abs(By_table) + abs(Bz_table)]

B_int = sum over z points: By_fit(x = 0, y = 0)

B_diff [x, y, z, tot] = B_diff for Bx, By, and Bz components. The 4th
number is just the sum of the first three.

B_rms [x, y, z, tot] = B_rms for Bx, By, and Bz components

B_dat: [x, y, z, tot] = Average |Bx_table|, |By_table|, and |Bz_table| 

The program also prints out lines like:
           1   391407.750877595        10.0000000000000     
           2   391407.750877595        100.000000000000     
           3   391393.714610333        100.000000000000     
           4   391357.721046570        100.000000000000     
           5   391357.721046570        1000.00000000000     
           6   391355.478001373        1000.00000000000     
           7   391352.133272867        1000.00000000000     
           8   391352.133272867        10000.0000000000     

The first column is n_cycles The second column is the merit function
The third column is something called "lambda" which is a measure of
how well the fitting is going. lambda decreases or remains roughly the
same when the optimizer is making progress and increases when the
optimizer is stuck.

%-----------------------------------------------------------------
FFT calculation

The fit will be very dependent upon the initial terms so choosing the
initial terms is important.

The general procedure for obtaining a good fit is as follows: 

First, start with a fitnnnn.in file with no terms. 

Second, Run wiggler_fitting/bin/fft_fit. This uses the same input files as wig_fit.
An example of what the output looks like is:

 Kx:  -50.0000000000000     
 Index       K_z       Amp_fft    Symmetric     Anti_sym
    25     15.79     0.305872     0.009402    -0.305727
    24     15.14     0.292969    -0.169035    -0.239286
    26     16.45     0.288817     0.184179    -0.222471
    23     14.49     0.238295    -0.224184    -0.080782
    27     17.10     0.229874     0.224383    -0.049942
    22     13.83     0.162141    -0.158195     0.035556
    28     17.76     0.147667     0.131929     0.066335
    21     13.18     0.076880    -0.059042     0.049240

 Kx:  0.000000000000000E+000
 Index       K_z       Amp_fft    Symmetric     Anti_sym
    25     15.79     1.514723     0.044730    -1.514062
    24     15.14     1.446352    -0.824673    -1.188212
    26     16.45     1.414771     0.891391    -1.098636
    23     14.49     1.167886    -1.096554    -0.401903


What the program does is set Kx to a few values and then steps through a
number of values for Kz and looks
to see what amplitude coefficient you would want to minimize |B_table - B_fit|
where B_fit is the fit function that it reads in from fitnnnn.in plus an extra
term with a given Kx and Kz. The columns are:

Index:        Ignore this
K_z:          Kz value
Amp_fft:      A measure of how much good the term would do with no symmetry. 
Symmetric:    What the coefficient you would want if the field was symmetric
                [with phi_z = 0]
Anti_sym:     What the coefficient you would want if the field was anti-symmetric 
                [with phi_z = -pi/2]

For example, with the above output, assuming the wiggler field was anti-symmetric, 
you would want to put a term in the fitnnnn.in file that looks like:
  term(  1) = 1.51   0.1  15.79   1.5707960
Note: This sets phi_z to pi/2 which is what you want for an anti-symmetric field. 
For a symmetric field you want phi_z to be 0.
Note: kx is set to something slightly nonzero (0.1) since there is a bug in the 
wig_fit program such that if kx is exactly 0 then the program bombs.

At this point you could put in more terms from the fft calculation if you want. 
After putting in the some terms run wig_fit to find the best local solution. 
After this, run fft_wig again to get further terms, etc., etc.
Eventually you get a fit that has the accuracy you want.

%-----------------------------------------------------------------
Converting to Bmad form.

The fit terms used by the programs in wiggler_fitting do not conform to the Bmad format.
Also the phi_z values must be changed since the reference point for the Bmad format
is at the beginning of the wiggler.
To convert you use the program wiggler_fitting/bin/to_bmad_format. This program will also
create some files that can be used for plotting results. The file with the Bmad 
coefficients has a ".bmad_coefs" suffix.

WARNING: THIS PROGRAM DID WORK IN TIMES PAST BUT THE FIELD TABLE FILE HAS CHANGED ENOUGH
SO THAT IT SHOULD BE TESTED THAT THE PHI_Z TRANSFORMATION STILL IS CORRECT.
