module opal_interface_mod

use bmad_struct
use bmad_interface
use write_lat_file_mod


contains

!------------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------------

!------------------------------------------------------------------------
!------------------------------------------------------------------------
!------------------------------------------------------------------------
!+ 
! Subroutine write_opal_lattice_file (opal_file, lat, err)
!
! Subroutine to write an OPAL lattice file using the information in
! a lat_struct. Optionally only part of the lattice can be generated.
!
! Modules needed:
!   ?? use write_lat_file_mod
!
! Input:
!   opal_file     -- Character(*): Name of the output lattice file.
!   lat           -- lat_struct: Holds the lattice information.
!   ix_start      -- Integer, optional: Starting index of lat%ele(i)
!                       used for output.
!   ix_end        -- Integer, optional: Ending index of lat%ele(i)
!                       used for output.
!
! Output:
!   err    -- Logical, optional: Set True if, say a file could not be opened.
!-

subroutine write_opal_lattice_file (opal_file, lat, err)

implicit none


type (ele_struct), pointer :: ele
type (lat_struct), target :: lat

real(rp), pointer :: val(:)

character(*)	:: opal_file
character(200)	:: file_name
character(40)	:: r_name = 'write_opal_lattice_file', name
character(2) 	:: continue_char, eol_char, comment_char
character(4000)	:: line
integer			:: iu,  ios, ix_match, ie, ix_start, ix_end
integer			:: n_names, n
character(40), allocatable :: names(:)
integer, allocatable :: an_indexx(:), name_occurrences(:)


logical, optional :: err

if (present(err)) err = .true.


! Open the file
iu = lunget()
call fullfilename (opal_file, file_name)
open (iu, file = file_name, iostat = ios)
if (ios /= 0) then
  call out_io (s_error$, r_name, 'CANNOT OPEN FILE: ' // trim(opal_file))
  return
endif

!OPAL formatting characters
comment_char = '//'
continue_char = ''
eol_char = ';'


!Elements to write
!FIXME
ix_start = 1 !lat%opal%ix_start
ix_end = 2   !lat%opal%ix_end
if (ix_start > ix_end) then
  call out_io (s_error$, r_name, 'Bad index range')
  return
endif

!Initialize unique name list
n = ix_end - ix_start + 1
allocate ( names(n), an_indexx(n), name_occurrences(n) )
name_occurrences = 0
n_names = 0

!-------------------------------------------
! Write info to the output file...
! lat lattice name

write (iu, '(3a)') comment_char, ' File generated by: write_opal_lattice_file', trim(eol_char)
write (iu, '(4a)') comment_char, ' Bmad Lattice File: ', trim(lat%input_file_name), trim(eol_char)
write (iu, '(4a)') comment_char, ' Bmad Lattice: ', trim(lat%lattice), trim(eol_char)
write (iu, *)

!Loop over all elements
ele_loop: do ie = ix_start, ix_end
	ele => lat%ele(ie)
	!point to value array for convenience
	val => ele%value
	
	
	!Make unique names	
    call find_indexx (ele%name, names, an_indexx, n_names, ix_match)
    if (ix_match > 0) then
    	name_occurrences(ix_match) = name_occurrences(ix_match) + 1
    	!Replace ele%name with a unique name
    	write(ele%name, '(2a,i0)') trim(ele%name), '_', name_occurrences(ix_match) 
    	!Be careful with this internal write statement
    	!This only works because ele%name is first in the write list
	end if
    !add name to list  
    call find_indexx (ele%name, names, an_indexx, n_names, ix_match, add_to_list = .true.)
    n_names = n_names + 1


	select case (ele%key)

     case (marker$)
        write (line, '(a, es13.5)') trim(ele%name) // ': marker'
     case (drift$)
        write (line, '(a, es13.5)') trim(ele%name) // ': drift, l =', val(l$)
     case (sbend$)
        write (line, '(a, es13.5)') trim(ele%name) // ': sbend, l =', val(l$)
        call value_to_line (line, val(b_field$), 'k0', 'es13.5', 'R')
        call value_to_line (line, val(e_tot$), 'designenergy', 'es13.5', 'R')
     case (quadrupole$)
        write (line, '(a, es13.5)') trim(ele%name) // ': quadrupole, l =', val(l$)
        !Note that OPAL-T has k1 = dBy/dx, and that bmad needs a -1 sign for electrons
        call value_to_line (line, -1*val(b1_gradient$), 'k1', 'es13.5', 'R')

     case default
        call out_io (s_error$, r_name, 'UNKNOWN ELEMENT TYPE: ' // key_name(ele%key), &
             'CONVERTING TO DRIFT')
        write (line, '(a, es13.5)') trim(ele%name) // ': drift, l =', val(l$)
	end select

    !elemedge The edge of the field is specifieda bsolute (floor space co-ordinates) in m.
	call value_to_line (line, ele%s - val(L$), 'elemedge', 'es13.5', 'R', .false.)


	!call write_opal_field_map()


	!Finally write out line
	call write_lat_line (line, iu, .true.)  

enddo ele_loop

end subroutine write_opal_lattice_file


!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!+
! Subroutine convert_particle_coordinates_t_to_s (particle, p0c, mc2, tref)
!
! Subroutine to convert particle coordinates from t-based to s-based system. 
!
! Modules needed:
!   use bmad
!
! Input:
!   particle   -- coord_struct: input particle
!   p0c        -- real: Reference momentum. The sign indicates direction of p_s. 
!   mc2        -- real: particle rest mass in eV
!   tref       -- real: reference time for z coordinate
! Output:
!    particle   -- coord_struct: output particle 
!-

subroutine convert_particle_coordinates_t_to_s (particle, p0c, mc2, tref)

!use bmad_struct

implicit none

type (coord_struct), intent(inout), target ::particle
real(rp), intent(in) :: p0c
real(rp), intent(in) :: mc2
real(rp), intent(in) :: tref

real(rp) :: pctot

real(rp), pointer :: vec(:)
vec => particle%vec

      !Convert t to s
      pctot = sqrt (vec(2)**2 + vec(4)**2 + vec(6)**2)
      !vec(1) = vec(1)   !this is unchanged
      vec(2) = vec(2)/abs(p0c)
      !vec(3) = vec(3)   !this is unchanged
      vec(4) = vec(4)/abs(p0c)
      vec(5) = -c_light * (pctot/sqrt(pctot**2 +mc2**2)) *  (particle%t - tref) !z \equiv -c \beta(s)  (t(s) -t_0(s)) 
      vec(6) = pctot/abs(p0c) - 1.0_rp

end subroutine convert_particle_coordinates_t_to_s

!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!+
! Subroutine convert_particle_coordinates_s_to_t (particle, p0c)
!
! Subroutine to convert particle coordinates from s-based to t-based system. 
!     The sign of p0c indicates the direction of p_s
!
! Modules needed:
!   use bmad
!
! Input:
!   particle   -- coord_struct: input particle
!   p0c        -- real: Reference momentum. The sign indicates direction of p_s 
! Output:
!    particle   -- coord_struct: output particle 
!-

subroutine convert_particle_coordinates_s_to_t (particle, p0c)

!use bmad_struct

implicit none

type (coord_struct), intent(inout), target :: particle
real(rp), intent(in) :: p0c
real(rp), pointer :: vec(:)

vec => particle%vec

      !Convert s to t
      vec(6) = p0c * sqrt( ((1+vec(6)))**2 - vec(2)**2 -vec(4)**2 )
      !vec(1) = vec(1) !this is unchanged
      vec(2) = vec(2)*abs(p0c)
      !vec(3) = vec(3) !this is unchanged
      vec(4) = vec(4)*abs(p0c)
      vec(5) = particle%s
      

end subroutine convert_particle_coordinates_s_to_t


end module
