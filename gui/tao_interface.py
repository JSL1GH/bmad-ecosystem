import sys
import os
import re
import io
if 'ACC_LOCAL_ROOT' in os.environ.keys():
  sys.path.append(os.environ['ACC_LOCAL_ROOT']+'/tao/python/')
elif 'ACC_LOCAL_DIR' in os.environ.keys():
  sys.path.append(os.environ['ACC_LOCAL_DIR']+'/tao/python/')
else:
  sys.path.append(os.environ['ACC_ROOT_DIR']+'/tao/python/')
from tao_pexpect.tao_pipe import tao_io
import pytao
import tkinter as tk

class new_stdout(object):
  '''
  Re-routes the print statements generated by tao_io
  so that they can be shown by tao_console.
  '''
  def __init__(self):
    self.file_obj = io.StringIO()
  def __enter__(self):
    self.current_out = sys.stdout
    sys.stdout = self.file_obj
    return self.file_obj
  def __exit__(self, type, value, traceback):
    sys.stdout = self.current_out

def filter_output(x):
  '''
  Filters out certain ANSI escape sequences from the string x
  '''
  if not isinstance(x, str):
    return x
  # Filter out \[[6 q first
  x = x.replace('\x1b[6 q', '')
  # replace line feed ('\x0a') with return ('\x0d')
  #while x.find('\x0a') != -1:
  #  x = x.replace('\x0a', '\x0d')
  # Remove xterm-specific escape code
  if x.find('\x1b[?1034h') != -1:
    x = x.replace('\x1b[?1034h', "")
  # Filter out color codes
  color_regex = re.compile('\x1b\\[[0-9;]*m')
  matches = color_regex.findall(x)
  for color in matches:
    x = x.replace(color, '')
  return x


class tao_interface():
  '''
  Provides an interface between the GUI and
  the Tao command line
  '''
  def __init__(self, mode, init_args = "", tao_exe =  "", expect_str = "Tao>", so_lib=""):
    self.mode = mode
    if 'ACC_LOCAL_ROOT' in os.environ.keys():
      if tao_exe == "":
        tao_exe = '$ACC_LOCAL_ROOT/production/bin/tao'
    # Needed to capture print statements from tao_io

    if mode == "pexpect":
      with new_stdout() as output:
        self.pexpect_pipe = tao_io(init_args=init_args,
            tao_exe=tao_exe, expect_str=expect_str)
    elif mode == "ctypes":
      with new_stdout() as output:
        self.ctypes_pipe = pytao.Tao(so_lib=so_lib)
        self.ctypes_pipe.init(init_args)

    # Process startup message
    output = output.getvalue()
    output = filter_output(output)
    self.startup_message = output

    self.message = ""
    self.message_type = "" #conveys color info to console
    self.printed = tk.BooleanVar()
    self.printed.set(False)

  def cmd_in(self, cmd_str, no_warn=False):
    '''
    Runs cmd_str at the Tao command line and returns the output
    Warning messages generated by this command are suppressed when
    no_warn is set True
    '''
    self.message = ""
    self.message_type = "normal" #conveys color info to console
    if cmd_str.find("single_mode") == 0:
      output = "single_mode not supported on the GUI command line"
      self.message_type = "error"
    elif self.mode=="pexpect":
      output = self.pexpect_pipe.cmd_in(cmd_str)
    elif self.mode=='ctypes':
      output_list = self.ctypes_pipe.cmd(cmd_str)
      output = ""
      for line in output_list:
        if line.strip != '':
          output += line + '\n'
      if (len(output) > 0) and (output[-1] == '\n'):
        output = output[:-1]
    # Scrub output for extra new lines at the end,
    # as well as escape characters
    if cmd_str.find('python') == 0:
      output = output.replace('\r\n\r\n', '')
    output = filter_output(output)
    #if no_warn:
    #  return output
    if cmd_str.find("spawn ") == 0:
      self.message += "WARNING: the spawn command is very dangerous "
      self.message += "and may cause the GUI to hang if the spawned "
      self.message += "process does not exit quickly."
      self.message_type = "error"
      self.printed.set(True)
      self.message = ""
      self.message_type = "normal"
    if output.find("[ERROR") != -1:
      self.message += "Warning: Error occurred in Tao\n"
      self.message += "The offending command: " + cmd_str + "\n"
      self.message += "The error (first 20 lines):\n"
      if len(output.splitlines()) > 20:
        for i in range(20):
          self.message += (output.splitlines()[i]) + "\n"
      else:
        self.message += output
      self.message_type = "error"
      if not no_warn:
        self.printed.set(True)
    if (output.find("Backtrace") != -1) | \
        (output.find("SIGSEGV") != -1):
      self.message = "Error occurred in Tao, causing it to crash\n"
      self.message += "The offending command: " + cmd_str + '\n'
      self.message += "The error:\n"
      self.message += output + '\n'
      self.message_type = "fatal"
      if not no_warn:
        self.printed.set(True)
    return output

  def cmd(self, cmd_str):
    '''
    Runs cmd_str at the Tao command line and prints the output
    '''
    self.cmd_in(cmd_str, no_warn=True)
    if self.is_open:
      print (self.pipe.after + self.pipe.before)
    else:
      print ('Not connected to Tao...')
