import sys
import os
import io
if 'ACC_LOCAL_DIR' in os.environ.keys():
  sys.path.append(os.environ['ACC_LOCAL_DIR']+'/tao/python/tao_pexpect')
else:
  sys.path.append(os.environ['ACC_ROOT_DIR']+'/tao/python/tao_pexpect')
from tao_pipe import tao_io
import tkinter as tk

class new_stdout(object):
  '''
  Re-routes the print statements generated by tao_io
  so that they can be shown by tao_console.
  '''
  def __init__(self):
    self.file_obj = io.StringIO()
  def __enter__(self):
    self.current_out = sys.stdout
    sys.stdout = self.file_obj
    return self.file_obj
  def __exit__(self, type, value, traceback):
    sys.stdout = self.current_out

class tao_interface():
  '''
  Provides an interface between the GUI and
  the Tao command line
  '''
  def __init__(self, mode, init_args = "", tao_exe =  "", expect_str = "Tao>"):
    self.mode = mode
    # Needed to capture print statements from tao_io

    if mode == "pexpect":
      with new_stdout() as output:
        tao_io.__init__(self, init_args=init_args,
            tao_exe=tao_exe, expect_str=expect_str)
      output = output.getvalue()
      output = output.replace('\r\n\r\n', '')
      output = output.replace('\x1b[6 q', '')
      self.startup_message = output
    elif mode == "ctypes":
      pass
      #Start ctypes interface
    self.message = ""
    self.message_type = "" #conveys color info to console
    self.printed = tk.BooleanVar()
    self.printed.set(False)

  def cmd_in(self, cmd_str, no_warn=False):
    '''
    Runs cmd_str at the Tao command line and returns the output
    Warning messages generated by this command are suppressed when
    no_warn is set True
    '''
    self.message = ""
    self.message_type = "normal" #conveys color info to console
    output = tao_io.cmd_in(self, cmd_str)
    # Scrub output for extra new lines at the end,
    # as well as escape characters
    output = output.replace('\r\n\r\n', '')
    output = output.replace('\x1b[6 q', '')
    #if no_warn:
    #  return output
    if output.find("[ERROR") != -1:
      self.message += "Warning: Error occurred in Tao\n"
      self.message += "The offending command: " + cmd_str + "\n"
      self.message += "The error (first 20 lines):\n"
      if len(output.splitlines()) > 20:
        for i in range(20):
          self.message += (output.splitlines()[i]) + "\n"
      else:
        self.message += (output)
      self.message_type = "error"
      if not no_warn:
        self.printed.set(True)
    if (output.find("Backtrace") != -1) | \
        (output.find("SIGSEGV") != -1):
      self.message = "Error occurred in Tao, causing it to crash\n"
      self.message += "The offending command: " + cmd_str + '\n'
      self.message += "The error:\n"
      self.message += output + '\n'
      self.message_type = "fatal"
      if not no_warn:
        self.printed.set(True)
    return output

  def cmd(self, cmd_str):
    '''
    Runs cmd_str at the Tao command line and prints the output
    '''
    self.cmd_in(cmd_str, no_warn=True)
    if self.is_open:
      print (self.pipe.after + self.pipe.before)
    else:
      print ('Not connected to Tao...')
