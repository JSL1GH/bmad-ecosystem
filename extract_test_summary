#!/usr/bin/python
####################################################################
# This script extracts the results of the test_suite script from a
# file to which that output has been directed and prints a summary
# of the success or failure of each program execution.
#
# This need only run properly under Linux to generate test
# summaries out of concatenated test job output.  It is called from
# the build_master script near the very end of a CESR build process.
#
# Usage : extract_test_summary <test_output_file>
#     i.e. extract_test_summary cesr_2007_0305_d.log
#
# Author : Matt Rendina
# Date   : 5 March 2007
####################################################################

import sys, os, string, shutil, time, ConfigParser

#================================
# Command line argument handling
#================================
if len(sys.argv) == 1:
  print "\nUsage: " + sys.argv[0] + " <file where test suite output resides>"
  sys.exit(0)
elif len(sys.argv) > 2:
  print "Invalid number of arguments."
  sys.exit(2)
else:
  file = sys.argv[1]


#============================================================================
# Set up config file machinery
#============================================================================
cfg_file = "/home/cesrulib/bin/util/BUILD_SYSTEM.conf"
config   = ConfigParser.ConfigParser()
config.optionxform = lambda x: x   # Obtain all values without changing case
config.read(cfg_file)              # Overrides default ConfigParser behavior
#============================================================================
# Grab necessary values from the Config files.
#============================================================================
UTIL_DIR = config.get("Paths", "UTIL_DIR")
suite_cfg_file = UTIL_DIR +'/'+ config.get("Test_Suite", "CONFIG_FILE")
sconfig = ConfigParser.ConfigParser()
sconfig.optionxform = lambda x: x
sconfig.read(suite_cfg_file)
test_list  = sconfig.sections()
test_list.remove("files")


#============
# Local vars
#============
num_tests = len(test_list)
num_completed = 0

pad = ""
f = open(file, 'r')
lines = f.readlines()

for line in lines:
  if line.find("Platform : ") != -1:
    platform = line.split(":")[1].strip()
    print platform
  if line.find("TEST COMPLETED") != -1:
    num_completed = num_completed + 1
    line = line.strip()
    chunks = line.split()
    returncode = chunks[5]
    name = chunks[0]
    if returncode == "0":
      status = "OK"
    elif returncode == "16" and name == "nonlin_bpm_test" and platform == "Linux_i686_lahey":
      status = "OK"
    elif returncode == "174" and name == "tao" and platform == "OSF1_alpha_hp":
      status = "OK"
    else:
      status = "FAILED!"
    for i in range( 0,22-len(name) ):
      name = name + ' '
    name = name + " : " + status
    if returncode != "0":
      name = name + ' (' + str(returncode) + ')'
    time = int( chunks[-2] )
    for i in range( 0,40-len(name) ):
      name = name + ' '
    name = name + ' '
    
    string = name + "Test lasted: "+str( time ) + " s"
    print string    
        

if num_completed < num_tests:
  print "\nERROR!  Could only obtain %i out of %i requested test results!" % (num_completed, num_tests)
  sys.exit(5)
    
