#!/usr/bin/perl 
#
########################################################################
##
## this script, called by M.tail, sorts out what to do about each of
## the files for which dependencies are required:
##
## if file is c++, get dependency list from the cxx/g++ compiler and
##    convert the output to CESR format
## if file is fortran, run makedepend and cesrdepend
## otherwise just run makedepend
##
#######################################################################

use File::Basename;

#print STDERR "\nin cesrmakedepend\n";
get_args(@ARGV);
#print "includes: @includes\n";
#print "cplusplus: $cplusplus, c: $c, fortran: $fortran \n";
#print "$prefix\n";
setup_commands();
run_command();
convert_to_cesr();

sub convert_to_cesr {
    open(d_file,">$out_file");
    foreach $dependency (@dependencies) {
        chomp $dependency;
        if(($dependency=~/^(.+?)\.o\s*?:\s+(.+?)[\s\/\\]*?$/)) {
            $tgt=basename($1);
            print d_file "$prefix$tgt$suffix: $2\n";
        }
        elsif(($dependency=~/\s*?(.+?)[\s\\]*?$/)) {
            $dep=$1;
            $out_file=~/\.depend\/(.+?)\.d/;
            $tgt=basename($1);
            print d_file "$prefix$tgt$suffix: $dep\n";
        }
        else {
            die "\nUnexpected dependency format from compiler: $dependency\n";
        }
    }
    close (d_file);
}


sub run_command {
    if($cplusplus) {
        @dependencies=`$command`;
    }
    elsif($fortran) {
#        system "$command;pwd"; exit(0);
#        system "$command";exit(0);
        system "$command";cesr_make_depend($cesrdep_args);exit(0);
    }
    elsif($c){
        system "$command";exit(0);
    }
}


sub setup_commands {
    @os=`uname`;
    $command="makedepend @includes $cpp -o'$suffix' -p'$prefix' -f$out_file $src_file";
    if($os[0]=~/Darwin/i) {
        #print "Setting makedepend path correctly for Darwin.\n";
        $command="/usr/X11R6/bin/makedepend @includes $cpp -o'$suffix' -p'$prefix' -f$out_file $src_file";
    }

    if($cplusplus) {
        if($os[0]=~/osf1/i) {
            $command="cxx -M @includes $src_file";
        }
        elsif($os[0]=~/linux/i) {
            $command="g++ -M -Wno-deprecated @includes $src_file";
        }
        elsif($os[0]=~/Darwin/i) {
            $command="g++ -M -Wno-deprecated @includes $src_file";
        }

    }
    elsif($fortran) {
#        $cesrdep_args="@includes -PRE'$prefix' -SUF'$suffix' -f$out_file $local_mods -MP'$mod_out_dir' -cpfile'$cpp_file' -cpt'$cpp_ftail' -fort_cpp'$fort_cpp' $cpp $src_file";
        $cesrdep_args="@includes -PRE'$prefix' -SUF'$suffix' -f$out_file -MP'$mod_out_dir' -cpt'$cpp_ftail' $src_file";
#        $command=$command."; \$CESR_UTIL/cesrdepend ".$cesrdep_args;
    }
}



sub get_args {
    @includes=();
    $local_mods=" ";
    $mod_out_dir=" ";
    $cpp=" ";
    $CASE="l";

#   Parse all command line arguments
    foreach $arg (@ARGV) {
        if($arg=~/^-I/) {
            push(@includes, $arg);
        }
        elsif($arg=~/^-MOD(.+)/) {
#            $local_mods="-MOD\"$1\"";
            $local_mods0="$1";
        }
        elsif($arg=~/^-MP(.+)/) {
            $mod_out_dir="$1";
        }
        elsif($arg=~/^-cpt(.+)/) {
            $cpp_ftail=$1;
        }
        elsif($arg=~/^-cpp_file(.+)/) {
            $cpp_file=$1;
        }
        elsif($arg=~/^-cpp(.+)/) {
#            $cpp="-cpp\"$1\"";
             $cpp="$1";
        }
        elsif($arg=~/^-out(.+)/) {
            $out_file=$1;
        } 
        elsif($arg=~/^-o(.+)/) {
            $suffix=$1;
#            $suffix=~s/\s//g;
        }
        elsif($arg=~/^-p(.+)/) {
            $prefix=$1;
        }
        elsif($arg=~/^-fort_cpp(.+)/) {
            $fort_cpp=$1;
        }
        #elsif($arg=~/^-f(.+)/) {  #removed because of anomalous behavior on Darwin
        #    $out_file=$1;         # replaced with -out (_BEFORE -o_ for proper short-circuit eval) above.
        #} 
        elsif($arg=~/^-CASE(.+)/) {
            $CASE=$1;
        } 
        elsif($arg!~/^-/) {
            $src_file=$arg;
        }
    }
    $cplusplus=0;
    $c=0;
    $fortran=0;

#   Check what language the file is in by examining the extension
    if(($src_file=~/\.cxx/i) or ($src_file=~/\.cpp/i) or ($src_file=~/\.cc/i) or ($src_file=~/\.C/) or ($src_file=~/\.c\+\+/i)) {
        $cplusplus=1;
    }
    elsif(($src_file=~/\.f90/i) or ($src_file=~/\.f/i) or ($src_file=~/\.f95/i) or ($src_file=~/\.f77/i)) {
        $fortran=1;
    }
    elsif($src_file=~/\.c/) {
        $c=1;
    }
    else{
        die "\n$src_file: file format not recognized";
    }
}




##################################################################
##
##  this script examines each fortran file for which dependencies
##  need to be generated, and searches for the files upon which
##  this source depends recursively.
##
##  WARNING:  Platform dependence is explicitly handled in this 
##            script, independent of platform dependent flags and 
##            executables set in the M.tail makefile.  For the 
##            long term this is unsafe and must be fixed.
##            MAP  11/09/03
##################################################################
sub cesr_make_depend {
   #print "arguments: $_[0]\n";
#    print "1: $_[0]\n";
    @ARGUMENTOS= split(/\s+/,$_[0]);
    @local_mods= split(/\s+/,$local_mods0);
    $cpp_flags=$cpp;
parse_args(@ARGUMENTOS);
#  print "2: $ARGUMENTOS[15]\n $cpp_file\n";
cpp_setup2();
#    print "eto cpp_command: $cpp_command\n";
#    print "a eto cpp_ftail: $cpp_ftail\n";
get_input();
get_used_file_tree();
print_d_file();
}

# Function to parse input arguments
sub parse_args {
    @search_dirs_4subs     =();
    @search_dirs           =();
#    @local_mods            =();
    $d_file                ="";
    $fixed_format=0;
    foreach $argument (@ARGUMENTOS) {
        if($argument=~/^-I(.+)/) {
            push(@search_dirs_4subs,$1);
            push(@search_dirs,$argument);
        }
#        elsif($argument=~/^-MOD(.*)/) {
#            push(@local_mods,(split /\s/,$1));
#        }
        elsif($argument=~/^-MP(.*)/) {
            $mod_out_dir=$1;
            $mod_out_dir=~ s/\'//g;
        }
        elsif($argument=~/^-PRE(.*)/) {
            $prefixa=$1;
            $prefixa=~ s/\'//g;
        }
        elsif($argument=~/^-SUF(.*)/) {
            $suffixa=$1;
            $suffixa=~ s/\'//g;
        }
#        elsif($argument=~/^-fort_cpp(.+)/) {
#            $fort_cpp=$1;
#        }
        elsif($argument=~/^-cpt(.+)/) {
            $cpp_ftail=$1;
        }
#        elsif($argument=~/^-cpfile(.+)/) {
#            $cpp_file=$1;
#        }
        elsif($argument=~/^-f(.*)/) {
            $d_file=$1;
        }
#        elsif($argument=~/^-cpp(.*)/) {
#            $cpp_flags=$1;
#        }
        elsif($argument!~/^-/) {
            $src_file=$argument;
        }
    }
    if($src_file=~/\.f$/i) {
        $fixed_format=1;
    }
}
#######
# Function to initialize cesrdepend configuration
sub cpp_setup2 {
#   Configure  full cpp command
    $cpp_file_tail=" ";
    if ($cpp_ftail=~/YES/){$cpp_file_tail=">$cpp_file"};
    $cpp_command = $fort_cpp." ".$cpp_flags." "."@search_dirs"." ".$src_file." ".$cpp_file_tail;
}
#######
# prints all the information collected into a dependency (.d) file
sub print_d_file {
    $print_to_file = 0;
    $mods_to_create_var="";
    $final_module_var  ="";
    $final_inc_var     ="";

    if(@final_mod_list or @final_inc_list or @mods_to_create) {
        foreach $mod (@mods_to_create) {
            $mods_to_create_var="$mods_to_create_var $mod_out_dir/$mod";
        }
        foreach $mod (@final_mod_list) {
            $final_module_var="$final_module_var $mod";
        }
        $src_file=~/(\w+)\.\w{1,3}$/;
        $src_file=$1;
        if (length($d_file) > 0) {
            open(F_out, ">>$d_file");
            $print_to_file = 1;
        }

        foreach $inc (@final_inc_list) {
            if ($print_to_file == 1) {
                print F_out ("$prefixa$src_file$suffixa: $inc\n");
            }
            else {
                print ("$prefixa$src_file$suffixa: $inc\n");
            }
        }
    
        if($final_module_var) {
            if ($print_to_file == 1) {
                print F_out ("$prefixa$src_file$suffix$mods_to_create_var: $final_module_var\n");
            }
            else {
                print ("$prefixa$src_file$suffixa$mods_to_create_var: $final_module_var\n");
            }
        } 

        if ($print_to_file == 1) {            
            close(F_out);
        }
    }
}

# search for any included (by a fortran include) files in search directories
sub find_incs {
    @new_incs=();
    $src_dir     ="";
  INC: foreach $inc (@needed_incs) {
#     If i've already found this file, go on.
      if($seen{$inc}) {
          next INC;
      }
#     If the include file starts with a ., we know where it is
      if($inc=~/^\./) {
          $src_file=~/^(.+)\//;
          $src_dir=$1;
      }
#     If the include file start with a /, we know where it is
      if(($inc=~/^\//) or ($src_dir ne "")) {
#         Check if the file exists
          if(-e $inc) {
              push(@new_incs,"$src_dir/$inc");
#             Note that we've found it
              $seen{$inc}++;
              next INC;
          }
#         Maybe it has a .f90 extension
          elsif(-e $inc.f90) {
              push(@new_incs,"$src_dir/$inc.f90");
#             Note that we've found it
              $seen{$inc}++;
              next INC;
          }
#         Maybe it has a .f extension
          elsif(-e $inc.f) {
              push(@new_incs,"$src_dir/$inc.f");
#             Note that we've found it
              $seen{$inc}++;
              next INC;
          }
          else {
              die "$src_dir/$inc not found";
          }
      }
#     If the inc file hasn't been found yet, search inc dirs
    DIR: foreach $dir (@search_dirs_4subs) {
#       If inc dir is not a dir, go on.
        if(!(-d $dir)) {
            next DIR;
        }
#       Get a list of all files in inc dir
        opendir(inc_dir,$dir);
        @dir_contents=readdir(inc_dir);
        closedir(inc_dir);
#       If file to be found has an extension, see if it's in the listing
        if($inc=~/(.+)\.(\w{1,3})$/) {
#           If it is, then put it on the stack containing found incs
            if(grep {/^$inc/} @dir_contents) {
                push(@new_incs,"$dir/$inc");
#               Note that we've found it
                $seen{$inc}++;
                next INC;
            }
        }
        else {
#           If the file in inc statement is not found, try extensions .f90 and .f
            if((grep {(/^$inc$/ and $sfx="") or (/^$inc\.f90$/ and $sfx=".f90") or (/^$inc\.f$/ and $sfx=".f")} @dir_contents)) {
                push(@new_incs,"$dir/$inc$sfx");
#               Note that we've found it
                $seen{$inc}++;
                next INC;
            }
        }
        closedir(inc_dir);
    }
#     If we're not able to find the inc file, exit program.
      die "$inc not found!";
  }
}

# Look for any mods specified in the use statements
sub find_mods {
#*********************
# if module basefilename is upper case 

if ($CASE eq "u"){
    for ($i=0;$i <= $#needed_mods;$i++){
        $needed_mods[$i]=~s/(\w+)\.mod/\U$1\E.mod/g;
    }
}


# Look for every mod on the needed_mods stack
  MOD: foreach $mod (@needed_mods) {
#     If we've already found this mod in a previous pass, go on to next mod.
      if($seen{$mod}) {
          next MOD;
      }
#     If the needed mod is a local mod, we're done
      if(grep{$_ eq $mod} @local_mods) {
#         Put the found mod on the found mods stack
          push(@new_mods,"$mod_out_dir/$mod");
#         Note that we've found it
          $seen{$mod}++;
          next MOD;
      }
#   If the mod isn't local, we need to look in search dirs
    DIR: foreach $dir (@search_dirs_4subs) {
#       If the directory does not exist, go on to the next dir.
        if(!(-d $dir)) {
            next DIR;
        }
        opendir(inc_dir,$dir);
#       If mod is in dir listing, we've found it.
        if(grep {$_ eq $mod} readdir(inc_dir)) {
#           Put it on the 'found' stack
            push(@new_mods,"$dir/$mod");
#           Note that we've found it
            $seen{$mod}++;
            close(inc_dir); 
            next MOD;
        }
        close(inc_dir);
    }
#     If we cannot find a needed mod anywhere, quit
      die "\n$mod not found in search dirs\n";
  }
}

sub get_used_file_tree {
    @needed_incs=();
    @needed_mods=();
# Go through the file looking for keywords
  LINE: foreach $line (@stripped_lines) {
      chomp($line);
      $line =~ s/\r//g;
      while($line) {
#         If include statement, get specified file and put it on 'needed' stack
          if(($line=~/(.*?)include\s\'(\S+?)\'/i) and ($1!~/!/)) {
              push(@needed_incs,$2) unless ($seen_inc{$2}++); $line=0;
          }
#         If module statement, get name of module
          elsif(($line=~/^\s*module\s(\S+)/i) and ($1!~/PROCEDURE/i)) {
              $alpha=$1;
              $mod_def=lc($alpha);
              $mod_def=$mod_def.".mod";
              $line=0;
#             If there is a mod definition for a mod that's not local, scream.
              if(!(grep {$_=~/$mod_def/i} @local_mods)) {
                  print STDERR "module definition for $mod_def was found in an included file.  This is very BAD, and unsupported at CESR!\n";
              }
#             If mod defined is in local mod list, push it onto 'create' stack
              else {
                  push(@mods_to_create,$mod_def) unless ($seen_create{lc($mod_def)}++);
              }
#             If i'm defining and using the same mod, ignore the use
#             --this is probably unnecessary, because i check the mods found
#             use statements against the creation list, but it's pretty cheap.
              $index=-1;
              if(grep {($_ eq $mod_def) and ($index++)} @needed_mods) {
                  $needed_mods[$index]="";
              }
          }
#         If use statement, get name of mod
          elsif(($line=~/^(\s*?)\buse\s+([\w_]+)[\s;,](.+)/i) or ($line=~/^(\s*?)\buse\s+([\w_]+)$/i)) {

#         Put mod on 'needed' stack, unless i already know i need it or I'm creating it
              push(@needed_mods,(lc($2).".mod")) unless ($seen_needed{lc($2)}++ || $seen_create{lc($2).".mod"});
#             Throw the rest of the line after the modname into $line, in order to
#             check for more keywords.  especially more uses
              $line=$3;
          }
          else {
              $line=0;
          }
      }
  }
#   Go look for the mods and incs i've just gotten out of the file
    find_mods();  
    find_incs();
#   Put the new mods i've found on the super-list
    push(@final_mod_list,@new_mods);
#   Make sure that the following recursive call doesn't screw up the array that
#   I'm looping over (should the namespaces get screwed up, that could get 
#   very very nasty)
    my @new_incs2=@new_incs;
#   Call the routine i'm in for each of the inc files that i've just found
    foreach $new_inc (@new_incs2) {
        $cpp_in_file=$new_inc;
#       !!recursive call within a loop!!
        get_used_file_tree();
#       Put the inc files i've just found on the super list (this happens on
#       the way up)
        push(@final_inc_list,$new_inc);
    } 
}

# Subroutine to get CPP processed file and strip fortran comments
sub get_input {
    
#   Run CPP
#    print "xxxxx\n $cpp_command \n xxxxxx \n";
    `$cpp_command`;
    
#   Filter all fortran comments
    @stripped_lines=();
    open(CPP_FILE,$cpp_file) || die "Could not open $cpp_file";
    while(<CPP_FILE>) {
        chomp;
        $in_line = $_;
#        printf "%s\n", $in_line;

#       Look for fortran comments
        $icomment = index($in_line,"!");
        
        if ($fixed_format and ($in_line=~/^c/i)) {
            $length = 0;
        } elsif ($icomment > -1) {
            $length = $icomment;
        } else {
            $length = length($in_line);
        }
        
#       Strip fortran comments and put in intermediate file
        if ($length > 0) {
            push(@stripped_lines, substr($in_line,0,$length));
        }
    }
    
#   Close files
    close(CPP_FILE);
    
#   Delete the CPP intermediate file

    unlink($cpp_file);
}












