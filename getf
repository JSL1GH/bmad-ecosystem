#!/usr/bin/perl
# modify to use File::Spec for transparent use on VMS
# 2005.09.28 mjf

use File::Find;
use File::Spec::Functions;

# Following two lines should be uncommented on VMS to check the master_list:

#my @args = ("type_header", @ARGV);
#system(@args) == 0 or warn "system @args failed: $!\n";

$found_one = 0;

# The idea is to look for a local copy of the library to search.
# We have found a local copy when we find one specific file that we know 
# is in the library.
# -r is a file test operator which checks if the file is can be read

my $curdir = curdir();
my $updir = updir();

if (-r catfile( $curdir, "bmad", "modules", "bmad_struct.f90" )) {
  $bmad_dir = catfile( $curdir, "bmad" );
} elsif (-r catfile( $updir, "bmad", "modules", "bmad_struct.f90")) {
  $bmad_dir = catfile( $updir, "bmad" );
} elsif (-r catfile( $updir, $updir, "bmad", "modules", "bmad_struct.f90")) {
  $bmad_dir = catfile( $updir, $updir, "bmad" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "bmad", "modules", "bmad_struct.f90")) {
  $bmad_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "bmad" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "bmad", "modules", "bmad_struct.f90")) {
  $bmad_dir = catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "bmad" );
} else {
  $bmad_dir = catfile( $ENV{"DIST_BASE_DIR"}, "bmad" );
}


if (-r catfile( $curdir, "cesr_utils", "modules", "cesr_utils.f90" )) {
  $cesr_utils_dir = catfile( $curdir, "cesr_utils" );
} elsif (-r catfile( $updir, "cesr_utils", "modules", "cesr_utils.f90")) {
  $cesr_utils_dir = catfile( $updir, "cesr_utils" );
} elsif (-r catfile( $updir, $updir, "cesr_utils", "modules", "cesr_utils.f90")) {
  $cesr_utils_dir = catfile( $updir, $updir, "cesr_utils" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "cesr_utils")) {
  $cesr_utils_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "cesr_utils" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "cesr_utils")) {
  $cesr_utils_dir = catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "cesr_utils" );
} else {
  $cesr_utils_dir = catfile( $ENV{"DIST_BASE_DIR"}, "cesr_utils" );
}


if (-r catfile( $curdir, "sim_utils", "interfaces", "sim_utils.f90" )) {
  $sim_utils_dir = catfile( $curdir, "sim_utils" );
} elsif (-r catfile( $updir, "sim_utils", "interfaces", "sim_utils.f90")) {
  $sim_utils_dir = catfile( $updir, "sim_utils" );
} elsif (-r catfile( $updir, $updir, "sim_utils", "interfaces", "sim_utils.f90")) {
  $sim_utils_dir = catfile( $updir, $updir, "sim_utils" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "sim_utils")) {
  $sim_utils_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "sim_utils" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "sim_utils")) {
  $sim_utils_dir = catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "sim_utils" );
} else {
  $sim_utils_dir = catfile( $ENV{"DIST_BASE_DIR"}, "sim_utils" );
}

if (-r catfile( $curdir, "mpm_utils", "code", "butout.f90" )) {
  $mpm_utils_dir = catfile( $curdir, "mpm_utils" );
} elsif (-r catfile( $updir, "mpm_utils", "code", "butout.f90")) {
  $mpm_utils_dir = catfile( $updir, "mpm_utils" );
} elsif (-r catfile( $updir, $updir, "mpm_utils", "code", "butout.f90")) {
  $mpm_utils_dir = catfile( $updir, $updir, "mpm_utils" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "mpm_utils")) {
  $mpm_utils_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "mpm_utils" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "mpm_utils")) {
  $mpm_utils_dir = catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "mpm_utils" );
} else {
  $mpm_utils_dir = catfile( $ENV{"DIST_BASE_DIR"}, "mpm_utils" );
}


if (-r catfile( $curdir, "recipes_f-90_LEPP", "lib_src", "nr.f90" )) {
  $recipes_dir = catfile( $curdir, "recipes_f-90_LEPP" );
} elsif (-r catfile( $updir, "recipes_f-90_LEPP", "lib_src", "nr.f90")) {
  $recipes_dir = catfile( $updir, "recipes_f-90_LEPP" );
} elsif (-r catfile( $updir, $updir, "recipes_f-90_LEPP", "lib_src", "nr.f90")) {
  $recipes_dir = catfile( $updir, $updir, "recipes_f-90_LEPP" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "recipes_f-90_LEPP")) {
  $recipes_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "recipes_f-90_LEPP" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "recipes_f-90_LEPP")) {
  $recipes_dir = catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "recipes_f-90_LEPP" );
} else {
  $recipes_dir = catfile( $ENV{"DIST_BASE_DIR"}, "recipes_f-90_LEPP" );
}


if (-r catfile( $curdir, "forest", "code", "i_tpsa.f90" )) {
  $forest_dir = catfile( $curdir, "forest" );
} elsif (-r catfile( $updir, "forest", "code", "i_tpsa.f90")) {
  $forest_dir = catfile( $updir, "forest" );
} elsif (-r catfile( $updir, $updir, "forest", "code", "i_tpsa.f90")) {
  $forest_dir = catfile( $updir, $updir, "forest" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "forest")) {
  $forest_dir = catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "forest" );
} else {
  $forest_dir = catfile( $ENV{"DIST_BASE_DIR"}, "forest" );
}

if (-r catfile( $curdir, "tao", "code", "tao_struct.f90" )) {
  $tao_dir = catfile( $curdir, "tao" );
} elsif (-r catfile( $updir, "tao", "code", "tao_struct.f90")) {
  $tao_dir = catfile( $updir, "tao" );
} elsif (-r catfile( $updir, $updir, "tao", "code", "tao_struct.f90")) {
  $tao_dir = catfile( $updir, $updir, "tao" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "tao")) {
  $tao_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "tao" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "tao")) {
  $tao_dir = catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "tao" );
} else {
  $tao_dir = catfile( $ENV{"DIST_BASE_DIR"}, "tao" );
}

if (-r catfile( $curdir, "bmadz", "modules", "bmadz_struct.f90" )) {
  $bmadz_dir = catfile( $curdir, "bmadz" );
} elsif (-r catfile( $updir, "bmadz", "modules", "bmadz_struct.f90")) {
  $bmadz_dir = catfile( $updir, "bmadz" );
} elsif (-r catfile( $updir, $updir, "bmadz", "modules", "bmadz_struct.f90")) {
  $bmadz_dir = catfile( $updir, $updir, "bmadz" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "bmadz")) {
  $bmadz_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "bmadz" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "bmadz")) {
  $bmadz_dir = catfile( $ENV{"ACC_RELEASE_DIR"}."/src", "bmadz" );
} else {
  $bmadz_dir = catfile( $ENV{"DIST_BASE_DIR"}, "bmadz" );
}

if (-r catfile( $curdir, "nonlin_bpm", "code", "nonlin_bpm_init.f90")) {
  $nonlin_bpm_dir = catfile( $curdir, "nonlin_bpm" );
} elsif (-r catfile( $updir, "nonlin_bpm", "code", "nonlin_bpm_init.f90")) {
  $nonlin_bpm_dir = catfile( $updir, "nonlin_bpm" );
} elsif (-r catfile( $updir, $updir, "nonlin_bpm", "code", "nonlin_bpm_init.f90")) {
  $nonlin_bpm_dir = catfile( $updir, $updir, "nonlin_bpm" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "nonlin_bpm")) {
  $nonlin_bpm_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "nonlin_bpm" );
} else {
  $nonlin_bpm_dir = catfile( $ENV{"DIST_BASE_DIR"}, "nonlin_bpm" );
}

if (-r catfile( $curdir, "recipes_f-90_LEPP", "lib_src", "nr.f90")) {
  $recipes_dir = catfile( $curdir, "recipes_f-90_LEPP" );
} elsif (-r catfile( $updir, "recipes_f-90_LEPP", "lib_src", "nr.f90")) {
  $recipes_dir = catfile( $updir, "recipes_f-90_LEPP" );
} elsif (-r catfile( $updir, $updir, "recipes_f-90_LEPP", "lib_src", "nr.f90")) {
  $recipes_dir = catfile( $updir, $updir, "recipes_f-90_LEPP" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "recipes_f-90_LEPP")) {
  $recipes_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "recipes_f-90_LEPP" );
} else {
  $recipes_dir = catfile( $ENV{"DIST_BASE_DIR"}, "recipes_f-90_LEPP" );
}

if (-r catfile( $curdir, "forest", "code", "a_scratch_size.f90")) {
  $forest_dir = catfile( $curdir, "forest" );
} elsif (-r catfile( $updir, "forest", "code", "a_scratch_size.f90")) {
  $forest_dir = catfile( $updir, "forest" );
} elsif (-r catfile( $updir, $updir, "forest", "code", "a_scratch_size.f90")) {
  $forest_dir = catfile( $updir, $updir, "forest" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "forest")) {
  $forest_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "forest" );
} else {
  $forest_dir = catfile( $ENV{"DIST_BASE_DIR"}, "forest" );
}

if (-r catfile( $curdir, "bsim", "code")) {
  $bsim_dir = catfile( $curdir, "bsim" );
} elsif (-r catfile( $updir, "bsim", "code")) {
  $bsim_dir = catfile( $updir, "bsim" );
} elsif (-r catfile( $updir, $updir, "bsim", "code")) {
  $bsim_dir = catfile( $updir, $updir, "bsim" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "bsim")) {
  $bsim_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "bsim" );
} else {
  $bsim_dir = catfile( $ENV{"DIST_BASE_DIR"}, "bsim" );
}

if (-r catfile( $curdir, "bsim_cesr", "code")) {
  $bsim_cesr_dir = catfile( $curdir, "bsim_cesr" );
} elsif (-r catfile( $updir, "bsim_cesr", "code")) {
  $bsim_cesr_dir = catfile( $updir, "bsim_cesr" );
} elsif (-r catfile( $updir, $updir, "bsim_cesr", "code")) {
  $bsim_cesr_dir = catfile( $updir, $updir, "bsim_cesr" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "bsim_cesr")) {
  $bsim_cesr_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "bsim_cesr" );
} else {
  $bsim_cesr_dir = catfile( $ENV{"DIST_BASE_DIR"}, "bsim_cesr" );
}

if (-r catfile( $curdir, "cesr_programs", "code")) {
  $cesr_programs_dir = catfile( $curdir, "cesr_programs" );
} elsif (-r catfile( $updir, "cesr_programs", "code")) {
  $cesr_programs_dir = catfile( $updir, "cesr_programs" );
} elsif (-r catfile( $updir, $updir, "cesr_programs", "code")) {
  $cesr_programs_dir = catfile( $updir, $updir, "cesr_programs" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "cesr_programs")) {
  $cesr_programs_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "cesr_programs" );
} else {
  $cesr_programs_dir = catfile( $ENV{"DIST_BASE_DIR"}, "cesr_programs" );
}

if (-r catfile( $curdir, "cesrv", "code")) {
  $cesrv_dir = catfile( $curdir, "cesrv" );
} elsif (-r catfile( $updir, "cesrv", "code")) {
  $cesrv_dir = catfile( $updir, "cesrv" );
} elsif (-r catfile( $updir, $updir, "cesrv", "code")) {
  $cesrv_dir = catfile( $updir, $updir, "cesrv" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "cesrv")) {
  $cesrv_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "cesrv" );
} else {
  $cesrv_dir = catfile( $ENV{"DIST_BASE_DIR"}, "cesrv" );
}

if (-r catfile( $curdir, "util_programs", "code")) {
  $util_programs_dir = catfile( $curdir, "util_programs" );
} elsif (-r catfile( $updir, "util_programs", "code")) {
  $util_programs_dir = catfile( $updir, "util_programs" );
} elsif (-r catfile( $updir, $updir, "util_programs", "code")) {
  $util_programs_dir = catfile( $updir, $updir, "util_programs" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "util_programs")) {
  $util_programs_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "util_programs" );
} else {
  $util_programs_dir = catfile( $ENV{"DIST_BASE_DIR"}, "util_programs" );
}

if (-r catfile( $curdir, "examples", "simple_program")) {
  $examples_dir = catfile( $curdir, "examples" );
} elsif (-r catfile( $updir, "examples", "simple_program")) {
  $examples_dir = catfile( $updir, "examples" );
} elsif (-r catfile( $updir, $updir, "examples", "simple_program")) {
  $examples_dir = catfile( $updir, $updir, "examples" );
} elsif (-r catfile( $ENV{"ACC_RELEASE_DIR"}, "examples")) {
  $examples_dir = catfile( $ENV{"ACC_RELEASE_DIR"}, "examples" );
} else {
  $examples_dir = catfile( $ENV{"DIST_BASE_DIR"}, "examples" );
}

# Look for arguments

$extra = 0;
$also_match_params = 1; 
$search_all = 0;

$_ = "@ARGV";  
@field = split;
$extra_dir = '';

for ($i = 0; $i <= @field; $i++) {

  $_ = $field[$i];

  if (! /^\-/) {last;}

  if ($_ eq '-d') {
    $extra = 1; 
    $extra_dir = $field[$i+1];
    $i = $i + 1;
    next;
  }

  if ($_ eq '-p') {
    $also_match_params = 1; 
    next;
  }

  if ($_ eq '-a') {
    $search_all = 1;
    next;
  }

  if ($_ eq '-h') {
    print "Usage:\n";
    print "  getf {options} <search_string>\n\n";
    print "Options:\n";
    print "   -a          # Search Numerical recipes, forest, and varies program directories as well.\n";
    print "   -d <dir>    # Search files in <dir> and sub-directories for matches.\n";
    ## print "   -p          # Match to parameters as well.\n";   # Not yet implemented!
    print "\n";
    print "Standard Libraries searched:\n";
    print "   bmad\n";
    print "   sim_utils\n";
    print "   cesr_utils\n";
    print "   mpm_utils\n";
    print "   tao\n";
    print "   bmadz\n";
    exit
  }

  last;

}

# Search for a match.

$match_str = $field[$i];
$match_str =~ s/\*/\\w\*/g;   # replace "*" by "\w*" (any word characters)
if ($match_str eq '') {&print_help_message; exit}

if ($extra_dir ne '') {
  print "Searching also: $extra_dir\n";
  find(\&searchit, $extra_dir);
}

find(\&searchit, $bmad_dir);
find(\&searchit, $sim_utils_dir);
find(\&searchit, $tao_dir);
find(\&searchit, $cesr_utils_dir);
find(\&searchit, $mpm_utils_dir);
find(\&searchit, $bmadz_dir);

if ($search_all == 1) {
  find(\&searchit, $recipes_dir);
  find(\&searchit, $forest_dir);
  find(\&searchit, $bsim_dir);
  find(\&searchit, $bsim_cesr_dir);
  find(\&searchit, $cesr_programs_dir);
  find(\&searchit, $cesrv_dir);
  find(\&searchit, $util_programs_dir);
  find(\&searchit, $examples_dir);
}

if ($found_one == 0) {
  print "Cannot match String! $match_str\n";
  print "Use '-h' command line option to list options.\n";
} else {
  print "\n";
}

#---------------------------------------------------------

sub searchit {

  # Do not search this directory.
  if ($File::Find::name =~ /cesr_utils\/original_from_vms/) {return;}  

  if (/\#/) {return;}
  $file = $_;
  $matches_file_name = 0;
  $have_printed_file_name = 0;
  $in_module_header = 0;

  # Check contents of .f90 file.

  if ($file =~ /\.f90$/ || $file =~/\.inc$/) {
    $n_com = 0;
    @comments = ();     

    $stat = open (F_IN, $file);
    if (! $stat) {
      print STDOUT "Cannot open File: $file\n"; 
      $_ = $file;
      return;
    }

    while (<F_IN>) {

      # skip interface blocks

      if (/^ *interface *$/i) {
        while (<F_IN>) {
          if (/^ *end +interface/i) {last;}
        }
      }

      # skip "type (" constructs and separator comments.

      if (/^ *type *\(/i) {next;}   
      if ($n_com == 0 && /^!\-\-\-\-\-\-\-\-\-/) {next;}
      if (/^#/) {next;}

      # Search for parameters

      if ($also_match_params == 1) {
        if (/^ *module/i) {$in_module_header = 1;}
        if ($in_module_header == 1) {
          if (/^ *contains/i) {$in_module_header = 0;}
          if (/parameter.* ::/) {
            ## print $';    #'
            $rest = ',' . $';       #'
            chomp($rest);
            $rest = (split(/!/, $rest))[0];
            while ($rest =~ /,\s*([\$\w\(-:\)]+) *\=/) {  # match to EG: "charge_of(-3:3)"
              $rest = $';  # '
              $param = (split(/\(/, $1))[0];
              if ($param =~ /^$match_str$/i || $param =~ /^$match_str\$$/i) {
                $found_one = 1;
                if ($have_printed_file_name == 0) {
                  print "\nFile: $File::Find::name\n";
                  $have_printed_file_name = 1;
                }
                print $_;
                while (/\&/) {
                  $_ = <F_IN>;
                  print $_;
                }
                last;
              }
              ## print ":::" . ($match) . ":::\n";
              ## print ":::" . $rest . ":::\n";
            }
            next;
          }
        } 
      }

      # Add to comment block if a comment line

      if (/^!/) {
        @comments[$n_com] = $_;
        $n_com++

      # match to type statement

      } elsif (/^ *type +$match_str\s/i) {
        $found_one = 1;
        print "\nFile: $File::Find::name\n";
        for ($i = 0; $i < $n_com; $i++) {print @comments[$i];}
        print "\n";
        print $_;
        while (<F_IN>) {
          print $_;
          if (/^ *end type/i) {last;}
        }

        $n_com = 0;

      # match to subroutine, function, etc.

      } elsif (&routine_here) {
        $routine_name =~ /^\s*(\w+)[ |\(\n]/i;
        $_ = $1;     # strip off "subroutine"
        if ($file =~ /^$match_str\.f90/i || $file =~ /^$match_str\.inc/i) {$matches_file_name = 1;}

        if (/^$match_str$/i) {
          $found_one = 1;
          print "\nFile: $File::Find::name\n";
          for ($i = 0; $i < $n_com; $i++) {print @comments[$i];}
        }

        $n_com = 0;

        # skip rest of routine including contained routines

        $count = 1;
        while (<F_IN>) {
          if (/^ *end /i) {
            $_ = $';     #' 
            if (/^ *subroutine/i || /^ *function/i || /^ *interface/i) {
              $count = $count - 1;
            }
          }
          elsif (&routine_here) {
            $count = $count + 1;
          }
          if ($count == 0) {last;}
        }

      # If not a blank line, reset comment block

      } elsif (/[^\s]/) {
        $n_com = 0; 

      }

    }
    close (F_IN);

  # match to C++ files

  } elsif ($file =~ /\.cpp$/ || $file =~ /\.h$/) {

    $in_class = 0;

    $stat = open (F_IN, $file);
    if (! $stat) {
      print STDOUT "Cannot open File: $file\n"; 
      $_ = $file;
      return;
    }

    while (<F_IN>) {

      if (/^ *class +(\w+) +\{ *$/) {     # match to "class xyz {"
        if ($1 =~ /^$match_str$/i) {
          $in_class = 1;
          $found_one = 1;
          print "\nFile: $File::Find::name\n";
        }
      }

      if ($in_class) {print $_;}
      if (m@// +end class@i) {$in_class = 0;}

    }
    close (F_IN);
  }

  #--------------------------------------------------
  # See if the file name matches.
  # Only print the file name here if:
  #    1) There are some comments at the top of the file or
  #    2) There has not been a match to a routine within the file.

  if ($matches_file_name == 0 && ($file =~ /^$match_str\.f90$/i || $file =~ /^$match_str\.inc$/i)) {

    $found_one = 1;
    print "\nFile: $File::Find::name\n";

    $stat = open (F_IN, $file);
    if (! $stat) {
      print STDOUT "Cannot open File: $file\n"; 
      $_ = $file;
      return;
    }

    # Print header

    $have_printed = 0;

    while (<F_IN>) {
      if (&routine_here) {last;}
      if (/^!/) {
        $have_printed = 1;
        print "$_";
      } elsif ($have_printed == 1) {
        last;
      }
    }

    close (F_IN);

  }


  $_ = $file;

}

#---------------------------------------------------------

sub routine_here {

  if (/^\s*subroutine /i || /^\s*recursive subroutine /i || 
      /^\s*elemental subroutine /i ||
      /^\s*function /i || /^\s*recursive function /i ||
      /^\s*real\(rp\) *function /i || /^\s*integer *function /i ||
      /^\s*logical *function /i || /^\s*interface /i) {
    $routine_name = $';              #' strip off "routine" string
    return 1;
  }

  return 0;

}


sub print_help_message {
  print "Usage:\n";
  print "  getf {options} <search_string>\n\n";
  print "Options:\n";
  print "   -a          # Search Numerical recipes, forest, and varies program directories as well.\n";
  print "   -d <dir>    # Search files in <dir> and sub-directories for matches.\n";
  ## print "   -p          # Match to parameters as well.\n";   # Not yet implemented!
  print "\n";
  print "Standard Libraries searched:\n";
  print "   bmad\n";
  print "   sim_utils\n";
  print "   cesr_utils\n";
  print "   mpm_utils\n";
  print "   tao\n";
  print "   bmadz\n";
}
