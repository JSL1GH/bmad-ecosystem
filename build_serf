#!/usr/bin/python
#####################################################

# Standard modules
import os
import sys
import time
import string
import socket
import popen2
import shutil

build_type    = ""
f90           = ""
platform      = ""
precision     = ""
revision      = 0
build_host    = ""
full_pkg_name = "none"
full_rel_name = "none"
branch        = ""
build_args    = []
errors        = 0

print sys.argv
if len(sys.argv) != 2:
    print "[build_serf] Incorrect number of arguments provided."
    sys.exit(5)
elif os.path.exists(sys.argv[1]) != 1:
    print "[build_serf] Logfile provided as argument does not exist."
    sys.exit(10)
else:
    logname = sys.argv[1]
    
logfile = open(logname, "r")         # Open logfile to read variables from header.
lines = logfile.readlines()
for line in lines:
    if line[0:10] == "Build Type":   # no find on crappy OSF python (!) fix this script to be portable
        #build_type = line.split(':')[1].strip()
        build_type = line[21:-1]
    if line[0:8]  == "Platform":
        platform   = line[21:-1]
    if line[0:12] == "F90 Compiler":
        #f90        = line.split(':')[1].strip()
        f90        = line[21:-1]
    if line[0:15] == "Float Precision":
        #precision  = line.split(':')[1].strip()
        precision  = line[21:-1]
        if precision == "double":
            precision = "DBL"
        else:
            precison = "SGL"
    if line[0:8] == "Revision":
        #revision   = line.split(':')[1].strip()
        revision   = line[21:-1]
    if line[0:10] == "Build Host":
        #build_host = line.split(':')[1].strip()
        build_host = line[21:-1]
    if line[0:18] == "Full Packages name":
        #full_pkg_name = line.split(':')[1].strip()
        full_pkg_name = line[21:-1]
    if line[0:17] == "Full Release name":
        #full_rel_name = line.split(':')[1].strip()
        full_rel_name = line[21:-1]
    if line[0:12] == "Link against":
        #pkg_name = line.split(':')[1].strip()
        pkg_name = line[21:-1]
    if line[0:16] == "Build System Dir":
        #build_sys_dir = line.split(':')[1].strip()
        build_sys_dir = line[21:-1]
    if line[0:17] == "Repository branch":
        #branch = line.split(':')[1].strip()
        branch = line[21:-1]
    if line[0:7] == "Bin dir":
        #bin_dir = line.split(':')[1].strip()
        bin_dir = line[21:-1]
    if line[0:10] == "Config Dir":
        #config_dir = line.split(':')[1].strip()
        config_dir = line[21:-1]
    if line [0:14] == "Run test suite":
        run_tests = line[21:-1]

logfile.close()                            # Close logfile.

sys.stdout      = open(logname, "a")      # Reopen log file as standard output stream for appending new data.

print "--> BUILD STATUS: INITIALIZING"
print "\nPython version is:"
print sys.version           # dump Python version to platform logfile.

#print "\n[build_release.py] rel name : " + rel_name

print "\nSuccessfully launched remote build process.\n"

cesrdefs = ". " + bin_dir + "/cesrdefs; "               # command to source the cesrdefs:cesrenv environment setup scripts 
env_setup3 = ""
test_script = bin_dir + "/util/CESRbuild_test_suite"

build_args.append("PACKAGE_NAME="+pkg_name)
build_args.append(" CESR_PRECISION=_"+precision)
build_args.append(" CHECKOUT=\"\"")
build_args.append(" BUILD=\"do_build\"")    # Common options to be passed to makefile, regardless of packages or release

#print "BUILD TYPE IS:" + build_type + "<<"

if build_type == "PACKAGES":  # make gets slightly different args depending on type
    build_args.append(" DO_PKG=1")
    env_setup1 = " CESRLIB="+pkg_name + "; CESRF90=" + f90 +'; '
    #env_setup2 = " export CESR_GMAKE="+build_sys_dir + " ; export CESR_UTIL=" + bin_dir + "/util; "
    #env_setup2 = " CESR_GMAKE="+build_sys_dir + "; CESR_UTIL=" + bin_dir + "/util; "
    env_setup2 = " XERCESCROOT="+full_pkg_name+"/xerces; export XERCESCROOT; CESR_GMAKE="+build_sys_dir + " ; CESR_UTIL=" + bin_dir + "/util; "

if build_type == "RELEASE":
    build_args.append(" DO_REL=1")
    build_args.append(" BRANCH="+branch)
    ## Short snippet here to get rel_name from full_rel name without using .split method (counteracting OSF lameness)
    char = ''
    rel_name = ""
    i = -1
    while char != '/':
        char = full_rel_name[i]
        rel_name = rel_name + char
        i = i - 1
    rel_name = reduce(lambda x,y: y+x, rel_name)  # reverse the string
    rel_name = rel_name[1:]                       # snip off leading '/' character
    #
    #name_chunk_list = full_rel_name.split('/')
    #rel_name        = name_chunk_list[-1]
    env_setup1 = " CESRLIB=" + rel_name + "; CESRF90=" + f90 +'; '
    env_setup2 = ""
    print "\nEnvironment setup\n"
    
    #build_args="PACKAGE_NAME="+pkg_name+" DO_REL=1 CESR_PRECISION=DBL CHECKOUT=\"\" BRANCH="+branch+" BUILD=\"do_build\""
    #build_cmd = env_setup + "make -f " + build_sys_dir + "/M.release " + build_args + "; echo $PATH"

build_cmd = env_setup1 + cesrdefs + env_setup2 + "gmake -f" + build_sys_dir + "/M.release "
for arg in build_args:
    build_cmd = build_cmd + arg                  # compose build command by appending the options determined above

#print build_cmd
print ""
print "--> BUILD STATUS: BUILDING"


##  Works for recent pythons, Popen4 does not exist on OSF1 python!
#build_process = popen2.Popen4(build_cmd)         # spawn gmake process
#if platform == "Linux_i686_intel" or platform == "Linux_i686_lahey":
if platform == "Linux_i686_intel" or platform == "Linux_i686_lahey" or platform == "OSF1_alpha_hp":
    build_process = popen2.Popen4(build_cmd)
    pid = build_process.pid
    line = build_process.fromchild.readline()
    while line:                                      # print output as it is generated
        print line.strip()
        #if line.find("Error") != -1:               # be on the lookout for errors in the build
        if line[0:10] == "gmake: ***":
            errors = 1
        line = build_process.fromchild.readline()
        
    if errors:
        print "--> BUILD STATUS: ERROR(S) DETECTED"
    else:
        print "--> BUILD STATUS: COMPLETE!"
        if run_tests == "YES":
            print "About to execute test suite."
            test_cmd = env_setup1 + cesrdefs + env_setup2 + test_script + " " + rel_name
            print test_cmd
            test_process = popen2.Popen4(test_cmd)
            pid = test_process.pid
            tline = test_process.fromchild.readline()
            while tline:
                print tline.strip()
                tline = test_process.fromchild.readline()
        
        
## ## ## ## ##


## -- implement workaround for crummy ancient Python version on cesrbuild2
#if platform == "OSF1_alpha_hp":
#    print "OSF1 workaround testing..."
#    build_process = popen2.Popen3(build_cmd, capturestderr=1)
#    #print build_cmd
#    #build_process = popen2.Popen3(build_cmd)
#    pid = build_process.pid
#    line = build_process.fromchild.readline()
#    #if build_process.childerr.readline() != None:
#    #    errline = build_process.childerr.readline()
#    while line:
#        print line[:-1]                         # snip off trailing newline character so output isn't double spaced
#        #if errline != "":
#        #    print errline[:-1]
#        if line[0:9] == "make: ***":
#            errors = 1
#        line = build_process.fromchild.readline()
#        #if build_process.childerr.readline() != None:
#        #    errline = build_process.childerr.readline()
#    if errors:
#        #print "--> BUILD STATUS:(%i) ERROR(S) DETECTED" % return_code
#        print "--> BUILD STATUS: ERROR(S) DETECTED"
#    else:
#        #print "--> BUILD STATUS:(%i) COMPLETE!" % return_code
#        print "--> BUILD STATUS: COMPLETE!"


if platform == "VMS_alpha_hp": #assumes files and dependencies generated and in place from OSF process (tighten all this up.)
    if build_type == "RELEASE":
        OSF_reldir = full_rel_name.replace("VMS_alpha_hp", "OSF1_alpha_hp")
        print "Waiting for OSF1 build to complete so dependencies can be copied to VMS area."
        dirlist = os.listdir(OSF_reldir + "/src")  # get list of OSF release src directory
        dirlist.remove(".svn")                     # Don't consider .svn administrative directory.
        print dirlist
        for dir in dirlist:           # copy over the hidden directory .depend and file .f90_module_rules
            if os.path.exists(OSF_reldir + "/src/" + dir + "/.depend"):
                print "Copying .depend directory from OSF1 " + dir + " area." 
                shutil.copytree(OSF_reldir + "/src/" + dir + "/.depend", full_rel_name + "/src/" + dir + "/.depend")
            if os.path.exists(OSF_reldir + "/src/" + dir + "/.f90_module_rules"):
                print "Copying .f90_module_rules file from OSF1 " + dir + " area."
                shutil.copyfile(OSF_reldir+"/src/"+dir+"/.f90_module_rules", full_rel_name+"/src/"+dir+"/.f90_module_rules")
            os.chdir(full_rel_name +'/src/'+ dir)
            print "Changed directory to: " + os.getcwd()
            print "Generating .depvms file..."
            dep_process = popen2.Popen4(bin_dir + "/util/filtercesr " + full_rel_name + ' ' + dir)
            line = dep_process.fromchild.readline()
            while line:
                print line.strip()
                line = dep_process.fromchild.readline()
        print "Copying config directory from OSF1 area."
        shutil.copytree(OSF_reldir + "/config", full_rel_name + "/config")
        build_process = popen2.Popen4(bin_dir + "/util/cesr_to_vms " + full_rel_name) # FTP upload to VMS cluster
        print "--> BUILD STATUS: COMPLETE!"

    if build_type == "PACKAGES":
        OSF_pkgdir = full_pkg_name.replace("VMS_alpha_hp", "OSF1_alpha_hp")
        dirlist = os.listdir(OSF_pkgdir)
        for dir in dirlist:
            if os.path.exists(OSF_pkgdir +'/'+ dir +"/.depend"):
                print "Copying .depend directory from OSF1 " + dir + " area."
                shutil.copytree(OSF_pkgdir +'/'+ dir + "/.depend", full_pkg_name +'/'+ dir + "/.depend")
            if os.path.exists(OSF_pkgdir +'/'+ dir +"/.f90_module_rules"):
                print "Copying .f90_module_rules file..."
                shutil.copyfile(OSF_pkgdir +'/'+ dir + "/.f90_module_rules", full_pkg_name +'/'+ dir + "/.f90_module_rules")
            if dir == "forest":
                print "Was in: " + os.getcwd()
                os.chdir(full_pkg_name +'/'+ dir)
                print "Changed directory to: " + os.getcwd()
                print "Generating .depvms file..."
                dep_process = popen2.Popen4(bin_dir + "/util/filtercesr " + full_pkg_name + ' ' + dir)
                line = dep_process.fromchild.readline()
                while line:
                    print line.strip()
                    line = dep_process.fromchild.readline()
            shutil.move(full_pkg_name + "/recipes_c-ansi", full_pkg_name + "/recipes_c_ansi")
            shutil.move(full_pkg_name + "/recipes_f-90", full_pkg_name + "/recipes_f_90")
        build_process = popen2.Popen4(bin_dir + "/util/cesr_to_vms " + full_pkg_name) # FTP upload to VMS cluster
        print "--> BUILD STATUS: COMPLETE!"


## Set group to cesr and add write permissions to the files in the config area

if build_type == "RELEASE" or build_type == "RELEASE & PACKAGES":
    os.system("chgrp -R cesr " + config_dir)
    os.system("chmod -R g+w " + config_dir)
    
os.system(bin_dir + "/create_fdb.pl")





sys.exit(0)

