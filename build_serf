#!/home/cesruilb/EXT/Python-2.5.1/Linux/python
############################################################
# The shebang above needn't really be present, as this
# script is only meant to be called from the build_master
# script.  It is left there as a reminder of the Python
# interpreter version used to properly execute this script.
############################################################
# Standard modules
import os, sys, string, time, socket
import popen2
import subprocess as sub     
import shutil                # For file copying routines.

build_type    = ""
f90           = ""
platform      = ""
precision     = ""
revision      = 0
build_host    = ""
full_pkg_name = "none"
full_rel_name = "none"
branch        = ""
build_args    = []
errors        = 0
dist_web_dir  = "/home/cesrulib/public_html/downloads/tarballs"

if len(sys.argv) != 2:
    print "[build_serf] Incorrect number of arguments provided."
    sys.exit(5)
elif os.path.exists(sys.argv[1]) != 1:
    print "[build_serf] Logfile provided as argument does not exist."
    sys.exit(10)
else:
    logname = sys.argv[1]
    
logfile = open(logname, "r")         # Open logfile to read variables from header.
lines = logfile.readlines()
for line in lines:
    if line[0:10] == "Build Type":   # B/c of no find on older 1.5 Python on OSF1.  
        build_type = line.split(':')[1].strip()
        #build_type = line[21:-1]
    if line[0:8]  == "Platform":
        platform   = line[21:-1]
    if line[0:12] == "F90 Compiler":
        f90        = line.split(':')[1].strip()
        #f90        = line[21:-1]
    if line[0:15] == "Float Precision":
        precision  = line.split(':')[1].strip()
        #precision  = line[21:-1]
        if precision == "double":
            precision = "DBL"
        else:
            precison = "SGL"
    if line[0:8] == "Revision":
        revision   = line.split(':')[1].strip()
        #revision   = line[21:-1]
    if line[0:10] == "Build Host":
        build_host = line.split(':')[1].strip()
        #build_host = line[21:-1]
    if line[0:18] == "Full Packages name":
        full_pkg_name = line.split(':')[1].strip()
        #full_pkg_name = line[21:-1]
    if line[0:17] == "Full Release name":
        full_rel_name = line.split(':')[1].strip()
        #full_rel_name = line[21:-1]
    if line[0:12] == "Link against":
        pkg_name = line.split(':')[1].strip()
        #pkg_name = line[21:-1]
    if line[0:16] == "Build System Dir":
        build_sys_dir = line.split(':')[1].strip()
        #build_sys_dir = line[21:-1]
    if line[0:17] == "Repository branch":
        branch = line.split(':')[1].strip()
        #branch = line[21:-1]
    if line[0:7] == "Bin dir":
        bin_dir = line.split(':')[1].strip()
        #bin_dir = line[21:-1]
    if line[0:10] == "Config Dir":
        config_dir = line.split(':')[1].strip()
        #config_dir = line[21:-1]
    if line [0:14] == "Run test suite":
        run_tests = line.split(':')[1].strip()
        run_tests = line[21:-1]

logfile.close()                            # Done with input parameter parsing. Close logfile.

sys.stdout      = open(logname, "a")      # Reopen log file as standard output stream for appending new data.

print "--> BUILD STATUS: INITIALIZING"
print "\nPython version is:"
print sys.version           # dump Python version to platform logfile.

print "\nSuccessfully launched remote build process.\n"

cesrdefs  = ". " + bin_dir + "/cesrdefs; "               # command to source the cesrdefs:cesrenv environment setup scripts
bmad_defs = ". " + bin_dir + "/bmad_defs; "
env_setup3 = ""
test_script = bin_dir + "/util/CESRbuild_test_suite"


build_args.append("PACKAGE_NAME="+pkg_name)
build_args.append(" CESR_PRECISION=_"+precision)
build_args.append(" CHECKOUT=\"\"")
build_args.append(" BUILD=\"do_build\"")    # Common options to be passed to makefile, regardless of packages or release

## Build-type command customization

if build_type == "PACKAGES":  # make gets slightly different args depending on type
    build_args.append(" DO_PKG=1")
    env_setup1 = " CESRLIB="+pkg_name + "; CESRF90=" + f90 +'; '
    #env_setup2 = " export CESR_GMAKE="+build_sys_dir + " ; export CESR_UTIL=" + bin_dir + "/util; "
    env_setup2 = " CESR_GMAKE="+build_sys_dir + "; CESR_UTIL=" + bin_dir + "/util; "
    #env_setup2 = " XERCESCROOT="+full_pkg_name+"/xerces; export XERCESCROOT; CESR_GMAKE="+build_sys_dir + " ; CESR_UTIL=" + bin_dir + "/util; "
    build_cmd = env_setup1 + cesrdefs + env_setup2 + "gmake -f" + build_sys_dir + "/M.release "
    for arg in build_args:
        build_cmd = build_cmd + arg                  # compose build command by appending the options determined above


if build_type == "RELEASE":
    build_args.append(" DO_REL=1")
    build_args.append(" BRANCH="+branch)
    ## Short snippet here to get rel_name from full_rel name without using .split method (counteracting OSF lameness)
    char = ''
    rel_name = ""
    i = -1
    while char != '/':
        char = full_rel_name[i]
        rel_name = rel_name + char
        i = i - 1
    rel_name = reduce(lambda x,y: y+x, rel_name)  # reverse the string
    rel_name = rel_name[1:]                       # snip off leading '/' character
    ## End snippet.
    #name_chunk_list = full_rel_name.split('/')
    #rel_name        = name_chunk_list[-1]
    env_setup1 = " CESRLIB=" + rel_name + "; CESRF90=" + f90 +'; '
    env_setup2 = ""
    #build_args="PACKAGE_NAME="+pkg_name+" DO_REL=1 CESR_PRECISION=DBL CHECKOUT=\"\" BRANCH="+branch+" BUILD=\"do_build\""
    #build_cmd = env_setup + "make -f " + build_sys_dir + "/M.release " + build_args + "; echo $PATH"    
    build_cmd = env_setup1 + cesrdefs + env_setup2 + "gmake -f" + build_sys_dir + "/M.release "
    for arg in build_args:
        build_cmd = build_cmd + arg                  # compose build command by appending the options determined above


if build_type == "BMAD DISTRIBUTION":
    print "IN BUILD_SERF... BMAD"
    os.chdir(full_rel_name)
    print "Changing directory to: " + os.getcwd()
    env_setup1 = " CESRF90=" + f90 + "; BMAD_="+full_rel_name + '; '  # Set BMAD_ var before invoking bmad_defs
    #env_setup2 = " BMAD_="+full_rel_name + '; '
    env_setup2 = ""
    print "env_setup2: " + env_setup2
    build_cmd = env_setup1 + bmad_defs + env_setup2 + "gmake -f" + build_sys_dir + "/M.distribution "
    for arg in build_args:
        build_cmd = build_cmd + arg

    
## END Build-type command customization
    


#print build_cmd
print ""
print "--> BUILD STATUS: BUILDING"


##  Works for recent pythons, Popen4 does not exist on OSF1 1.5 python!
#if platform == "Linux_i686_intel" or platform == "Linux_i686_lahey":
if platform == "Linux_i686_intel" or platform == "Linux_i686_lahey" or platform == "OSF1_alpha_hp":
    print build_cmd
    build_process = popen2.Popen4(build_cmd)
    pid = build_process.pid
    line = build_process.fromchild.readline()
    while line:                                     # print output as it is generated
        print line.strip()
        #if line.find("Error") != -1:               # be on the lookout for errors in the build
        if line[0:10] == "gmake: ***":
            errors = 1
        line = build_process.fromchild.readline()
    if errors:
        print "--> BUILD STATUS: ERROR(S) DETECTED"
    else:
        if run_tests == "YES":
            print "About to execute test suite."
            if platform == "Linux_i686_intel" or platform == "Linux_i686_lahey":
                Py_interpreter = "/home/cesrulib/EXT/Python-2.5.1/Linux/python"
            else:
                Py_interpreter = "/home/cesrulib/EXT/Python-2.5.1/OSF1/python"
            #test_cmd = env_setup1 + cesrdefs + env_setup2 + Py_interpreter +' '+ test_script +" "+ rel_name
            test_cmd = [Py_interpreter, test_script, rel_name, platform]
            print test_cmd
            #o test_process = popen2.Popen4(test_cmd)
            #o2 test_process = sub.Popen(test_cmd)
            test_process = sub.Popen(test_cmd, stdout=sub.PIPE, stderr=sub.STDOUT)
            lines = test_process.stdout.readlines()
            for line in lines:
                print line.strip()
            pid = test_process.pid
            returncode = test_process.wait()
            print "\n Test Suite Return code: " + str(returncode) + '\n'
            time.sleep(2)
            #o tline = test_process.fromchild.readline()
            #o while tline:
            #o     print tline.strip()
            #o     tline = test_process.fromchild.readline()
        print "--> BUILD STATUS: COMPLETE!"
        if build_type == "BMAD DISTRIBUTION":   # if build completes successfully,
            shutil.copy(full_rel_name+".tar.gz", dist_web_dir) # copy tarball to dist web page



if platform == "VMS_alpha_hp": #assumes files and dependencies generated and in place from OSF process (tighten all this up.)
    if build_type == "RELEASE":
        OSF_reldir = full_rel_name.replace("VMS_alpha_hp", "OSF1_alpha_hp")
        print "Waiting for OSF1 build to complete so dependencies can be copied to VMS area."
        dirlist = os.listdir(OSF_reldir + "/src")  # get list of OSF release src directory
        dirlist.remove(".svn")                     # Don't consider .svn administrative directory.
        print dirlist
        for dir in dirlist:           # copy over the hidden directory .depend and file .f90_module_rules
            if os.path.exists(OSF_reldir + "/src/" + dir + "/.depend"):
                print "Copying .depend directory from OSF1 " + dir + " area." 
                shutil.copytree(OSF_reldir + "/src/" + dir + "/.depend", full_rel_name + "/src/" + dir + "/.depend")
            if os.path.exists(OSF_reldir + "/src/" + dir + "/.f90_module_rules"):
                print "Copying .f90_module_rules file from OSF1 " + dir + " area."
                shutil.copyfile(OSF_reldir+"/src/"+dir+"/.f90_module_rules", full_rel_name+"/src/"+dir+"/.f90_module_rules")
            os.chdir(full_rel_name +'/src/'+ dir)
            print "Changed directory to: " + os.getcwd()
            print "Generating .depvms file..."
            dep_process = popen2.Popen4(bin_dir + "/util/filtercesr " + full_rel_name + ' ' + dir)
            line = dep_process.fromchild.readline()
            while line:
                print line.strip()
                line = dep_process.fromchild.readline()
        print "Copying config directory from OSF1 area."
        shutil.copytree(OSF_reldir + "/config", full_rel_name + "/config")
        build_process = popen2.Popen4(bin_dir + "/util/cesr_to_vms " + full_rel_name) # FTP upload to VMS cluster
        print "--> BUILD STATUS: COMPLETE!"


    if build_type == "PACKAGES":
        OSF_pkgdir = full_pkg_name.replace("VMS_alpha_hp", "OSF1_alpha_hp")
        dirlist = os.listdir(OSF_pkgdir)
        for dir in dirlist:
            if os.path.exists(OSF_pkgdir +'/'+ dir +"/.depend"):
                print "Copying .depend directory from OSF1 " + dir + " area."
                shutil.copytree(OSF_pkgdir +'/'+ dir + "/.depend", full_pkg_name +'/'+ dir + "/.depend")
            if os.path.exists(OSF_pkgdir +'/'+ dir +"/.f90_module_rules"):
                print "Copying .f90_module_rules file..."
                shutil.copyfile(OSF_pkgdir +'/'+ dir + "/.f90_module_rules", full_pkg_name +'/'+ dir + "/.f90_module_rules")
            if dir == "forest":
                print "Was in: " + os.getcwd()
                os.chdir(full_pkg_name +'/'+ dir)
                print "Changed directory to: " + os.getcwd()
                print "Generating .depvms file..."
                dep_process = popen2.Popen4(bin_dir + "/util/filtercesr " + full_pkg_name + ' ' + dir)
                line = dep_process.fromchild.readline()
                while line:
                    print line.strip()
                    line = dep_process.fromchild.readline()
            shutil.move(full_pkg_name + "/recipes_c-ansi", full_pkg_name + "/recipes_c_ansi")
            shutil.move(full_pkg_name + "/recipes_f-90", full_pkg_name + "/recipes_f_90")
        build_process = popen2.Popen4(bin_dir + "/util/cesr_to_vms " + full_pkg_name) # FTP upload to VMS cluster
        print "--> BUILD STATUS: COMPLETE!"


## Set group to cesr and add write permissions to the files in the config area

if build_type == "RELEASE" or build_type == "RELEASE & PACKAGES":
    os.system("chgrp -R cesr " + config_dir)
    os.system("chmod -R g+w " + config_dir)

## Create the 'database' of files and functions.
if build_type == "RELEASE" or build_type == "BMAD DISTRIBUTION":
    os.chdir(full_rel_name)
    os.system(bin_dir + "/create_fdb.pl")


sys.exit(0)

