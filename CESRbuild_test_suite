#!/usr/bin/python
################################################################################
# Executes a verification suite on the executable applications produced during
# a CESR Release build.
#
# The names of the applications to test are defined in the dictionary 'progs'
# just below.  The integer after each program name is whether or not
# pseudo-terminal magic needs to be performed in order for this script to
# interact with the program to get it to produce verifiable output.
# The actual return codes from each program execution are not available, so
# the text output of the program is checked against expected strings to verify
# successful completion.
#
# NOTE: This program uses the external utility 'empty' to enable the pseudo TTY
#       process interaction capabilities.  This script originally supports
#       Linux_i686 and OSF1_alpha with external 'empty' binaries called
#       'empty' and 'empty-osf' that have been build specifically for those
#       two platforms respectively.
#
#    Those two utility programs must exist in the same
#       directory as this test suite (or in a PATH directory as described by the
#       shell running this test program) for everything to work on
#       all supported platforms.
#
#
# Usage  : test_suite <release> (<platform>)
#            release   is of the form cesr_YYYY_MMDD_d_N and
#            platform  is optional and should take the form 'Linux_i686_linux'
#
# Author : Matt Rendina
# Date   : 5 March 2007
################################################################################

import os
import sys
import shutil
import string
import time
import popen2

########################################################################################
# Dictionary that defines the group of programs to test and the mode required for each.
########################################################################################
progs = {
         'bmadz':0,                 # good
         'bmad_to_mad_and_xsif':0,  # good
         'analyzer':1,              # good
         'closed_orbit':1,          # good
         'dynamic_aperture_test':1, # good
         'tune_scan':1,             # good
         'tune_plane_res_plot':0,   # good though, X error, grep output for key phrase
         'tao':0                    # good, X error, same as tune_plane_res_plot
         
#         'nonlin_bpm_test':?,       # dies reading phase.03378 file
#         'toad':1?                  # dies trying to parse the presumably correct file
          }
                              # NOTE: python 1.5.x on OSF doesn't support iterating over
                              # dicts, so the X.keys() method is needed when looping
########################################################################################

src = "src"
testlist = []
HOST = ""
libdir   = "/home/cesrulib/cesr_libs"
utilpath = "/home/cesrulib/bin/util/"
wd = os.getcwd()
namestrings = []

if sys.platform == "linux2":
  compiler = os.environ['CESR_F90']
  platform = "Linux_i686_" + compiler
  empty = "empty"
elif sys.platform == "osf1V4":
  platform = "OSF1_alpha_hp"
  empty = "empty-osf"

# Grab command line argument(s)
if len(sys.argv) == 2 or len(sys.argv) == 3:
  release = sys.argv[1]
  if len(sys.argv) == 3:
    platform = sys.argv[2]
  if os.access(libdir + '/' + platform + '/' + release, 4) == 0:
    print "The release " +release+ " does not exist in the "+ platform + " archive."
    sys.exit(2)
else:
  print "Incorrect number or arguments provided to " + sys.argv[0]
  sys.exit(3)

srcpath = libdir +'/'+ platform +'/'+ release +'/'+ src

#Disable X display
os.environ['DISPLAY'] = "none"

#================================================================================
# Support functions for formatting output and preparing for test object spawning
#================================================================================
def print_lines(list):
  for line in list:       
    print line[:-1]

def print_out_and_err(outobj, errobj):
  olist = outobj.readlines()
  elist = errobj.readlines()
  for line in elist:
    olist.append( line )
  print_lines( olist )
  return olist

def borderpad_string( string ):
  pad = 62 - len(string) - 3
  string = "* " + string
  for i in range(0,pad):
    string = string + ' '
  string = string + '*'
  return string

def prep_for_tests(progs, testdir):
  shutil.copytree(srcpath + "/bmadz/test_jobs", testdir+"/")          # copy test input files
  shutil.copy(srcpath + "/bsim/dynamic_aperture/da_test.in", testdir) # copy da_test.in file over
  shutil.copy(srcpath + "/bsim/tune_plane_res_plot/tune_plane_res_plot.in", testdir)
  shutil.copy(srcpath + "/bsim/tune_scan/tunescan.in", testdir)
  shutil.copy(srcpath + "/tao/program/tao.init", testdir)
  shutil.copy(srcpath + "/tao/program/tao_plot.init", testdir)
  shutil.copy(srcpath + "/tao/program/bmad_6wig_lum_20030915_v1.lat", testdir)
  for prog in progs.keys():
    shutil.copy(libdir +'/'+ platform+"/"+ release + "/bin/" + prog, testdir)
  shutil.copy(utilpath + empty, testdir)
  return testdir

#=====================================================================================
## Class that represents an individual release binary test event
## This contains the procedures for properly initiating and interacting with each
## CESR Release program in order to produce output that will indicate whether or not
## The program operates correctly.
#=====================================================================================
class testobject:
  name = ""        #Name of program to test
  t1 = 0
  t1 = 0
  interactive = "" #boolean
  
  def execute(self, testdir):
    ret = -1
    header = ""
    print ""
    print "**********************************************************************************************"
    textlen = len(self.name) + len(release) + 24   # normalize length of all header label lines
    symlen  = (94-textlen)/2
    for i in range(0, symlen ):
      header = header + '<'
    header = header + " Post-build  " +self.name+"  test for "+release+ " "
    for i in range(0, symlen ):
      header = header + '>'
    if len(header) > 94:
      header = header[:-1]
    print header                                   # end normalize
    print "**********************************************************************************************"
    
    t1 = time.time()
    print str(t1) + "  --  BEGIN "+ self.name + " test for "+ platform

    print "Changing working directory."
    os.chdir(testdir)
    print "\n================================================="
    
    if self.interactive:
      os.system("./"+empty+" -f -i ./in -o ./out ./" + self.name + " 2>&1")
      
      if self.name == "dynamic_aperture_test":
        (sout, sin, serr)=popen2.popen3("./"+empty+" -w -v -i ./out -o ./in -t 20 \": \" \
                                        \"da_test.in\n\"; echo da_test.in; cat ./out")
        outlist = print_out_and_err( sout, serr )
        for line in outlist:
          if line[0:20] == " After second qtune:":  # Possibly fragile test here in literal
            ret = 0                                 # output checking.
          else:
            ret = -1


      elif self.name == "tune_scan":
        (sout, sin, serr)=popen2.popen3("./"+empty+" -w -v -i ./out -o ./in -t 4 \"in>:\" \
                                        \"tunescan.in\n\"; cat ./out")
        outlist = print_out_and_err( sout, serr )
        if outlist[-2][0:21] == " Track: max amplitude":
          ret = 0
        else:
          ret = -1

        
      elif self.name == "closed_orbit" or self.name == "analyzer":
        (sout, sin, serr) = popen2.popen3("./"+empty+" -w -v -i ./out -o ./in -t 300 \")\" \
                            \"bmad_4170_2ma_20051220.lat\n\"; echo bmad_4170_2ma_20051220.lat ")
        outlist = print_out_and_err( sout, serr )        
        (sout, sin, serr) = popen2.popen3("./"+empty+" -w -v -i ./out -o ./in -t 300 \">\"  \
                                          \"go\n\"; echo \"go\" ")
        templist = print_out_and_err( sout, serr )
        for line in templist:
          outlist.append(line)
        (sout, sin, serr) = popen2.popen3("./"+empty+" -w -v -i ./out -o ./in -t 300 \"])\" \
                                          \"quit\n\"; echo \"quit\" ")
        templist = print_out_and_err( sout, serr )
        for line in templist:
          outlist.append(line)
        (sout, sin, serr) = popen2.popen3("./"+empty+" -w -v -i ./out -o ./in -t 300 \">\"  \
                                          \"quit\n\"")               ###; echo \"quit\" ")
        templist = print_out_and_err( sout, serr )
        for line in templist:
          outlist.append( line )
        if outlist[-1][0:14]==" CLOSED_ORBIT:"or outlist[-1][0:10]==" ANALYZER:"or outlist[-2][0:7]==" Plot ?":
          ret = 0
        else:
          ret = -1
        time.sleep(4)
 
          
    else:
      if self.name == "tune_plane_res_plot":
        outlist = os.popen(testdir+"/"+self.name).readlines()
        print_lines( outlist )
        ret = -1
        if outlist[-1][0:23] == " Written: quick_plot.ps":
          ret = 0
        else:
          ret = -1
  
            
      elif self.name == "tao":                # actually interactive, but runs like a single-shot w/o X
        outlist = os.popen(testdir+"/"+self.name).readlines()
        print_lines( outlist )
        if outlist[-1][0:45] == " Init: Read tao_template_graph namelist: this":
          ret = 0
        else:
          ret = -1
          
      elif self.name == "bmad_to_mad_and_xsif":
        (sout, sin, serr)=popen2.popen3(testdir+"/"+self.name+" "+testdir+"/bmad_4170_2ma_20051220.lat")
        outlist = print_out_and_err( sout, serr )
        if outlist[-2][0:20] == " Written MAD lattice" or outlist[-1][0:20] == " Written MAD lattice":
          ret = 0
        else:
          ret = -1
        
      elif self.name == "bmadz":
        (sout, sin, serr)=popen2.popen3(testdir+"/"+self.name+" cons_nonlin.in bmad_4170_2ma_20051220.lat")
        outlist = print_out_and_err( sout, serr)
        if outlist[-3][0:17] == " figure of merit:":
          ret = 0
        else:
          ret = -1

    print "=================================================\n"
    t2 = time.time()
    print str(t2) + " END "
    if ret == 0:
      print self.name + " TEST COMPLETED SUCCESSFULLY!     Elapsed time: %i s" % (t2-t1)
    else:
      print self.name + " TEST COMPLETED WITH STATUS: %s   Elapsed time: %i s" % (ret, (t2-t1) )
    
    print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n"

# END class def
################################################################################################
  

if platform == "Linux_i686_intel":
  HOST = "lnx209"
  flag = "LI"
elif platform == "Linux_i686_lahey":
  HOST = "lnx209"
  flag = "LL"
elif platform == "OSF1_alpha_hp":
  HOST = "cesr68"
  flag = "OH"
elif platform == "VMS_alpha_hp":
  HOST = "cesr68"
  flag = "VH"
elif platform == "CYGWIN_i686_intel":
  HOST = "pc6115"
  flag = "CI"

testdir = "/tmp/release_test_suite_area-" + release + "_" +flag

#=========================================================================
# Compose list of test objects and format status strings for the log file
#=========================================================================
for prog in progs.keys():
  namestrings.append( borderpad_string('Setting up '+prog) )
  T = testobject()
  T.name = prog
  if progs[prog] == 0:
   T.interactive = 0
  else:
   T.interactive = 1
  testlist.append( T )


#================================================================================
# Encapsulate the output of each test, delimiting where the separate
# tests begin and end, with suitable metadata for later test summary extraction.
#================================================================================
print ""
print "  ***********************************"
print " **  CESR Release Build Test Suite  **"
print "**                                   ************************"
print "**************************************************************"
print "      Release  : "+release
print "      Platform : "+platform
print "**************************************************************"
print "*                                                            *"
print "* Initializing test location:                                *"
print borderpad_string(testdir)
print borderpad_string("")
for string in namestrings:
  print string
  
# Initialize testing location and copy all necessary .in and .lat files.
prep_for_tests(progs, testdir)

print "*                                                            *"
print "* Starting tests...                                          *"
print "*                                                            *"
print "*                                                             *"
print "*                                                              ******************************"
print "**********************************************************************************************\n"

# Run each test
for test in testlist:
  test.execute( testdir )

# Clean up
print "**********************************************************************************************"
print "*                                                            ********************************"
print "*                                                            *"
print "* Test suite complete for CESR Release build                 *"
print borderpad_string(release + " on " + platform)
print "*                                                            *"
print "* Cleaning up... DONE.                                       *"
print "*                                                            *"
print "**************************************************************"
os.system("rm -rf "+testdir)


