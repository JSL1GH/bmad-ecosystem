#!/home/cesrulib/EXT/Python-2.5.1/python
################################################################################
# Executes a verification suite on the executable applications produced during
# a CESR Release build.
#
# The names of the applications to test are defined in the dictionary 'progs'
# just below.  The integer after each program name is whether or not
# pseudo-terminal magic needs to be performed in order for this script to
# interact with the program to get it to produce verifiable output.
# The actual return codes from each program execution are not available, so
# the text output of the program is checked against expected strings to verify
# successful completion.
#
# NOTE: This program uses the external utility 'empty' to enable the pseudo TTY
#       process interaction capabilities.  This script originally supports
#       Linux_i686 and OSF1_alpha with external 'empty' binaries called
#       'empty' and 'empty-osf' that have been built specifically for those
#       two platforms.
#
#       'empty' can be obtained along with documentation at
#       http://empty.sourceforge.net/
#
# Developer note: If Python versions >= 2.4 can be used on all major build
#                 machines, then the new subprocess module might make process
#                 interaction much easier and help standardize behavior across
#                 platforms.  This is under investigation.
#
#
#    Those two utility programs must exist in the same
#       directory as this test suite (or in a PATH directory as described by the
#       shell running this test program) for everything to work on
#       all supported platforms.
#
#
# Usage  : test_suite <release> (<platform>)
#            release   is of the form cesr_YYYY_MMDD_d_N and
#            platform  is optional and should take the form 'Linux_i686_intel'
#
# Author : Matt Rendina
# Date   : 5 March 2007
################################################################################

import os, sys, string, time, shutil
import subprocess as sub
import pexpect

print ""
print sys.version

########################################################################################
# Dictionaries that define the group of programs to test, based on mode. Int or non-int.
########################################################################################
cmd  = []
icmd = ""

# NO or YES flag indicates whether or not the program to test requires console interaction.
prog_list = {
    "bmadz"                 : ["NO", "cons_nonlin.in", "bmad_4170_2ma_20051220.lat"], # OK
    "bmad_to_mad_and_xsif"  : ["NO", "bmad_4170_2ma_20051220.lat"],                   # OK
    "tao"                   : ["NO"],                                                 # OK w/ no DISPLAY set
    "tune_plane_res_plot"   : ["NO"],                                                 # OK
    "toad"                  : ["NO"],                                                 # 0 stat, but ERROR text
    "nonlin_bpm_test"       : ["NO"],                                                 # Errors.. who knows.  
    "closed_orbit"          : ["YES", "bmad_4170_2ma_20051220.lat"],                  # OK
    "analyzer"              : ["YES", "bmad_4170_2ma_20051220.lat"],                  # OK
    "dynamic_aperture_test" : ["YES"],                                                # OK
    "tune_scan"             : ["YES"]                                                 # OK
    }
###############################################################################################

src = "src"
testlist = []
HOST = ""
libdir   = "/home/cesrulib/cesr_libs"
utilpath = "/home/cesrulib/bin/util/"
wd = os.getcwd()
namestrings = []

if sys.platform == "linux2":
  compiler = os.environ['CESR_F90']
  platform = "Linux_i686_" + compiler
elif sys.platform == "osf1V4":
  platform = "OSF1_alpha_hp"

# Grab command line argument(s)
if len(sys.argv) == 2 or len(sys.argv) == 3:
  release = sys.argv[1]
  if len(sys.argv) == 3:
    platform = sys.argv[2]
  if os.access(libdir + '/' + platform + '/' + release, 4) == 0:
    print "The release " +release+ " does not exist in the "+ platform + " archive."
    sys.exit(2)
else:
  print "Incorrect number or arguments provided to " + sys.argv[0]
  sys.exit(3)

srcpath = libdir +'/'+ platform +'/'+ release +'/'+ src

#Disable X display for unattended operation
os.environ['DISPLAY'] = "none"

#================================================================================
# Support functions for formatting output and preparing for test object spawning
#================================================================================
def borderpad_string( string ):
  pad = 62 - len(string) - 3
  string = "* " + string
  for i in range(0,pad):
    string = string + ' '
  string = string + '*'
  return string

def prep_for_tests(progs, testdir):
  shutil.copytree(srcpath + "/bmadz/test_jobs", testdir + "/")          # copy test input files
  shutil.copy(srcpath + "/tao/program/layout_c_6wig_2003_07_08.bmad", testdir + "/")
  shutil.copy(srcpath + "/bsim/dynamic_aperture/da_test.in", testdir) # copy da_test.in file over
  shutil.copy(srcpath + "/bsim/tune_plane_res_plot/tune_plane_res_plot.in", testdir)
  shutil.copy(srcpath + "/bsim/tune_scan/tunescan.in", testdir)
  shutil.copy(srcpath + "/tao/program/tao.init", testdir)
  shutil.copy(srcpath + "/tao/program/tao_plot.init", testdir)
  shutil.copy(srcpath + "/tao/program/bmad_6wig_lum_20030915_v1.lat", testdir)
  shutil.copy(srcpath + "/tao/program/wiggler_def_6wig_negpol.bmad", testdir)
  shutil.copy(srcpath + "/toad/example/toad.in", testdir)
  shutil.copy(srcpath + "/toad/example/toad.lat", testdir)
  for prog in progs:
    shutil.copy(libdir +'/'+ platform+"/"+ release + "/bin/" + prog, testdir)
  return testdir

#=====================================================================================
## Class that represents an individual release binary test event
## This contains the procedures for properly initiating and interacting with each
## CESR Release program in order to produce output that will indicate whether or not
## The program operates correctly.
#=====================================================================================
class testobject:
  name = ""        #Name of program to test
  t1 = 0
  t1 = 0
  interactive = "" #boolean

  def execute(self, testdir):
    ret = -1
    header = ""
    print ""
    print "**********************************************************************************************"
    textlen = len(self.name) + len(release) + 24   # normalize length of all header label lines
    symlen  = (94-textlen)/2
    for i in range(0, symlen ):
      header = header + '<'
    header = header + " Post-build  " +self.name+"  test for "+release+ " "
    for i in range(0, symlen ):
      header = header + '>'
    if len(header) > 94:
      header = header[:-1]
    print header                                   # end normalize
    print "**********************************************************************************************"
    
    t1 = time.time()
    print str(t1) + "  --  BEGIN "+ self.name + " test for "+ platform

    print "Changing working directory."
    os.chdir(testdir)
    print "\n================================================="
    
    if self.interactive: # Program is interactive, pexpect is needed to respond to prompts.
      icmd = ""
      icmd = icmd + self.name
      for arg in prog_list[self.name][1:]:
        icmd = icmd + " " + arg
      print icmd
      child = pexpect.spawn(icmd, timeout=300)
      child.logfile = sys.stdout
      if self.name == "dynamic_aperture_test": # Customized interaction steps
        child.expect("IN>:")
        child.sendline("da_test.in")
        lines = child.readlines()
        for line in lines:
            print line.strip()
      if self.name == "tune_scan":             # Customized interaction steps
        child.expect("in>:")
        child.sendline("tunescan.in")
        lines = child.readlines()
        for line in lines:
            print line.strip()
      if self.name == "closed_orbit" or self.name == "analyzer": # Customized interaction steps
        child.expect("GO> ")
        child.sendline("go")
        child.expect("DIFF")
        child.sendline("")
        child.expect("GO> ")
        child.sendline("quit")
      icmd = ""
      lines = []
      while child.isalive():
        time.sleep(1)
      child.close()
      returncode = child.exitstatus
      print "\nReturn code: " + str(returncode)
      time.sleep(2)

    else:   # Program is not of the interactive type, just run it and log output.
      cmd = []
      cmd.append(self.name)
      for arg in prog_list[self.name][1:]:
        cmd.append(arg)
      print cmd
      p = sub.Popen(cmd)
      returncode = p.wait()
      print "\nReturn code: " + str(returncode) + '\n'
      time.sleep(2)
      cmd = []

    print "=================================================\n"
    t2 = time.time()
    print str(t2) + " END "
    print self.name + " TEST COMPLETED WITH STATUS: %s   Elapsed time: %i s" % (returncode, (t2-t1) )
    print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n"

# END class def
################################################################################################
# Main starts here
#######################################

if platform == "Linux_i686_intel":
  HOST = "lnx209"
  flag = "LI"
elif platform == "Linux_i686_lahey":
  HOST = "lnx209"
  flag = "LL"
elif platform == "OSF1_alpha_hp":
  HOST = "cesr68"
  flag = "OH"
elif platform == "VMS_alpha_hp":
  HOST = "cesr68"
  flag = "VH"
elif platform == "CYGWIN_i686_intel":
  HOST = "pc6115"
  flag = "CI"

testdir = "/home/cesrulib/temp/test_suite_area-" + release + "_" +flag

#=========================================================================
# Compose list of test objects and format status strings for the log file
#=========================================================================
for prog in prog_list:
  namestrings.append( borderpad_string('Setting up '+prog) )
  T = testobject()
  T.name = prog
  if prog_list[prog][0] == "YES":
    T.interactive = 1
  else:
    T.interactive = 0
  testlist.append( T )

prep_for_tests(prog_list, testdir)

#================================================================================
# Encapsulate the output of each test, delimiting where the separate
# tests begin and end, with suitable metadata for later test summary extraction.
#================================================================================
print ""
print "  ***********************************"
print " **  CESR Release Build Test Suite  **"
print "**                                   ************************"
print "**************************************************************"
print "      Release  : "+release
print "      Platform : "+platform
print "**************************************************************"
print "*                                                            *"
print "* Initializing test location:                                *"
print borderpad_string(testdir)
print borderpad_string("")
for string in namestrings:
  print string
  
# Initialize testing location and copy all necessary .in and .lat files.
#prep_for_tests(progs, testdir)

print "*                                                            *"
print "* Starting tests...                                          *"
print "*                                                            *"
print "*                                                             *"
print "*                                                              ******************************"
print "**********************************************************************************************\n"

# Run each test
for test in testlist:
  test.execute( testdir )

# Clean up
print "**********************************************************************************************"
print "*                                                            ********************************"
print "*                                                            *"
print "* Test suite complete for CESR Release build                 *"
print borderpad_string(release + " on " + platform)
print "*                                                            *"
print "* Cleaning up... DONE.                                       *"
print "*                                                            *"
print "**************************************************************"
os.system("rm -rf "+testdir)


