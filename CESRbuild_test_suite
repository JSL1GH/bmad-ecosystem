#!/home/cesrulib/EXT/Python-2.5.1/Linux/python
################################################################################
# This script uses the above Python interpreter which is more recent than the
# standard interpreter installed on LEPP Linux systems (2.2.3).
################################################################################
# Executes a verification suite on the executable applications produced during
# a CESR Release build.  This will ultimately be easily extensible to allow for
# more thorough testing of application functionality instead of a simple
# run/no-run check.
#
# --The names of the applications to test are defined in the dictionary
# 'prog_list' just below.  The YES:NO flag after each program name is whether
# or not pseudo-terminal magic needs to be performed in order for this script to
# interact with the program and get it to produce verifiable output (by using
# the pexpect module, an all-python analogue to the classic unix utility
# 'expect'.)  The PTY stuff is required if the application depends on any
# keyboard interaction from the user during operation.
#
# --Any remaining list entries are command line arguments to be passed to said
# application.
# 
# The return codes from each sub-process are now available in this version of
# the script and are output in a standardized way for secondary parsing.
#
# Python 2.4 or greater MUST be used to allow access to the 'subprocess' and
# 'pexpect' modules. 
#
# Usage  : test_suite <release> (<platform>)
#            release   is of the form cesr_YYYY_MMDD_d_N and
#            platform  is optional and should take the form 'Linux_i686_intel'
#
# Author : Matt Rendina
# Date   : 5 March 2007
################################################################################

import os, sys, string, time, shutil, ConfigParser
import subprocess as sub

print "\nUsing Python interpreter:"
print sys.version

#============================================================================
# Set up Configuration Parser
#============================================================================
cfg_file = "/home/cesrulib/bin/util/BUILD_SYSTEM.conf"
config   = ConfigParser.ConfigParser()
config.optionxform = lambda x: x   # <-Obtain values without changing case --
config.read(cfg_file)              #  overrides default ConfigParser behavior
#============================================================================
# Grab the UTIL path value from the Config file here to facilitate 2nd-tier
#============================================================================
UTIL_DIR   = config.get("Paths", "UTIL_DIR")
#============================================================================
# Set up parser for 2nd-tier test suite config file
#============================================================================
suite_cfg_file = UTIL_DIR +'/'+ config.get("Test_Suite", "CONFIG_FILE")
sconfig = ConfigParser.ConfigParser()
sconfig.optionxform = lambda x: x  # <-Obtain values without changing case --
sconfig.read(suite_cfg_file)       #  overrides default ConfigParser behavior


#=== Paths ==================================================================
test_list  = sconfig.sections().remove("files")
BIN_DIR    = config.get("Paths", "BIN_DIR")
LIBS_DIR   = config.get("Paths", "LIBS_DIR")
LOG_DIR    = config.get("Paths", "LOG_DIR")
repository = config.get("Repository", "path")


#============================================================================
# Third party module search path set up and importation
#============================================================================
sys.path.append(UTIL_DIR + "/3rd-party")
import pexpect # Pexpect module for controlling spawned interactive processes.


#============================================================================
#   VARIABLE SETUP
#============================================================================
platforms  = []
for plat in config.options("Platforms"):
    if config.get("Platforms", plat) == "FULL":
        platforms.append(plat)
src = "src"
testlist = []
HOST = ""
wd = os.getcwd()
namestrings = []
env_var = ""

#if sys.platform == "linux2":
plat_val = os.environ['CESR_PLATFORM']
compiler = os.environ['CESR_F90']
platform = plat_val + "_" + compiler
#elif sys.platform == "osf1V4":
#  platform = "OSF1_alpha_hp"

#============================================================================
# Dictionary of macros available for expansion in the config file.
#============================================================================
#macros = {

        
#============================================================================
# Populate the dictionary the defines the group of programs to test.
# Slurp up the arguments to use, any interaction dialog needed, and
# any environment variable definitions provided in the config file.
#============================================================================
tests  = {}
for section in sconfig.sections():
    if section != "files":
        interact = []
        args     = []
        dialog   = []
        evars    = []
        if "ARGS" in sconfig.options(section):
            for arg in sconfig.get(section, "ARGS").split(' '):    ## 0
                args.append( arg )
        if "DIALOG" in sconfig.options(section):
            for arg in sconfig.get(section, "DIALOG").split():     ## 1
                dialog.append( arg )
            if len(dialog)%2 != 0:
                print "Prompt-response dialog sequence for " + prog + " must have an even number of entries."
                sys.exit(20)
        if "ENV_VARS" in sconfig.options(section):                 ## 2
            for var in sconfig.get(section, "ENV_VARS").split():
                evars.append( var )
        entry = [args, dialog, evars]
        tests[section] = entry


# Grab command line argument(s)
if len(sys.argv) == 2 or len(sys.argv) == 3:
  release = sys.argv[1]
  if len(sys.argv) == 3:
    platform = sys.argv[2]
  if os.access(LIBS_DIR + '/' + platform + '/' + release, 4) == 0:
    print "The release " +release+ " does not exist in the "+ platform + " archive."
    sys.exit(2)
else:
  print "Incorrect number or arguments provided to " + sys.argv[0]
  sys.exit(3)

srcpath = LIBS_DIR +'/'+ platform +'/'+ release +'/'+ src

#Disable X display for unattended operation
os.environ['DISPLAY'] = "none"

#================================================================================
# Support functions
#================================================================================

#----------------------------------------------------------------
# Function accepts a string and performs macro substution on it
# according to the macros defined in the dictionary above.
#----------------------------------------------------------------
def expand_macros(string):
    tok1 = string.find("{")
    tok2 = string.find("}")
    if tok1 > 0 and tok2 > 0:
        macro = string[tok1+1 : tok2]
        if macro == "testdir":
            string = string.replace("${"+macro+"}", testdir)
    return string

#-----------------------------------------------------------------------------------------
#==Function to pad out an arbitrary string to conform to cosmetic requirements in output.
#==Pads out line with spaces and terminates with an * to allow for ASCII-art box output.
#-----------------------------------------------------------------------------------------
def borderpad_string( string ):
  pad = 62 - len(string) - 3
  string = "* " + string
  for i in range(0,pad):
    string = string + ' '
  string = string + '*'
  return string


#==Copies the host of ancillary test input files, lattices, etc... to the
#==test directory and copies over the complement of binaries to execute.
def prep_for_tests(progs, testdir):
  # Create directory where testing will take place for this platform.
  os.mkdir(testdir)
  # Copy all the files / directories specified in config file to test dir
  for entry in sconfig.options("files"):
      destination = expand_macros(sconfig.get("files", entry))
      if not os.path.exists( destination ):
          os.mkdir(destination)
      if entry[-1] == "/":
          for name in os.listdir(srcpath + entry):
              if name.find("svn") == -1:  # exclude SVN admin dirs
                  #print srcpath + entry + name
                  #print "-->" 
                  shutil.copy(srcpath + entry + name,  destination )
      else:
          shutil.copy( srcpath + entry,  destination  )
  for prog in progs:
    shutil.copy(LIBS_DIR +'/'+ platform+"/"+ release + "/bin/" + prog, testdir)
  return testdir



#=====================================================================================
## Class that represents an individual release binary test event
## This contains the procedures for properly initiating and interacting with each
## CESR Release program in order to produce output that will indicate whether or not
## The program operates correctly.
#=====================================================================================
class testobject:
  name = ""        #Name of program to test
  t1 = 0
  t1 = 0
  params = []

  def execute(self, testdir):
    ##Set up any necessary environment variables needed for test jobs.
    # An environment variable needs to be set to the resource directory in order for the
    # nonlin_bpm_test program to run.
    for var in self.params[2]:
        varname = var.split("=")[0]      # TODO: support for multiple macros in one
        varval  = var.split("=")[1]      # line?
        varval = expand_macros(varval)
        os.putenv(varname, varval)
        
    header = ""
    print ""
    print "**********************************************************************************************"
    textlen = len(self.name) + len(release) + 24   # normalize length of all header label lines
    symlen  = (94-textlen)/2
    for i in range(0, symlen ):
      header = header + '<'
    header = header + " Post-build  " +self.name+"  test for "+release+ " "
    for i in range(0, symlen ):
      header = header + '>'
    if len(header) > 94:
      header = header[:-1]
    print header                                   # end normalize
    print "**********************************************************************************************"
    
    t1 = time.time()
    print str(t1) + "  --  BEGIN "+ self.name + " test for "+ platform

    print "Setting working directory."
    os.chdir(testdir)
    print "\n================================================="
    
    cmd = self.name
    for arg in self.params[0]:
      cmd = cmd + " " + arg
    child = pexpect.spawn(env_var + cmd, timeout=300)
    child.logfile = sys.stdout

    # Is there a dialog to execute? If so, determine its length.
    diag_len = len( self.params[1] )
    if diag_len > 0:         # If there is a dialog to execute
        for i in range(diag_len / 2): # Send each pair through pexpect
            if child.isalive():
                child.expect( self.params[1][i] )
                child.sendline( self.params[1][i+1] )
                i = i + 2
    else:                       #Program is not of an interactive type, just run it and log output.
      lines = child.readlines() # Readlines needed to force buffering.
    cmd = ""
    lines = []
    while child.isalive():
      child.readlines()
      time.sleep(1)
    child.close()
    returncode = child.exitstatus
    time.sleep(2)
    

    print "=================================================\n"
    t2 = time.time()
    print str(t2) + " END "
    print self.name + " TEST COMPLETED WITH STATUS: %s   Elapsed time: %i s" % (returncode, (t2-t1) )
    print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n"

# END class def
################################################################################################

# Main starts here
#######################################

#if platform == "Linux_i686_intel":
#  flag = "LI"
#elif platform == "Linux_i686_lahey":
#  flag = "LL"
#elif platform == "OSF1_alpha_hp":
#  flag = "OH"
#elif platform == "VMS_alpha_hp":
#  flag = "VH"
#elif platform == "CYGWIN_i686_intel":
#  flag = "CI"

flag = string.upper( platform[0] + platform.split("_")[2][0] )

testdir = "/home/cesrulib/temp/test_suite_area-" + release + "_" +flag

# vars available by macro substitution in the .conf file
#============================================================================


#=========================================================================
# Compose list of test objects and format status strings for the log file
#=========================================================================
for test in tests:
  namestrings.append( borderpad_string('Setting up '+ test) )
  #T = testobject(test, tests[test])
  T = testobject()
  #print test + "--" + str( tests[test] ) + "\n"
  T.params = tests[test]
  T.name      = test
  testlist.append( T )

prep_for_tests(tests, testdir)

#================================================================================
# Encapsulate the output of each test, delimiting where the separate
# tests begin and end, with suitable metadata for later test summary extraction.
#================================================================================
print ""
print "  ***********************************"
print " **  CESR Release Build Test Suite  **"
print "**                                   ************************"
print "**************************************************************"
print "      Release  : "+release
print "      Platform : "+platform
print "**************************************************************"
print "*                                                            *"
print "* Initializing test location:                                *"
print borderpad_string(testdir)
print borderpad_string("")
for string in namestrings:
  print string
  
print "*                                                            *"
print "* Starting tests...                                          *"
print "*                                                            *"
print "*                                                            **"
print "****************************************************************\n"

# Run each test
for test in testlist:
  test.execute( testdir )

# Clean up
print "****************************************************************"
print "*                                                            **"
print "*                                                            *"
print "* Test suite complete for CESR Release build                 *"
print borderpad_string(release + " on " + platform)
print "*                                                            *"
print "* Cleaning up... DONE.                                       *"
print "*                                                            *"
print "**************************************************************"
os.system("rm -rf " + testdir)


