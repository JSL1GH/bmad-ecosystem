#!/home/cesrulib/EXT/Python-2.5.1/Linux/python
################################################################################
# This script uses the above Python interpreter which is more recent than the
# standard interpreter installed on LEPP Linux systems (2.2.3).
################################################################################
# Executes a verification suite on the executable applications produced during
# a CESR Release build.  This will ultimately be easily extensible to allow for
# more thorough testing of application functionality instead of a simple
# run/no-run check.
#
# --The names of the applications to test are defined in the dictionary
# 'prog_list' just below.  The YES:NO flag after each program name is whether
# or not pseudo-terminal magic needs to be performed in order for this script to
# interact with the program and get it to produce verifiable output (by using
# the pexpect module, an all-python analogue to the classic unix utility
# 'expect'.)  The PTY stuff is required if the application depends on any
# keyboard interaction from the user during operation.
#
# --Any remaining list entries are command line arguments to be passed to said
# application.
# 
# The return codes from each sub-process are now available in this version of
# the script and are output in a standardized way for secondary parsing.
#
# Python 2.4 or greater MUST be used to allow access to the 'subprocess' and
# 'pexpect' modules. 
#
# Usage  : test_suite <release> (<platform>)
#            release   is of the form cesr_YYYY_MMDD_d_N and
#            platform  is optional and should take the form 'Linux_i686_intel'
#
# Author : Matt Rendina
# Date   : 5 March 2007
################################################################################

import os, sys, string, time, shutil
import subprocess as sub
import pexpect

print "\nUsing Python interpreter:"
print sys.version

########################################################################################
# Dictionaries that define the group of programs to test, based on mode. Int or non-int.
########################################################################################
cmd  = []  # Command for non-interactive processes. A list of command components, as per subprocess module operation.
icmd = ""  # Command for processes requiring 'keyboard' interactin.  A string, as per pexpect module operation.

# NO or YES flag indicates whether or not the program to test requires console interaction.
prog_list = {
    "bmadz"                    : ["NO", "cons_nonlin.in", "bmad_4170_2ma_20051220.lat"], # OK
    "bmad_to_mad_and_xsif"  : ["NO", "bmad_4170_2ma_20051220.lat"],                   # OK
    "tao"                      : ["NO"],                                                 # OK w/ no DISPLAY set
    "tune_plane_res_plot"   : ["NO"],                                                 # OK
    "toad"                     : ["NO"],                                                 # 0 stat, but ERROR text
    "nonlin_bpm_test"       : ["NO"],                                                 # Errors.. who knows.  
    "closed_orbit"           : ["YES", "bmad_4170_2ma_20051220.lat"],                  # OK
    "analyzer"                 : ["YES", "bmad_4170_2ma_20051220.lat"],                  # OK
    "dynamic_aperture_test" : ["YES"],                                                # OK
    "tune_scan"               : ["YES"]                                                 # OK
    }
###############################################################################################

src = "src"
testlist = []
HOST = ""
libdir   = "/home/cesrulib/cesr_libs"
utilpath = "/home/cesrulib/bin/util/"
wd = os.getcwd()
namestrings = []
env_var = ""

if sys.platform == "linux2":
  compiler = os.environ['CESR_F90']
  platform = "Linux_i686_" + compiler
elif sys.platform == "osf1V4":
  platform = "OSF1_alpha_hp"

# Grab command line argument(s)
if len(sys.argv) == 2 or len(sys.argv) == 3:
  release = sys.argv[1]
  if len(sys.argv) == 3:
    platform = sys.argv[2]
  if os.access(libdir + '/' + platform + '/' + release, 4) == 0:
    print "The release " +release+ " does not exist in the "+ platform + " archive."
    sys.exit(2)
else:
  print "Incorrect number or arguments provided to " + sys.argv[0]
  sys.exit(3)

srcpath = libdir +'/'+ platform +'/'+ release +'/'+ src

#Disable X display for unattended operation
os.environ['DISPLAY'] = "none"

#================================================================================
# Support functions for formatting output and preparing for test object spawning
#================================================================================
#==Function to pad out an arbitrary string to conform to cosmetic requirements in output.
#==Pads out line with spaces and terminates with an * to allow for ASCII-art box output.
def borderpad_string( string ):
  pad = 62 - len(string) - 3
  string = "* " + string
  for i in range(0,pad):
    string = string + ' '
  string = string + '*'
  return string

#==Copies the host of ancillary test input files, lattices, etc... to the test directory 
#==and copies over the complement of binaries to execute.
def prep_for_tests(progs, testdir):
  shutil.copytree(srcpath + "/bmadz/test_jobs", testdir + "/")          # copy test input files
  shutil.copy(srcpath + "/bmad/lat/bmad_hibetainj_20040628_v01.lat", testdir)
  shutil.copy(srcpath + "/tao/program/layout_c_6wig_2003_07_08.bmad", testdir + "/")
  shutil.copy(srcpath + "/tao/program/tao.init", testdir)
  shutil.copy(srcpath + "/tao/program/tao_plot.init", testdir)
  shutil.copy(srcpath + "/tao/program/bmad_6wig_lum_20030915_v1.lat", testdir)
  shutil.copy(srcpath + "/tao/program/wiggler_def_6wig_negpol.bmad", testdir)
  shutil.copy(srcpath + "/tao/program/wig_7pole_plus.bmad", testdir)
  shutil.copy(srcpath + "/tao/program/wig_8pole_plus.bmad", testdir)
  shutil.copy(srcpath + "/tao/program/6wig_track.bmad", testdir)
  shutil.copy(srcpath + "/bsim/dynamic_aperture/da_test.in", testdir) # copy da_test.in file over
  shutil.copy(srcpath + "/bsim/tune_plane_res_plot/tune_plane_res_plot.in", testdir)
  shutil.copy(srcpath + "/bsim/tune_scan/tune_scan.in", testdir)
  shutil.copy(srcpath + "/toad/example/toad.in", testdir)
  shutil.copy(srcpath + "/toad/example/toad.lat", testdir)
  shutil.copytree(srcpath + "/nonlin_bpm/nonlin_bpm_resource", testdir + "/nonlin_bpm_resource")
  for file in os.listdir(srcpath + "/nonlin_bpm/test"): # Grab all files in nbpm test dir
    if file.find("svn") == -1:  #Don't grab the SVN administration directory.
      shutil.copy(srcpath + "/nonlin_bpm/test/" + file, testdir)
  for prog in progs:
    shutil.copy(libdir +'/'+ platform+"/"+ release + "/bin/" + prog, testdir)
  return testdir

  
#=====================================================================================
## Class that represents an individual release binary test event
## This contains the procedures for properly initiating and interacting with each
## CESR Release program in order to produce output that will indicate whether or not
## The program operates correctly.
#=====================================================================================
class testobject:
  name = ""        #Name of program to test
  t1 = 0
  t1 = 0
  interactive = "" #boolean

  def execute(self, testdir):
    ##Set up any necessary environment variables needed for test jobs.
    # An environment variable needs to be set to the resource directory in order for the
    # nonlin_bpm_test program to run.
    os.putenv("L_NONLIN_BPM", testdir +"/nonlin_bpm_resource")
    ret = -1
    header = ""
    print ""
    print "**********************************************************************************************"
    textlen = len(self.name) + len(release) + 24   # normalize length of all header label lines
    symlen  = (94-textlen)/2
    for i in range(0, symlen ):
      header = header + '<'
    header = header + " Post-build  " +self.name+"  test for "+release+ " "
    for i in range(0, symlen ):
      header = header + '>'
    if len(header) > 94:
      header = header[:-1]
    print header                                   # end normalize
    print "**********************************************************************************************"
    
    t1 = time.time()
    print str(t1) + "  --  BEGIN "+ self.name + " test for "+ platform

    print "Setting working directory."
    os.chdir(testdir)
    print "\n================================================="
    
    icmd = ""
    icmd = icmd + self.name
    for arg in prog_list[self.name][1:]:
      icmd = icmd + " " + arg
    print icmd
    #child = pexpect.spawn(icmd, timeout=300)
    child = pexpect.spawn(env_var + icmd, timeout=300)
    child.logfile = sys.stdout
    
    if self.name == "dynamic_aperture_test": # Customized interaction steps
      if child.isalive():
        child.expect("IN>:")
        child.sendline("da_test.in")
    if self.name == "tune_scan":                # Customized interaction steps
      if child.isalive():
        child.expect("in>:")
        child.sendline("tune_scan.in")
    if self.name == "closed_orbit" or self.name == "analyzer": # Customized interaction steps
      if child.isalive():
        child.expect("GO> ")
        child.sendline("go")
      if child.isalive():
        child.expect("DIFF")
        child.sendline("")
      if child.isalive():
        child.expect("GO> ")
        child.sendline("quit")
    else:                       #Program is not of an interactive type, just run it and log output.
      lines = child.readlines() # Readlines needed to force buffering.

    icmd = ""
    lines = []
    while child.isalive():
      time.sleep(1)
    child.close()
    returncode = child.exitstatus
    #print "\nReturn code: " + str(returncode)
    time.sleep(2)
    

    print "=================================================\n"
    t2 = time.time()
    print str(t2) + " END "
    print self.name + " TEST COMPLETED WITH STATUS: %s   Elapsed time: %i s" % (returncode, (t2-t1) )
    print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n"

# END class def
################################################################################################

# Main starts here
#######################################

if platform == "Linux_i686_intel":
  HOST = "lnx209"
  flag = "LI"
elif platform == "Linux_i686_lahey":
  HOST = "lnx209"
  flag = "LL"
elif platform == "OSF1_alpha_hp":
  HOST = "cesr68"
  flag = "OH"
elif platform == "VMS_alpha_hp":
  HOST = "cesr68"
  flag = "VH"
elif platform == "CYGWIN_i686_intel":
  HOST = "pc6115"
  flag = "CI"

testdir = "/home/cesrulib/temp/test_suite_area-" + release + "_" +flag

#=========================================================================
# Compose list of test objects and format status strings for the log file
#=========================================================================
for prog in prog_list:
  namestrings.append( borderpad_string('Setting up '+prog) )
  T = testobject()
  T.name = prog
  if prog_list[prog][0] == "YES":
    T.interactive = 1
  else:
    T.interactive = 0
  testlist.append( T )

prep_for_tests(prog_list, testdir)

#================================================================================
# Encapsulate the output of each test, delimiting where the separate
# tests begin and end, with suitable metadata for later test summary extraction.
#================================================================================
print ""
print "  ***********************************"
print " **  CESR Release Build Test Suite  **"
print "**                                   ************************"
print "**************************************************************"
print "      Release  : "+release
print "      Platform : "+platform
print "**************************************************************"
print "*                                                            *"
print "* Initializing test location:                                *"
print borderpad_string(testdir)
print borderpad_string("")
for string in namestrings:
  print string
  
print "*                                                            *"
print "* Starting tests...                                          *"
print "*                                                            *"
print "*                                                             *"
print "*                                                              ******************************"
print "**********************************************************************************************\n"

# Run each test
for test in testlist:
  test.execute( testdir )

# Clean up
print "**********************************************************************************************"
print "*                                                            ********************************"
print "*                                                            *"
print "* Test suite complete for CESR Release build                 *"
print borderpad_string(release + " on " + platform)
print "*                                                            *"
print "* Cleaning up... DONE.                                       *"
print "*                                                            *"
print "**************************************************************"
os.system("rm -rf "+testdir)


