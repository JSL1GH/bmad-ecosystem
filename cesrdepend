#!/usr/bin/perl
#-*-perl-*-
#
# this program checks dependencies of individual fortan files when
# called from the makefile.


#print "now CESRDEPEND:\n\n";
#foreach $argument (@ARGV)
#{
#		print "$argument\n";
#}
#print "\n\n\n";



($search_dirs, $local_mods, $mod_out_dir, $prefix, $suffix, $d_file, $f_file, $cpp_flags)
    =parse_args(\@ARGV);

$the_file=get_cpp_out($search_dirs, $f_file, $cpp_flags);

($needed_incs, $needed_mods, $mods_to_create)
    =get_used_module_names($the_file, $d_file);
if(@{$needed_mods} || @{$needed_incs})
 {

  ($final_module_list, $final_inc_list)
    =find_mods($needed_mods, $search_dirs, $mod_out_dir, $local_mods, $needed_incs);

  $mods_to_create=finalize_mods_to_create($mods_to_create, $mod_out_dir);

  print_d_file($prefix, $f_file, $suffix, $d_file, $mods_to_create, $final_module_list, $needed_incs);
 }


sub get_cpp_out
 {
  $cpp_options=" -C ";
  $search_dirz=$_[0];
  $f_file=$_[1];
  $cpp_flags=$_[2];
  $all_cpp_flags="$cpp_options $cpp_flags";
	@search_dirs=();
	foreach $dir (@{$search_dirz})
	 {push(@search_dirs,"-I$dir");}
	@the_file=split /\n/, `cpp $all_cpp_flags @search_dirs $f_file`;
  return \@the_file;
 }

sub print_empty_d_file
 {
  $d_file=$_[0];
  open(F_out, ">>$d_file");
#  print "no dependencies to record: $d_file\n"
 }

sub print_d_file
 {
  $prefix            =$_[0];
  $f_file            =$_[1];
  $suffix            =$_[2];
  $d_file            =$_[3];
  $mods_to_create    =$_[4];
  $final_module_list =$_[5];
  $final_inc_list    =$_[6];
  $mods_to_create_var="";
  $final_module_var  ="";
  $final_inc_var     ="";

  foreach $mod (@{$mods_to_create})
   {$mods_to_create_var="$mods_to_create_var $mod";}
  foreach $mod (@{$final_module_list})
   {$final_module_var="$final_module_var $mod.mod";}
  $f_file=~/(\w+)\.\w{1,3}$/;
  $f_file=$1;
  open(F_out, ">>$d_file");
  foreach $inc (@{$final_inc_list})
   {print F_out ("$prefix$f_file$suffix: $inc\n");}    
  if($final_module_var)
   {print F_out ("$prefix$f_file$suffix$mods_to_create_var: $final_module_var\n");} 
  close(F_out);
 }

sub finalize_mods_to_create
 {
  $mods_to_create=$_[0];
  $mod_out_dir   =$_[1];
  foreach $mod (@{$mods_to_create})
   {push(@mods_to_create2,"$mod_out_dir/$mod.mod");}
  return \@mods_to_create2;
 }


sub find_mods
 {
  @final_inc_list   =();
  @final_module_list=();
  $needed_mods      =$_[0];
  $search_dirs      =$_[1];
  $mod_out_dir      =$_[2];
  $local_mods       =$_[3];
  $needed_incs      =$_[4];
  MOD: foreach $mod (@ {$needed_mods})
   {
    foreach $local_mod (@ {$local_mods})
     {
      if("$mod.mod" eq $local_mod)
       {
        push(@final_module_list,"$mod_out_dir/$mod");        
        next MOD;
       }
     }
    foreach $dir (@ {$search_dirs})
     {
			$norm_dir=$dir;
			$norm_dir=~s/\/[\w_]+\/\.\.//g;
      $file_in=0;
      opendir(include_dir, $dir);
      $file_in=(grep { $_ eq "$mod.mod"} readdir(include_dir));
      closedir(include_dir);
      if($file_in)
#      if(`find $dir -maxdepth 1 -name $mod.mod -print 2>temp.out`)
       {
        push(@final_module_list,"$dir/$mod");
        next MOD;
       }
     }
    if($mod!~/\.inc$/)
     {push(@final_module_list, "$mod");}
    die "fatal: can't find $mod in include paths.\n";
   }
  `rm -fr temp.out`;
  return (\@final_module_list, \@final_inc_list);
 }


sub get_used_module_names
 {
  $file           =$_[0];
  $d_file         =$_[1];
  @needed_incs    =();
  @mods_to_create =();
  @needed_mods    =();
  @grep_out_inc_t =grep /include\s/i, @{$file};
  @grep_out_inc   =grep !/#include/i, @grep_out_inc_t; 
  @grep_out_mod_t =grep /module\s/i, @{$file};
  @grep_out_mod   =grep !/end\s/i, @grep_out_mod_t;
  @grep_out_use   =grep /\buse\s/i, @{$file};
  foreach $line (@grep_out_inc)
   {
#we are currently assuming that the path in a fortran include statement is
#full, requiring no searching
#also, there is no recursive search for includes
#let's find a fortran pre-compiler that will do all that!
    if(($line=~/(.*?)include\s\'(\S+?)\'/i) && (!($1=~/!/)))
     {
      if($2=~/^\//)
       {push(@needed_incs,$2) unless ($seen{$2}++);}
      else
			 {
				$!=0;
        die "fatal: fortran includes need an absolute path from root specified within the statement.\nwarning: recursive searching of fortran includes not supported!";
		   }
	   }
   }
  foreach $line (@grep_out_mod)
   {
    if(($line=~/^\s*module\s(\S+)/i) && ($1!~/PROCEDURE/i))
     {push(@mods_to_create,lc($1)) unless ($seen{lc($1)}++);}
   }
  foreach $line (@grep_out_use)
   { 
    while($line)
     {
      if(($line=~/^(\s*?)\buse\s+([\w_]+)[\s;,](.+)/i) || ($line=~/^(\s*?)\buse\s+([\w_]+)$/i))
       {
        push(@needed_mods,lc($2)) unless ($seen{lc($2)}++);
        $line=$3;
       }
      else
       {$line=0;}
     }
   }
  $needed_mods_length=@needed_mods;
  $needed_incs_length=@needed_incs;
  if((!$needed_mods_length)&&(!$needed_incs_length))
   {
    print_empty_d_file($d_file);
    return (0,0);
   }
  return (\@needed_incs, \@needed_mods, \@mods_to_create);
 }
  


sub parse_args
 {
  $arguments    =$_[0];
  @Is           =();
  @MOD          =();
  foreach $argument (@{$arguments})
   {
    if($argument=~/^-I(.*)/)
     {push(@Is,$1);}
    elsif($argument=~/^-MOD(.*)/)
     {push(@MOD,(split /\s/,$1));}
    elsif($argument=~/^-MP(.*)/)
     {$MP=$1;}
    elsif($argument=~/^-PRE(.*)/)
     {$PRE=$1;}
    elsif($argument=~/^-SUF(.*)/)
     {$SUF=$1;}
    elsif($argument=~/^-f(.*)/)
     {$f=$1;}
    elsif($argument=~/^-cpp(.*)/)
		 {$cpp_flags=$1;}
    else
     {$f_filename=$argument;}
   }
  return (\@Is, \@MOD, $MP, $PRE, $SUF, $f, $f_filename, $cpp_flags);
 }






