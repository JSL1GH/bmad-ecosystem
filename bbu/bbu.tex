\documentclass[12pt]{article}

\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{amssymb}
\usepackage{amsmath}
\begin{document}
\title{A Description of the BBU Code Structure}

\author{Changsheng Song}

\maketitle



\section{Main Program: csbbu}

In the future, other programs should pass the lat\_struct variable, bunch frequency, tracking time
and print out time to the main program. The ``power\_t'' and ``coor\_t'' are allocated in the main
program based on the tracking time and print out time.


\subsection{The bbu\_struct module}

In this module we define the structure ``{\bf bbu\_info}'' stores all the information that we need for the simulation.
The definition of each component of ``{\bf bbu\_info}'' is listed below.

\texttt{TYPE bbu\_info}

\texttt{  real(rp), Dimension(:), allocatable :: time\_c}  

\texttt{  real(rp), Dimension(:), allocatable :: mat\_c}

\texttt{  real(rp), Dimension(:), allocatable :: freq\_c}

\texttt{  real(rp), Dimension(:), allocatable :: Q\_c}

\texttt{  real(rp), Dimension(:), allocatable :: RoQ\_c}

\texttt{  real(rp), Dimension(:), allocatable :: angle\_c}

\texttt{  real(rp), Dimension(:), allocatable :: power\_c}

\texttt{  integer,  Dimension(:), allocatable ::   hom}

\texttt{  real(rp)  current}

\texttt{  real(rp)  b\_freq}

\texttt{  integer   b\_time}

\texttt{  integer   p\_time}

\texttt{  real(rp)  n\_amp}

\texttt{  real(rp)  p\_amp}

\texttt{  real(rp)  n\_on}

\texttt{  integer   cavity}

\texttt{  integer   hom\_num}

\texttt{END TYPE bbu\_info}

{\bf 1. current} : Real variable that stores the current.

{\bf 2. cavity}  : Integer variable that stores the number of cavities in the lattice.

{\bf 3. mat\_c}   : One dimensional array that stores the tranfer matrices between cavities.

{\bf 4. time\_c}  : One dimensional array that stores the arrival time of each cavity.

{\bf 5. hom}     : Integer array that stores the number of HOMs in each cavity.


{\bf 6. Q\_c}     : One dimensional array that stores the Q value of each HOMs.


{\bf 7. RoQ\_c}   : One dimensional array that stores the R/Q value of each HOMs.

{\bf 8. freq\_c}  : One dimensional array that stores the frequency of each HOMs.

{\bf 9. angle\_c} : One dimensional array that stores the polarization angle of each HOMs.

{\bf 10. power\_c}: One dimensional array that stores the power of each HOMs.

{\bf 11. b\_time} : Real variable that stores the tracking time.

{\bf 12. p\_time} : Real variable that stores the print time.

{\bf 13. n\_amp}  : Real variable that stores the noise amplitude(Not important at the moment).

{\bf 14. p\_amp}  : Real variable that stores the position error amplitude(Not important at the moment).

{\bf 15. n\_on}   : Real variable that stores the time when the noise is on(Not important at the moment).

{\bf 16. hom\_num} : Integer variable that stores the total number of HOMs in the lattice.

A new structure "{\bf pair\_num}'' is also defined to store the data of the threshold's dependency on other parameters.

\texttt{TYPE pair\_num}

\texttt{  real(rp), Dimension(:), allocatable ::  var}

\texttt{  real(rp), Dimension(:), allocatable ::  threshold}

\texttt{end TYPE pair\_num}

{\bf 1. var} : Real array that stores the value of the varying parameter.

{\bf 2. threshold} : Real array that stores the corresponding threshold current.

A structure ``{\bf HOM\_power} is defined to store the power in each cavity at the end of the tracking.

\texttt{TYPE HOM\_power}

\texttt{  real(rp)  power}

\texttt{  integer   c\_ind}

\texttt{  integer   h\_ind}

\texttt{end TYPE HOM\_power}

{\bf 1. power}: Real variable that stores the value of the HOM power.

{\bf 2. c\_ind}: Integer variable that stores the lord index of the cavity in the lattice.

{\bf 3. h\_ind}: Integer variable that stores the indices of HOMs in each cavity.

\subsection{The bbu\_interface module}
In this module we write the interface between the main program and the subroutines.

\subsection{Subroutine Get\_info()}

{\bf Get\_info(lattice, cur, bbu,  Hpower,output)}

The subroutine ``Get\_info'' will take the lattice and put all the useful information into ``bbu'', allocate the array  ``Hpower'' and return ''bbu"  to the main program.

If ``output'' is true, the subroutine will also write the information of the lattice into two files, ``Beta'' and ``MAT''.

Inside this routine several parameters needed for tracking are defined. 


\texttt{real, parameter :: noise\_amp = 0.0}

\texttt{real, parameter :: pos\_amp = 0.0}

\texttt{real, parameter :: noise\_on = 0.0}

\texttt{real, parameter :: pw=0.1}

The subroutine interface 

\texttt{subroutine Get\_info(lattice,cur,bbu,Hpower,output)}

\texttt{    use bmad}

\texttt{    use bbu\_struct}

\texttt{    implicit none}

\texttt{    type (lat\_struct), INTENT(IN)    :: lattice}

\texttt{    real(rp),           INTENT(IN)    :: cur}

\texttt{    type (bbu\_info),    INTENT(INOUT) :: bbu}

\texttt{    type (HOM\_power), dimension(:), allocatable, INTENT(INOUT) :: Hpower}

\texttt{    logical, INTENT(IN) :: output}

\texttt{end subroutine}

\subsection{Subroutine Tracking()}
{\bf Tracking(bbu, power\_t, coor\_t, Hpower, output)}

The subroutine ``Tracking'' will track the beam once at the given current and generate a plot of the time evolution of the average power in the cavities.
The data of the average power in the cavities is stored in the array ``power\_t''. The data of the bunch's phase space coordinate in the last cavity is stored in the array ``coor\_t''.

If ``output'' is true, the subroutine will also write the tracking data stored in ``power\_t'' and ``coor\_t'' into file ``coor\_t''. The first column in this file is the bunch number, the second column is average power and the rest columns are the phase space coordinates $X,\;P_x,\;Y,\;P_y$.

The power in each cavity will also be written into the file ``power\_c''.
 
\texttt{subroutine Tracking(bbu,power\_t,coor\_t,Hpower,output)}

\texttt{    use bbu\_struct}

\texttt{    implicit none}

\texttt{    type (bbu\_info), INTENT(INOUT):: bbu}

\texttt{    real(rp), dimension(:), INTENT(INOUT) :: power\_t}

\texttt{    type(coord\_struct), dimension(:), INTENT(INOUT) :: coor\_t}  

\texttt{    type (HOM\_power), dimension(:), INTENT(INOUT) :: Hpower}

\texttt{    logical, INTENT(IN) :: output}

\texttt{end subroutine}

\subsection{Subroutine Threshold()}
{\bf Threshold(bbu, cur, power\_t, coor\_t, Hpower, output)}

The subroutine ''Threshold'' will take the input current as a trial value and search the threshold current of the given lattice.

The ``plot'' is a logical variable to specify whether to generate a plot of the time evolution of the power or not.

The threshold current value is returned to ``cur''.

If ``output'' is true, the subroutine will also write the tracking data stored in ``power\_t'' and ``coor\_t'' into file ``coor\_t''. The first column in this file is the bunch number, the second column is average power and the rest columns are the phase space coordinates $X,\;P_x,\;Y,\;P_y$.

\texttt{subroutine Threshold(bbu,cur,power\_t,coor\_t,Hpower,output)}

\texttt{    use bbu\_struct}

\texttt{    implicit none}

\texttt{    type (bbu\_info), INTENT(INOUT):: bbu}

\texttt{   real(rp),        INTENT(OUT)  :: cur}

\texttt{    real(rp), dimension(:), INTENT(INOUT) :: power\_t}

\texttt{    type(coord\_struct), dimension(:), INTENT(INOUT) :: coor\_t}

\texttt{    type (HOM\_power), dimension(:), INTENT(INOUT) :: Hpower}

\texttt{    logical, INTENT(IN) :: output}

\texttt{end subroutine}

\subsection{Subroutine Qdep()}
{\bf Qdep(bbu, power\_t, coor\_t, Q\_l, Q\_u, ck, N, thresh\_dep, output)}

The subroutine ``Qdep'' will evenly pick up $N$ points in the range $[Q_l, Q_u]$ and find the corresponding threshold current.

``ck'' indicates which HOM you want to change. If ``ck=0'', all HOMs will be changed.

The result will be stored in ``thresh\_dep''.

If ``out\_put'' is true, the result will be written into the file ``QDEP''.

\texttt{subroutine Qdep(bbu,power\_t,coor\_t,Q\_l,Q\_u,ck,N,thresh\_dep,output)}

\texttt{    use bbu\_struct}

\texttt{    implicit none}

\texttt{    type (bbu\_info), INTENT(INOUT):: bbu}

\texttt{    real(rp), dimension(:), INTENT(INOUT) :: power\_t}

\texttt{    type(coord\_struct), dimension(:), INTENT(INOUT) :: coor\_t}

\texttt{    real(rp), INTENT(IN) :: Q\_l}

\texttt{    real(rp), INTENT(IN) :: Q\_u}

\texttt{    integer, INTENT(IN) :: ck}

\texttt{    integer, INTENT(IN) :: N}

\texttt{    type (pair\_num), INTENT(INOUT) :: thresh\_dep}

\texttt{    logical, INTENT(IN) :: output}

\texttt{end subroutine}

\subsection{Subroutine Fdep()}
{\bf Fdep(bbu, power\_t, coor\_t, f\_l, f\_u, ck, N, thresh\_dep, output))}

The subroutine ``Fdep'' will change the frequency spread of HOMs and find the dependency of the threshold currnet on the frequency spread.

``ck'' indicates which HOM you want to change. If ``ck=0'', all HOMs will be changed.

The result will be stored in ``thresh\_dep''.

If ``out\_put'' is true, the result will be written into the file ``FDEP''.

\texttt{subroutine Fdep(bbu,power\_t,coor\_t,f\_l,f\_u,ck,N,thresh\_dep,output)}

\texttt{    use bbu\_struct}

\texttt{    implicit none}

\texttt{    type (bbu\_info), INTENT(INOUT):: bbu}

\texttt{    real(rp), dimension(:), INTENT(INOUT) :: power\_t}

\texttt{    type(coord\_struct), dimension(:), INTENT(INOUT) :: coor\_t}

\texttt{    real(rp), INTENT(IN) :: f\_l}

\texttt{    real(rp), INTENT(IN) :: f\_u}

\texttt{    integer, INTENT(IN) :: ck}

\texttt{    integer, INTENT(IN) :: N}

\texttt{    type (pair\_num), INTENT(INOUT) :: thresh\_dep}

\texttt{    logical, INTENT(IN) :: output}

\texttt{end subroutine}
\subsection{Subroutine Pdep()}
{\bf Pdep(bbu, power\_t, coor\_t, a\_l, a\_u, ck, N, thresh\_dep, output))}

The subroutine ''Pdep'' will change the polarization angles of HOMs and find the dependency of the threshold current on the polarization angle.

$a_l$ and $a_u$ are in degrees.

``ck'' indicates which HOM you want to change. If ``ck=0'', all HOMs will be changed.

The result will be stored in ``thresh\_dep''.

If ``out\_put'' is true, the result will be written into the file ``PDEP''.

\texttt{subroutine Qdep(bbu,power\_t,coor\_t,a\_l,a\_u,ck,N,thresh\_dep,output)}

\texttt{    use bbu\_struct}

\texttt{    implicit none}

\texttt{    type (bbu\_info), INTENT(INOUT):: bbu}

\texttt{    real(rp), dimension(:), INTENT(INOUT) :: power\_t}

\texttt{    type(coord\_struct), dimension(:), INTENT(INOUT) :: coor\_t}

\texttt{    real(rp), INTENT(IN) :: a\_l}

\texttt{    real(rp), INTENT(IN) :: a\_u}

\texttt{    integer, INTENT(IN) :: ck}

\texttt{    integer, INTENT(IN) :: N}

\texttt{    type (pair\_num), INTENT(INOUT) :: thresh\_dep}

\texttt{    logical, INTENT(IN) :: output}

\texttt{end subroutine}

\subsection{C++ Subroutine bbu\_track()}

\texttt{extern "C" void bbu\_track\_(double\& cur, int\& cav\_num, double* cavmat,}

\texttt{                             double* cavtime, int\& hom\_num, double* homQ,double* homRoQ,}

\texttt{			     double* cshomfreq, double* homang, double* hompw, double* power,}
 
\texttt{                             double* pcoor, double\& csbfreq, int\& N, int\& n\_prt, double\& csd\_amp,}

\texttt{                             double\& cspos\_err\_amp, double\& cst\_noise, int\& check)}

Subroutine \texttt{bbu\_track()} takes the lattice and HOM information from bmad and passes it 
to the bbu tracking subroutine \texttt{tbbu()}.

\subsection{C++ Subroutine tbbu()}

\texttt{tbbu(cur, cav\_num, hom\_total, hom, start, csbunch\_num, csbfreq, N,}

\texttt{     n\_prt, csd\_amp, cspos\_err\_amp, cst\_noise, cavtime, cavmat,}

\texttt{     homQ, homRoQ,homfreq, cosang, sinang, cspw, power, }

\texttt{     pcoor, hompw, cscalls, crl)}

Subroutine \texttt{tbbu()} does the tracking at a given current and return the growth rate of 
the HOM power. The threshold current is found when the returned growth rate is 
close to zero.

\subsection{C++ Subroutine root()}

\texttt{root(cur\_low, theta\_low, cur\_high, theta\_high, accuracy, cav\_num,}

\texttt{     hom\_total, hom, start, csbunch\_num, csbfreq, N,  n\_prt, csd\_amp,}

\texttt{     cspos\_err\_amp, cst\_noise, cavtime, cavmat, homQ, homRoQ, homfreq,}

\texttt{     cosang, sinang, cspw, power, pcoor, hompw, cscalls, crl)}

Subroutine \texttt{root()} searches the threshold current that makes the 
HOM power growth rate close to zero and returns the value of the
threshold current.

\subsection{C++ Subroutine check\_result1()}

\texttt{extern ``C" void check\_result1\_(double* power\_t, int\& N)}

This subroutine is used to plot ``HOM Power vs. t'' and ``log(power) vs. t''.
The data are taken from file \texttt{wout} and processed by \texttt{gnuplot}.

\subsection{C++ Subroutine check\_result2()}

\texttt{extern "C" void check\_result2\_(double* var, double* thresh, int\& N)}

This subroutine is used to plot ``Threshold Current vs. HOM Parameters($Q_\lambda$, $\theta_\lambda$ and $\Delta f$)''. The data are taken from file \texttt{threshdep} and processed by \texttt{gnuplot}.

\subsection{An Example of Running BBU Program}

Once the program is started, the program displays

\texttt{What would you like to do with this lattice}

\texttt{1. Do the tracking at a given current}

\texttt{2. Find the threshold current of a given lattice}

\texttt{3. Find the dependence of the threshold current on the HOM Q.}

\texttt{4. Find the dependence of the threshold current on the HOM frequency spread.}

\texttt{5. Find the dependence of the threshold current on the HOM polarization angle.}

\texttt{3}

\texttt{Please input the trial current in mA}

\texttt{100}

\texttt{Do you want to check the plot of Power v.s.t at the end?}

\texttt{If you do, enter 1, otherwise enter 2}

\texttt{1}

As it is shown above, the user can just follow the instruction from
the program to choose the type of simulation and the initial trial
beam current. The trial current should be a reasonable guess
of the threshold current in order to improve the efficiency of
the program.

The range over which different HOM parameters are varied is 
defined in the main program ``csbbu.f90'' and any modification thereof
should be made in ``csbbu.f90''. 

It is recommended that users should check the plot of the time evolution
of the HOM power in the end. This is especially important for HOMs with
high $Q$ values because the tracking time might not be long enough to show
the stablized behavior of the HOM power. As the program only checks the
average growth rate of the HOM power, it could mistake a ``V'' shape curve
as a flat curve and thus falsely conclude that the HOM power reaches its 
equilibrium point and the threshold current is found for this particular mode.
Thus it is necessary to check the ``power vs. t'' curve to avoid this
type of error.
 
\section{Longitudinal BBU Code}

The way the program works is very similar to that of the transverse BBU code
except that the tracking code contains different formulas. In order to find
the longitudinal BBU threshold current, users should run the tracking 
subroutine with different beam currents and record the HOM power at the
end of each tracking. Then a plot of ``HOM power vs. Current'' should
be generated and the threshold current is found at the point where
the discontinuity occurs. It should be noted that only the first option
is functional in the LBBU case.

\section{Quadrupole BBU Code}

The quadrupole BBU code is almost identical to the dipole BBU code except
that the \texttt{c++} tracking code contains formulas for quadrupole HOM.
One can follow the exact same steps as those in the dipole BBU code and
obtain the threshold current for a given lattice. It should be noted that 
only the first two options are functional in the QBBU case.

\end{document}
