#!/usr/bin/env python

import subprocess
from bbu import find_threshold, drscan, phase_scan
import os
import math

# Parse the tracking result of a bbu run
# In: for_py.txt file generated by the bbu run
# Out: the parsed result, dictionary d
def parse_for_py(filename='for_py.txt'):
  d = {}
  f =  open(filename,'r')
  for line in f:
    line = line.strip()
    key, value = line.replace(' ','').split('=')
    if len(key) > 0:
      if (key == 'lostbool' or key == 'growth_rate_set'):
        if (value == 'True'): val = True
        elif (value == 'False'): val = False
        d[key] = val
      else:
        d[key] = float(value)
  f.close()
  return d

def single_threshold( py_par ):
  if ( os.path.exists(os.path.join(py_par['temp_dir'],"for_py.txt")) ): os.remove(os.path.join(py_par['temp_dir'],"for_py.txt"))    
  # Define dictionay t for threshold calculation
 # t = {'charge0':0,'charge1':-1,'charge_old':-1,'charge_try':-1,'growth_rate0':-1,'growthrate1':-1,'growth_rate_set0':False,'growth_rate_set1':False,'growth_rate':0,'growth_rate_old':0,'bunch_charge':0,'charge_threshold':0}
  t  = {'charge0':0,'charge1':-1,'growth_rate':0,'bunch_charge':0}
  temp_curr = py_par['threshold_start_curr']

  print('Start running BBU for first current')
  find_threshold.run_bbu( temp_curr, py_par, 'current' )   # Run bbu for first tempory current
  d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt'))
  t['bunch_charge'] = temp_curr * d['bunch_dt']   
 
  keep_looking = 1
  while ( keep_looking ):   # Pinning down Ith between charge1 and charge0
    t['growth_rate'] = d['growth_rate']
    bool_stable = find_threshold.get_stability(d['v_gain'], d['lostbool'])
    find_threshold.calc_new_charge( t, bool_stable, d['rel_tol'] ) # clac_new_charge() updates many things in t
    temp_curr = t['bunch_charge'] / d['bunch_dt']    # Bunch charge updated in calc_new_charge()
    find_threshold.run_bbu( temp_curr, py_par, 'current' )    #Run BBU on new trail current
    d.clear()
    d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt'))

    if (abs(t['charge1'] - t['charge0']) < (t['charge1']*d['rel_tol'])): 
      keep_looking = 0
      histo = open(os.path.join(py_par['temp_dir'],'thresholds.txt'), 'a')
      print('= = = = = = = = =')
      print('	CALCULATED THRESHOLD IS ', temp_curr, ' (A)')
      histo.write(str(temp_curr)+'\n')
      histo.close()
    if ( temp_curr < 10**-15 or temp_curr > 10**5 ): 
      keep_looking = 0
      print('==!!==!!==!!==')
      print('	THRESHOLD DID NOT CONVERGE WITHIN BOUNDS')
      if (temp_curr < 10**-15):
        print('Test current below 10^-15 A, no stable current found')
      else:
        print('Test current above 10^5 A, no unstable current found')
      histo = open(os.path.join(py_par['temp_dir'],'thresholds.txt'), 'a')
      histo.write('DID NOT CONVERGE\n')
      histo.close()
  
  # Clean up working directory when finished
  #if ( os.path.exists("bbu_template.init") ): os.remove(os.path.join(py_par['temp_dir'],"bbu_template.init"))    
  #if ( os.path.exists(os.path.join(py_par['temp_dir'],"bbu.init")) ): os.remove(os.path.join(py_par['temp_dir'],"bbu.init"))    
  t.clear()



def drscanner( py_par ):
  # Define dictionary t for threshold calculation
  t={}

  # Create thres_v_trotb.txt in temp_dir to store the computed Ith for each tr/tb 
  my_file = open(os.path.join(py_par['temp_dir'],'thresh_v_trotb.txt'),'w')

  # Define step size
  if(py_par['ndata_pnts_DR'] >= 2):
    print('Caution: Too many ndata_pnts_DR may take a long time!!')
    step_size = (py_par['end_dr_arctime']-py_par['start_dr_arctime'])/(py_par['ndata_pnts_DR']-1)
  elif(py_par['ndata_pnts_DR'] == 1):
    print('Just one data point.')
    step_size = 0
  else:
    print('Invalid ndata_pnts_DR specified!!!')

  for n in range (0, py_par['ndata_pnts_DR']):
    
    t  = {'charge0':0,'charge1':-1,'growth_rate':0,'bunch_charge':0}
    temp_arctime = py_par['start_dr_arctime'] + n*(step_size)
    if (temp_arctime>1):
      print(n)
    # Make lat2 file to vary the arctime (i.e. vary arclength)
    drscan.setup_drscan( temp_arctime, py_par ) 

    # Run bbu at this arc_time 
    find_threshold.run_bbu( py_par['threshold_start_curr'], py_par, 'drscan' ) # First time run bbu
    d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt')) #parse the result
    t['bunch_charge'] = py_par['threshold_start_curr'] * d['bunch_dt']   
    keep_looking = 1

    # For a specific arctime, find the Ith
    while ( keep_looking ):   # Nudge stable current very close to the higher, unstable current
      #t['growth_rate_set0'] = d['growth_rate_set']
      t['growth_rate'] = d['growth_rate']
      bool_stable = find_threshold.get_stability(d['v_gain'], d['lostbool']) #check stability 
      find_threshold.calc_new_charge( t, bool_stable, d['rel_tol'] ) #update  many things in t 
      temp_curr = t['bunch_charge'] / d['bunch_dt']    # New trial current using updated t[bunch_charge]
      find_threshold.run_bbu( temp_curr, py_par, 'drscan' )    # Try the new guessed current
      d.clear()
      d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt'))
      #t['growth_rate_set1'] = d['growth_rate_set']
      if ( abs(t['charge1'] - t['charge0']) < abs(t['charge1']*d['rel_tol']) ): 
      # If the difference between min_I_unstable and max_I_stable is within the tolerance, Ith is considered found 
        keep_looking = 0 
        print('= = = = = = = = =')
        print('	STEP IN DRSCAN COMPLETE')
        # Record tr/tb, Log(Ith, 10), and  Ith for plotting
        trotb = temp_arctime / d['bunch_dt'] #tr/tb
        #my_file.write(str(trotb)+'	'+str(math.log(temp_curr,10))+'	'+str(temp_curr)+'\n')
        my_file.write(str(trotb)+'	'+str(temp_curr)+'\n')
        print('JUST WROTE TO thresh_v_trotb.txt in the temporary directory')
    d.clear()
  my_file.close()

  # Clean up temp 2nd lattice and the temp working directory when finished
  ##if ( os.path.exists(os.path.join(py_par['temp_dir'],"lat2.lat")) ): os.remove(os.path.join(py_par['temp_dir'],"lat2.lat"))    
  ##if ( os.path.exists(os.path.join(py_par['temp_dir'],"bbu_template.init")) ): os.remove(os.path.join(py_par['temp_dir'],"bbu_template.init"))    
  ##if ( os.path.exists(os.path.join(py_par['temp_dir'],"bbu.init")) ): os.remove(os.path.join(py_par['temp_dir'],"bbu.init"))    
  
  # If requested, plot Log(Ith) vs tr/tb for all arctimes 
  if (py_par['plot_drscan']):
    print('Producing plot(s). To continue, exit the plots.') 
    drscan.make_dr_plot(py_par)  
    #drscan.make_dr_plot(py_par)  
    


def phase_scanner( py_par ):
  # Define dictionary t for threshold calculation
  t={}

  # Create thres_v_phase.txt in temp_dir to store the computed Ith for each phase
  my_file = open(os.path.join(py_par['temp_dir'],'thresh_v_phase.txt'),'w')
  
  # Define step size
  if(py_par['ndata_pnts_PHASE'] >= 2):
    print('Caution: Too many ndata_pnts_PHASE may take a long time!!')
    step_size = (py_par['end_phase']-py_par['start_phase'])/(py_par['ndata_pnts_PHASE']-1)
  elif(py_par['ndata_pnts_PHASE'] == 1):
    print('Just one data point.')
    step_size = 0
  else:
    print('Invalid ndata_pnts_PHASE specified!!! ')

  # Looping over phases 
  for n in range (0, py_par['ndata_pnts_PHASE']):
    t  = {'charge0':0,'charge1':-1,'growth_rate':0,'bunch_charge':0}
    
    if (step_size > 0):  # If step_size is not defined, user has given invalid ndata_pnts_PHASE
      temp_phase = py_par['start_phase'] + n*(step_size)    # For scan (more than one data point, can be slow)
    elif (step_size == 0):
      temp_phase = py_par['ONE_phase']                      # For one data point
    
    # Make lat2 file with the temp_phase
    phase_scan.setup_phase_scan( temp_phase, py_par ) 

    # Run bbu first time with the test_curr at this phase 
    find_threshold.run_bbu( py_par['threshold_start_curr'], py_par, 'phase_scan' )
    d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt')) # parse the result (from Fortran to Python)
    t['bunch_charge'] = py_par['threshold_start_curr'] * d['bunch_dt']   
    keep_looking = 1

    # For a specific phase, find the Ith
    while ( keep_looking ):   # Nudge stable current very close to the higher, unstable current
      t['growth_rate'] = d['growth_rate']
      bool_stable = find_threshold.get_stability(d['v_gain'], d['lostbool']) #check stability 
      find_threshold.calc_new_charge( t, bool_stable, d['rel_tol'] ) #update t based on the stability of previous trial currents
      temp_curr = t['bunch_charge'] / d['bunch_dt']    # compute the new trial current using updated t[bunch_charge]
      find_threshold.run_bbu( temp_curr, py_par, 'phase_scan' )    # Try the new guessed current
      d.clear()
      d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt'))
      if ( abs(t['charge1'] - t['charge0']) < abs(t['charge1']*d['rel_tol']) ): 
      # If the difference between min_I_unstable and max_I_stable is within the tolerance, Ith is considered found 
        keep_looking = 0 
        print('= = = = = = = = =')
        print('	STEP IN PHASE_SCAN COMPLETE')
        # Record phase and Ith for plotting
        my_file.write(str(temp_phase)+'	'+str(temp_curr)+'\n')
        print('JUST WROTE TO thresh_v_phase.txt in the temporary directory')
    d.clear()
  my_file.close()

  
  # If requested, plot Log(Ith) vs phase 
  #if (py_par['plot_phase_scan']):
    #print('Producing plot(s). To continue, exit the plots.') 
    #phase_scan.make_phase_plot(py_par)  
    

def phase_xy_scanner( py_par ):

  # Create thres_v_phase.txt in temp_dir to store the computed Ith for each phase
  my_file = open(os.path.join(py_par['temp_dir'],'thresh_v_phase_xy.txt'),'w')

  # Define dictionary t for threshold calculation
  t  = {'charge0':0,'charge1':-1,'growth_rate':0,'bunch_charge':0}
    
  # Make lat2 file with the temp_phase
  phase_scan.setup_phase_xy_scan( py_par ) 

  # Run bbu first time with the test_curr at this phase 
  find_threshold.run_bbu( py_par['threshold_start_curr'], py_par, 'phase_xy_scan' )
  d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt')) # parse the result (from Fortran to Python)
 
  t['bunch_charge'] = py_par['threshold_start_curr'] * d['bunch_dt']   
  keep_looking = 1

  # For a specific x-y phase combination, find the Ith
  while ( keep_looking ):   # Nudge stable current very close to the higher, unstable current
    t['growth_rate'] = d['growth_rate']
    bool_stable = find_threshold.get_stability(d['v_gain'], d['lostbool']) #check stability 
    find_threshold.calc_new_charge( t, bool_stable, d['rel_tol'] ) #update t based on the stability of previous trial currents
    temp_curr = t['bunch_charge'] / d['bunch_dt']    # compute the new trial current using updated t[bunch_charge]
    find_threshold.run_bbu( temp_curr, py_par, 'phase_scan' )    # Try the new guessed current
    d.clear()
    d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt'))
    if ( abs(t['charge1'] - t['charge0']) < abs(t['charge1']*d['rel_tol']) ): 
    # If the difference between min_I_unstable and max_I_stable is within the tolerance, Ith is considered found 
      keep_looking = 0 
      print('= = = = = = = = =')
      print('	STEP IN PHASE_SCAN COMPLETE')
      # Record phase (x and y) and Ith for plotting
      my_file.write(str(py_par['ONE_phase_x'])+' '+str(py_par['ONE_phase_y'])+'	'+str(temp_curr)+'\n')
      print('JUST WROTE TO thresh_v_phase_xy.txt in the temporary directory')
  d.clear()
  my_file.close()

