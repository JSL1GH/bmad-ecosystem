#!/home/cesrulib/EXT/Python-2.5.1/Linux/python
####################################################################
# This script is the front-end machinery behind initiating a
# CESR Accelerator Physics libraries release build or a CESR
# 3rd-party packages release build.
#
# Running with no arguments will output a comprehensive list of
# command-line options.
#
#---
# Example 1:
#  build_master -lin -osf -vms PKG=packages_2006_1031_d
#
# Will build a CESR libraries release for all supported Linux
# platforms
#    - Linux_i686_intel
#    - Linux_i686_lahey
# the OSF1 alpha platform
#    - OSF1_alpha_HP]
# and will (via some external utilities) package up into a .zip file
# the entire source tree and some special dependency specfication
# files needed by the build system on OpenVMS.
#
#---
# Example 2:
#  build_master -lin -osf -pkg
#
# Will build a CESR 3rd-party packages release, automatically
# generating a unique name in the same manner as above.
#
#---
# Example 3:
#  build_master -lin -osf -vms REL=<custom_release_name>
#
# Will build a CESR libraries release as in Example 1, but with a
# user-specified string as the name of the release, instead of an
# automatically-generated one.
#
#---
#
# Other variations are possible as well.
#
# Other notes:
# The VMS build depends directly on the OSF1 build for dependency
# information (the compilers are nearly identical).  Therefore,
# -vms by itself is the same as simultaneous -osf and -vms flags.
#
# This script is meant to build either a CESR libraries release, OR
# a packages release, but _not_both_ during the same execution.
#
# Author : Matt Rendina
# Date   : 17-April-2007
#
####################################################################
# Document Standout logcodes for output redirection.
####################################################################
# exit code key:
# 10  - command-line argument problem
# 15  - release specified on cmd line already exists
# 25  - kerberos error
# 30  - insufficient disk space
# 35  - no release platforms specified on cmd line
# 40  - build name not specified
# 45  - all builds failed with make errors
# 47  - all builds have stopped, but some due to failure
# 50  - svn access failed for file retrieval
# 55  - builds ceased due to timeout
# 56  - one or more builds failed, w/ summary
# 60  - tar error in Bmad distribution
# 65  - gzip error in Bmad distribution
# 70  - problem with rotation command
# 75  - problem with automatic Bmad build initiation
####################################################################
#===========================================================================
# Standard modules
#===========================================================================
import os, sys, time, string, shutil, socket, random, types, ConfigParser
import popen2             # For subprocess calls to build_serf.
import subprocess as sub  # Use this instead, try to avoid possible buffer freezes?


#============================================================================
# Set up Configuration Parser
#============================================================================
cfg_file = "/home/cesrulib/bin/util/BUILD_SYSTEM.conf"
config   = ConfigParser.ConfigParser()
config.optionxform = lambda x: x   # Obtain all values without changing case;
config.read(cfg_file)              # overrides default ConfigParser behavior


# Will need to use these env vars if SWIG python bindings are desired.
# It is probably easier to just use external process calls as they stand
# to avoid the added complexity.
#export PYTHONPATH=${PYTHONPATH}:/nfs/opt/svn/lib/svn-python
#export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/nfs/opt/svn/lib
#import svn

#=== Paths ==================================================================
bin_dir       = config.get("Paths", "BIN_DIR")
util_dir      = config.get("Paths", "UTIL_DIR")
lin_py_dir    = config.get("Paths", "LIN_PY_DIR")
osf_py_dir    = config.get("Paths", "OSF_PY_DIR")
makefile_dir  = config.get("Paths", "MAKEFILE_DIR")
libs_dir      = config.get("Paths", "LIBS_DIR")
prev_blt      = libs_dir + "/log/prev_built"      # path to file naming the last built release
prev_blt_pkg  = libs_dir + "/log/prev_built_pkg" # likewise for last build packages release
stats_dir     = config.get("Paths", "STATS_DIR")
fixes_dir     = config.get("Paths", "FIXES_DIR")

#============================================================================
# Third party module search path set up and importation
#============================================================================
sys.path.append(util_dir + "/3rd-party")
from standout import StandOut    # StandOut module is for advanced logging capabilities.

#=== Support Scripts ========================================================
master        = util_dir + '/' + config.get("Scripts", "master")
build_serf    = util_dir + '/' + config.get("Scripts", "serf")
rot_querier   = util_dir + '/' + config.get("Scripts", "rot_querier")
deleter       = util_dir + '/' + config.get("Scripts", "deleter")
rotator       = util_dir + '/' + config.get("Scripts", "rotator")


#============================================================================
#   VARIABLE SETUP
#============================================================================
hostname          = socket.gethostname()
reporter          = config.get("Scripts", "reporter")
repo_url          = config.get("Repository", "URL")
offsite_repo_url  = config.get("Repository", "UAP_URL")
platforms         = config.options("Platforms")

# These next few module lists have to be actual python lists, hence the split() call.
repo_modules      = config.get("Repository", "modules").strip().split()
bmad_dist_modules = config.get("Repository", "bmad_dist_mods").strip().split()
# Have this list pushed to the build_serf script, and the Makefile instead of manually synchronizing them?
pkg_modules       = config.get("Repository", "pkg_modules").strip().split()
#pkg_modules       = ["xerces"]
offsite_pkg_modules = config.get("Repository", "UAP_modules").strip().split()


# Automatically populate the plat_combos dictionary and initialize fields used
# for build-status checking.
avail_cmd_labels   = [] # List of available command-line arg flags, generated from platform dict.
poss_plat_combos   = {} # Dictionary of all possible platform combos direct from config file.
plat_combos        = {} # Working dictionary of platform combos constructed after cmd line is parsed.

# Error code to be mailed out if problems occur
error_analysis_code = 0 #the code used by error_analysis script to diagnose the problem


for platform in platforms:
  plat_llist = config.get("Platforms", platform).split(",")
  if plat_llist[0].strip()[:4] == "FULL" or plat_llist[0].strip()[:4] == "PREP":
    poss_plat_combos[platform]              = { "act" : plat_llist[0].strip() }  # Add Activity indicator 'act'
    poss_plat_combos[platform]['host']     = plat_llist[1].strip()               # Add Host               'host'
    poss_plat_combos[platform]['label']   = platform[:3].lower()                 # Add cmd_label          'label'
    poss_plat_combos[platform]['builder'] = "NYI"                         # Fill with 'Not Yet Initiated'
    poss_plat_combos[platform]['done'] = False                             # build-done flag
    poss_plat_combos[platform]['time'] = 0                                 # Initialize time field
    avail_cmd_labels.append( "-" + poss_plat_combos[platform]["label"] )  # Add '-augmented' cmd_label to it's own list
                                                                             # for auto-documentation purposes and to
                                                                             # allow command line inputs to be recognized.
# Dictionary structure follows the form:
#--------------------------------------------------------------------------------------
#         plat_combos = { <platform_name> : {    'act' : "FULL or PREP-<platform_name>",
#                                               'host' : <hostname>,
#                                              'label' : automatically the first three characters of <platform_name>
#                                            'builder' : To hold instance of builder class once build is initiated
#                                               'done' : "True" or "False" - Whether or not the build has stopped for whatever reason
#                                               'time' : integer used for build duration calculations  }         }

# Work out how to sync this list with the pkg build list in the M.release makefile... keeping them sync'd manually is not so hot.

statuses      = {0 : "Building", 1 : "Complete", -1 : "ERROR", 'NYI' : "Not yet initiated"}
ranks         = {0 : "Isolated", 1 : "Nightly",
                 2 : "Nightly with DEVEL attempt", 3 : "Isolated with DEVEL attempt"}

release       = ""
revision      = 0
build_release = 1              # default to building an ACC release only
bmad          = 0
bmad_build    = 0
fixes         = 0
bmad_name     = "none"
fixes_name    = "none"
custom_relflag= 0              # flag system to allow three cmd-line possibilities; pkg, rel, or both
rel_name      = "none"
build_packages= 0
custom_pkgflag= 0
pkg_name      = "none"
space_needed  = 2500000        # rough estimate 2.5 Gig needed for a (future) full build
dump          = 1              # Dump a list of all the key configuration parameters used in this script
show_status   = 1              # Flag to indicate if periodic status updates of all the remote builds will be shown during execution
nightly       = 0              # Build is a nightly.  If successful, this will delete the previously-built release.
rotate        = 0              # EXPERIMENTAL: if -rotate flag given, ATTEMPT a DEVEL rotation IF certain repository
                               #               characteristics are present. i.e. commits in critical areas in last X days.
prec          = "DBL"         # precision flag
rank          = 0
devel         = 0
tag_release   = 0
tag_packages  = 0
run_tests     = "NO"          # Whether or not a test suite will be run on the products of this build.
t_begin_master= int(time.time())




#=== Function to print usage information ===========================
def print_help():
  print ""
  print "Usage is:  build_master [options] [var. defs]"
  print ""

  print "Options:"
  print "--Platform Flags------------------------------------------------------------------"
  desc_list = []
  for platform in poss_plat_combos:
      line = "   -"+poss_plat_combos[platform]['label']+"          Check out and build an ACC release \n\
                   for all supported " + platform.split("_")[0] + " platforms."
      if line not in desc_list:
        desc_list.append(line)
  desc_list.sort()
  for line in desc_list:
    print line
  print "   -all or -a    Check out and build an ACC Libraries release for"
  print "                   ALL supported platforms."
  print "---- Others ----------------------------------------------------------------------"
  print "   -cesr         Checkout and build an ACC Libraries release [default behavior]"
  print "   -pkg          Checkout and build a 3rd-party packages release."
  print "   -bmad         Checkout and assemble a BMAD distribution .tar.gz file"
  print "   -bmad_build   Checkout, build and if successful, publish BMAD dist .tar.gz file."
  print "   -fixes        Build the libraries requested by the fixes initiation file."
  print "   -build_only   Build using previously checked-out files [Not implemented]"
  print "   -nodump       Disable display this script's configuration information."
  print "   -nobs         Suppress periodic build-status messages."
  print "   -ntly         Nightly build, rotate library links when done"
  print "   -devel        Determine if release is a DEVEL candidate and rotate if it is."
  print "   -oneshot      One-shot testing build with no prev_build indicator update."
  print "   -test         Run test jobs on all executable products and summarize results."
  print "" 
  print "Variable definitions:"
  print "   REL=<release_name>    Specify a custom release name"
  print "   PKG=<packages_name>   Specify a custom packages release name"
  print "   F90=<f90_compiler>    Specify a 3rd-party fortran compiler"
  print "   GMAKE=<gmake_dir>     Specify a custom CESR_GMAKE directory"
  print "   UTIL=<util_dir>       Specify a custom CESR_UTIL  directory"
  print "   BIN=<bin_dir>         Specify a custom CESR_BIN   directory"
  print "   FIX=<fixes_init_file> Specify the name of the fixes build init file."
  print "   <DBL/SGL>             Double or Single numeric precision [default is DBL]"
  print "   REV=<revision num>    Specify a SVN revision number to check out."
  print "                          [Default is the most recent revision]"
  print ""

#=== Function to notify about build failure by mail ===========================
def report_errors(nightly, code):
# error codes used:
# 11: build ceased / failed
# 13: build passed, but test suite failed
# 14: bmad error
# 16: other errors

  ###
  # Perform the final error check. If error code is nonzero and this is a nightly build, run error_analysis script independently
  ###
  if (code != 0 )and((nightly)or(opt == "-bmad")):
    stout.close()   # Close stream to logfile before quitting
    #Generate a web-page with the summary (log files) of all builds
    if build_type == "RELEASE":
        os.popen('/home/cesrulib/bin/util/generate_html '+rel_name) 
    os.spawnl(os.P_NOWAIT, "/home/cesrulib/bin/util/error_analysis","test", rel_name, str(code))


#=== Get Command Line Arguments and set vars =======================
for opt in sys.argv[1:]:
  if opt in ("DBL", "dbl", "Dbl"):
    prec                = "double"
    continue
  elif opt in ("SGL", "sgl", "Sgl"):
    prec                = "single"
  elif opt == "-rel":
    custom_relflag      = 1
    build_release       = 1
  elif opt == "-pkg":
    custom_pkgflag      = 1
    build_packages      = 1  # no packages builds simultaneous with release builds
  elif opt == "-bmad":
    for platform in poss_plat_combos:
      if platform.split("_")[2] == "intel":
        plat_combos[platform] = poss_plat_combos[platform]
    bmad                = 1
    build_release       = 0
    build_packages      = 0
  elif opt == "-bmad_build":
    for platform in poss_plat_combos:
      if platform.split("_")[2] == "intel":
        plat_combos[platform] = poss_plat_combos[platform]
    bmad_build          = 1
    build_release       = 0
    build_packages      = 0
  elif opt == "-fixes":
    fixes               = 1
    build_release       = 0
  elif opt == "-build_only":
    checkout            = "NO"
  elif opt == "-nodump":
    dump                = 0
  elif opt in avail_cmd_labels:        # If platform request exists on command line,
    for platform in poss_plat_combos:  # Search through all possible platforms
      if poss_plat_combos[platform]['label'] == opt[1:]:   # if platform has the cmd label
        plat_combos[platform] = poss_plat_combos[platform]  # move platform into active list
  elif opt in ("-all", "-a"):
    plat_combos = poss_plat_combos     # Copy over entire dictionary into the active one
  elif opt == "-nobs":
    show_status         = 0
  elif opt == "-ntly" or opt == "-nightly":
    nightly             = 1
    rank                = 1
  elif opt == "-devel":
    devel               = 1
    tag_release         = 1
  elif opt == "-test":
    run_tests           = "YES"
  elif opt.find("REV=") != -1:
    revision            = opt.split('=')[1]
  elif opt.find("TAG=") != -1:
    rel_tag             = opt.split('=')[1]
    print rel_tag
  elif opt.find("PKG=") != -1:
    pkg_name            = opt.split('=')[1]
    build_packages      = 1   # Tentatively set these both to 1. An existence check
    custom_pkgflag      = 1   # is performed below and may revise these values.
  elif opt.find("REL=") != -1:
    rel_name            = opt.split('=')[1]
  elif opt.find("FIX=") != -1:
    fixes_name          = opt.split('=')[1]
  elif opt.find("GMAKE=") != -1:
    makefile_area        = opt.split('=')[1]
  elif opt.find("UTIL=") != -1:
    util_dir            = opt.split('=')[1]
  elif opt.find("BIN=") != -1:
    bin_dir             = opt.split('=')[1]
  elif opt != sys.argv[0]:
    print_help()
    print "\nYou might want to check the number of command line arguments and/or their syntax.\n"
    sys.exit(10)

for platform in plat_combos:
  if os.path.exists(libs_dir + "/" + platform + "/" + pkg_name):  # if packages name already exists in any platform dir (user-spec'd),
    build_packages      = 0                                        # do NOT build packages (release only).
    custom_pkgflag      = 0                                       
    break

if custom_pkgflag and not custom_relflag:             # accomodate an isolated packages build
  build_release = 0

rquant      = len( plat_combos )
rquant_full = 0
for platform in plat_combos:
  if plat_combos[platform]['act'] == "FULL":
    rquant_full = rquant_full + 1

if rquant == 0:
  print_help()
  print "\nYou have not requested any releases to be built."
  print "Specify at least one platform flag on the command line.\n"
  sys.exit(35)

if build_release and pkg_name == "none":
  prevfile = open(prev_blt_pkg, 'r')
  pkg_name = prevfile.readline().strip()
  prevfile.close()

if nightly and devel:  # Select proper build rank for descriptive configuration summary.
  rank = 2
elif nightly:
  rank = 1
elif devel:
  rank = 3

if fixes:
  ffile = open(fixes_dir + "/control/"+ fixes_name, 'r')
  fixline = ffile.readline()
  ffile.close()
  fix_modline = fixline.strip().split(";")[0]
  fixlist     = fix_modline.strip().split(":")

if rquant > 1:
  plural = "s"
else:
  plural = ""

if os.environ['CESR_GMAKE']:
  makefile_area = os.environ['CESR_GMAKE']
else:
  print "Environment variable \'CESR_GMAKE\' not set, testing for default"
  

#===============================================================================================
#=== Set up timing apparatus ============================
TIME1      = time.clock()
TIME2      = 0
TIME_TOTAL = 0
timetuple  = time.localtime()
year       = str(timetuple[0])
if timetuple[1] < 10:                    # Clean this up with leading zeroes
  month      = '0' + str(timetuple[1])  # in original date retrieval?
else:
  month      = str(timetuple[1])
if timetuple[2] < 10:
  day        = '0' + str(timetuple[2])
else:
  day        = str(timetuple[2])
datecode   = year + '_' + month + day



#=== Generic Parameters ================================
rel_prefix    = "cesr"                                  # WAS rel_tag
pkg_prefix    = "packages"                             # WAS pkg_tag
bmad_prefix   = "bmad_dist"
fixes_prefix  = "fixes"
general_log   = ""
checkout      = 1

tagname       = ""                                      # WAS CVS_tagname
branch        = "TRUNK"
gmake_override= 0                                       # needed?
util_override = 0                                       
gmake         = "gmake"


#=====================================================================
# Global Support Function definitions
#=====================================================================

## Function to convert elapsed seconds number into Hour Minute Second values
## Returns a tuple
def seconds_to_HMS(seconds):
  hrs  = seconds / 3600
  mins = (seconds % 3600) / 60
  secs = seconds % 60
  return hrs, mins, secs


## Function to generate a unique release name
## Accepts: 'RELEASE' or 'PACKAGES' and generates an appropriate unique name.
## Clean this routine up.  Two loops not needed.  Opted to make release builds always separate from packages builds
## to simplify operation.
def get_build_name(type, initial_name):
  uniq_suffix = 0
  basename   = ""
  build_name = initial_name
  build_list    = []
  if type == "RELEASE":
    prefix = rel_prefix
  elif type == "PACKAGES":
    prefix = pkg_prefix
  elif type == "BMAD DISTRIBUTION":
    prefix = bmad_prefix
  #elif type == "FIXES":
  #  prefix = fixes_prefix

  full_logname_to_test = libs_dir + '/log/' + build_name + '.genlog'

  if build_name == "":                    # if the command line was messed up, inform and abort
    print "Build name not specified."
    sys.exit(40)
  if os.path.exists(full_logname_to_test):   # otherwise, if the RELEASE specified on cmd line already exists, quit
    print "\nA release with the name "+build_name+" already exists."
    print "Specify a different name on the command line."
    print "\nNote: If no release name is provided, a unique one guaranteed to work will be"
    print "generated automatically.\n"
    sys.exit(15)
  elif build_name == "none":             # otherwise, a name was not specified, so proceed with unique name generation
    build_already_exists = 0
    basename = prefix + '_' + datecode + '_' + prec.lower()[0]  # unadorned 1st iteration generated name
    if os.path.exists("/nfs/acc/libs/distribution/" + basename) and type == "BMAD DISTRIBUTION":
      build_already_exists = 1
      full_buildname = libs_dir +"/distribution/" + basename
    else:
      for platform in plat_combos:          # check if the name already exists in any platform area
        full_buildname = libs_dir +'/'+ platform +'/'+ basename
        if os.path.exists(full_buildname):
          build_already_exists = 1
    if build_already_exists:              # if it does, make it okay by appending a unique suffix
      while os.path.exists(full_buildname):
        uniq_suffix    = uniq_suffix + 1
        build_name     = basename + '_' + str(uniq_suffix)
        if type == "BMAD DISTRIBUTION":
          full_buildname = "/nfs/acc/libs/distribution/" + build_name
        else:
          full_buildname = libs_dir+'/'+ "Linux_i686_intel" +'/'+build_name
    else:
      build_name = basename
  return build_name


## Function to print out a summary of all the build parameters being used.
def dump_parameters():
  print "---- Common Configuration Dump ----"
  print "          -- General --"
  print "Build Type        : " + build_type
  if prec == "DBL":
    precision = "double"
  else:
    precision = "single"
  if rel_name != "none":
    print "Release name      : " + rel_name
  if pkg_name != "none":
    print "Packages name     : " + pkg_name
  print "Float Precision   : " + precision
  print "Branch            : " + branch
  print "Revision          : " + revision
  if show_status:
    show_stat = "YES"
  else:
    show_stat = "NO"
  print "Realtime status   : " + show_stat
  print "Run test suite    : " + run_tests
  print "Build rank        : " + ranks[ rank ] # See ranks dict. above for possible values.
  print "Current host      : " + hostname
  print ""
  print "           -- Paths --"
  print "ACC archive dir   : " + libs_dir
  print "Build system dir  : " + makefile_dir
  print "Util dir          : " + util_dir
  print "Scripts dir       : " + bin_dir
  print "General log file  : " + genlog
  print ""
  print "   --  Platforms and Hosts  --"
  print "      " + str(rquant) +" "+ build_type.lower() +" build"+ plural +"."
  print "   OS   Arch   (compiler)   Build Host"
  print "--------------------------------------------"
  if bmad:
    print "  N/A -- Source-only distribution"
  else:
    for platform in plat_combos:
      name_list = platform.split("_")
      print name_list[0].ljust(7), name_list[1].ljust(7), name_list[2].ljust(10), plat_combos[platform]['host']
    


#=== Class defninitions ============================================================================
#===================================================================================================

#===================================================================================================
#== This class will allow the creation of a builder object, the responsibility of which will
#== be to set up all the variables needed to initiate a build process on a remote machine.
#== This involves checking out the necessary code for either a release build, a packages build
#== or both(NO) initiating the build, monitoring it to completion or abort due to error, and
#== optionally making realtime reports of the status of the build.
#===================================================================================================
class builder:
  libs_dir_loc         = libs_dir      # global to all class instantiations
  precision            = prec
  rev                  = 0
  
  # Initialize all the relevant variables local to this class, check out the necessary code, initiate (remote) builds.
  # May not be needed if first use provides a local variable instantiation.  Check it out!
  def __init__(self, release_names, revision, build_type, pcombo, print_co, stout):
    time_1           = 0
    time_2           = 0

    ###### hopefully reduce all name vars to these:
    full_logfile     = ""     # implemented
    name             = ""
    full_name        = ""
    __param_list     = []     # implemented
    checkout         = 0
    ######
    
    rel_name         = ""
    full_rel_name    = ""
    full_rel_logfile = ""
    __rel_param_list = []
    checkout_release = 0
    
    pkg_name         = ""
    full_pkg_name    = ""        # clean these up
    full_pkg_logfile = ""
    __pkg_param_list = []
    checkout_packages= 0

    __lines           = []
    qline             = ""
    status_lsit       = []

    self.rel_name, self.pkg_name = release_names
    self.bld_name     = build_name
    self.rev          = revision
    self.platform     = pcombo
    self.OS           = pcombo.split("_")[0]
    self.f90          = pcombo.split("_")[2]

    self.base_dir     = self.libs_dir_loc + '/' + self.platform
    self.build_host   = plat_combos[pcombo]['host']
    self.build_type   = build_type

    # Force newer Python versions (2.5.1) for Linux AND OSF1
    # to allow for possible subprocess module use among other amenities.
    # Define these assignments in the config file?
    if self.platform == "OSF1_alpha_hp":
      self.build_script = osf_py_dir + '/python ' + build_serf
    else:
      self.build_script = lin_py_dir + '/python ' + build_serf

    # Set up special paths for building on a Windows machine.
    if self.platform == "Cygwin_i686_intel":
      #  use_cesr_bin = "/cygdrive/z/cesrulib/bin"
      cyg_build_dir = "/cygdrive/c/user_local/cesrulib/cesr_libs"
    print time.asctime() + " -- Checking out code for " + self.platform
    if print_co:
      sys.stdout.write("The full checkout manifest is available in the general log file.\n", 5)
      sys.stdout.write("Checkout manifest:\n", 4)   # Message Priority 4 goes ONLY to logfile
      
    #=== Variable Setup =================================
    __param_list.append("Build Type         : " + self.build_type + '\n')
    __param_list.append("Activity           : " + plat_combos[self.platform]['act'] + '\n')
    __param_list.append("Repository branch  : " + branch + '\n')
    __param_list.append("Revision           : " + str(self.rev) + '\n')
    __param_list.append("F90 Compiler       : " + self.f90 + '\n')
    __param_list.append("Platform           : " + self.platform + '\n')
    __param_list.append("Float Precision    : " + self.precision + '\n')
    __param_list.append("Link against packs : " + self.pkg_name + '\n')
    __param_list.append("Build Host         : " + self.build_host + '\n')
    __param_list.append("Build System Dir   : " + makefile_dir + '\n')
    __param_list.append("Bin dir            : " + bin_dir + '\n')
    __param_list.append("Run test suite     : " + run_tests + '\n')


    ####################################################################################
    if self.build_type == "PACKAGES":
      self.full_pkg_name = self.base_dir + '/' + self.pkg_name
      self.full_logfile   = self.libs_dir_loc + "/log/" + self.platform + '/' + self.pkg_name + ".log"
      
      __param_list.append("Full Packages name : " + self.full_pkg_name + '\n')
    
      self.plog = open(self.full_logfile, "w")
      self.plog.writelines( __param_list )
      self.plog.close()

      # Perform the actual checkout using a call to the SVN client
      for package in pkg_modules:
        loc_package = package.split('/')[-1]
        svn_cmd = "svn co "+repo_url+'/'+ \
                  branch.lower()+"/packages/"+package+'@'+str(self.rev)+' '+self.full_pkg_name+'/'+loc_package
        print "Retrieving package " + package
        svnlines = os.popen(svn_cmd).readlines()
        for line in svnlines:
          __lines.append(line)
      if print_co:
        for line in __lines:
          sys.stdout.write(line, 4)  # Message priority 4 here to send checkout list ONLY to logfile and not clutter screen
      self.lines = []

      # Check out 3rd-party files from offsite repository.
      print "Obtaining 3rd-party files from off-site repository:"
      print "  " + offsite_repo_url
      for package in offsite_pkg_modules:
        loc_package = package.split('/')[-1]
        if loc_package == "trunk":
          loc_package = "UAP"
        if loc_package == "xerces":
          loc_package = "xerces-c-src_2_7_0"
        svn_cmd = "svn co " + offsite_repo_url + package + ' ' + self.full_pkg_name + '/' + loc_package
        print "Retrieving package " + package
        svnlines = os.popen(svn_cmd).readlines()
        for line in svnlines:
          __lines.append(line)
      if print_co:
        for line in __lines:
          sys.stdout.write(line, 4)  # Message priority 4 here to send checkout list ONLY to logfile and not clutter screen
      self.lines = []       
      
      cmd = "rsh -x "+self.build_host+" \". .bash_profile; "+self.build_script+" "+ self.full_logfile +"\""
      self.PID = sub.Popen(cmd , shell=True).pid
      cmd = ""
      time.sleep(3)
      print "Spawned build process with PID : " + str(self.PID) + '\n'      

      
    ####################################################################################  
    if self.build_type == "RELEASE":
      self.full_rel_name = self.base_dir + '/' + self.rel_name
      self.full_logfile  = self.libs_dir_loc + "/log/" + self.platform + '/' + self.rel_name + ".log"
      
      __param_list.append("Full Release name  : " + self.full_rel_name + '\n')
      __param_list.append("Config Dir         : " + self.full_rel_name + "/config\n")
      __param_list.append("--> BUILD STATUS: HANDING CONTROL TO REMOTE SUBSCRIPT\n")
      
      self.rlog = open(self.full_logfile, "w")
      self.rlog.writelines( __param_list )
      self.rlog.close()

      # Perform the actual checkout using a call to the SVN client
      for module in repo_modules:
        #print "Retrieving module " + module
        svn_cmd = "svn co "+repo_url+'/'+branch.lower()+'/'+module+"@"+str(self.rev)+' '+self.full_rel_name+'/'+module 
        svnlines = os.popen(svn_cmd).readlines()
        for line in svnlines:
          __lines.append(line)
      if print_co:
        for line in __lines:
          sys.stdout.write(line, 4)    # Message priority 4 here to send checkout list ONLY to logfile and not clutter screen
      self.lines = []
      ## REMOTE EXECUTION of build process
      cmd = "rsh -x "+self.build_host+" \". .bash_profile; "+self.build_script+" "+ self.full_logfile +"\""
      self.PID = sub.Popen(cmd , shell=True).pid
      cmd = ""
      time.sleep(3)
      print time.asctime() + " -- Spawned build process with PID : " + str(self.PID) + '\n'
      
      
    #####################################################################################
    if self.build_type == "FIXES":
      #self.full_rel_name = self.base_dir + '/' + self.rel_name
      #self.base_dir     = self.libs_dir_loc + "/fixes/staging"
      self.base_dir     = fixes_dir + "/staging"
      self.full_rel_name = self.base_dir + '/' + self.platform
      self.full_logfile  = self.libs_dir_loc + "/log/" + self.platform + '/' + self.rel_name + ".log"
      
      __param_list.append("Full Release name  : " + self.full_rel_name + '\n')
      self.aline = "Modules to build   :"
      for module in fixlist:
        self.aline = self.aline + " " + module
      self.aline = self.aline + '\n'
      __param_list.append(self.aline)
      __param_list.append("--> BUILD STATUS: HANDING CONTROL TO REMOTE SUBSCRIPT\n")

      self.rlog = open(self.full_logfile, "w")
      self.rlog.writelines( __param_list )
      self.rlog.close()

      print "FIXLIST"
      print fixlist
      for module in fixlist:
        module = module.strip()
        print "Retrieving module " + module
        svn_cmd = "svn co "+repo_url+'/'+branch.lower()+"/src/"+module+"@"+str(self.rev)+' '+self.full_rel_name+'/'+module 
        svnlines = os.popen(svn_cmd).readlines()
        for line in svnlines:
          __lines.append(line)
      if print_co:
        for line in __lines:
          sys.stdout.write(line, 4)    # Message priority 4 here to send checkout list ONLY to logfile and not clutter screen
      self.lines = []
      ## REMOTE EXECUTION of build process
      cmd = "rsh -x "+self.build_host+" \". .bash_profile; "+self.build_script+" "+ self.full_logfile +"\""
      self.PID = sub.Popen(cmd , shell=True).pid
      cmd = ""
      time.sleep(3)
      print time.asctime() + " -- Spawned build process with PID : " + str(self.PID) + '\n'
      
      
    #####################################################################################  
    if self.build_type == "BMAD DISTRIBUTION":
      print "Check out code for bmad distribution\n"

      self.base_dir = "/home/cesrulib/distribution"
      self.full_rel_name    = self.base_dir + '/' + self.rel_name
      self.full_logfile = self.base_dir + "/log/" + self.rel_name + ".log"

      __param_list.append("Full Release name  : " + self.full_rel_name + '\n')
      __param_list.append("Config Dir         : " + self.full_rel_name + "/config\n")
      __param_list.append("--> BUILD STATUS: HANDING CONTROL TO REMOTE SUBSCRIPT\n")

      self.rlog = open(self.full_logfile, "w")
      self.rlog.writelines( __param_list )
      self.rlog.close()

      # Perform the actual checkout using a call to the SVN client
      os.mkdir(self.full_rel_name)
      os.chdir(self.full_rel_name)
      for module in bmad_dist_modules:
        print "Retrieving module " + module
        svn_cmd = "svn co "+repo_url+'/'+branch.lower()+'/'+module+"@"+str(self.rev)
 
        svnlines = os.popen(svn_cmd).readlines()
        for line in svnlines:
          __lines.append(line)
      if print_co:
        for line in __lines:
          sys.stdout.write(line, 4)    # Message priority 4 here to send checkout list ONLY to log file and not clutter screen
      self.lines = []

      # Copy the bmad distribution environment setup scripts
      os.mkdir(self.full_rel_name + "/bin")
      shutil.copy(util_dir + "/bmadenv", self.full_rel_name + "/bin")
      shutil.copy(util_dir + "/bmad_def", self.full_rel_name + "/bin")
      shutil.copy(util_dir + "/bmad_defs", self.full_rel_name + "/bin")
      print "Environment scripts copied to distribution bin directory."
      
      ## Create the distribution source tarball
      print "\nCreating distribution tarball..."
      os.chdir(self.base_dir) # possibly not needed.
      print "Current dir: " + os.getcwd()
      tar_cmd_list = ["tar", "-cvf", self.rel_name+".tar", "./"+self.rel_name]
      t            = sub.Popen(tar_cmd_list, cwd=self.base_dir, stdout=sub.PIPE, stderr=sub.STDOUT)
      lines        = t.stdout.readlines()
      for line in lines:
        #print line.strip()
        sys.stdout.write(line, 4)   # Only to log file
      pid = t.pid      
      t_rcode = t.wait()
      print "TAR operation completed successfully."
      if t_rcode != 0:
        print "ERROR during TAR operation!  Status: " + str(t_rcode) + " Quitting."
        sys.exit(60)
        
      print "Compressing tar file..."
      gzip_cmd_list = ["gzip", "-v", self.full_rel_name+".tar"]
      t       = sub.Popen(gzip_cmd_list, cwd=self.base_dir)
      t_rcode = t.wait()
      print "GZIP operation completed successfully."
      if t_rcode != 0:
        print "ERROR during gzip operation!  Status: " + str(t_rcode) + " Quitting.\n"
        sys.exit(65)
        

      ## REMOTE-EXECUTE build process
      if bmad_build:
        print "Spawning build process..."
        cmd = "rsh -x "+self.build_host+" \". .bash_profile; "+self.build_script+" "+ self.full_logfile +"\""
        self.PID = sub.Popen(cmd , shell=True).pid
        cmd = ""
        time.sleep(3)
        print time.asctime() + " -- Spawned build process with PID : " + str(self.PID) + '\n'


  ############################################

  def status(self):    ## return the value of the most recently-stamped status message in logfile passed to this method
    build_status = 0
    file_to_check = self.full_logfile
      
    self.lq = open(file_to_check, "r")
    self.qline = self.lq.readline()
    self.status_list = []
    while self.qline:
      if self.qline.find("BUILD STATUS:") != -1:
        self.qline = self.qline.strip()
        self.status_list.append(self.qline)
      self.qline = self.lq.readline()
      
    self.lq.close()

    if len(self.status_list) != 0:  # Allow this to continue checking gracefully in case the log file(s)
      if self.status_list[-1].find("ERROR") != -1:  # -are not populated yet.
        build_status = -1                                # any errors give return value of -1
      elif self.status_list[-1].find("COMPLETE") != -1:
        build_status = 1                                 # code 1 means complete with no errors
      self.status_list = []
    return build_status                                    # still building will return value of 0


    
#======================================================================================================================  
#======================================================================================================================
# Main Script Starts Here
#======================================================================================================================

if build_release:
  build_type  = "RELEASE"
  build_name  = get_build_name(build_type, rel_name)
  rel_name    = build_name
  release_names = (rel_name, pkg_name)
elif build_packages:
  build_type  = "PACKAGES"
  build_name  = get_build_name(build_type, pkg_name)
  pkg_name    = build_name
  release_names = (rel_name, pkg_name)
elif bmad or bmad_build:
  build_type  = "BMAD DISTRIBUTION"
  build_name  = get_build_name(build_type, bmad_name)
  rel_name    = build_name
  release_names = (rel_name, "")
elif fixes:
  build_type  = "FIXES"
  #build_name  = get_build_name(build_type, fixes_name)
  build_name  = fixes_name
  rel_name    = fixes_prefix + "_" + fixes_name.replace("_BUILDING","")
  release_names = (rel_name, "")
  
genlog      = build_name + ".genlog"
#genlog      = rel_name + ".genlog"
full_genlog = libs_dir + "/log/" + genlog


stout = StandOut(full_genlog, unbuffered=True)   # This transparently applies to all print stmnts and directs all the printed output of
                                   # this program to stdout AND to the general log file defined above.  Set verbosity here?
                                   # Default priority for all messages is _5_.
stout.outThreshold        = 5      # These logging threshold values are used to selectively direct normal output of this
stout.outLogfileThreshold = 4      # script to any combination of the screen or general logfile


#== Request KRB credentials so remote-shell calls work later ==============
(krbout, krbin) = popen2.popen4("kinit -k -t /etc/cesrulib-keytab cesrulib/" + hostname)
krblines = krbout.readlines()
for line in krblines:
  print line
  if line[0:5] == "kinit":
    print "Problem obtaining Kerberos 5 credentials, terminating."
    print "Verify that your current shell is a login shell.\n"
    sys.exit(25)


#== Determine which revision to check out, default is most recent ==
if revision == 0:
  infolist = os.popen("svn info "+repo_url).readlines()       # adjust here for getting stderr as well
  for line in infolist:
    if line.find("Revision") != -1:
      revision = line.split(':')[1].strip()
    elif line.find("failed") != -1:
      print "SVN repository access failed!  Quitting."
      report_errors(nightly, 16) #since we're about to exit, need to notify about the errors
      sys.exit(50)


#== Print out all the configuration information collected or derived up to this point ===
print ""
print time.asctime()
if dump:
  dump_parameters()
print ""


#== Check available disk space ========
spaceline    = os.popen("df " + libs_dir).readlines()[1]
space_free   = int(spaceline.split()[3])            # Bytes free
if space_free <= space_needed:
  print "Insufficient disk space in " + libs_dir + "!"
  print "Disk free space = %i" % space_free
  print "Space required  = %i" % space_needed
  report_errors(nightly, 16) #since we're about to exit, need to notify about the errors
  sys.exit(30)


#== Instantiate a builder object for each process that needs to be initiated
#== a total of rquant builds will be executed.
#== This starts the build processes on their respective hosts.

print_co = True      # allows only the first build initiated to print its checkout list, preventing redundancy of output
for platform in plat_combos:
  if plat_combos[platform]['act'] == "FULL":
    plat_combos[platform]['builder'] = builder(release_names, revision, build_type, platform, print_co, stout)
    plat_combos[platform]['time'] = time.time()  # Set start timestamp
    print_co = False

    
loop             = 0
max_loops        = 450
complete_fraction= 0.0
complete_tally   = 0
error_fraction   = 0.0
error_tally      = 0
failure          = 0

####
if not bmad:
  print "Waiting for builds to fully initiate."
  time.sleep(60)       # Long wait here to allow OSF1 builds to eventually dump the output of the
  if not show_status:  # gmake call to a file for status parsing. Buffer clearing is slow or something.
    print "Builds initiated.  Status output suppressed.  This will take a while.\n"
    
####
stout.outThreshold        = 4      # Swap stdout and logfile thresholds to allow for writing
stout.outLogfileThreshold = 5      # build-status messages to the screen and not to logfile.
stout.priority            = 4

while complete_fraction < 1 and loop < max_loops: 
  error_fraction    = 0.0
  # Skip all the status printing if this is just a bmad checkout & archival
  if bmad:
    break
  
  if show_status:
    t_cur_master = int(time.time())
    print "\n\nBuild status info:   (loop " + str(loop) + ")"
    print "  %i hr %i min %i sec elapsed" % seconds_to_HMS(t_cur_master - t_begin_master)
    print "----------------------------------------"

  for platform in plat_combos:
    done   = plat_combos[platform]['done']

    if not done:
      # Grab status appropriately depending on whether the builder object for the given platform
      # has been spawned already or not.
      if type( plat_combos[platform]['builder'] ) == types.InstanceType:
        Status = plat_combos[platform]['builder'].status()    # -1 = ERROR :: 0 = building :: 1 = success
      else:
        Status = plat_combos[platform]['builder']

      # if this platform has a dependency, note it and build if dep's build is complete
      if plat_combos[platform]['act'][:4] == "PREP":
        depends_upon = plat_combos[platform]['act'].split('-')[1].strip()
        if plat_combos[depends_upon]['builder'].status() == 1:
          plat_combos[platform]['builder'] = builder(release_names, revision, build_type, platform, print_co, stout)
          plat_combos[platform]['time'] = time.time()  # Set start timestamp
          # Alter PREP string in the platform's 'act' field to prevent multiple initiations
          plat_combos[platform]['act'] = "Building-->" + plat_combos[platform]['act']
        elif plat_combos[depends_upon]['builder'].status() == -1:
          error_tally = error_tally + 1
          plat_combos[platform]['done'] = True
          plat_combos[platform]['time'] = time.time() - plat_combos[platform]['time'] # Calculate elapsed time and store

      if Status == 1:                                   # Completed successfully
        complete_tally = complete_tally + 1
        plat_combos[platform]['done'] = True
        plat_combos[platform]['time'] = time.time() - plat_combos[platform]['time']

      if Status == -1:                                  # Stopped with error(s)
        error_tally = error_tally + 1
        plat_combos[platform]['done'] = True
        plat_combos[platform]['time'] = time.time() - plat_combos[platform]['time']
      
    if show_status:
      if type( plat_combos[platform]['builder'] ) == types.InstanceType:
        Status = plat_combos[platform]['builder'].status() # -1 = ERROR :: 0 = building :: 1 = success
        print platform.ljust(16), ":", str(Status), " ", statuses[Status]
      else:
        Status = plat_combos[platform]['builder']
        print platform.ljust(16), ":", str(Status)


  complete_fraction = complete_tally / float(rquant)
  error_fraction    = error_tally / float(rquant)

  #if complete_fraction == 1.0:
  if complete_tally == rquant:
    print "\n" + time.asctime() + " All Builds completed successfully.\n"
    successful_build = 1
    break

  #if error_fraction == 1.0:
  if error_tally    == rquant:
    print "All builds have failed.  Stopping."
    failure = 1

  if (complete_tally > 0 and error_tally > 0) and (complete_tally + error_tally == rquant):
    print "All builds have ceased, with some due to failure."
    failure = 1

  if (loop == max_loops):
    print "One or more builds have ceased due to timeout!"
    failure = 1

  if failure:
    print "Summary:"
    for platform in plat_combos:
      if type( plat_combos[platform]['builder'] ) == types.InstanceType:
        Status = plat_combos[platform]['builder'].status()  # -1 = ERROR :: 0 = building :: 1 = success
        print platform + " : " + statuses[ Status ]
      else:
        Status = plat_combos[platform]['builder']
        print platform + " : " + Status
    report_errors(nightly, 11) #since we're about to exit, need to notify about the errors
    sys.exit(56)
  
  if loop < 10:
    time.sleep(5)
  else:
    time.sleep(30)
    
  loop = loop + 1
##  
##End while loop [ while complete_fraction < 1 and loop < max_loops: ]
##


###########################################
stout.outThreshold        = 5      # Swap stdout and logfile thresholds again to return everything
stout.outLogfileThreshold = 4      # to the initially set up state.
stout.priority            = 5      # Set priority back to default value.


t_end_master = int(time.time())

##== Build has completed successfully, compute and summarize relevant statistics ====================================
print "          ======== Statistics for this build process ========"
print "============================ Time summary: ==============================="
print "         Overall:     %i hr %i min %i sec elapsed" % seconds_to_HMS(t_end_master - t_begin_master)
for platform in plat_combos:
  print platform + " build : %i hr %i min %i sec" % seconds_to_HMS( plat_combos[platform]['time'] )

if build_type != "FIXES":
  lines = os.popen(util_dir + "/rel_disk_total " + rel_name).readlines()
  for line in lines:
    print line.strip()
#else:
#  print "Disk utilization summary for packages builds has not yet been implemented."

if build_type == "RELEASE" and run_tests == "YES":
  print "=========================  Test Suite Summary  ==========================="
  for platform in plat_combos:
    if plat_combos[platform]['act'] == "FULL":
      print "Testing summary for " + platform
      logfile = libs_dir + '/log/'+ platform + '/' + rel_name + '.log'
      lines = os.popen(util_dir + "/extract_test_summary " + logfile + " " + platform ).readlines()
      for line in lines:
        print line.strip()
        if line.find("FAILED!") != -1 :
            error_analysis_code = 13
      print ""

print "=========================================================================="
print "          =============  End Statistics Summary =============\n"


  
#========================================================================
# If a devel attempt was requested, determine if this newly-built release
# is a candidate for promotion to DEVEL.
#========================================================================
defer          = False
recommendation = 9
if devel:
  print "\nChecking to see if this release is a DEVEL candidate."
  qr = sub.Popen( [rot_querier, "-r", rel_name], stdout=sub.PIPE, stderr=sub.STDOUT )
  (outstream, errstream) = qr.communicate()
  recommendation = qr.wait()
  print str(outstream)

#  if recommendation == 0:  # If there has been a recommendation to rotate rot_querier exit code.
#    print "TESTING fixes auto-rotation system.  Rotation REQUESTED.  Overridden."
#    recommendation = 8

  if recommendation == 0:
    # Calculate deferral times
    cur_hourval = int( time.asctime().split()[3].split(":")[0] )
    def_hourval = 8
    def_hourstr = str( def_hourval )
    minuteval   = random.randint(0,59)
    min_str     = str( minuteval )
    if minuteval < 10:
      min_str = "0" + min_str

    if cur_hourval < 8: # If current time is before 8am and hence this
      defer  = True     # was cron-initiated, use deferrals. Otherwise,
    else:               # execute subtasks immediately in sequence.
      defer  = False

    if defer:
      #= Schedule this release to be promoted to DEVEL status.
      print "sched. time:", def_hourstr, min_str
      tmpname = "/tmp/tmp_atfile_01"
      atfile  = open(tmpname, 'w')
      atfile.write(rotator + " -devel -tag -mail " + rel_name)
      atfile.close()
      at = sub.Popen( ["at", def_hourstr + ':' + min_str, "-f", tmpname], stdout=sub.PIPE, stderr=sub.STDOUT )
      (outstream, errstream) = at.communicate()
      atval = at.wait()
      os.remove(tmpname)
      if atval == 0:
        print "Will rotate release : " + str(outstream)
      else:
        print str(outstream)
        print "ERROR: There was a problem with the rotation initiation."
        report_errors(nightly, 16) #since we're about to exit, need to notify about the errors
        sys.exit(70)
      
      #= Schedule a Bmad distribution build and rotation.
      if minuteval != 59:
        minuteval = minuteval + 1
      else:
        minuteval = 0
        def_hourval = def_hourval + 1
      if minuteval < 10:
        min_str   = str( minuteval )
        min_str = "0" + min_str


      print "sched. time:", def_hourstr, min_str
      tmpname   = "/tmp/tmp_atfile_02"
      atfile    = open(tmpname, 'w')
      atfile.write(master + " -nobs -bmad_build REV="+ revision) # Call master script again
      atfile.close()
      at = sub.Popen( ["at", def_hourstr + ':' + min_str, "-f", tmpname], stdout=sub.PIPE, stderr=sub.STDOUT )
      (outstream, errstream) = at.communicate()
      atval = at.wait()
      os.remove(tmpname)
      if atval == 0:
        print "Will produce a Bmad distribution : " + str(outstream)
      else:
        print str(outstream)
        print "ERROR: There was a problem with the Bmad dist. initiation."
        report_errors(nightly, 14) #since we're about to exit, need to notify about the errors
        sys.exit(75)
#==============================================================================
#== Check to see if this release is a current candidate
#==============================================================================
if build_type == "RELEASE":
  if (not os.system(util_dir+"/query_current_rotation")):
    print "Rotating this release into DEVEL.."
    lines = os.popen(util_dir+"/rotate_release -mail -tag "+rel_name)
    for line in lines:
      print line.strip()
    print "Proceeding with rotating latest devel to CURRENT.."
    lines = os.popen(util_dir+"/rotate_release -current -mail -tag "+os.readlink("/home/cesrulib/cesr_libs/Linux_i686_intel/devel")).readlines()
    for line in lines:
      print line.strip()
    print "Rotation successful"


#==============================================================================
#== If this was a nightly build, rotate into position and delete the previous.
#==============================================================================
if nightly and build_type == "RELEASE":
  print "This is a nightly build, proceeding with replacement of previous nightly."
  lines = os.popen(util_dir + "/rotate_release -nightly " + rel_name).readlines()
  for line in lines:
    print line.strip()
  print "Rotation successful"
  #== If everything has completed successfully so far, delete previous build, as long as it hasn't
  #== been promoted.
  prevfile = open(prev_blt, 'r')
  previously_built = prevfile.readline().strip()
  prevfile.close()
  dr = sub.Popen( [deleter, "-QUIET", "REL="+previously_built], stdout=sub.PIPE, stderr=sub.STDOUT )
  (outstream, errstream) = dr.communicate()
  del_exit = dr.wait()
  print str(outstream)
  if del_exit != 0:
    print "Previously-built release not deleted."
  os.chmod(prev_blt, 0644)         # set permissions to writable
  prevfile = open(prev_blt, 'w')
  prevfile.write(rel_name + '\n')      # write the name of the release just built to file
  prevfile.close()
  os.chmod(prev_blt, 0444)         # reset permissions to disallow writes

if build_type == "PACKAGES":
  print "Updating previously-built packages indicator."
  os.chmod(prev_blt_pkg, 0644)           # set permissions to writable
  prevfile = open(prev_blt_pkg, 'w')
  prevfile.write(pkg_name + '\n')   # write the name of the packages release just built to file
  prevfile.close()
  os.chmod(prev_blt_pkg, 0444)       # reset permissions to disallow writes

if bmad_build:
  print "Rotating Bmad distribution archive file into position."
  rot = sub.Popen( [rotator, "-bmad", rel_name], stdout=sub.PIPE, stderr=sub.STDOUT )
  (outstream, errstream) = rot.communicate()
  exitval = rot.wait()
  print str(outstream)
  

#==================================================
#   Generate repository statistics reports
#==================================================
#if not fixes:
#  print "Generating and publishing HTML repository statistics reports:"
#  sr = sub.Popen([util_dir + "/" + reporter, "src"], stdout=sub.PIPE, stderr=sub.STDOUT )
#  (outstream, errstream) = sr.communicate()
#  sr_exit = sr.wait()
#  print str(outstream)
#  if sr_exit != 0:
#    print "ERROR:  There was a problem generating the repository statistics reports."
#    error_msg = error_msg + "ERROR:  There was a problem generating the repository statistics reports.\n"
if not fixes:
    print "Starting a remote, independent HTML repository statistics report.."
    os.spawnl(os.P_NOWAIT,util_dir + "/"+reporter+" > /home/cesrulib/output.dat","src")

print "\n================== Build process finished completely. ====================\n"

if recommendation == 0 and not defer:             
  print "Starting sequential rotation and build processes"
  print "as per rotation recommendation."
  os.execv( rotator, ["-devel", "-tag", "-mail", rel_name] )
  os.execv( master, ["-bmad_build"] )


stout.close()   # Close stream to logfile before quitting

## final error reporting via mail
report_errors(nightly, error_analysis_code)
##

###
#Generate a web-page with the summary (log files) of all builds
###
if build_type == "RELEASE":
  os.popen('/home/cesrulib/bin/util/generate_html '+rel_name)
### 

###
#Write the trigger file to the shared VMS directory to start the VMS build process
###
#if build_type == "RELEASE":
#  os.popen('/home/cesrulib/bin/util/write_trigger_file '+rel_name)
###
sys.exit(0)
