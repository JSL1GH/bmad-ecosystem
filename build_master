#!/home/cesrulib/EXT/Python-2.5.1/Linux/python
####################################################################
# This script is the front-end machinery behind initiating a
# CESR Accelerator Physics libraries release build or a CESR
# 3rd-party packages release build.
#
# Running with no arguments will output a comprehensive list of
# command-line options.
#
#---
# Example 1:
#  build_master -lnx -osf -vms PKG=packages_2006_1031_d
#
# Will build a CESR libraries release for all supported Linux
# platforms
#    - Linux_i686_intel
#    - Linux_i686_lahey
# the OSF1 alpha platform
#    - OSF1_alpha_HP]
# and will (via some external utilities) package up into a .zip file
# the entire source tree and some special dependency specfication
# files needed by the build system on OpenVMS.
#
#---
# Example 2:
#  build_master -lnx -osf -pkg
#
# Will build a CESR 3rd-party packages release, automatically
# generating a unique name in the same manner as above.
#
#---
# Example 3:
#  build_master -lnx -osf -vms REL=<custom_release_name>
#
# Will build a CESR libraries release as in Example 1, but with a
# user-specified string as the name of the release, instead of an
# automatically-generated one.
#
#---
#
# Other variations are possible as well.
#
# Other notes:
# The VMS build depends directly on the OSF1 build for dependency
# information (the compilers are nearly identical).  Therefore,
# -vms by itself is the same as simultaneous -osf and -vms flags.
#
# This script is meant to build either a CESR libraries release, OR
# a packages release, but _not_both_ during the same execution.
#
# Author : Matt Rendina
# Date   : 17-April-2007
#
####################################################################
# Document Standout logcodes for output redirection.
####################################################################
# exit code key:
# 10  - command-line argument problem
# 15  - release specified on cmd line already exists
# 25  - kerberos error
# 30  - insufficient disk space
# 35  - no release platforms specified on cmd line
# 40  - build name not specified
# 45  - all builds failed with make errors
# 47  - all builds have stopped, but some due to failure
# 50  - svn access failed for file retrieval
# 55  - builds ceased due to timeout
# 60  - TAR ERROR in BMAD DISTRIBUTION
# 65  - gzip ERROR in BMAD DISTRIBUTION
####################################################################

# Standard modules
import os
import sys
import time
import string
import shutil
import socket
import popen2  # For subprocess calls to build_serf.
import subprocess as sub  # Use this instead, try to avoid possible buffer freezes?

# Will need to use these env vars if SWIG python bindings are desired.
# It is probably easier to just use external process calls as they stand, to
# avoid the added complexity of needing the bindings installed and maintained by the CG.
#export PYTHONPATH=${PYTHONPATH}:/nfs/opt/svn/lib/svn-python
#export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/nfs/opt/svn/lib
#import svn                        # are SWIG bindings availabile from this node? looks as if they are, how to use?

# 3rd party modules              (PUT these in the same directory for the time-being.
from standout import StandOut  # figure out where to consolidate all 3rd party modules later)
                               # standout module for logging capabilities

#========= VARIABLE SETUP ==========================================
#===================================================================
#== Node names =========================================
osf_host      = "cesrbuild2.lepp.cornell.edu"
lnx_host      = "lnx209.lepp.cornell.edu"
vms_host      = "cesrbuild1.lepp.cornell.edu"
win_host      = "pc6115.lepp.cornell.edu"
hostname      = socket.gethostname()

platform_combos = { "linuxi": ["Linux_i686",      'intel', lnx_host ],
                    "linuxl": ["Linux_i686",      'lahey', lnx_host ],
                    "osfhp":  ["OSF1_alpha",      'hp',     osf_host ],
                    "vmshp":  ["VMS_alpha" ,      'hp',     vms_host ],
                    "win":    ["CYGWIN_NT_i686", 'intel', win_host ] }

# Local lab repository
repo_loc          = "https://accserv.lepp.cornell.edu/svn/"
# For UAP project kept on Sourceforge.net
offsite_repo_loc  = "https://accelerator-ml.svn.sourceforge.net/svnroot/accelerator-ml/uap/" 

repo_modules      = ["util", "Gmake", "src"]
bmad_dist_modules = ["util", "Gmake", "documents", "src/include", "src/bmad", "src/dcslib",
                       "src/recipes_f-90_LEPP", "src/cesr_utils", "packages/forest",
                       "packages/PGPLOT", "packages/xsif", "examples/twiss_track_test", #change ttt soon?
                       "src/bmadz", "src/toad", "src/tao", "src/bsim", "src/ilcv"]

# Have this list pushed to the build_serf script, and the Makefile instead of manually synchronizing them?
pkg_modules   = ["cfortran", "forest", "num_recipes/recipes_f-90", "num_recipes/recipes_c-ansi", \
                 "xsif", "PGPLOT", "xerces"]
pkg_modules   = ["xerces"]
offsite_pkg_modules = ["trunk"]

# Work out how to sync this list with the pkg build list in the M.release makefile... keeping them sync'd manually is not so hot.

statuses      = {0 : "Building", 1 : "Complete", -1 : "ERROR"}
ranks         = {0 : "Isolated", 1 : "Nightly",
                 2 : "Nightly with DEVEL attempt", 3 : "Isolated with DEVEL attempt"}

release       = ""
revision      = 0
build_release = 1              # default to building a CESR release only
bmad          = 0
bmad_build    = 0
bmad_name     = "none"
custom_relflag= 0              # flag system to allow three cmd-line possibilities; pkg, rel, or both
rel_name      = "none"
build_packages= 0
custom_pkgflag= 0
pkg_name      = "none"
space_needed  = 2500000        # rough estimate 2.5 Gig needed for a (future) full build
lnx           = 0              # flags to indicate which OSs are meant to host this build 
osf           = 0              # |
vms           = 0              # |
win           = 0              # |
dump          = 1              # Dump a list of all the key configuration parameters used in this script
show_status   = 1              # Flag to indicate if periodic status updates of all the remote builds will be shown during execution
nightly       = 0              # Build is a nightly.  If successful, this will delete the previously-built release.
rotate        = 0              # EXPERIMENTAL: if -rotate flag given, ATTEMPT a DEVEL rotation IF certain repository
                               #               characteristics are present. i.e. commits in critical areas in last X days.
prec          = "DBL"         # precision flag
rank          = 0
devel         = 0
tag_release   = 0
tag_packages  = 0
run_tests     = "NO"          # Whether or not a test suite will be run on the products of this build.
t_begin_master= int(time.time())

#=== Paths =========================================================
bin_dir       = "/home/cesrulib/bin"
osf_py_dir    = "/home/cesrulib/EXT/Python-2.5.1/OSF1"
lin_py_dir    = "/home/cesrulib/EXT/Python-2.5.1/Linux"
build_sys_dir = bin_dir + "/Gmake"
util_dir      = bin_dir + "/util"
libs_dir      = "/nfs/acc/libs"
prev_blt      = libs_dir + "/log/prev_built"           # path to file logging last built release
prev_blt_pkg  = libs_dir + "/log/prev_built_pkg"
build_serf    = util_dir + "/build_serf"

#=== Function to print usage information ===========================
def print_help():
  print ""
  print "Usage is:  build_master [options] [var. defs]"
  print ""

  print "Options:"
  print "--Platform Flags--"
  print "   -lnx          Check out and build an ACC Libraries release"
  print "                 for all supported Linux platforms."
  print "   -osf          Check out and build an ACC Libraries release"
  print "                 for the OSF1 platform."
  print "   -vms          Generate VMS dependency files, package up and "
  print "                 deliver source tree to VMS cluster. (Automatically selects -osf)"
  print "   -win          Check out and build an ACC Libraries release"
  print "                 for the Windows platform. [Not yet operational]"
  print "----- Others -----"
  print "   -cesr         Checkout and build an ACC Libraries release [default behavior]"
  print "   -pkg          Checkout and build a 3rd-party packages release"
  print "   -bmad         Checkout and produce a BMAD distribution .tar.gz file"
  print "   -bmad_build   Checkout, build, and if successful, produce a BMAD distribution .tar.gz file."
  print "   -build_only   Build using previously checked-out files [Not implemented]"
  print "   -nodump       Do not display this script's configuration information. [default is display]"
  print "   -nobs         Suppress periodic build-status messages."
  print "   -ntly         Nightly build, rotate library links when done"
  print "   -devel        Determine if release is a DEVEL candidate, rotate if it passes the check."
  print "   -oneshot      Run a one-shot testing build with no prev_build indicator update."
  print "   -test         Run test jobs on all executable build products and summarize the results."
  print "" 
  print "Variable definitions:"

  print "   REL=<release_name>    Specify a custom release name"
  print "   PKG=<packages_name>   Specify a custom packages release name"
  print "   F90=<f90_compiler>    Specify a 3rd-party fortran compiler"
  print "   GMAKE=<gmake_dir>     Specify a custom CESR_GMAKE directory"
  print "   UTIL=<util_dir>       Specify a custom CESR_UTIL  directory"
  print "   BIN=<bin_dir>         Specify a custom CESR_BIN   directory"
  print "   <DBL/SGL>             Double or Single numeric precision [default is DBL]"
  print "   REV=<revision num>    Specify a SVN revision number to check out."
  print "                          [Default is the most recent revision]"
  print ""
  #print "   PATH =  $PATH "

#=== Get Command Line Arguments and set vars =======================
for opt in sys.argv:
  if opt in ("DBL", "dbl", "Dbl"):
    prec                = "double"
    continue
  elif opt in ("SGL", "sgl", "Sgl"):
    prec                = "single"
  elif opt == "-rel":
    custom_relflag      = 1
    build_release       = 1
  elif opt == "-pkg":
    custom_pkgflag      = 1
    build_packages      = 1  # no packages builds simultaneous with release builds
  elif opt == "-bmad":
    bmad                = 1
    build_release       = 0
    build_packages      = 0
  elif opt == "-bmad_build":
    bmad_build          = 1
    build_release       = 0
    build_packages      = 0
  elif opt == "-build_only":
    checkout            = "NO"
  elif opt == "-nodump":
    dump                = 0
  elif opt == "-osf":
    osf                 = 1
  elif opt == "-lnx":
    lnx                 = 1
  elif opt == "-vms":
    vms                 = 1
    osf                 = 1
  elif opt == "-win":
    win                 = 1
  elif opt == "-nobs":
    show_status         = 0
  elif opt == "-ntly" or opt == "-nightly":
    nightly             = 1
    rank                = 1
  elif opt == "-devel":
    devel               = 1
    tag_release         = 1
  elif opt == "-test":
    run_tests           = "YES"
  elif opt.find("REV=") != -1:
    revision            = opt.split('=')[1]
  elif opt.find("TAG=") != -1:
    rel_tag             = opt.split('=')[1]
    print rel_tag
  elif opt.find("PKG=") != -1:
    pkg_name            = opt.split('=')[1]
    if os.path.exists(libs_dir + "/Linux_i686_intel/" + pkg_name):   # if packages name specified, AND it already exists,
      #print "Pack exists!"                                              # build a requested release and LINK to the packages.
      build_packages      = 0                                            # Check in Linux(intel) area first, change this to be
      custom_pkgflag      = 0
    else:                                                                # more general later.  If only PKG option is used
      build_packages      = 1                                            # AND the packages already exist, initiate a RELEASE
      custom_pkgflag      = 1                                            # build and link aginst the packages specified.
  elif opt.find("REL=") != -1:
    rel_name            = opt.split('=')[1]
  elif opt.find("GMAKE=") != -1:
    bld_sys_area        = opt.split('=')[1]
  elif opt.find("UTIL=") != -1:
    util_dir            = opt.split('=')[1]
  elif opt.find("BIN=") != -1:
    bin_dir             = opt.split('=')[1]
  elif opt != sys.argv[0]:
    print_help()
    print "\nYou might want to check the number of command line arguments and their syntax.\n"
    sys.exit(10)

if custom_pkgflag and not custom_relflag:             # accomodate an isolated packages build
  build_release = 0
rquant = lnx*2 + osf + vms + win + bmad + bmad_build  # tally of releases to build
if rquant == 0:
  print_help()
  print "\nYou have not requested any releases to be built."
  print "Specify at least one platform flag on the command line.\n"
  sys.exit(35)

if build_release and pkg_name == "none":
  prevfile = open(prev_blt_pkg, 'r')
  pkg_name = prevfile.readline().strip()
  prevfile.close()

if nightly and devel:  # Select proper build rank for descriptive configuration summary.
  rank = 2
elif nightly:
  rank = 1
elif devel:
  rank = 3

if rquant > 1:
  plural = "s"
else:
  plural = ""

if os.environ['CESR_GMAKE']:
  bld_sys_area = os.environ['CESR_GMAKE']
else:
  print "Environment variable \'CESR_GMAKE\' not set, testing for default"
  

#=== Set up timing apparatus ============================
TIME1      = time.clock()
TIME2      = 0
TIME_TOTAL = 0
timetuple  = time.localtime()
year       = str(timetuple[0])
if timetuple[1] < 10:                   # Clean this up with leading zeroes
  month      = '0' + str(timetuple[1])  # in original date retrieval?
else:
  month      = str(timetuple[1])
if timetuple[2] < 10:
  day        = '0' + str(timetuple[2])
else:
  day        = str(timetuple[2])
datecode   = year + '_' + month + day



#=== Generic Parameters ================================
rel_prefix    = "cesr"                                  # WAS rel_tag
pkg_prefix    = "packages"                             # WAS pkg_tag
bmad_prefix   = "bmad_dist"
general_log   = ""
checkout      = 1

tagname       = ""                                      # WAS CVS_tagname
branch        = "TRUNK"
gmake_override= 0                                       # needed?
util_override = 0                                       
gmake         = "gmake"


#=====================================================================
# Global Support Function definitions
#=====================================================================

## Function to convert elapsed seconds number into Hour Minute Second values
## Returns a tuple
def seconds_to_HMS(seconds):
  hrs  = seconds / 3600
  mins = (seconds % 3600) / 60
  secs = seconds % 60
  return hrs, mins, secs

#def get_packages_name():
#  

## Function to generate a unique release name
## Accepts: 'RELEASE' or 'PACKAGES' and generates an appropriate unique name.
## Clean this routine up.  Two loops not needed.  Opted to make release builds always separate from packages builds
## to simplify operation.
def get_build_name(type, initial_name):
  uniq_suffix = 0
  basename   = ""
  build_name = initial_name
  build_list    = []
  if type == "RELEASE":
    prefix = rel_prefix
  elif type == "PACKAGES":
    prefix = pkg_prefix
  elif type == "BMAD DISTRIBUTION":
    prefix = bmad_prefix

  #print "build name : " + build_name
  full_logname_to_test = libs_dir + '/log/' + build_name + '.genlog'
  #print "full logname to test: " + full_logname_to_test

  if build_name == "":                    # if the command line was messed up, inform and abort
    print "Build name not specified."
    sys.exit(40)
  if os.path.exists(full_logname_to_test):   # otherwise, if the RELEASE specified on cmd line already exists, quit
    print "\nA release with the name "+build_name+" already exists."
    print "Specify a different name on the command line."
    print "\nNote: If no release name is provided, a unique one guaranteed to work will be"
    print "generated automatically.\n"
    sys.exit(15)
  elif build_name == "none":             # otherwise, a name was not specified, so proceed with unique name generation
    #d print "NONEtest build_name: " + build_name
    #d print "basename: " + basename
    basename = prefix + '_' + datecode + '_' + prec.lower()[0]  # unadorned 1st iteration generated name
    #d print "new basename: " + basename
    build_already_exists = 0   # move up to top of this function?
    if os.path.exists("/nfs/acc/libs/distribution/" + basename) and type == "BMAD DISTRIBUTION":
      #d print "Dist already exists"
      build_already_exists = 1
      full_buildname = libs_dir +"/distribution/" + basename
      #d print full_buildname
    else:
      for plat in platform_combos:          # check if the name already exists in any platform area
        #d print libs_dir +'/'+ platform_combos[plat][0]+'_'+platform_combos[plat][1]+'/'+basename
        full_buildname = libs_dir +'/'+ platform_combos[plat][0]+'_'+platform_combos[plat][1]+'/'+basename
        #d print "full buildname (gen): " + full_buildname
        if os.path.exists(full_buildname):
          build_already_exists = 1
    if build_already_exists:              # if it does, make it okay by appending a unique suffix
      #d print "Build already exists"
      while os.path.exists(full_buildname):
        uniq_suffix    = uniq_suffix + 1
        build_name     = basename + '_' + str(uniq_suffix)
        if type == "BMAD DISTRIBUTION":
          full_buildname = "/nfs/acc/libs/distribution/" + build_name
        else:
          full_buildname = libs_dir+'/'+platform_combos["linuxi"][0]+'_'+platform_combos["linuxi"][1]+'/'+build_name
        #d print build_name
    else:
      build_name = basename
  return build_name


## Function to print out a summary of all the build parameters being used.
def dump_parameters():
  print "---- Common Configuration Dump ----"
  print "          -- General --"
  print "Build Type        : " + build_type
  if prec == "DBL":
    precision = "double"
  else:
    precision = "single"
  if rel_name != "none":
    print "Release name      : " + rel_name
  if pkg_name != "none":
    print "Packages name     : " + pkg_name
  print "Float Precision   : " + precision
  print "Branch            : " + branch
  print "Revision          : " + revision
  if show_status:
    show_stat = "YES"
  else:
    show_stat = "NO"
  print "Realtime status   : " + show_stat
  print "Run test suite    : " + run_tests
  print "Build rank        : " + ranks[ rank ] # See ranks dict. above for possible values.
  print "Current host      : " + hostname
  print ""
  print "           -- Paths --"
  print "CESR libs dir     : " + libs_dir
  print "Build system dir  : " + build_sys_dir
  print "Util dir          : " + util_dir
  print "Binary dir        : " + bin_dir
  print "General log file  : " + genlog
  print ""
  print "   --  Platforms and Hosts  --"
  print "      " + str(rquant) +" "+ build_type.lower() +" build"+ plural +"."
  print "  OS   (compiler)      Build Host"
  print "--------------------------------------------"
  if lnx:
    print "Linux   (Intel)  " + lnx_host
    print "Linux   (Lahey)  " + lnx_host
  if osf:
    print "OSF1    (HP)     " + osf_host
  if vms:
    print "VMS     (HP)     " + vms_host
  if win:
    print "Windows (?)      " + win_host
  if bmad:
    print "  N/A -- Source-only distribution"



#=== Class defninitions ============================================================================
#===================================================================================================

#===================================================================================================
#== This class will allow the creation of a builder object, the responsibility of which will
#== be to set up all the variables needed to initiate a build process on a remote machine.
#== This involves checking out the necessary code for either a release build, a packages build
#== or both(NO) initiating the build, monitoring it to completion or abort due to error, and
#== optionally making realtime reports of the status of the build.
#===================================================================================================
class builder:
  libs_dir_loc         = libs_dir      # global to all class instantiations
  precision            = prec
  rev                  = 0
  
  # Initialize all the relevant variables local to this class, check out the necessary code, initiate (remote) builds.
  # May not be needed if first use provides a local variable instantiation.  Check it out!
  def __init__(self, release_names, revision, build_type, pcombo, print_co, stout):
    time_1           = 0
    time_2           = 0

    ###### hopefully reduce all name vars to these:
    full_logfile     = ""     # implemented
    name             = ""
    full_name        = ""
    __param_list     = []     # implemented
    checkout         = 0
    ######
    
    rel_name         = ""
    full_rel_name    = ""
    full_rel_logfile = ""
    __rel_param_list = []
    checkout_release = 0
    
    pkg_name         = ""
    full_pkg_name    = ""        # clean these up
    full_pkg_logfile = ""
    __pkg_param_list = []
    checkout_packages= 0

    __lines           = []
    qline             = ""
    status_lsit       = []

    self.rel_name, self.pkg_name = release_names
    self.bld_name     = build_name
    self.rev          = revision
    self.OS           = platform_combos[pcombo][0]
    self.f90          = platform_combos[pcombo][1]
    self.platform     = self.OS + '_' + self.f90
    self.base_dir     = self.libs_dir_loc + '/' + self.platform
    self.build_host   = platform_combos[pcombo][2]
    self.build_type   = build_type

    # Force newer Python versions (2.5.1) for Linux AND OSF1
    # to allow for possible subprocess module use among other amenities.
    if self.platform == "OSF1_alpha_hp":
      self.build_script = osf_py_dir + '/python ' + build_serf
    else:
      self.build_script = lin_py_dir + '/python ' + build_serf

    # Set up special paths for building on a Windows machine.
    if self.platform == "Cygwin_i686_intel":
      #  use_cesr_bin = "/cygdrive/z/cesrulib/bin"
      cyg_build_dir = "/cygdrive/c/user_local/cesrulib/cesr_libs"
    print time.asctime() + " -- Checking out code for " + self.platform
    if print_co:
      print "The full checkout manifest is available in the general log file."
      sys.stdout.write("Checkout manifest:", 4)   # Message Priority 4 goes ONLY to logfile
      
    #=== Variable Setup =================================
    __param_list.append("Build Type         : " + self.build_type + '\n')
    __param_list.append("Repository branch  : " + branch + '\n')
    __param_list.append("Revision           : " + str(self.rev) + '\n')    
    __param_list.append("F90 Compiler       : " + self.f90 + '\n')
    __param_list.append("Platform           : " + self.platform + '\n')
    __param_list.append("Float Precision    : " + self.precision + '\n')
    __param_list.append("Link against packs : " + self.pkg_name + '\n')
    __param_list.append("Build Host         : " + self.build_host + '\n')
    __param_list.append("Build System Dir   : " + build_sys_dir + '\n')
    __param_list.append("Bin dir            : " + bin_dir + '\n')
    __param_list.append("Run test suite     : " + run_tests + '\n')


    ####################################################################################
    if self.build_type == "PACKAGES":
      self.full_pkg_name = self.base_dir + '/' + self.pkg_name
      self.full_logfile   = self.libs_dir_loc + "/log/" + self.platform + '/' + self.pkg_name + ".log"
      
      __param_list.append("Full Packages name : " + self.full_pkg_name + '\n')
    
      self.plog = open(self.full_logfile, "w")
      self.plog.writelines( __param_list )
      self.plog.close()

      # Perform the actual checkout using a call to the SVN client
      for package in pkg_modules:
        loc_package = package.split('/')[-1]
        svn_cmd = "svn co "+repo_loc+'/'+ \
                  branch.lower()+"/packages/"+package+'@'+str(self.rev)+' '+self.full_pkg_name+'/'+loc_package
        #print svn_cmd
        print "Retrieving package " + package
        svnlines = os.popen(svn_cmd).readlines()
        for line in svnlines:
          __lines.append(line)
      if print_co:
        for line in __lines:
          sys.stdout.write(line, 4)  # Message priority 4 here to send checkout list ONLY to logfile and not clutter screen
      self.lines = []

      # Check out 3rd-party files from offsite repository.
      print "Obtaining 3rd-party files from off-site repository:"
      print "  " + offsite_repo_loc
      for package in offsite_pkg_modules:
        loc_package = package.split('/')[-1]
        if loc_package == "trunk":
          loc_package = "UAP"
        if loc_package == "xerces":
          loc_package = "xerces-c-src_2_7_0"
        svn_cmd = "svn co " + offsite_repo_loc + package + ' ' + self.full_pkg_name + '/' + loc_package
        #print svn_cmd
        print "Retrieving package " + package
        svnlines = os.popen(svn_cmd).readlines()
        for line in svnlines:
          __lines.append(line)
      if print_co:
        for line in __lines:
          sys.stdout.write(line, 4)  # Message priority 4 here to send checkout list ONLY to logfile and not clutter screen
      self.lines = []       
      
      print "Spawning build process..."
      cmd = "rsh -x "+self.build_host+" \". .bash_profile; "+self.build_script+" "+ self.full_logfile +"\""
      #o self.PID = os.spawnlp(os.P_NOWAIT,"rsh","rsh","-x",self.build_host,". .bash_profile;",self.build_script,self.full_pkg_logfile)
      self.PID = sub.Popen(cmd , shell=True).pid
      cmd = ""
      time.sleep(3)
      print "Spawned build process with PID : " + str(self.PID) + '\n'      

      
    ####################################################################################  
    if self.build_type == "RELEASE":
      self.full_rel_name = self.base_dir + '/' + self.rel_name
      self.full_logfile   = self.libs_dir_loc + "/log/" + self.platform + '/' + self.rel_name + ".log"
      
      __param_list.append("Full Release name  : " + self.full_rel_name + '\n')
      __param_list.append("Config Dir         : " + self.full_rel_name + "/config\n")
      __param_list.append("--> BUILD STATUS: HANDING CONTROL TO REMOTE SUBSCRIPT\n")
      
      self.rlog = open(self.full_logfile, "w")
      self.rlog.writelines( __param_list )
      self.rlog.close()

      # Perform the actual checkout using a call to the SVN client
      for module in repo_modules:
        #print "Retrieving module " + module
        svn_cmd = "svn co "+repo_loc+'/'+branch.lower()+'/'+module+"@"+str(self.rev)+' '+self.full_rel_name+'/'+module
 
        svnlines = os.popen(svn_cmd).readlines()
        for line in svnlines:
          __lines.append(line)
      if print_co:
        for line in __lines:
          sys.stdout.write(line, 4)    # Message priority 4 here to send checkout list ONLY to logfile and not clutter screen
      self.lines = []
      ## REMOTE-EXECUTE build process
      print "Spawning build process..."
      #o self.PID = os.spawnlp(os.P_NOWAIT,"rsh","rsh","-x",self.build_host,". .bash_profile;",self.build_script,self.full_rel_logfile)
      cmd = "rsh -x "+self.build_host+" \". .bash_profile; "+self.build_script+" "+ self.full_logfile +"\""
      self.PID = sub.Popen(cmd , shell=True).pid
      cmd = ""
      time.sleep(3)
      print time.asctime() + " -- Spawned build process with PID : " + str(self.PID) + '\n'

      
    #####################################################################################  
    if self.build_type == "BMAD DISTRIBUTION":
      print "Check out code for bmad distribution\n"

      self.base_dir = "/home/cesrulib/distribution"
      self.full_rel_name    = self.base_dir + '/' + self.rel_name
      self.full_logfile = self.base_dir + "/log/" + self.rel_name + ".log"

      __param_list.append("Full Release name  : " + self.full_rel_name + '\n')
      __param_list.append("Config Dir         : " + self.full_rel_name + "/config\n")
      __param_list.append("--> BUILD STATUS: HANDING CONTROL TO REMOTE SUBSCRIPT\n")

      self.rlog = open(self.full_logfile, "w")
      self.rlog.writelines( __param_list )
      self.rlog.close()

      # Perform the actual checkout using a call to the SVN client
      os.mkdir(self.full_rel_name)
      os.chdir(self.full_rel_name)
      for module in bmad_dist_modules:
        print "Retrieving module " + module
        svn_cmd = "svn co "+repo_loc+'/'+branch.lower()+'/'+module+"@"+str(self.rev)
 
        svnlines = os.popen(svn_cmd).readlines()
        for line in svnlines:
          __lines.append(line)
      if print_co:
        for line in __lines:
          sys.stdout.write(line, 4)    # Message priority 4 here to send checkout list ONLY to logfile and not clutter screen
      self.lines = []

      # Copy the bmad distribution environment setup scripts
      os.mkdir(self.full_rel_name + "/bin")
      shutil.copy(util_dir + "/bmadenv", self.full_rel_name + "/bin")
      shutil.copy(util_dir + "/bmad_def", self.full_rel_name + "/bin")
      shutil.copy(util_dir + "/bmad_defs", self.full_rel_name + "/bin")
      print "Environment scripts copied to distribution bin directory."
      
      ## Create the distribution source tarball
      print "\nCreating distribution tarball..."
      os.chdir(self.base_dir) # possibly not needed.
      print "Current dir: " + os.getcwd()
      tar_cmd_list = ["tar", "-cvf", self.rel_name+".tar", "./"+self.rel_name]
      #print tar_cmd_list
      t       = sub.Popen(tar_cmd_list, cwd=self.base_dir)
      t_rcode = t.wait()
      print "TAR operation completed successfully."
      if t_rcode != 0:
        print "ERROR during TAR operation!  Status: " + str(t_rcode) + " Quitting."
        sys.exit(60)
        
      print "Compressing tar file..."
      gzip_cmd_list = ["gzip", "-v", self.full_rel_name+".tar"]
      #print gzip_cmd_list
      t       = sub.Popen(gzip_cmd_list, cwd=self.base_dir)
      t_rcode = t.wait()
      print "GZIP operation completed successfully."
      if t_rcode != 0:
        print "ERROR during gzip operation!  Status: " + str(t_rcode) + " Quitting.\n"
        sys.exit(65)
        

      ## REMOTE-EXECUTE build process
      if bmad_build:
        print "Spawning build process..."
        #o self.PID = os.spawnlp(os.P_NOWAIT,"rsh","rsh","-x",self.build_host,". .bash_profile;",self.build_script,self.full_rel_logfile)
        print "Build bmad dist here.\n"
        # Build it locally, don't use the build_serf script, have all log output in the genlog file?
        cmd = "rsh -x "+self.build_host+" \". .bash_profile; "+self.build_script+" "+ self.full_logfile +"\""
        self.PID = sub.Popen(cmd , shell=True).pid
        cmd = ""
        time.sleep(3)
        print time.asctime() + " -- Spawned build process with PID : " + str(self.PID) + '\n'


  ############################################

  def status(self):    ## return the value of the most recently-stamped status message in logfile passed to this method
    build_status = 0
    if self.build_type == "RELEASE":
      file_to_check = self.full_logfile
    elif self.build_type == "PACKAGES":
      file_to_check = self.full_logfile
    elif self.build_type == "BMAD DISTRIBUTION":
      file_to_check = self.full_logfile
      
    self.lq = open(file_to_check, "r")
    self.qline = self.lq.readline()
    self.status_list = []
    while self.qline:
      if self.qline.find("BUILD STATUS:") != -1:
        #print self.qline
        self.qline = self.qline.strip()
        self.status_list.append(self.qline)
      self.qline = self.lq.readline()
      
    self.lq.close()
    #print self.status_list

    #if self.STATUS == "ERROR(S) DETECTED":         ## code pickup here for more specific contingencies?
    if self.status_list[-1].find("ERROR") != -1:
      build_status = -1                                # any errors give return value of -1
    elif self.status_list[-1].find("COMPLETE") != -1:
      build_status = 1                                 # code 1 means complete with no errors
    #self.qline = self.lq.readline()
    #self.lq.close()
    self.status_list = []
    return build_status                                    # still building will return value of 0



    
#======================================================================================================================  
#======================================================================================================================
# Main Script Starts Here
#======================================================================================================================

if build_release:
  build_type  = "RELEASE"
  build_name  = get_build_name(build_type, rel_name)
  rel_name    = build_name
  release_names = (rel_name, pkg_name)
elif build_packages:
  build_type  = "PACKAGES"
  build_name  = get_build_name(build_type, pkg_name)
  pkg_name    = build_name
  release_names = (rel_name, pkg_name)
elif bmad or bmad_build:
  build_type  = "BMAD DISTRIBUTION"
  build_name  = get_build_name(build_type, bmad_name)
  rel_name    = build_name
  release_names = (rel_name, "")
  
genlog      = build_name + ".genlog"
full_genlog = libs_dir + "/log/" + genlog


stout = StandOut(full_genlog, unbuffered=True)   # This transparently applies to all print stmnts and directs all the printed output of
                                   # this program to stdout AND to the general log file defined above.  Set verbosity here?
                                   # That can control the status output as well.
stout.outThreshold        = 5      # These logging threshold values are used to selectively direct normal output of this
stout.outLogfileThreshold = 4      # script to any combination of the screen or general logfile



#== Request KRB credentials so remote-shell calls work later ==============
(krbout, krbin) = popen2.popen4("kinit -k -t /etc/cesrulib-keytab cesrulib/" + hostname)
krblines = krbout.readlines()
for line in krblines:
  print line
  if line[0:5] == "kinit":
    print "Problem obtaining Kerberos 5 credentials, terminating."
    print "Verify that your current shell is a login shell.\n"
    sys.exit(25)  # commented out so I can use a su'd terminal for testing


#== Determine which revision to check out, default is most recent ==
if revision == 0:
  infolist = os.popen("svn info "+repo_loc).readlines()       # adjust here for getting stderr as well
  for line in infolist:
    if line.find("Revision") != -1:
      revision = line.split(':')[1].strip()
    elif line.find("failed") != -1:
      print "SVN repository access failed!  Quitting."
      sys.exit(50)


#== Print out all the configuration information collected or derived up to this point ===
print ""
print time.asctime()
if dump:
  dump_parameters()
print ""


#== Check available disk space ========
spaceline    = os.popen("df " + libs_dir).readlines()[1]
space_free   = int(spaceline.split()[3])            # Bytes free
if space_free <= space_needed:
  print "Insufficient disk space in " + libs_dir + "!"
  print "Disk free space = %i" % space_free
  print "Space required  = %i" % space_needed
  sys.exit(30)




#== Instantiate a builder object for each process that needs to be initiated
#== a total of rquant builds will be executed.
#== This starts the build processes on their respective hosts. Also only prints out the
#== svn list of files being checked out a single time to reduce clutter in genlog file.   LOOP HERE for generality?
print_co = True      # flag to allow only the first build initiated to print its checkout list, preventing redundancy of output
if build_type == "BMAD DISTRIBUTION":
  t_begin_LIN = time.time()
  LINBUILD = builder(release_names, revision, build_type,"linuxi", print_co, stout) 

if build_type == "PACKAGES" or build_type == "RELEASE":
  if lnx:
    t_begin_LIN = time.time()
    LINBUILD = builder(release_names, revision, build_type,"linuxi", print_co, stout)  # Initialize a builder object for given platform.
    t_begin_LLA = int(time.time())
    LLABUILD = builder(release_names, revision, build_type, "linuxl", print_co, stout)  # Linux intel and lahey are always together
    print_co = False
  if osf:
    t_begin_OSF = int(time.time())
    t_begin_VMS = int(time.time())
    OSFBUILD = builder(release_names, revision, build_type, "osfhp", print_co, stout)
    print_co = False
  if win:
    t_WIN    = int(time.time())
    WINBUILD = builder(release_names, revision, build_type, "win", print_co, stout)

##  Package phase initiation complete here.
loop             = 0
max_loops        = 450
complete_fraction= 0.0
complete_tally   = 0
error_fraction   = 0.0
error_fraction   = 0
error_tally      = 0
lin_donelatch    = 0
lla_donelatch    = 0
osf_donelatch    = 0
vms_donelatch    = 0
t_end_LIN        = 0
t_end_LLA        = 0
t_end_OSF        = 0
t_end_VMS        = 0
elapsed          = 0

####
if not bmad:
  print "Waiting for builds to fully initiate."
  time.sleep(60)       # Long wait here to allow OSF1 builds to eventually dump the output of the
  if not show_status:  # gmake call to a file for status parsing. Buffer clearing is slow or something.
    print "Builds initiated.  Status output suppressed.  This will take a while.\n"
####

while complete_fraction < 1 and loop < max_loops: 
  error_fraction    = 0
  error_tally       = 0
  if bmad:
    break
  
  if show_status:
    t_cur_master = int(time.time())
    print "\n\nBuild status info:   (loop " + str(loop) + ")"
    print "  %i hr %i min %i sec elapsed" % seconds_to_HMS(t_cur_master - t_begin_master)
    print "----------------------------------------"

  if lnx:
    lin_stat = LINBUILD.status()
    lla_stat = LLABUILD.status()
    #===Check if Intel is done==============
    if lin_stat > 0 and lin_donelatch == 0:
      complete_tally = complete_tally + 1
      t_end_LIN = int(time.time() )
      lin_donelatch = 1
    elif lin_stat < 0:
      error_tally = error_tally + 1
    #===Check if Lahey is done==============
    if lla_stat > 0 and lla_donelatch == 0:
      complete_tally = complete_tally + 1
      t_end_LLA = int(time.time() )
      lla_donelatch = 1
    elif lla_stat < 0:
      error_tally = error_tally + 1
    if show_status:
      print "  Linux Intel : (" + str( lin_stat ) + ') ' + statuses[lin_stat]
      print "  Linux Lahey : (" + str( lla_stat ) + ') ' + statuses[lla_stat]


  if bmad_build:
    lin_stat = LINBUILD.status()
    #===Check if Intel is done==============
    if lin_stat > 0 and lin_donelatch == 0:
      complete_tally = complete_tally + 1
      t_end_LIN = int(time.time() )
      lin_donelatch = 1
    elif lin_stat < 0:
      error_tally = error_tally + 1
    #===Check if Lahey is done==============
    #if lla_stat > 0 and lla_donelatch == 0:
    #  complete_tally = complete_tally + 1
    #  t_end_LLA = int(time.time() )
    #  lla_donelatch = 1
    #elif lla_stat < 0:
    #  error_tally = error_tally + 1
    if show_status:
      print "  Linux(bmad) Intel : (" + str( lin_stat ) + ') ' + statuses[lin_stat]
    #  print "  Linux Lahey : (" + str( lla_stat ) + ') ' + statuses[lla_stat]

            
  if osf:                        
    osf_stat = OSFBUILD.status()
    #===Check if HP is done=================
    if osf_stat > 0 and osf_donelatch == 0:
      complete_tally = complete_tally + 1
      t_end_OSF = int(time.time())
      osf_donelatch = 1
      # Put call to VMS builder here, it will check out, and then this will copy OSF deps over.
      if vms:
        print ""
        VMSBUILD = builder(release_names, revision, build_type, "vmshp", print_co, stout)
        time.sleep(20)  # is this needed?
    elif osf_stat < 0:
      error_tally = error_tally + 1
    if show_status:
      print "  OSF1   HP   : (" + str( osf_stat ) + ') ' + statuses[osf_stat]
      if vms and osf_donelatch == 0:   # if VMS release is to be prepared and OSF is still running
        print "  VMS    HP   : (0) WAITING for OSF1"


    # VMS build depends on successful OSF build
  if vms and osf_donelatch:   # if VMS release is to be prepared AND OSF is done building
    vms_stat = VMSBUILD.status()
    if vms_stat > 0 and vms_donelatch == 0:  # if VMS preparations have completed
      complete_tally = complete_tally + 1
      t_end_VMS = int(time.time())
      vms_donelatch = 1
    if show_status:
      print "  VMS    HP   : (" + str(vms_stat) + ") PREPARING TO TRANSFER"
      
    
  complete_fraction = complete_tally / float(rquant)
  error_fraction    = error_tally / float(rquant)

  if complete_fraction == 1.0:
    print "\n" + time.asctime() + " All Builds completed successfully.\n"
    successful_build = 1
    break

  if vms and error_fraction == float(1.0 - (1.0/float(rquant))):    # Mark as failed if all but VMS fail.
    print "All conventional builds have failed."
    print "VMS preparation will not be attempted.  Stopping."
    sys.exit(45)
  elif error_fraction == 1.0:
    print "All builds have failed.  Stopping."
    sys.exit(45)

  if (complete_tally + error_tally) == rquant:
    print "All builds have ceased, with some due to failure."
    sys.exit(47)

  if (loop == max_loops):
    print "One or more builds have ceased due to timeout!"
    sys.exit(55)
      
  if loop < 10:
    time.sleep(5)
  else:
    time.sleep(30)
  loop = loop + 1
  
##End while loop [ while complete_fraction < 1 and loop < max_loops: ]

t_end_master = int(time.time())

##== Build has completed successfully, compute and summarize relevant statistics ==========================================
print "          ======== Statistics for this build process ========"
print "============================ Time summary: ==============================="
print "         Overall:     %i hr %i min %i sec elapsed" % seconds_to_HMS(t_end_master - t_begin_master)

if lnx:
  print "Linux intel build : %i hr %i min %i sec" % seconds_to_HMS(t_end_LIN - t_begin_LIN)
  print "Linux lahey build : %i hr %i min %i sec" % seconds_to_HMS(t_end_LLA - t_begin_LLA)
if bmad or bmad_build:
  print "Linux (bmad) intel build : %i hr %i min %i sec" % seconds_to_HMS(t_end_LIN - t_begin_LIN)
if osf:
  print "OSF1 alpha  build : %i hr %i min %i sec" % seconds_to_HMS(t_end_OSF - t_begin_OSF)
if vms:
  print "VMS  alpha  build : %i hr %i min %i sec" % seconds_to_HMS(t_end_VMS - t_begin_VMS)

#if build_type == "RELEASE":
lines = os.popen(util_dir + "/rel_disk_total " + rel_name).readlines()
for line in lines:
  print line.strip()
#else:
#  print "Disk utilization summary for packages builds has not yet been implemented."


if build_type == "RELEASE" and run_tests == "YES":
  print "=========================  Test Suite Summary  ==========================="
  if lnx:
    platform = platform_combos['linuxi'][0] + '_' + platform_combos['linuxi'][1]
    print "Testing summary for " + platform
    logfile = libs_dir + '/log/'+ platform + '/' + rel_name + '.log'
    lines = os.popen(util_dir + "/extract_test_summary " + logfile).readlines()
    for line in lines:
      print line.strip()
    print ""
    platform = platform_combos['linuxl'][0] + '_' + platform_combos['linuxl'][1]
    print "Testing summary for " + platform
    logfile = libs_dir + '/log/'+ platform + '/' + rel_name + '.log'
    lines = os.popen(util_dir + "/extract_test_summary " + logfile).readlines()
    for line in lines:
      print line.strip()
    print ""
  if osf:
    platform = platform_combos['osfhp'][0] + '_' + platform_combos['osfhp'][1]
    print "Testing summary for " + platform
    logfile = libs_dir + '/log/'+ platform + '/' + rel_name + '.log'
    lines = os.popen(util_dir + "/extract_test_summary " + logfile).readlines()
    for line in lines:
      print line.strip()
    print ""

print "=========================================================================="
print "          =============  End Statistics Summary =============\n"


#== If nightly build has been requested, rotate this one into position and delete the previous.
if nightly and build_type == "RELEASE":
  print "This is a nightly build, proceeding with replacement of previous build."
  lines = os.popen(util_dir + "/rotate_release -nightly " + rel_name).readlines()
  for line in lines:
    print line.strip()
  print "Rotation successful-- deleting previous night's build."

  #== If everything has completed successfully so far, delete previous build, as long as it hasn't
  #== been promoted.
  prevfile = open(prev_blt, 'r')
  previously_built = prevfile.readline().strip()
  prevfile.close()
  lines = os.popen(util_dir + "/DELETE_release -QUIET REL=" + previously_built)
  for line in lines:
    print line.strip()
  print "Deletion successful.  Updating previously-built indicator."
  os.chmod(prev_blt, 0644)         # set permissions to writable
  prevfile = open(prev_blt, 'w')
  prevfile.write(rel_name + '\n')      # write the name of the release just built to file
  prevfile.close()
  os.chmod(prev_blt, 0444)         # reset permissions to disallow writes

if build_type == "PACKAGES":
  print "Updating previously-built packages indicator."
  os.chmod(prev_blt, 0644)         # set permissions to writable
  prevfile = open(prev_blt_pkg, 'w')
  prevfile.write(rel_name + '\n')      # write the name of the release just built to file
  prevfile.close()
  os.chmod(prev_blt_pkg, 0444)         # reset permissions to disallow writes

# Ask if this newly-built release is a candidate for promotion to DEVEL.
if devel:
  print "Checking to see whether " + rel_name + " is a DEVEL candidate."
  qr = sub.Popen([util_dir + "/query_rotate", "-r", rel_name])
  recommendation = qr.wait()
  if recommendation == 0:
    print "Perform rotation here."

print "\n================== Build process finished completely. ===================="




stout.close()                           # Close stream to logfile before quitting
