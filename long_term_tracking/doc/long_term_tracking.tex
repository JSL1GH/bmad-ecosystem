%-----------------------------------------
% Note: Use pdflatex to process this file.
%-----------------------------------------

%\documentclass{article}
\documentclass{hitec}
\usepackage{color,soul}

\usepackage{setspace}
\usepackage{graphicx}
\usepackage{moreverb}    % Defines {listing} environment.
\usepackage{amsmath, amsthm, amssymb, amsbsy, mathtools}
\usepackage{alltt}
\usepackage{rotating}
\usepackage{subcaption}
\usepackage{toc-bmad}
\usepackage{xspace}
\usepackage[section]{placeins}   % For preventing floats from floating to end of chapter.
\usepackage{longtable}   % For splitting long vertical tables into pieces
\usepackage{index}
\usepackage{multirow}
\usepackage{booktabs}    % For table layouts
\usepackage{yhmath}      % For widehat
\usepackage{xcolor}      % Needed for listings package.
\usepackage{listings}
\usepackage[T1]{fontenc}   % so _, <, and > print correctly in text.
\usepackage[strings]{underscore}    % to use "_" in text
\usepackage[pdftex,colorlinks=true]{hyperref}   % Must be last package!

\definecolor{light-gray}{gray}{0.95}
\lstset{backgroundcolor=\color{light-gray}}
\lstset{xleftmargin=0cm}
\lstset{framexleftmargin=0.3em}
%\lstset{basicstyle = \ttfamily\fontsize{11}{11}\selectfont} 
\lstset{basicstyle = \small}
\lstnewenvironment{code}{}{}

%---------------------------------------------------------------------------------

\definecolor{lightestgray}{gray}{0.99}
\sethlcolor{lightestgray}
\soulregister{\texttt}{1}
\newcommand\dottcmd[1]{\hl{\em#1}\endgroup}
%\newcommand\dottcmd[1]{{#1}\endgroup}
\newcommand{\vn}{\begingroup\catcode`\_=11 \catcode`\%=11 \dottcmd}
\newcommand{\ltt}{\vn{long_term_tracking}\xspace}
\newcommand{\Newline}{\hfil \\}
\newcommand{\sref}[1]{$\S$\ref{#1}}
\newcommand{\Th}{$^{th}$\xspace}

%---------------------------------------------------------------------------------

\renewcommand{\textfraction}{0.1}
\renewcommand{\topfraction}{1.0}
\renewcommand{\bottomfraction}{1.0}

\settextfraction{0.9}  % Width of text
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex}
%\setlength{\textwidth}{6in}
\newcommand{\Section}[1]{\section{#1}\vspace*{-1ex}}

\newenvironment{display}
  {\vspace*{-1.5ex} \begin{alltt}}
  {\end{alltt} \vspace*{-1.0ex}}

%---------------------------------------------------------------------------------

\title{Long Term Tracking Program}
\author{}
\date{David Sagan \\ February 8, 2021}
\begin{document}
\maketitle

\tableofcontents

%---------------------------------------------------------------------------------

\Section{Introduction} 
\label{s:intro}

The \ltt program is for long term tracking of a particle or a beam possibly including tracking of the
spin.

The \ltt program is built atop the Bmad software toolkit \cite{b:bmad}. The Bmad toolkit is a
library, developed at Cornell, for the modeling relativistic charged particles in storage rings and
Linacs, as well as modeling photons in x-ray beam lines.

The \ltt program comes with the ``Bmad Distribution'' which is a package which contains Bmad along with
a number of Bmad based programs. See the Bmad web site for more details.

The \ltt program comes in two versions: 
\begin{code}
long_term_tracking      ! Single threaded version
long_term_tracking_mpi  ! Multi-threaded version
\end{code}
The first is a single threaded version and the second is a multi-threaded version using MPI.

[Note to Distribution maintainers: The single threaded version will be built when compiling a Bmad
Distribution. If MPI is not enabled (which is the default setting), the MPI version will not be built. 
The MPI version can be built by setting:
\begin{code}
  export ACC_ENABLE_MPI=Y
\end{code}
and then using the ``\vn{mk}'' command in the \vn{bsim} directory to build the executable. See the
documentation on the Bmad web site for more details.]

%------------------------------------------------------------------
\Section{Running the Long Term Tracking Program} 
\label{s:run}

See the documentation for setting up the Bmad environmental variables at
\begin{code}
  https://wiki.classe.cornell.edu/ACC/ACL/RunningPrograms
\end{code}

Once the Bmad environmental variables have been set, the syntax for invoking the single threaded
version of the \ltt program is:
\begin{code}
  long_term_tracking {<master_input_file_name>}
\end{code}
Example:
\begin{code}
  long_term_tracking my_input_file.init
\end{code}
The \vn{<master_input_file_name>} optional argument is used to set the master input file name. The
default value is ``\vn{long_term_tracking.init}''. 

Example input files are in the directory (relative to the root of a Distribution):
\begin{code}
  bsim/long_turn_tracking/example
\end{code}

The syntax of the master input file is explained in \sref{s:input}.

%------------------------------------------------------------------
\Section{Definition of Some Terms}
\label{s:def}

\begin{description}
\item[Beam] \Newline
A \vn{beam} consists of a train \vn{bunches}. Each \vn{bunch} consists of a number of particles contained
within one RF bucket.
%
\item[Radiation Damping and fluctuations] \Newline
At a given particle position, the energy kick $dE$ that a particle receives due to emission of
radiation can be decomposed into two parts. One part is the average kick $dE_d$ and the other part
is a random fluctuation $dE_r$ around the average 
\begin{equation}\large
  dE = dE_d + dE_r
\end{equation}
An analysis shows that the average part $dE_d$ leads to damping with respect to the closed orbit and
the fluctuation part leads to excitation of the particle motion. Over many turns, there is an
equilibrium reached which gives a particle beam its natural size. While it is not physically
possible to have radiation damping without excitation and vice versa, this can be done with ease in
a simulation.
%
\item[PTC] \Newline
PTC is a library developed by \'Etienne Forest to handle Taylor maps to any arbitrary order. In
particular, PTC is used for constructing maps for the \vn{long_term_tracking} program. PTC can also
be used to do element-by-element tracking.
\end{description}

%------------------------------------------------------------------
\Section{Simulation Modes}
\label{s:sim.modes}

There are a number of simulation ``modes'' which determine what is done by the program. The
simulation mode is set by the \vn{ltt%simulation_mode} parameter in the master input file
(\sref{s:input}).  Possible settings of \vn{ltt%simulation_mode} are:
\begin{code}
  "CHECK"   ! Quick tracking check.
  "SINGLE"  ! Single particle tracking.
  "BEAM"    ! Beam tracking.
  "STAT"    ! Lattice statistics.
\end{code}

\begin{description}
\item["CHECK"] \Newline
In this mode, a particle is tracked from \vn{ltt%ele_start} to \vn{ltt%ele_stop} three times using a
different tracking method each time. The three tracking methods are 1) using a set of maps
(\sref{s:map}), and element-by-element tracking using 2) \vn{Bmad} and 3) \vn{PTC}. The results are then
printed to the terminal. This mode can be used to get a sense of how the three different methods
compare to each other. The starting coordinates are set by \vn{particle_start} commands in the
lattice file. Included in the output is the transfer matrix (Jacobian) with respect to the tracked
orbit for each of the three tracking methods. These transfer matrices are computed using finite
differences when the starting position is varied. The variation used in the computation can be
specified by setting in the master input file the vector \vn{bmad_com%d_orb}. This vector has 6
components, one for each phase space component. That is, \vn{bmad_com%d_orb(1)} sets the variation
of the $x$ phase space component, etc.

No data files are produced in this mode.

Radiation fluctuations are turned off in this mode but radiation damping will still be applied if
turned on.

%
\item["SINGLE"] \Newline
In this mode a single particle is tracked for \vn{ltt%n_turns} turns. The name of the data file is set
by the \vn{ltt%particle_output_file} parameter (\sref{s:input}). The particle position will be output every
\vn{ltt%particle_output_every_n_turns} turns.
%
\item["BEAM"] \Newline
In this mode a particle beam is tracked for \vn{ltt%n_turns} turns. The output data file(s) format is
described in Section~\sref{s:part.out}.
%
\item["STAT"] \Newline
In this mode statistics about the lattice are calculated. No long term tracking is done.

Three data files are produced: 
\begin{code}
  twiss.dat         ! Twiss parameters
  coupling.dat      ! Coupling parameters
  closed_orbit.dat  ! Closed orbit
\end{code}
\end{description}

%------------------------------------------------------------------
\Section{Tracking Methods}
\label{s:track.methods}

When tracking with \vn{ltt%simulation_mode} set to \vn{"SINGLE"} or \vn{"BEAM"}, the setting of
\vn{ltt%tracking_method} determines how particles are tracked. Possible settings are:
\begin{code}
  "MAP"     ! Tracking using maps.
  "PTC"     ! Element-by-element tracking with PTC. Slow.
  "BMAD"    ! Element-by-element tracking using Bmad. Default. Slow.
\end{code}

which is used to determine if tracking is done using a map or not. If a map is used, the order of
the map (the degree at which the Taylor series comprising the map are truncated) is given by
\vn{ltt%map_order} parameter. A larger map order will mean better accuracy at the expense of more
computation time. Tracking using a map will be extremely quick compared to element-by-element
tracking. However, map tracking can be inaccurate if the map order is too small or the particle
amplitude is too large.

Only the \vn{BMAD} method is able to handle a machine that is being ramped (\sref{s:ramp}). That is,
when \vn{ltt%ramping_on} set to True. The program will detect if there is a conflict and issue an error
message and stop.

%------------------------------------------------------------------
\Section{Map Tracking}
\label{s:map}

The \ltt program uses the PTC/FPP library of \'Etienne Forest to handle Taylor maps which can be
constructed to any arbitrary order. Maps will transport both orbital and spin coordinates.  In
particular, PTC is used for constructing the map(s) used for tracking when the
\vn{ltt%tracking_method} parameter is set to "\vn{MAP}" (\sref{s:sim.params}). PTC tracking is also
used when \vn{ltt%tracking_method} is set to "\vn{PTC}". In this case, tracking is done
element-by-element using symplectic integration.

Note: Using maps is not compatible when a machine is being ramped (\sref{s:ramp}.

Sometimes it is convenient to exclude certain lattice elements from a map. For example, the
beam-beam interaction is highly non-linear so excluding any \vn{beambeam} elements can improve map
accuracy at larger amplitudes. Which elements are excluded is determined by the setting of
\vn{ltt%exclude_from_maps} which is a list of what elements are to be excluded. Elements can be
excluded for a number of reasons. When an element is excluded, multiple maps are created, one for
each of the sections of the lattice where there are no excluded elements. In this case, tracking
consists of using a map to track from one excluded element to the next followed by tracking through
the excluded element.

Depending upon how things are setup, a \vn{PTC} map can include radiation damping and fluctuations
effects. \footnote
  {
Radiation fluctuations are included by actually using two maps to track a particle from one point to
the next. One map represents the transport with damping and the second map represents the
fluctuations. When a particle is tracked, the first map with damping is applied and then the second
map is applied using six random numbers.
  }
Damping and excitation are controlled by two parameters that can be set in the master input file:
\begin{code}
bmad_com%radiation_damping_on
bmad_com%radiation_fluctuations_on
\end{code}

The problem with trying to use a map to track a particle's spin when there are radiation effects
present is that a map may not properly model the effect of the radiation fluctuations on the spin
precession (radiation damping is not problematic in itself but that is small comfort). To get around
this, the switch \vn{ltt%split_bends_for_radiation} may be set True. In this case, all bend elements
are split in the center and special radiation marker elements are placed in between the split
bends. These radiation marker elements are excluded when constructing maps so the result is many
maps whose boundaries will be at the bend centers. When tracking, the maps will not incorporate any
radiation effects and a radiation kick will be put in at the radiation marker elements as well as any
other elements that are excluded from the maps.

This technique of bend splitting for the purposes of including radiation effects was originally
implemented in a program called \vn{SLICK} and later in the offshoot program \vn{SLICKTRACK}. As
such, this algorithm is known as \vn{SLICK} tracking. A drawback with \vn{SLICK} tracking is the
number of maps needed to track a particle over one turn may be considerably more than just using one
map (essentially there will be one map for every bend in the lattice). This will lengthen
computation times. This being so, it is recommended that \vn{SLICK} tracking only be used when
needed. That is, when both radiation effects and spin tracking are to be simulated. \vn{SLICK}
tracking is also potentially problematical in that radiation effects are not taken into account for
non-dipole elements that are included in any map. If there are any such elements (for example,
wiggler elements), these elements should be excluded from being included in any map.

Maps are saved to a file for use if the program is rerun. The name of a map file is determined, in
part, by the setting of the \vn{ltt%map_file_prefix} parameter. See the documentation on this
parameter in \sref{s:out.params}.

%------------------------------------------------------------------
\Section{Tuning Map and PTC Tracking Parameters}
\label{s:map.tuning}

When tracking using maps or element-by-element with PTC 
there are a few points to keep in mind. First is that \vn{PTC} tracks through a lattice element
step by step. This is true for both map creation and symplectic integration. This means that the
setting of the element parameter \vn{num_steps} (or equivalently \vn{ds_step}) for each element will
affect the accuracy and speed of the computations. Bmad tries to choose reasonable default settings
for the number of steps however the calculation is not perfect. To make sure that the number of
steps is set properly, vary the number of steps and choose a step size (which can be different for
different elements) such that the number of steps is minimal (to minimize computation time) while at
the same time is large enough so that results do not change significantly if the number of steps is
increased.

Another thing to keep in mind is that whether a map will give accurate results is dependent on a
number of factors. One factor is the order of the map. Generally higher order is better but will
take more computation time. When the lattice is tracked using a single map, the tracking is only
valid when the tracked particles are far from any strong resonances. That is, if you are interested
in tracking halo particles, you probably should not be using a single map.

In terms of speed, using maps will be the fastest, using standard Bmad tracking will be much
slower, and using PTC element-by-element tracking will be slowest.

In terms of symplecticity, both the PTC tracking and map tracking will be symplectic.
Bmad is not symplectic but the deviation from symplecticity is generally fairly small. If the
radiation effects are large enough, the radiative stochastic noise will negate any non-symplectic
effects and standard Bmad tracking can be used. A very rough rule of thumb is that if the damping times
or the number of turns tracked are under 100,000 turns then Bmad standard tracking can be used.

PTC element-by-element tracking cannot be done when using the MPI version of the \ltt program.

%------------------------------------------------------------------
\Section{Correcting the Orbit when Radiation is Present}

In storage rings, When radiation damping is simulated, the orbit that is flat when there is no
radiation will show a ``sawtooth" pattern'' in a plot of beam energy versus position. This will lead
to a nonzero orbit. In an actual ring, the non-zero orbit will be compensated using steerings. Thus,
to simulate the actual ring, compensating steerings should be added to the simulated lattice as
well. How to do this is covered in the Bmad and Tao Cookbook available from the Bmad web site.

%------------------------------------------------------------------
\Section{Ramping in a Lattice}
\label{s:ramp}

``\vn{Ramping}'' is the situation where lattice parameters are changing as a function of
time. Ramping examples include changing magnet and RF strengths to ramp the beam energy or changing
magnet strengths to squeeze beta at the interaction pont of a colliding beam machine.

Ramping is accomplished by defining \vn{ramper} elements in the lattice file. These ramper elements
will be applied to each element in turn before particles are tracked through them. Example:
\begin{code}
  ramp_e: ramper = \{*[e_tot]:\{4e+08, 4.00532e+08, 4.01982e+08, ...\}\},
                var = \{time\}, x_knot = \{0, 0.001, 0.002, ...\}
  amp = 1e9;  omega = 0.167;  t0 = 0.053
  ramp_rf: ramper = \{rfcavity::*[voltage]:amp*sin(omega *(t + t0)),
        rfcavity::*[phi0]:0.00158*t^2 + 2*q \}, var = \{t, q\}
\end{code}
See the Bmad manual for documentation on \vn{ramper} syntax. The ``\vn{*[e_tot]}'' construct in the
definition of \vn{ramp_e} means that the ramper will be applied all elements (since the wild card
character ``\vn{*}'' will match to any element name), and it is the element's \vn{e_tot} attribute
(the element's reference energy) that will be varied.

In the above example, the \vn{ramp_rf} ramper will be applied to all \vn{rfcavity} elements with
the cavity voltage and phase (\vn{phi0}) being varied.

In the case where the reference energy \vn{e_tot} or reference momentum \vn{p0c} is being varied, the
effect on an element will depend upon the setting of the element's \vn{field_master} parameter. For
example:
\begin{code}
  q1: quadrupole, k1 = 0.3
  q2: quadrupole, k1 = 0.3, field_master = T
\end{code}
In this example, \vn{q1} will have its \vn{field_master} parameter set to \vn{False} since the
quadrupole strength was specified using the normalized strength \vn{k1}. With \vn{q1}, since
\vn{field_master} is False, varying the reference energy or momentum will result in the normalized
strength \vn{k1} remaining fixed and the unnormalized strength \vn{B1_gradient} varying in
proportion to the reference momentum. With \vn{q2}, since \vn{field_master} is True, the
unnormalized strength \vn{B1_gradient} will remain fixed and normalized \vn{k1} will vary
inversely with the reference momentum.

Before ramper elements are applied to an element, the time bench center is at the center of the
element is computed and this value is applied to the first variable of each ramper. For example,
with the \vn{ramp_rf} element defined above, the \vn{t} variable will be set to the time. particle
time The \ltt program assumes that the fist variable of a ramper element is that the ramper control
variable is time. Implicit in this is the assumption that controlled parameters are varying slow
enough so that the ramplers only need be applied once per beam passage. This is done to minimize
computational time.

In the lattice file, individual ramper elements may be toggled on or off using the element's
\vn{is_on} attribute. 
\begin{code}
  ramp_rf: ramper = ...  ! Ramper element defined.
  ramp_rf[is_on] = F     ! After being defined, ramper may be turned off.
\end{code}

If \vn{ltt%ramping_on} is set to True, ramping will be done if \vn{ltt%simulation_mode} is set to
"\vn{BEAM}" or "\vn{SINGLE}". Ramping will be ignored in the other modes.

\ltt program parameters that affect ramping in the simulation are:
\begin{code}
  ltt%ramping_on
  ltt%ramper_start_time
\end{code}

When ramping, the \vn{ltt%simulation_mode} (\sref{s:track.methods}) must be set to "\vn{BMAD}". The
program will detect if there is a conflict and issue an error message and stop.

%------------------------------------------------------------------
\Section{Initial Particle Positions}
\label{s:init.pos}

When the \vn{ltt%simulation_mode} (\sref{s:sim.modes}) is set to \vn{"SINGLE"} or \vn{"CHECK"}, the
initial particle position will be set to the initial beam center position. The parameters that are used to
determine the beam center position are
\begin{code}
  beam_init%center           ! (x, px, y, py, z, pz)
  beam_init%spin             ! (Sx, Sy, Sz)
  beam_init%use_particle_start_for_center 
  ltt%add_closed_orbit_to_init_position
\end{code}
If \vn{beam_init%use_particle_start_for_center} is set to \vn{True}, instead of using
\vn{beam_init%center}, the \vn{particle_start} parameters that are set in the lattice file will be
used. If the \vn{ltt%add_closed_orbit_to_init_position} logical is set to \vn{True}, the closed
orbit position is added in to the center position calculation.

When the \vn{ltt%simulation_mode} is set to \vn{"BEAM"}, the initial particle positions are calculated
using the \vn{beam_init} structure as discussed in the \vn{Beam Initialization} chapter of the Bmad
manual. Like the other modes, if the \vn{ltt%add_closed_orbit_to_init_position} logical is set to
\vn{True}, the closed orbit position is added to the initial particle positions. To read in a file
with beam particle positions, set the \vn{beam_init} structure appropriately. Example:
\begin{code}
  beam_init%file_name = 'beam_particle_file.init'
\end{code}

In all cases, tracking will start at the lattice element set by \vn{ltt%ele_start}.

The \vn{beam_init} structure:
\begin{code}
  type beam_init_struct
    character(200) :: position_file = ''       ! Initialization file name.
    character distribution_type(3)             ! "ELLIPSE", "KV", "GRID", "".
    type (ellipse_beam_init_struct) ellipse(3) ! For ellipse beam distribution
    type (kv_beam_init_struct) KV              ! For KV beam distribution
    type (grid_beam_init_struct) grid(3)       ! For grid beam distribution
    logical use_particle_start_for_center = F  ! Use particle_start?
    character random_engine            ! "pseudo" (default) or "quasi". 
    character random_gauss_converter   ! "exact" (default) or "quick". 
    real center(6) = 0                 ! Bench center offset.
    real center_jitter(6) = 0          ! Bunch center rms jitter
    real emit_jitter(2)   = 0          ! %RMS a and b-mode emittance jitter
    real sig_z_jitter     = 0          ! bunch length RMS jitter 
    real sig_pz_jitter     = 0         ! pz energy spread RMS jitter 
    real random_sigma_cutoff = -1      ! -1 => no cutoff used.
    integer n_particle = 0             ! Num of simulated particles per bunch.
    logical renorm_center = T          ! Renormalize centroid?
    logical renorm_sigma = T           ! Renormalize sigma?
    real(rp) spin(3) = 0, 0, 0         ! Spin (x, y, z)
    real a_norm_emit = 0               ! a-mode normalized emittance
    real b_norm_emit = 0               ! b-mode normalized emittance
    real a_emit = 0                    ! a-mode emittance
    real b_emit = 0                    ! b-mode emittance
    real dpz_dz = 0                    ! pz vs z correlation.
    real dt_bunch = 0                  ! Time between bunches.
    real sig_z = 0                     ! Z sigma in m.
    real sig_pz = 0                    ! pz sigma.
    real bunch_charge = 0              ! Charge in a bunch.
    integer n_bunch = 0                ! Number of bunches.
    character species = ""             ! Species to track.
    logical full_6D_coupling_calc = F  ! Use 6x6 1-turn mat to match distribution?  
    logical use_t_coords = F  ! If true, the distributions will be 
                              !   calculated using time coordinates
    logical use_z_as_t   = F  ! Only used if use_t_coords = T:
                              !   True:  The z coordinate stores the time.
                              !   False: The z coordinate stores the s-position.
  end type
\end{code}

%------------------------------------------------------------------
\Section{Fortran Namelist Input}
\label{s:namelist}

Fortran namelist syntax is used for parameter input in the master input file. The general form of a namelist is
\begin{code}
&<namelist_name>
  <var1> = ...
  <var2> = ...
  ...
/
\end{code}
The tag \vn{"\&<namelist_name>"} starts the namelist where
\vn{<namelist_name>} is the name of the namelist. The namelist ends
with the slash \vn{"/"} tag. Anything outside of this is
ignored. Within the namelist, anything after an exclamation mark
\vn{"!"} is ignored including the exclamation mark. \vn{<var1>},
\vn{<var2>}, etc. are variable names. Example:
\begin{code}
&place 
  section = 0.0, "arc_std", "elliptical", 0.045, 0.025 
/
\end{code}
here \vn{place} is the namelist name and \vn{section} is a
variable name.  Notice that here \vn{section} is a ``structure'' which
has five components -- a real number, followed by two strings,
followed by two real numbers.

Everything is case insensitive except for quoted strings.

Logical values are specified by \vn{True} or \vn{False} or can be
abbreviated \vn{T} or \vn{F}. Avoid using the dots (periods) that one
needs in Fortran code.

\newpage

%------------------------------------------------------------------
\Section{Master Input File}
\label{s:input}

The \vn{master input file} holds the parameters needed for running the long term tracking
program. The master input file must contain a single namelist (\sref{s:namelist}) named \vn{params}.
Example:
\begin{code}
&params
  ! Input
  ltt%lat_file   =  "lat.bmad"     ! Bmad lattice file
  ltt%ramper_on = False
  ltt%ramper_start_time = 0

  ! Output parameters
  ltt%particle_output_file = "snap.dat"
  ltt%beam_binary_output_file = "beam.dat"
  ltt%averages_output_file = "average.dat"
  ltt%sigma_matrix_output_file = "sigma.dat"
  ltt%custom_output_file = ""
  ltt%averages_output_every_n_turns = 200
  ltt%particle_output_every_n_turns = 200
  ltt%only_live_particles_out = T
  ltt%averaging_window = 1
  ltt%print_on_dead_loss = -1
  ltt%map_file_prefix = "ltt"

  ltt%column(1) = "n_turn", "N_turn", "i7"
  ltt%column(2) = "rf0##1[voltage]", "Volt", "f10.0"
  ltt%column(3) = "rf0##1[phi0] + z/rf0##1[rf_wavelength]", "dPhi", "f12.8"

  ! Simulation parameters
  ltt%simulation_mode    = "BEAM"
  ltt%tracking_method    = "BMAD"
  ltt%ele_start          = ""
  ltt%ele_stop           = ""            ! Used for "CHECK" simulation_mode 
  ltt%n_turns            = 1000
  ltt%map_order          = 5
  ltt%rfcavity_on        = True
  ltt%timer_print_dtime  = 300
  ltt%random_seed        = 0
  ltt%ptc_aperture       = 0.1, 0.1
  ltt%exclude_from_maps  = "beambeam::*"
  ltt%split_bends_for_radiation = False
  ltt%symplectic_map_tracking = False
  ltt%dead_cutoff        = -1
  ltt%b_emittance        = 1e-9          ! Used with space charge calc.
  ltt%debug              = F
  ltt%mpi_runs_per_subprocess = 4
  bmad_com%spin_tracking_on = T          ! See Bmad manual for 
  bmad_com%radiation_damping_on = F      !    bmad_com parameters.
  bmad_com%radiation_fluctuations_on = F 
  bmad_com%space_charge_on = F

  ! Beam initialization
  ltt%add_closed_orbit_to_init_position = True
  beam_init%use_particle_start_for_center = F
  beam_init%center = 0, 0, 0, 0, 0, 0
  beam_init%n_particle = 10
  beam_init%spin = 0, 0, 0        ! See Bmad manual for 
  beam_init%a_emit = 1e-8         !    beam_init_struct parameters.
  beam_init%b_emit = 1e-8
  beam_init%sig_z = 1e-4
  beam_init%sig_pz = 1e-4
/
\end{code}

\newpage

The namelist parameters can be divided into three categories: Input files, output parameters, and
simulation parameters.

%----------------------------------------------------
\subsection{Input Files}

The input files that can be specified in the \vn{params} namelist of the master input file are:
\begin{description}
\item[ltt\%lat_file] \Newline
Name of the Bmad lattice file to use. This name is required.
\end{description}

%----------------------------------------------------
\subsection{Output Parameters}
\label{s:out.params}

Parameters in the master input file that affect the output are:
\begin{description}
\item[ltt\%averages_output_every_n_turns] \Newline
Sets the number of turns between data rows specified by:
\begin{code}
  ltt%averages_output_file
  ltt%sigma_matrix_output_file
  ltt%custom_output_file
\end{code}
If set to -1 (the default), the output will only happen at the last turn. If set to 0, output will
happen on the beginning turn (turn 0) and the last turn. Example:
\begin{code}
  ltt%averages_output_every_n_turns = 1000
\end{code}
In this example, output will happen every 1000 turns.  Also see: \vn{particle_output_every_n_turns}.
%
\item[ltt\%averaging_window] \Newline
Number of turns to average over when computing beam sigma matrix and averaged positions. Default is
1. This affects the files specified by: 
\begin{code}
  ltt%averages_output_file
  ltt%sigma_matrix_output_file
\end{code}

For example:
\begin{code}
  ltt%averages_output_every_n_turns = 1000
  ltt%averaging_window = 201
  ltt%n_turns = 20040
\end{code}
This would average over 201 turns and this averaging would be done every 1000 turns. That is, the
beam sigma matrix and position is output every 1000 turns and the sigma matrix and position numbers
for, say, turn 6000 are computed by averaging over all particle positions in the window from turn
5900 through turn 6100. The averaging window used with turn 0 will be the half interval from 0
through \vn{(ltt%averaging_window-1)/2}. The number of turns averaged over for the last point will
extend from \vn{n_last - (ltt%averaging_window-1)/2} up through \vn{ltt%n_turns} where \vn{n_last}
is the number of turns of the nominal ``center'' of the last averaging window. In the above example,
\vn{n_last} will be 20000 and the averaging window will extend from turn 19900 through 20040. The
value of \vn{ltt%averaging_window} should be set to an odd number. If the value of
\vn{ltt%averaging_window} is even, the effective averaging window with will be one more than the set
number.
%
\item[ltt\%beam_binary_output_file] \Newline
Used with \vn{ltt%simulation_mode} set to \vn{"BEAM"}. This parameter sets the name of the file
that is created to hold the particle positions at the end of tracking. This is similar to
\vn{ltt%particle_output_file} but here the file will be a binary file that is portable to other
programs and can also be used as input to the \ltt program.
%
\item[ltt\%averages_output_file] \Newline
Used with \vn{ltt%simulation_mode} set to \vn{"BEAM"}. The name of the file that contain orbital
and spin positions averaged over all the particles of the bunches as well as the six bunch size sigmas
($\sigma_x$, $\sigma_{px}$, etc.).  Each line in the file represents the averages at the end of a
turn and a new line is added every \vn{ltt%averages_ouput_every_n_turns} number of turns. If
\vn{ltt%averages_output_file} is blank, no averages file is produced. Data is always recorded when
the beam is at the \vn{ltt%ele_start} position independent of where the lattice begins and
ends. To reduce noise, the \vn{ltt%averaging_window} parameter can be set appropriately.
Note: The file \vn{ltt%sigma_matrix_output_file} will show the 6x6 sigma matrix.
%
\item[ltt\%custom_output_file]\Newline
A custom output file can be created that records beam and lattice parameters every $N$\Th turn where
$N$ is set by \vn{ltt%averages_output_every_n_turns}. Columns are specified by setting
\vn{ltt%column(<i>)}. The general syntax is:
\begin{code}
  ltt%column(<i>) = "<expression>", "<header-name>",  "<format>"
\end{code}
where \vn{<i>} is the column index, \vn{<expression>} is an arithmetical expression that determines
the values displayed in the column, \vn{<header-name>} is a descriptive string used in constructing
the header line (first line) in the file, and \vn{<format>} is the format specifier used when
converting the value of an expression into a string. Example:
\begin{code}
  ltt%column(1) = "n_turn", "N_turn", "i7"
  ltt%column(2) = "rf0##1[voltage]", "Volt", "f10.0"
  ltt%column(3) = "rf0##1[phi0] + z/rf0##1[rf_wavelength]", "dPhi", "es12.8"
\end{code}
Here three columns are specified. Parameters that are used in a column's \vn{<expression>} can be element
attributes or beam quantities. Using element attributes can be helpful when ramping is used. In the above
example, the second column's expression is the \vn{voltage} of the first element named \vn{rf0} in the
lattice (see the Bmad manual for lists of element parameters). Other parameters are:
\begin{code}
  n_turn    -- Turn number
  time      -- Time at the N\Th turn averaged over the beam.
  x, px, y, py, z, pz
            -- Particle phase space averaged over the beam.
\end{code}
Thus the third column in the above example is the averaged particle phase with respect to the zero
crossing phase of the first element named \vn{rf0} in the lattice. [Note that $z$ is always evaluated
at the start of the turn and not at the position of the RF cavity.]
%
\item[ltt\%exclude_from_maps] \Newline
List of elements to exclude when constructing maps for \vn{SLICK} tracking. These elements will be
individually tracking. The default value is \vn{"beambeam::*"} which excludes any \vn{beambeam}
element. See the Bmad manual section on ``\vn{Matching to Lattice Element Names}'' for details on
the format for such lists.
%
\item[ttl\%map_file_prefix] \Newline
Prefix, including possible directory specification, for creating files in which maps are saved. Map
files are used to quickly retrieve maps previously computed in prior running of the program. The
default prefix is \vn{"ltt"}.  The general form of a map file name is
\begin{code}
<map_file_prefix>.<hash>.map
\end{code}
where \vn{<hash>} is a hash string that represents input parameters (like the order of the map) used
to compute the map(s). This hash string is used so that map(s) constructed with one set of
parameters are not used if the parameters are changed.
%
\item[ltt\%only_live_particles_out] \Newline
If this parameter is True (the default), dead particles will not be recorded in the
\vn{ltt%particles_ouput_file}. If set to False, all particles will be recorded. Note: The last
column of this file indicates if the particle is alive or dead.
%
\item[ltt\%particle_output_every_n_turns] \Newline
Sets the number of turns between particle position data files.
If set to -1 (the default), a file will only be generated at the last turn. If set to 0, a file 
will be generated at the beginning turn (turn 0) and at the last turn. Example:
\begin{code}
  ltt%particle_output_every_n_turns = 1000
\end{code}
In this example, output will happen every 1000 turns.
Also see: \vn{averages_output_every_n_turns}.
%
\item[ltt\%particle_output_file] \Newline
Used with \vn{ltt%simulation_mode} set to \vn{"BEAM"}. The name of the ASCII file or files that are
created to hold the particle positions. A file is created every \vn{ltt%particle_ouput_every_n_turns}
turns. See Section~\sref{s:part.out} for more details. If \vn{ltt%particle_ouput_file} is blank, no
particle output file is created. See also \vn{ltt%beam_binary_output_file} which will produce a
portable binary file.
%
\item[ltt\%print_on_dead_loss] \Newline
After each turn, the number of particles that are still living (have not hit an aperture) are
counted and if the percentage of particles that have died, counting from the last time a message was
printed, is larger than \vn{ltt%print_on_dead_loss}, a message is printed. For example, if
\vn{ltt%print_on_dead_loss} is set to 0.01, every time the beam loses 1\% of the particles a message is printed.
Default is -1 which will cause a message printed every turn where there is particle loss.
%
\item[ltt\%ptc_aperture] \Newline
The PTC code does not have apertures. This being the case, for \vn{ltt%tracking_method} set to
\vn{"MAP"} or \vn{"PTC"}, \vn{ltt%ptc_aperture}, which is a 2-vector, defines \vn{x} and \vn{y}
apertures. The default is 0.1~meter in both the horizontal and vertical. When used, the aperture is
applied at the beginning/end of the lattice. PTC has an internal aperture of 1.0~meter. To be safe,
the \ltt program will additionally impose a 0.9~meters aperture independent of the setting of
\vn{ltt%ptc_aperture}.
%
\item[ltt\%sigma_matrix_output_file] \Newline
String specifying the name of the file to create to hold the calculated 6x6 sigma matrix. If blank (the
default), no sigma matrix file will be created. The 6x6 sigma matrix $\boldsymbol{\sigma}$ is a
measure of the beam size defined by
\begin{equation}\large
  \sigma_{ij} = \left< dr_i \, dr_j \right>
\end{equation}
where $\bf dr$ is the deviation of the particle phase space position from the average and $<\ldots>$
denotes an average over all particles. 

With \vn{ltt%simulation_mode} set to \vn{"BEAM"}, Each line in the file represents the averages at
the end of a turn and a new line is added every \vn{ltt%ouput_every_n_turns} number of turns. With
\vn{ltt%simulation_mode} set to "SINGLE"), The average is done over all the turns. Data is always
recorded when the beam is at the \vn{ltt%ele_start} position independent of where the lattice
begins and ends.

Also see the \vn{ltt%averages_output_file} parameter.

\end{description}

%----------------------------------------------------
\subsection{Simulation Parameters}
\label{s:sim.params}

Parameters in the master input file that affect the simulation are:
\begin{description}

\item[ltt\%add_closed_orbit_to_init_position] \Newline
If set \vn{True} (the default), initial particle positions are set equal to the input particle positions
plus the closed orbit position. See Section~\sref{s:init.pos}.
%
\item[beam_init\%...] \Newline
This sets the initial beam distribution. See Section~\sref{s:init.pos}. 

If spin tracking is on (\vn{bmad_com%spin_tracking_on} = T), and if all three components of
\vn{beam_init%spin} are zero, the closed orbit spin direction ($n_0$) is used.

Also: the values of \vn{beam_init%a_emit} and \vn{beam_init%b_emit} are used in the high energy
space charge calculation (\sref{s:space.charge}). If set to zero (the default) or negative, the
emittance as calculated via radiation integrals will be used. Note: A value of

%
\item[bmad_com\%...] \Newline
The \vn{bmad_com} structure contains various parameters that affect tracking. For example, whether
radiation damping and fluctuations are included in tracking. A full list of \vn{bmad_com} parameters
is detailed in the Bmad reference manual. The \vn{bmad_com%space_charge_on} logical can be used to
turn on/off ultra-relativistic space charge effects. See section~\sref{s:space.charge} for more
details. Note: \vn{bmad_com} parameters can be set in the Bmad lattice file as well. \vn{Bmad_com}
parameter set in the master input file will take precedence over parameters set in the lattice file.
%
\item[ltt\%dead_cutoff] \Newline
Sets the cutoff for the number of dead particles below which the simulation will stop. For example,
if \vn{ltt%dead_cutoff} is set to 0.01, when 1\% of the beam has been lost the simulation will stop. The
default value for \vn{ltt%dead_cutoff} is zero.
%
\item[ltt\%debug] \Newline
This parameter is used for debugging the program. This is not of interest to the general user.
%
\item[ltt\%ele_start] \Newline
Name or element index of the element to start the tracking. Examples:
\begin{code}
  ele_start = "Q3##2"   ! 2nd element named Q3 in the lattice.
  ele_start = 37        ! 37th element in the lattice.
\end{code}
The default is to start at the beginning of the lattice. Notice that the tracking starts at the
downstream end of the element so the first element tracked through is the element after the chosen
one. Also see \vn{ltt%ele_stop}.
%
\item[ltt\%ele_stop] \Newline
Used when \vn{ltt%simulation_mode} is set to \vn{"CHECK"}. \vn{ttl%ele_stop} sets the stopping
point for tracking to be the downstream edge of the element. Also see \vn{ltt%ele_start}. Default
if not set or set to a blank string is for \vn{ltt%ele_stop} to be equal to \vn{tll%ele_start}.
%
\item[ltt\%map_order] \Newline
Map order. See Section~\sref{s:track.methods}. The default is what is set in the lattice
file and if not set in the lattice file the default is 3. Note: \vn{ltt%map_order} is only used when
generating a map.  When a map is read in from a file, the order of this map is independent of the
current setting of \vn{ltt%map_order}.
%
\item[ltt\%mpi_runs_per_subprocess] \Newline
Only used when the MPI version of the \ltt program is used (\sref{s:intro}). This parameter
determines the number of times, on average, the simulation will be run in a given subprocess. The
default value is 4. For example, if there are 11 subprocesses, one of these will be designated the
``master'' subprocess and will just be responsible for collecting the data together. The other 10
subprocesses will run simulations. If, say, there are 1M particles in each of two bunches, and if
\vn{ltt%mpi_runs_per_subprocess} has the default value of 4, then each simulation will use 50K
particles (= 2 * 1M / (4 * 10)) and each of the 10 subprocesses will run the simulation about 4
times. The reason why the work is broken up this way is to minimize the effect that one slow
subprocess can have on the simulation time.
%
\item[ltt\%n_turns] \Newline
Number of turns to track. See Section~\sref{s:track.methods}.
%
\item[ltt\%ramping_on] \Newline
If set to True, \vn{ramper} control elements will be use to modify the lattice during tracking
(\sref{s:ramp}). Default is False.
%
\item[ltt\%ramper_start_time] \Newline
The starting (offset) time used to set \vn{ramper} elements. This enables simulations to start in the middle
of a ramp cycle. Default is 0.
%
\item[ltt\%random_seed] \Newline
The random number seed used by the random number generator. If set to 0, the
system clock will be used. That is, if set to 0, the output results will vary from run to run.
%
\item[ltt\%rfcavity_on] \Newline
If set to \vn{False}, the voltage on all RF cavity elements will be turned off. Default is \vn{True}.
%
\item[ltt\%simulation_mode] \Newline
Sets the simulation mode for the program. See Section~\sref{s:sim.modes} for more details.
%
\item[ltt\%split_bends_for_radiation] \Newline
Use a radiation point in the middle of all the bends instead of including radiation effects in the
transport maps? Default is False.
%
\item[ltt\%symplecitic_map_tracking]\Newline
If False (the default), the maps used for tracking will be a set of truncated Taylor series
polynomials. If True, the tracking maps will be derived from the Taylor map by partially inverting
it forming an implicit symplectic map. The advantage of the symplectic map is that it is symplectic.
The disadvantage is that, being an implicit map, the computation time will be longer.
%
\item[ltt\%timer_print_dtime] \Newline
The program will print a tracking status message every so often. The nominal time between status
messages is set by \vn{ltt%timer_print_dtime} which is a number in seconds.
%
\item[ltt\%tracking_method] \Newline
String switch which sets how particles are tracked when the \vn{simulation_mode} is set to
"\vn{BEAM}" or "\vn{SINGLE}". Possible settings are:
\begin{code}
  "MAP"     ! Tracking using maps.
  "PTC"     ! Element-by-element tracking with PTC. Slow.
  "BMAD"    ! Element-by-element tracking using Bmad. Default. Slow.
\end{code}
See sections \sref{s:map} and \sref{s:track.methods} for more details.
\end{description}

%------------------------------------------------------------------
\Section{Simulations with Ultra-Relativistic Space Charge Effects}
\label{s:space.charge}

A space charge kick can be applied in the simulation. The space charge kick is calculated using an
approximation suitable at ultra-relativistic energies. The kick is turned on by setting the logical
\vn{bmad_com%space_charge_on} to \vn{True} (default is \vn{False}. See the Bmad manual documentation
on \vn{bmad_com%space_charge_on} for more details. The high energy space charge kick is only applied when 
\vn{ltt%tracking_method} is set to \vn{"BMAD"}.

The $a$ and $b$ mode emittances are used as input to the space charge calculation. [If there is no
coupling, the $a$ mode corresponds to the ``horizontal'' mode and the $b$ mode corresponds to the
``vertical'' mode.] These emittance can be specified by setting \vn{beam_init%a_emit} and/or
\vn{beam_init%b_emit}. If set to zero or negative, an emittance is calculated using a radiation
integral calculation. Additionally, the longitudinal beam size is calculated via radiation integrals.

%------------------------------------------------------------------
\Section{Particle Data Output}
\label{s:part.out}

The following describes the particle data output format. Particle data is outputted when the
\vn{ltt%simulation_mode} is set to \vn{"BEAM"}.

Particle data is always recorded when the beam is at the \vn{ltt%ele_start} position independent of
where the lattice begins and ends.

An output data file will be produced every \vn{ltt%particle_output_every_n_turns} turns. Each line
in this file records a particle's orbital and spin position. The name of the data file is derived
from the \vn{ltt%particle_output_file} string.  If \vn{ltt%particle_output_file} contains a hash
character ''\#'', the data file name is formed by substituting the turn number for the hash
token. If there is no hash character, the data file name is formed by appending the turn number to
the \vn{ltt%particle_output_file} string. If there are multiple bunches, instead of using the turn
number, the substituted string will be of the form
\begin{code}
  \{bunch index\}-\{turn number\}
\end{code}

Nominally particle data is recorded every \vn{ltt%particle_output_every_n_turns} number of turns. However, if
\vn{ltt%particle_output_every_n_turns} is set to 0, particle data is recorded only at the start and end of
the tracking. If \vn{ltt%particle_output_every_n_turns} is set to -1, particle data is only recorded at the
end of tracking.

%------------------------------------------------------------------
\begin{thebibliography}{9}

\bibitem{b:bmad}
D. Sagan,
``Bmad: A Relativistic Charged Particle Simulation Library''
Nuc.\ Instrum.\ \& Methods Phys.\ Res.\ A, {\bf 558}, pp 356-59 (2006).

\bibitem{b:ptc}
É. Forest, Y. Nogiwa, and F. Schmidt. The FPP and PTC libraries. In Int.\ Conf.\ Accel.\
Phys pp 17–21, (2006).

\end{thebibliography}

\end{document}

