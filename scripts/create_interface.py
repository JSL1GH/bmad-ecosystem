#!/usr/bin/env python

# Script to read in Fortran structures and create:
#   Fortran bind(c) version.
#   C version
#   Translators between Fortran original structure and bind(c) version.
#   Translators between C version and C++ version

import sys
import shutil
import os
import copy

##################################################################################
##################################################################################
# Class defs

class f_var_class:

  def __init__(self):
    self.name = ''
    self.type = ''
    self.pointer_type = '-'    # 'pointer', 'allocatable'
    self.array = ''            # [':', ':'] or ['6']
    self.init_value = ''
    self.comment = ''
    
  def __repr__(self):
    return '[%s, %s, %s, %s, %s]' % (self.type, self.pointer_type, self.name, self.array, self.init_value)

class f_struct_def_class:
  def __init__(self):
    self.name = ''
    self.var = []

  def __repr__(self):
    return '[name: %s, #var: %i]' % (self.name, len(self.var))

##################################################################################
##################################################################################
# Translations

f_type_to_bind_c = {
            'real(rp)'    : 'real(c_double)',
            'complex(rp)' : 'complex(c_double_complex)',
            'integer'     : 'integer(c_int)',
            'logical'     : 'logical(c_bool)'}

##################################################################################
##################################################################################
# Get the list of structs

f_struct_list_file = open('fortran_structs.list')

f_struct_def = {}
f_struct_list = []
f_module_files = []

for line in f_struct_list_file:
  line = line.strip()
  if len(line) == 0: continue
  split_line = line.split()

  if split_line[0] == 'FILE:':
    f_module_files.append(split_line[1])
  else:
    f_struct_list.append(split_line)
    f_struct_def[line.split()[0]] = f_struct_def_class()

f_struct_list_file.close()

### print f_struct_list

##################################################################################
##################################################################################
# Parse structure definitions

# Current restrictions: Syntax to avoid:
#   Spaces in type def: "real (rp)"
#   Multiple inits: "real a = 5, b = 7"
#   No space after type: "type(abc_struct)"
#   Space between var name and array def: "arr (:)"

for file_name in f_module_files:
  f_module_file = open('../../' + file_name)

  for line in f_module_file:
    split_line = line.split()
    if len(split_line) < 2: continue
    if split_line[0] != 'type': continue
    if not split_line[1] in f_struct_def: continue

    struct_name = split_line[1]
    f_struct_def[struct_name].name = struct_name

    # Now collect the struct variables

    for line in f_module_file:
      var = f_var_class()

      part = line.partition('!')
      var.comment = part[2].strip()

      part = part[0].partition('=')
      var.init_value = part[2].strip()
      if var.init_value[:1] == '>': var.init_value = ''  # Ignore pointer "=> null()" init.

      split_line = part[0].replace(',', ' ').replace('::', ' ').split()
      if len(split_line) == 0: continue
      if split_line[0:2] == ['end', 'type']: break

      var.type = split_line.pop(0)
      if var.type == 'type': var.type = 'type:' + split_line.pop(0)[1:-1]

      if split_line[0] == 'allocatable' or split_line[0] == 'pointer':
        var.pointer_type = split_line.pop(0)

      # Handle lines like: "real(rp) kx, ky, kz"

      for name in split_line:
        var = copy.copy(var)
        var.name = name
        part = var.name.partition('(')
        var.name = part[0]
        var.array = part[2][:-1]     # Remove last ')'
        f_struct_def[struct_name].var.append(var)
        
  f_module_file.close()

##################################################################################
##################################################################################
# As a check, write results to file. 

f_out = open('f_structs.parsed', 'w')

for struct in f_struct_def:
  f_out.write('******************************************\n')
  f_out.write (struct + '    ' + str(len(f_struct_def[struct].var)) + '\n')
  for var in f_struct_def[struct].var:
    f_out.write ('    ' + str(var) + '\n')

f_out.close()

##################################################################################
##################################################################################
# Create Fortran side of interface

f_out = open('../cpp_interface/bmad_and_cpp_mod.f90', 'w')

f_out.write ('''
!+
! Fortran side of the Bmad / C++ interface.
!
! File Generated by: create_interface.py
! Do not edit this file directly! 
!-

module bmad_and_cpp_mod

use bmad_struct
use bmad_interface
use fortran_and_cpp_mod

contains

''')

for struct in f_struct_def:
  s_name = struct[0:-7]  # Strip off ending "_struct"
  # Count simple reals and ints


  f_out.write ('''
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine zzz_to_c (f_zzz, c_zzz) bind(c)
!
! Routine to convert a Bmad zzz_struct to a C++ C_zzz
!
! Input:
!   f_zzz -- type (c_ptr), value :: Input Bmad zzz_struct structure.
!
! Output:
!   c_zzz -- type(c_ptr), value :: Output C++ C_zzz struct.
!-

subroutine zzz_to_c (f_zzz, c_zzz)

implicit none

interface
  subroutine zzz_to_c2 (c_zzz, c_real_arr, c_int_arr)
    import fortran_and_cpp_mod
    type (c_ptr), value :: c_zzz, c_int_arr, c_real_arr
    type (c_ptr), value
  end subroutine
end interface

type (zzz_struct), pointer :: f_zzz
type (c_ptr), value :: c_zzz
'''.replace('zzz', s_name))

  
  f_out.write ('abc')

#real(c_double) c_real_arr(NNN)
#integer(c_int) c_int_arr(MMM)

  f_out.write ('''
!

c_real_arr = [f_zzz%, ...]
c_in_arr = [f_zzz%, ...]

call zzz_to_c2 (c_zzz, c_real_arr, c_int_arr)

end subroutine zzz_to_c
'''.replace('zzz', s_name))


f_out.write('end module\n')

##################################################################################
##################################################################################
# Create Fortran bind(c) struct version

f_out = open('../cpp_interface/bmad_bind_c_mod.f90', 'w')

f_out.write ('''
!+
! Fortran bind(c) structures used for the Bmad / C++ interface.
!
! File Generated by: create_interface.py
! Do not edit this file directly! 
!-

module bmad_bind_c_mod

use iso_c_binding

''')

for key, struct in f_struct_def.iteritems():
  f_out.write('\n')
  f_out.write('!---------------------------------------------------------------------------\n')
  f_out.write('\n')
  f_out.write('type, bind(c) :: ' + key.replace('_struct', '_bind_c') + '\n')

  for struct in f_struct_list:
    var = f_struct_def[struct]

    if var.type[0:5] == 'type:':
      line = var.type.replace(':', ' (') + ')'
    else:
      line = f_type_to_bind_c(var.type)

    if var.pointer_type == '-':
      
    else:

f_out.write('\n')
f_out.write('end module\n')


f_out.close()

##################################################################################
##################################################################################
# Create C struct version

##################################################################################
##################################################################################
# Create C++ class version

!---------------------------------------------------------------------------
!---------------------------------------------------------------------------
!---------------------------------------------------------------------------
!+
! Subroutine
''')


f_out.close()

##################################################################################
##################################################################################
# Create C++ side of interface

##################################################################################
##################################################################################
# Create Fortran struct equality check code

##################################################################################
##################################################################################
# Create C++ class equality check code

##################################################################################
##################################################################################
# Create interface check code

