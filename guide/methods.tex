\chapter{Tracking and Transfer Matrix Calculation Methods}

Typically there are several ways to do tracking and transfer matrix
calculations for a given element type within \bmad\. What method is used
is selected on an element--by--element basis using
an elements \vn{tracking_method} and \vn{mat6_calc_method} attributes 
(mat6 refers to the size of the 6 by 6 transfer matricies). By supplying
the appropriate routines a programmer can extend \bmad\ to do customized 
tracking.

%----------------------------------------------------------------------------
\section{Tracking Methods}
\label{s:tkm}

Adaptive step size control used with the \vn{Adaptive_Boris} and
\vn{Runge_Kutta} integrators means that instead of taking fixed step sizes
the integrator chooses the proper step size so that the error in the
tracking is below the maximum alowable error set by \vn{rel_tol} and
\vn{abs_tol} tolerances. The advantage of step size control is that
the integrator is smarter about using a smaller step size when needed
but making larger stepswhen it can. The disadvantage is that a step is
more computationally intensive since the error in a step is estimated by
repeating a step using two mini steps.

\begin{description}
\item[Adaptive\_Boris]
Second order Boris integration\cite{boris} with adaptive step size control.
This should be nearly symplectic but slow.

\item[Boris]
Second order Boris Integration. Like \vn{Runge_Kutta} \vn{Boris} does
tracking by integrating the equation of motion. The difference is that
Boris integration is symplectic.

\item[Bmad\_Standard]
Uses formulas for tracking. The emphesis here is on speed and not
symplecticity. Appropriate when you are interested in single turn
stuff. May be appropriate for long term tracking depending upon how
many turns are tracked and what kind of elements are involved. 

\item[Custom]
This method will call a routine \vn{track1_custom} which can be supplied by
the user. The default \vn{track1_custom} supplied with the BMAD release will
print an error message if it is called which indicates a program linking problem.

\item[Linear]
Linear just uses the 0th order vector with the 1st order 6x6 transfer
matrix for an element. Very simple.  Depending upon how the transfer
matrix was generated this might or might not be symplectic.

\item[Runge\_Kutta]
This uses a 4th order Runge Kutta integration algorithm with adaptive
step size control.  This is essentially ODEINT adopted from Numerical
Recipes\cite{nr}. This may be slow but it should be accurate. This method is
non-symplectic.

\item[Symp\_Lie\_Bmad]
Symplectic tracking using a Hamiltonian with Lie operation techniques.
This is similar to \vn{Symp_Lie_PTC} (see below) except this uses a
BMAD routine.  The difference between this and \vn{Symp_Lie_PTC} is
\vn{Symp_Lie_Bmad} is about a factor of 10 faster but \vn{Symp_lie_Bmad}
has
that PTC tries do do things correctly while BMAD goes for speed by
making approximations like the small angle approximation, etc. Right
now only implemented for Wigglers.

\item[Symp\_Lie\_PTC]
Symplectic tracking using a Hamiltonian with Lie operation techniques.
This uses Etienne's PTC software for the calculation. This method is
symplectic but can be slow. See below for additional switches that affect this
calculation. This method can only be used on elements that have a Hamiltonian.
Quadrupoles, Solenoids, and most other element types have Hamiltonians. A
Hybrid element is an  example where there is no Hamiltonian.

\item[Symp\_Map]
This uses an implicit (partially inverted) Taylor map.
Since the map is implicit a Newton search method must be used. This will slow
things down from the Taylor method but this is guaranteed symplectic.

\item[Taylor]
This uses a Taylor map generated from Etienne's PTC package. Generating
the map may take time but once you have it it should be very fast. One
possible problem with using a Taylor series is that you have to worry about
the accuracy if you do tracking at points that are far from the point about
which the series was made. This method is non-symplectic. See below for
additional switches that affect this calculation.

\item[Wiedemann]
This is Wiedemann's hard edge model of a wiggler.

\end{description}

\vfill \break

\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|} \hline
\rule{0pt}{80pt} &
\begin{sideways}\vn{Adaptive_Boris}\end{sideways} &
\begin{sideways}\vn{BMAD_Standard}\end{sideways} &
\begin{sideways}\vn{Boris}\end{sideways} &
\begin{sideways}\vn{Custom}\end{sideways} &
\begin{sideways}\vn{Linear}\end{sideways} &
\begin{sideways}\vn{Runge_Kutta}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_Bmad}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_PTC}\end{sideways} &
\begin{sideways}\vn{Symp_Map}\end{sideways} &
\begin{sideways}\vn{Taylor}\end{sideways} &
\begin{sideways}\vn{Wiedemann}\end{sideways}
\\ \hline
  \vn{ab_multipole}            & & D & & & & & & & & & \\ \hline 
  \vn{beambeam}                & & D & & & & & & & & & \\ \hline 
  \vn{custom}                  & & D & & & & & & & & & \\ \hline 
  \vn{drift}                   & & D & & & & & & & & & \\ \hline 
  \vn{ecollimator}             & & D & & & & & & & & & \\ \hline 
  \vn{elseparator}             & & D & & & & & & & & & \\ \hline 
  \vn{hkicker}                 & & D & & & & & & & & & \\ \hline 
  \vn{instrument}              & & D & & & & & & & & & \\ \hline 
  \vn{kicker}                  & & D & & & & & & & & & \\ \hline 
  \vn{lcavity}                 & & D & & & & & & & & & \\ \hline 
  \vn{marker}                  & & D & & & & & & & & & \\ \hline 
  \vn{monitor}                 & & D & & & & & & & & & \\ \hline 
  \vn{multipole}               & & D & & & & & & & & & \\ \hline 
  \vn{octupole}                & & D & & & & & & & & & \\ \hline
  \vn{patch}                   & & D & & & & & & & & & \\ \hline
  \vn{quadrupole}              & & D & & & & & & & & & \\ \hline
  \vn{rbend}                   & & D & & & & & & & & & \\ \hline
  \vn{rcollimator}             & & D & & & & & & & & & \\ \hline
  \vn{rfcavity}                & & D & & & & & & & & & \\ \hline
  \vn{sbend}                   & & D & & & & & & & & & \\ \hline
  \vn{sextupole}               & & D & & & & & & & & & \\ \hline
  \vn{solenoid}                & & D & & & & & & & & & \\ \hline
  \vn{sol_quad}                & & D & & & & & & & & & \\ \hline
  \vn{taylor}                  & & D & & & & & & & & & \\ \hline
  \vn{vkicker}                 & & D & & & & & & & & & \\ \hline
  \vn{wiggler} (periodic type) & & D & & & & & & & & & \\ \hline
  \vn{wiggler} (map type)      & & D & & & & & & & & & \\ \hline
\end{tabular}

\vfill \break

%----------------------------------------------------------------------------
\section{Transfer Matrix Calculation Methods}
\label{s:xfer}

\begin{description}

\item[\vn{Bmad\_Standard}]
This is meant to be quick and dirty. It tries to be symplectic but this
is not guaranteed. Sextupoles and octupoles are done using a simple
kick-drift-kick model.

\item[\vn{Custom}]
This method calls a routine \rn{make_mat6_custom} which may be supplied
by the user (which must have been linked into whatever program is
running).  The default \rn{make_mat6_custom} supplied by the \bmad\ release
will use Runge Kutta tracking. 

\item[\vn{Symp\_Lie\_Bmad}]
Symplectic integration using a Hamiltonian and Lie operators. The
difference between this and \vn{Symp_lie_PTC} is that PTC tries to do things
correctly while \bmad\ goes for speed by making approximations like the small
angle approximation, etc. Right now only implemented for Wigglers.

\item[\vn{Symp\_Lie\_PTC}]
Symplectic integration using a Hamiltonian and Lie operators.
This uses Etienne's PTC software for the calculation.
This method is symplectic but can be slow. See below for additional switches
that affect this calculation. This method can only be used on elements that
have a Hamiltonian. Quadrupoles, Solenoids, and most other element types have
Hamiltonians. A Hybrid element is an example where there is no Hamiltonian.

\item[\vn{Taylor}]
This uses a Taylor map generated from Etienne's PTC package. Generating
the map may take time but once you have it should be very fast. One
possible problem with using a Taylor series is that you have to worry about
the accuracy of the series if you calculate the Jacobian about a point that is
far from the point about which the series was made. This method is
non-symplectic. See below for additional switches that affect this
calculation.

\item[\vn{Tracking}]
This uses the tracking method set by \vn{tracking_method} to track 6
particles around the central orbit. This method is susceptible to inaccuracies
caused by nonlinearities. Furthermore this method
is almost surely slow. While non--symplectic, the advantage of this method
is that it is directly related to any tracking results.

\end{description}

Symplectic integration is like ordinary integration of a function f(x)
but what is integrated here is the Hamiltonian H(y) where y here could
be a 6-dimensional vector (for tracking) or be a taylor series (for
the mat6 calculation). The order at which a Taylor series is truncated
at is set by \vn{taylor_order} (this is a global variable). Like
ordinary integration there are various formulas that one can use to do
symplectic integration. In \bmad\ (or more precisely Etienne's PTC)
you can use one of 3 methods. This is set by \vn{integration_ord}. 
\vn{integration_ord} = n (n = 2, 4, or 6)
means that the error scales as $dz^n$ where $dz$ is the integration step
size. The step size dz is set by the length of the element and the
value of \vn{num_steps}. Remember, as in ordinary integration, higher
order does not necessarily imply higher accuracy.
