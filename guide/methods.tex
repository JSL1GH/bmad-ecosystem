\chapter{Tracking and Transfer Matrix Calculation Methods}
\label{c:methods}

\index{Element!class}
Typically, there are several ways to do tracking and transfer matrix
calculations for a given element class within \bmad. What method is
used is selected on an element--by--element basis using the attributes
\begin{example}
  tracking_method = Switch   ! Method for tracking.
  mat6_calc_method = Switch  ! Method for 6x6 transfer matrix calculation.
\end{example}
These switches are discussed in more detail in sections \sref{s:tkm} 
and \sref{s:xfer}.

%----------------------------------------------------------------------------
\section{tracking\_method Switches}
\label{s:tkm}
\index{Tracking method|textbf}

Below are listed the methods for the \vn{tracking_method}
attribute with an explanation of what the different methods do. A
table giving which methods are available with which element classes is give
in Table~\ref{t:track_methods}. 

A note on terminology: Adaptive step size control used with the
\vn{Adaptive_Boris} and \vn{Runge_Kutta} integrators means that 
instead of taking fixed step sizes the integrator chooses the proper
step size so that the error in the tracking is below the maximum
allowable error set by \vn{rel_tol} and \vn{abs_tol} tolerances. The
advantage of step size control is that the integrator uses a smaller
step size when needed (the fields are rapidly varying), but makes
larger steps when it can. The disadvantage is that a step is more
computationally intensive since the error in a step is estimated by
repeating a step using two mini steps. If the fields are rather
uniform and you know what a good step size is you can save time by using
a fixed step size.

\begin{description}
\index{Tracking method!Adaptive_Boris}
\item[\vn{Adaptive\_Boris}]
Second order Boris integration\cite{b:boris} with adaptive step size control.
This should be nearly symplectic but slow.

\index{Tracking method!Boris}
\item[\vn{Boris}]
Second order Boris Integration\cite{b:boris}. Like \vn{Runge_Kutta},
\vn{Boris} does tracking by integrating the equation of
motion. \vn{Boris} handles both electric and magnetic fields and does
not assume that the particle is ultra--relativistic. \vn{Boris} preserves
conserved quantities more accurately than \vn{Runge_Kutta}.

\index{Tracking method!Bmad_Standard}
\item[\vn{Bmad\_Standard}]
Uses formulas for tracking. The emphasis here is on speed.

\index{Tracking method!Custom}
\item[\vn{Custom}]
This method will call a routine \vn{track1_custom} which must be
supplied by the programmer implementing the custom tracking. The
default \vn{track1_custom} supplied with the \bmad\ release will print
an error message and stop the program if it is called which probably
indicates a program linking problem.

\index{Tracking method!Linear}
\item[\vn{Linear}]
Linear just uses the 0th order vector with the 1st order 6x6 transfer
matrix for an element. Very simple.  Depending upon how the transfer
matrix was generated this may or may not be symplectic.

\index{Tracking method!MAD}
\item[\vn{MAD}]
This uses the MAD 2nd order transfer map.

\index{Tracking method!None}
\item[\vn{None}]
This prevents the transfer matrix from being recomputed.
Using \vn{None} in the input file is generally not a good idea since
it prevents the matrix from being computed in the first place.
Typically \vn{None} is used internally in a program to prevent recomputation.

\index{Tracking method!Runge_Kutta}
\item[\vn{Runge\_Kutta}]
This uses a 4\Th\ order Runge Kutta integration algorithm with adaptive
step size control.  This is essentially the \vn{ODEINT} subroutine
from Numerical Recipes\cite{b:nr}. This may be slow but it should be
accurate. This method is non-symplectic.

\index{Tracking method!Symp_Lie_Bmad}
\item[\vn{Symp\_Lie\_Bmad}]
Symplectic tracking using a Hamiltonian with Lie operation techniques.
This is similar to \vn{Symp_Lie_PTC} (see below) except this uses a
\bmad\ routine. By bypassing some of the generality inherent in PTC's routines
\vn{Symp_Lie_Bmad} achieves about a factor of 10 improvement in speed over
\vn{Symp_Lie_PTC}. However, \vn{Symp_lie_Bmad} is
currently only implemented for Wigglers.

\index{Tracking method!Symp_Lie_PTC}
\item[\vn{Symp\_Lie\_PTC}]
Symplectic tracking using a Hamiltonian with Lie operator techniques.
This uses Etienne's PTC software for the calculation. This method is
symplectic but can be slow.

\index{Tracking method!Symp_Map}
\item[\vn{Symp\_Map}]
This uses a partially inverted, implicit Taylor map. The calculation
uses Etienne's PTC software.  Since the map is implicit, a Newton
search method must be used. This will slow things down from the Taylor
method but this is guaranteed symplectic.

\index{Tracking method!Taylor}
\item[\vn{Taylor}]
This uses a Taylor map generated from Etienne's PTC
package. Generating the map may take time but once you have it it
should be very fast. One possible problem with using a Taylor map is
that you have to worry about the accuracy if you do tracking at points
that are far from the expansion point about which the map was
made. This method is non-symplectic away from the expansion point. 

\index{Tracking method!Wiedemann}
\item[\vn{Wiedemann}]
This is Wiedemann's hard edge model of a wiggler
\cite{wiedemann}. This model divides a wiggler pole into a constant 
bend rectangular section with drifts at either end. The total length
of the model pole matches the actual pole length of the element. The
strength of the bend and the lengths of the bend and drifts are
adjusted so that the vertical focusing and horizontal deflection are
the same in the modal as with a model assuming a sinusoidally varying
field. \bmad\ augments this model by assuming that the horizontal
deflection varies as the $\sinh$ with vertical offset.  Since
Wiedemann's model does not include longitudinal fields it is not clear
that it can be used for long term tracking.

\end{description}

\vfill \break
{\vfill}

\index{Element!table of class types}
\begin{table}[h]
\centering {
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|} \hline
\rule{0pt}{80pt} &
\begin{sideways}\vn{Adaptive_Boris}\end{sideways} &
\begin{sideways}\vn{Bmad_Standard}\end{sideways} &
\begin{sideways}\vn{Boris}\end{sideways} &
\begin{sideways}\vn{Custom}\end{sideways} &
\begin{sideways}\vn{Linear}\end{sideways} &
\begin{sideways}\vn{MAD}\end{sideways} &
\begin{sideways}\vn{Runge_Kutta}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_Bmad}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_PTC}\end{sideways} &
\begin{sideways}\vn{Symp_Map}\end{sideways} &
\begin{sideways}\vn{Taylor}\end{sideways} &
\begin{sideways}\vn{Wiedemann}\end{sideways}
\\ \hline
%                               AB  BS   B   C   L   M   N  RK  SLB SLP SM   T   W
  \vn{ab_multipole}            &   & D &   & X & X &   &   &   & X & X & X &   \\ \hline 
  \vn{beambeam}                &   & D &   & X & X &   &   &   &   &   &   &   \\ \hline 
  \vn{bend_sol_quad}           &   &   &   &   &   &   &   & D &   &   &   &   \\ \hline 
  \vn{custom}                  & X &   & X & D & X &   & X &   &   &   &   &   \\ \hline 
  \vn{drift}                   & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline 
  \vn{ecollimator}             & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline 
  \vn{elseparator}             & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline 
  \vn{hkicker}                 & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline 
  \vn{instrument}              & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline 
  \vn{kicker}                  & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline 
  \vn{lcavity}                 &   & D &   & X & X &   &   &   &   &   &   &   \\ \hline 
  \vn{marker}                  &   & D &   & X & X &   &   &   & X & X & X &   \\ \hline 
  \vn{match}                   &   & D &   &   &   &   &   &   &   &   &   &   \\ \hline
  \vn{monitor}                 & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline 
  \vn{multipole}               &   & D &   & X & X &   &   &   & X & X & X &   \\ \hline 
  \vn{octupole}                & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline
  \vn{patch}                   &   & D &   & X &   &   &   &   &   &   &   &   \\ \hline
  \vn{quadrupole}              & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline
  \vn{rbend}                   &   & D &   & X & X & X &   &   & X & X & X &   \\ \hline
  \vn{rcollimator}             & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline
  \vn{rfcavity}                &   & D &   & X & X & X &   &   & X & X & X &   \\ \hline
  \vn{sbend}                   &   & D &   & X & X & X &   &   & X & X & X &   \\ \hline
  \vn{sextupole}               & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline
  \vn{solenoid}                & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline
  \vn{sol_quad}                & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline
  \vn{taylor}                  &   & D &   & X & X &   &   &   &   &   &   &   \\ \hline
  \vn{vkicker}                 & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline
  \vn{wiggler} (periodic type) &   & D &   & X & X &   &   &   &   &   &   & X \\ \hline
  \vn{wiggler} (map type)      & X & D & X & X & X &   & X & X & X & X & X &   \\ \hline
\end{tabular}
}
\caption[Table of available {\bf tracking\_method}\ switches for a
given element class.]{Table of available {\bf tracking\_method}\
switches for a given element class. D denotes the default method. X
denotes an available method.}
\label{t:track_methods}
\end{table}

\vfill\break

%----------------------------------------------------------------------------
\section{mat6\_calc\_method Switches}
\label{s:xfer}
\index{Mat6_calc_method|textbf}

Below are listed the methods for the \vn{mat6_calc_method}
attribute with an explanation of what the different methods do. A
table giving which methods are available with which element classes is give
in Table~\ref{t:mat6_methods}. 

For methods that do not necessarily produce a symplectic matrix the
\vn{symplectify} attribute of an element can be set to \vn{True} to
solve the problem. See \sref{s:symp_method}. 

Symplectic integration is like ordinary integration of a function f(x)
but what is integrated here is a Taylor map. Truncating the map to
0\Th\ order gives the particle trajectory and truncating to 1\St\
order gives the transfer matrix (Jacobian).  The order at which a
Taylor series is truncated at is set by \vn{taylor_order} (see
\sref{s:param}. Like ordinary integration there are various
formulas that one can use to do symplectic integration. In \bmad\ (or
more precisely Etienne's PTC) you can use one of 3 methods. This is
set by \vn{integrator_order}.  \vn{integrator_order} = n where $n$ is
allowed by PTC to be 2, 4, or 6. With an integration order of $n$ the
error in an integration step scales as $dz^n$ where $dz$ is step
size. The step size $dz$ is set by the length of the element and the
value of \vn{num_steps}. Remember, as in ordinary integration, higher
integration order does not necessarily imply higher accuracy.

\begin{description}

\index{Mat6_calc_method!Bmad_Standard}
\item[\vn{Bmad\_Standard}]
Uses formulas for the calculation. The emphasis here is on speed

\index{Mat6_calc_method!Custom}
\item[\vn{Custom}]
This method will call a routine \vn{make_mat6_custom} which must be
supplied by the programmer implementing the custom transfer matrix
calculation. The default \vn{make_mat6_custom} supplied with the
\bmad\ release will print an error message and stop the program if it
is called which probably indicates a program linking problem.

\index{Mat6_calc_method!MAD}
\item[\vn{MAD}]
This uses the MAD 2nd transfer map.

\index{Mat6_calc_method!None}
\item[\vn{None}]
This prevents the transfer matrix from being recomputed.
Using \vn{None} in the input file is generally not a good idea since
it prevents the matrix from being computed in the first place.
Typically \vn{None} is used internally in a program to prevent recomputation.

\index{Mat6_calc_method!Symp_lie_Bmad}
\item[\vn{Symp\_Lie\_Bmad}]
A Symplectic calculation using a Hamiltonian with Lie operator techniques.
This is similar to \vn{Symp_Lie_PTC} (see below) except this uses a
\bmad\ routine. By bypassing some of the generality inherent in PTC's routines
\vn{Symp_Lie_Bmad} achieves about a factor of 10 improvement in speed over
\vn{Symp_Lie_PTC}. However, \vn{Symp_lie_Bmad} is
currently only implemented for Wigglers.

\index{Mat6_calc_method!Symp_Lie_PTC}
\item[\vn{Symp\_Lie\_PTC}]
Symplectic integration using a Hamiltonian and Lie operators.
This uses Etienne's PTC software for the calculation.
This method is symplectic but can be slow.

\index{Mat6_calc_method!Taylor}
\item[\vn{Taylor}]
This uses a Taylor map generated from Etienne's PTC
package. Generating the map may take time but once you have it it
should be very fast. One possible problem with using a Taylor map is
that you have to worry about the accuracy if you do a calculation at points
that are far from the expansion point about which the map was
made. This method is non-symplectic away from the expansion point. 

\index{Mat6_calc_method!Tracking}
\item[\vn{Tracking}]
This uses the tracking method set by \vn{tracking_method} to track 6
particles around the central orbit. This method is susceptible to inaccuracies
caused by nonlinearities. Furthermore this method
is almost surely slow. While non--symplectic, the advantage of this method
is that it is directly related to any tracking results.

\end{description}

\vfill \break
\vfill

\begin{table}[th]
\centering {
\begin{tabular}{|l|c|c|c|c|c|c|c|c|} \hline
\rule{0pt}{80pt} &
\begin{sideways}\vn{Bmad_Standard}\end{sideways} &
\begin{sideways}\vn{Custom}\end{sideways} &
\begin{sideways}\vn{MAD}\end{sideways} &
\begin{sideways}\vn{None}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_Bmad}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_PTC}\end{sideways} &
\begin{sideways}\vn{Taylor}\end{sideways} &
\begin{sideways}\vn{Tracking}\end{sideways}
\\ \hline
%                               BS   C   M   N  SLB SLP Tlr Trk 
  \vn{ab_multipole}            & D & X &   & X &   & X & X &   \\ \hline 
  \vn{beambeam}                & D & X &   & X &   &   &   & X \\ \hline 
  \vn{bend_sol_quad}           &   &   &   & X & D &   &   & X \\ \hline 
  \vn{custom}                  &   & D &   & X &   &   &   & X \\ \hline 
  \vn{drift}                   & D & X & X & X &   & X & X & X \\ \hline 
  \vn{ecollimator}             & D & X &   & X &   & X & X & X \\ \hline 
  \vn{elseparator}             & D & X & X & X &   & X & X & X \\ \hline 
  \vn{hkicker}                 & D & X &   & X &   & X & X & X \\ \hline 
  \vn{instrument}              & D & X &   & X &   & X & X & X \\ \hline 
  \vn{kicker}                  & D & X &   & X &   & X & X & X \\ \hline 
  \vn{lcavity}                 & D & X &   & X &   &   &   & X \\ \hline 
  \vn{marker}                  & D & X &   & X &   & X & X & X \\ \hline 
  \vn{match}                   & D &   &   & X &   &   &   &   \\ \hline 
  \vn{monitor}                 & D & X &   & X &   & X & X & X \\ \hline 
  \vn{multipole}               & D & X &   & X &   & X & X &   \\ \hline 
  \vn{octupole}                & D & X &   & X &   & X & X & X \\ \hline
  \vn{patch}                   & D & X &   & X &   &   &   &   \\ \hline
  \vn{quadrupole}              & D & X & X & X &   & X & X & X \\ \hline
  \vn{rbend}                   & D & X & X & X &   & X & X & X \\ \hline
  \vn{rcollimator}             & D & X &   & X &   & X & X & X \\ \hline
  \vn{rfcavity}                & D & X & X & X &   & X & X & X \\ \hline
  \vn{sbend}                   & D & X & X & X &   & X & X & X \\ \hline
  \vn{sextupole}               & D & X & X & X &   & X & X & X \\ \hline
  \vn{solenoid}                & D & X & X & X &   & X & X & X \\ \hline
  \vn{sol_quad}                & D & X & X & X &   & X & X & X \\ \hline
  \vn{taylor}                  & D & X &   & X &   &   &   &   \\ \hline
  \vn{vkicker}                 & D & X &   & X &   & X & X & X \\ \hline
  \vn{wiggler} (periodic type) & D & X &   & X &   &   &   & X \\ \hline
  \vn{wiggler} (map type)      & D & X &   & X & X & X & X & X \\ \hline
\end{tabular}
}

\caption[Table of available \vn{mat6\_calc\_method}\ switches for a
given element class.]{Table of available \vn{mat6\_calc\_method}\
switches for a given element class. D denotes the default method.  X
denotes an available method.}

\label{t:mat6_methods}
\end{table}

\vfill \break

%-----------------------------------------------------------------
\section{Transfer Maps via Integration}
\label{s:integ}
\index{Transfer map}

When calculating transfer (Taylor) maps and tracking through integration
there are a number of attributes that can affect the calculation. They are
\begin{example}
  num_steps = Integer         ! Number of integration steps
  integration_ord = Integer   ! Integrator order
  rel_tol = Real              ! Relative tolerance
  abs_tol = Real              ! Absolute tolerance
  field_calc = Switch         ! How the field is calculated
\end{example}
Example:
\begin{example}
  q1: quadrupole, l = 0.6, tracking_method = bmad_standard, &
        mat6_calc_method = symp_lie_ptc, num_steps = 20, field_calc = custom
\end{example}

\index{Num_steps}
One way to create a transfer map through an element is to divide the
element up into slices and then to propagate the transfer map slice by
slice.  There are several ways to do this integration. The
\vntm{Boris} and \vntm{Runge_Kutta} methods integrate the equations of
motion to give the 0\Th order Taylor map which just represents a
particle's orbit.  Symplectic
integration\index{Symplectic!integration} using Lie algebraic
techniques, on the other hand, can generate Taylor maps to any order.
The \vn{num_steps} attribute determines the number of slices. This
is applicable to \vn{Boris}, \vntm{Symp_Lie_Bmad}, and
\vntm{Symp_Lie_PTC} integration.

\index{Integration_ord}
\index{Num_steps}
\vn{integrator_order} is the order of the integration formula for 
\vn{Symp_Lie_PTC}. Possible values are
\begin{example}
  integrator_order = 2 (default), 4, or 6
\end{example}
Essentially, an integration order of $n$ means that the error in an 
integration step scales as $dz^{n+1}$ where $dz$ is the slice thickness.
For a given number of steps a higher order will give more accurate results
but a higher order integrator will take more time per step. It turns out
that for wigglers, after adjusting \vn{num_steps} for a given accuracy, 
the order 2 integrator is the fastest. This is not surprising given the
highly nonlinear nature of a wiggler. Note that \vntm{Symp_Lie_Bmad} always
uses a order 2 integrator.

\index{Num_steps}
\index{Rel_tol}
\index{Abs_tol}
\vntm{Adaptive_Boris} and \vntm{Runge_Kutta} use adaptive step
control independent of \vn{num_steps}. These methods use the \vn{rel_tol} and
\vn{abs_tol} attributes to try to keep the estimated error of the integration
such that
\begin{example}
  error < abs_tol + |orbit| * rel_tol
\end{example}
lowering the error bounds makes for greater accuracy (as long as round-off 
doesn't hurt) but for slower tracking. 

\index{Field_calc}
\vntm{Boris}, \vntm{Adaptive_Boris}, and \vntm{Runge_Kutta} tracking all use
as input the electric and magnetic fields of an element. How the EM fields
are calculated is determined by the \vn{field_calc} attribute for an element.
Possible values for \vn{field_calc} are:
\begin{example}
  Bmad_Standard     ! This is the default
  Custom
\end{example}
\index{Custom}
\vn{Custom} means that the field calculations are done outside of the
\bmad software. A program doing \vn{Custom} field calculations will
need the appropriate custom routine. See \sref{s:custom_field} for more
details.

\vntm{Boris} (Both \vn{Boris} and \vntm{Adaptive_Boris}) tracking does not
assume that a particle is relativistic so \vn{Boris} tracking can be
used with non--relativistic particles. The phase space coordinates
used in \vn{Boris} tracking are not the usual \bmad coordinates Rather
what is used is
\begin{example}
    (x, p_x/p_0, y, p_y/p_0, s-ct, dE/(cP_0))
\end{example}
At high energy $s-ct = z$ which is the distance of the particle from the 
reference particle and $cP_0 = vE_0/C = E_0$ so that $dE/cP_0 = dE/E$ giving
the standard \bmad coordinates.

