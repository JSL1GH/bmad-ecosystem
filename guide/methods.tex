\chapter{Tracking and Transfer Matrix Calculation Methods}

Typically, there are several ways to do tracking and transfer matrix
calculations for a given element type within \bmad. What method is
used is selected on an element--by--element basis using an element's
\vn{tracking_method} and \vn{mat6_calc_method} attributes (mat6 refers
to the size of the 6 by 6 transfer matrices). By supplying the
appropriate routines a programmer can extend \bmad\ to do customized
tracking. In general \bmad assumes that particles are
ultra--relativistic. The methods that do not make this assumption are:
\vn{Boris}, \vn{Adaptive_Boris}, \vn{Symp_Lie_Ptc}, \vn{Symp_map}, and \vn{Taylor}

If this is not the case 

%----------------------------------------------------------------------------
\section{tracking\_method Switches}
\label{s:tkm}
\index{Tracking method|textbf}

Below are listed the methods for the \vn{tracking_method}
attribute with an explanation of what the different methods do. A
table giving which methods are available with which element types is give
in Table~\ref{t:track_methods}. 

A note on terminology: Adaptive step size control used with the
\vn{Adaptive_Boris} and \vn{Runge_Kutta} integrators means that 
instead of taking fixed step sizes the integrator chooses the proper
step size so that the error in the tracking is below the maximum
allowable error set by \vn{rel_tol} and \vn{abs_tol} tolerances. The
advantage of step size control is that the integrator uses a smaller
step size when needed (the fields are rapidly varying), but makes
larger steps when it can. The disadvantage is that a step is more
computationally intensive since the error in a step is estimated by
repeating a step using two mini steps. If the fields are rather
uniform and you know what a good step size is you can save time by using
a fixed step size.

\begin{description}
\item[\vn{Adaptive\_Boris}]
Second order Boris integration\cite{b:boris} with adaptive step size control.
This should be nearly symplectic but slow.

\item[\vn{Boris}]
Second order Boris Integration\cite{b:boris}. Like \vn{Runge_Kutta},
\vn{Boris} does tracking by integrating the equation of
motion. \vn{Boris} handles both electric and magnetic fields and does
not assume that the particle is ultra--relativistic. \vn{Boris} preserves
conserved quantities more accurately than \vn{Runge_Kutta}.

\item[\vn{Bmad\_Standard}]
Uses formulas for tracking. The emphasis here is on speed and not
symplecticity. Appropriate when you are interested in single turn
stuff. May be appropriate for long term tracking depending upon how
many turns are tracked and what kind of elements are involved. 

\item[\vn{Custom}]
This method will call a routine \vn{track1_custom} which must be
supplied by the programmer implementing the custom tracking. The
default \vn{track1_custom} supplied with the \bmad\ release will print
an error message and stop the program if it is called which probably
indicates a program linking problem.

\item[\vn{Linear}]
Linear just uses the 0th order vector with the 1st order 6x6 transfer
matrix for an element. Very simple.  Depending upon how the transfer
matrix was generated this may or may not be symplectic.

\item[\vn{MAD}]
This uses the MAD 2nd order transfer map.

\item[\vn{Runge\_Kutta}]
This uses a 4\Th\ order Runge Kutta integration algorithm with adaptive
step size control.  This is essentially the \vn{ODEINT} subroutine
from Numerical Recipes\cite{b:nr}. This may be slow but it should be
accurate. This method is non-symplectic.

\item[\vn{Symp\_Lie\_Bmad}]
Symplectic tracking using a Hamiltonian with Lie operation techniques.
This is similar to \vn{Symp_Lie_PTC} (see below) except this uses a
\bmad\ routine. By bypassing some of the generality inherent in PTC's routines
\vn{Symp_Lie_Bmad} achieves about a factor of 10 improvement in speed over
\vn{Symp_Lie_PTC}. However, \vn{Symp_lie_Bmad} is
currently only implemented for Wigglers.

\item[\vn{Symp\_Lie\_PTC}]
Symplectic tracking using a Hamiltonian with Lie operator techniques.
This uses Etienne's PTC software for the calculation. This method is
symplectic but can be slow.

\item[\vn{Symp\_Map}]
This uses a partially inverted, implicit Taylor map. The calculation
uses Etienne's PTC software.  Since the map is implicit, a Newton
search method must be used. This will slow things down from the Taylor
method but this is guaranteed symplectic.

\item[\vn{Taylor}]
This uses a Taylor map generated from Etienne's PTC
package. Generating the map may take time but once you have it it
should be very fast. One possible problem with using a Taylor map is
that you have to worry about the accuracy if you do tracking at points
that are far from the expansion point about which the map was
made. This method is non-symplectic away from the expansion point. 

\item[\vn{Wiedemann}]
This is Wiedemann's hard edge model of a wiggler
\cite{wiedemann}. This model divides a wiggler pole into a constant 
bend rectangular section with drifts at either end. The total length
of the model pole matches the actual pole length of the element. The
strength of the bend and the lengths of the bend and drifts are
adjusted so that the vertical focusing and horizontal deflection are
the same in the modal as with a model assuming a sinusoidally varying
field. \bmad\ augments this model by assuming that the horizontal
deflection varies as the $\sinh$ with vertical offset.  Since
Wiedemann's model does not include longitudinal fields it is not clear
that it can be used for long term tracking.

\end{description}

\vfill \break
{\vfill}

\begin{table}[h]
\centering {
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|} \hline
\rule{0pt}{80pt} &
\begin{sideways}\vn{Adaptive_Boris}\end{sideways} &
\begin{sideways}\vn{Bmad_Standard}\end{sideways} &
\begin{sideways}\vn{Boris}\end{sideways} &
\begin{sideways}\vn{Custom}\end{sideways} &
\begin{sideways}\vn{Linear}\end{sideways} &
\begin{sideways}\vn{MAD}\end{sideways} &
\begin{sideways}\vn{Runge_Kutta}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_Bmad}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_PTC}\end{sideways} &
\begin{sideways}\vn{Symp_Map}\end{sideways} &
\begin{sideways}\vn{Taylor}\end{sideways} &
\begin{sideways}\vn{Wiedemann}\end{sideways}
\\ \hline
%                               AB  BS   B   C   L   M  RK  SLB SLP SM   T   W
  \vn{ab_multipole}            &   & D &   & X & X &   &   &   & X & X & X &   \\ \hline 
  \vn{beambeam}                &   & D &   & X & X &   &   &   &   &   &   &   \\ \hline 
  \vn{bend_sol_quad}           &   &   &   &   &   &   &   & D &   &   &   &   \\ \hline 
  \vn{custom}                  & X &   & X & D & X &   & X &   &   &   &   &   \\ \hline 
  \vn{drift}                   & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline 
  \vn{ecollimator}             & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline 
  \vn{elseparator}             & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline 
  \vn{hkicker}                 & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline 
  \vn{instrument}              & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline 
  \vn{kicker}                  & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline 
  \vn{lcavity}                 &   & D &   & X & X &   &   &   &   &   &   &   \\ \hline 
  \vn{marker}                  &   & D &   & X & X &   &   &   & X & X & X &   \\ \hline 
  \vn{monitor}                 & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline 
  \vn{multipole}               &   & D &   & X & X &   &   &   & X & X & X &   \\ \hline 
  \vn{octupole}                & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline
  \vn{patch}                   &   & D &   & X &   &   &   &   &   &   &   &   \\ \hline
  \vn{quadrupole}              & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline
  \vn{rbend}                   &   & D &   & X & X & X &   &   & X & X & X &   \\ \hline
  \vn{rcollimator}             & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline
  \vn{rfcavity}                &   & D &   & X & X & X &   &   & X & X & X &   \\ \hline
  \vn{sbend}                   &   & D &   & X & X & X &   &   & X & X & X &   \\ \hline
  \vn{sextupole}               & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline
  \vn{solenoid}                & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline
  \vn{sol_quad}                & X & D & X & X & X & X & X &   & X & X & X &   \\ \hline
  \vn{taylor}                  &   & D &   & X & X &   &   &   &   &   &   &   \\ \hline
  \vn{vkicker}                 & X & D & X & X & X &   & X &   & X & X & X &   \\ \hline
  \vn{wiggler} (periodic type) &   & D &   & X & X &   &   &   &   &   &   & X \\ \hline
  \vn{wiggler} (map type)      & X & D & X & X & X &   & X & X & X & X & X &   \\ \hline
\end{tabular}
}
\caption[Table of available {\bf tracking\_method}\ switches for a
given element type.]{Table of available {\bf tracking\_method}\
switches for a given element type. D denotes the default method. X
denotes an available method.}
\label{t:track_methods}
\end{table}

\vfill\break

%----------------------------------------------------------------------------
\section{mat6\_calc\_method Switches}
\label{s:xfer}
\index{Mat6_calc_method|textbf}

Below are listed the methods for the \vn{mat6_calc_method}
attribute with an explanation of what the different methods do. A
table giving which methods are available with which element types is give
in Table~\ref{t:mat6_methods}. 

For methods that do not necessarily produce a symplectic matrix the
\vn{symplectify} attribute of an element can be set to \vn{True} to
solve the problem. See section~\ref{s:symp_method}. 

Symplectic integration is like ordinary integration of a function f(x)
but what is integrated here is a Taylor map. Truncating the map to
0\Th\ order gives the particle trajectory and truncating to 1\St\
order gives the transfer matrix (Jacobian).  The order at which a
Taylor series is truncated at is set by \vn{taylor_order} (see
Section~\ref{s:param}. Like ordinary integration there are various
formulas that one can use to do symplectic integration. In \bmad\ (or
more precisely Etienne's PTC) you can use one of 3 methods. This is
set by \vn{integration_ord}.  \vn{integration_ord} = n where $n$ is
allowed by PTC to be 2, 4, or 6. With an integration order of $n$ the
error in an integration step scales as $dz^n$ where $dz$ is step
size. The step size $dz$ is set by the length of the element and the
value of \vn{num_steps}. Remember, as in ordinary integration, higher
integration order does not necessarily imply higher accuracy.

\begin{description}

\index{Mat6_calc_method!Bmad_Standard}
\item[\vn{Bmad\_Standard}]
Uses formulas for the calculation. The emphasis here is on speed and not
symplecticity. Appropriate when you are interested in single turn
stuff. May be appropriate for long term tracking depending upon how
many turns are tracked and what kind of elements are involved. 

\index{Mat6_calc_method!Custom}
\item[\vn{Custom}]
This method will call a routine \vn{make_mat6_custom} which must be
supplied by the programmer implementing the custom transfer matrix
calculation. The default \vn{make_mat6_custom} supplied with the
\bmad\ release will print an error message and stop the program if it
is called which probably indicates a program linking problem.

\index{Mat6_calc_method!MAD}
\item[\vn{MAD}]
This uses the MAD 2nd transfer map.

\index{Mat6_calc_method!Symp_lie_Bmad}
\item[\vn{Symp\_Lie\_Bmad}]
A Symplectic calculation using a Hamiltonian with Lie operator techniques.
This is similar to \vn{Symp_Lie_PTC} (see below) except this uses a
\bmad\ routine. By bypassing some of the generality inherent in PTC's routines
\vn{Symp_Lie_Bmad} achieves about a factor of 10 improvement in speed over
\vn{Symp_Lie_PTC}. However, \vn{Symp_lie_Bmad} is
currently only implemented for Wigglers.

\index{Mat6_calc_method!Symp_Lie_PTC}
\item[\vn{Symp\_Lie\_PTC}]
Symplectic integration using a Hamiltonian and Lie operators.
This uses Etienne's PTC software for the calculation.
This method is symplectic but can be slow.

\index{Mat6_calc_method!Taylor}
\item[\vn{Taylor}]
This uses a Taylor map generated from Etienne's PTC
package. Generating the map may take time but once you have it it
should be very fast. One possible problem with using a Taylor map is
that you have to worry about the accuracy if you do a calculation at points
that are far from the expansion point about which the map was
made. This method is non-symplectic away from the expansion point. 

\index{Mat6_calc_method!Tracking}
\item[\vn{Tracking}]
This uses the tracking method set by \vn{tracking_method} to track 6
particles around the central orbit. This method is susceptible to inaccuracies
caused by nonlinearities. Furthermore this method
is almost surely slow. While non--symplectic, the advantage of this method
is that it is directly related to any tracking results.

\end{description}

\vfill \break
\vfill

\begin{table}[th]
\centering {
\begin{tabular}{|l|c|c|c|c|c|c|c|} \hline
\rule{0pt}{80pt} &
\begin{sideways}\vn{Bmad_Standard}\end{sideways} &
\begin{sideways}\vn{Custom}\end{sideways} &
\begin{sideways}\vn{MAD}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_Bmad}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_PTC}\end{sideways} &
\begin{sideways}\vn{Taylor}\end{sideways} &
\begin{sideways}\vn{Tracking}\end{sideways}
\\ \hline
%                               BS   C   M  SLB SLP Tlr Trk 
  \vn{ab_multipole}            & D & X &   &   & X & X &   \\ \hline 
  \vn{beambeam}                & D & X &   &   &   &   & X \\ \hline 
  \vn{bend_sol_quad}           &   &   &   & D &   &   & X \\ \hline 
  \vn{custom}                  &   & D &   &   &   &   & X \\ \hline 
  \vn{drift}                   & D & X & X &   & X & X & X \\ \hline 
  \vn{ecollimator}             & D & X &   &   & X & X & X \\ \hline 
  \vn{elseparator}             & D & X & X &   & X & X & X \\ \hline 
  \vn{hkicker}                 & D & X &   &   & X & X & X \\ \hline 
  \vn{instrument}              & D & X &   &   & X & X & X \\ \hline 
  \vn{kicker}                  & D & X &   &   & X & X & X \\ \hline 
  \vn{lcavity}                 & D & X &   &   &   &   & X \\ \hline 
  \vn{marker}                  & D & X &   &   & X & X & X \\ \hline 
  \vn{monitor}                 & D & X &   &   & X & X & X \\ \hline 
  \vn{multipole}               & D & X &   &   & X & X &   \\ \hline 
  \vn{octupole}                & D & X &   &   & X & X & X \\ \hline
  \vn{patch}                   & D & X &   &   &   &   &   \\ \hline
  \vn{quadrupole}              & D & X & X &   & X & X & X \\ \hline
  \vn{rbend}                   & D & X & X &   & X & X & X \\ \hline
  \vn{rcollimator}             & D & X &   &   & X & X & X \\ \hline
  \vn{rfcavity}                & D & X & X &   & X & X & X \\ \hline
  \vn{sbend}                   & D & X & X &   & X & X & X \\ \hline
  \vn{sextupole}               & D & X & X &   & X & X & X \\ \hline
  \vn{solenoid}                & D & X & X &   & X & X & X \\ \hline
  \vn{sol_quad}                & D & X & X &   & X & X & X \\ \hline
  \vn{taylor}                  & D & X &   &   &   &   &   \\ \hline
  \vn{vkicker}                 & D & X &   &   & X & X & X \\ \hline
  \vn{wiggler} (periodic type) & D & X &   &   &   &   & X \\ \hline
  \vn{wiggler} (map type)      & D & X &   & X & X & X & X \\ \hline
\end{tabular}
}

\caption[Table of available \vn{mat6\_calc\_method}\ switches for a
given element type.]{Table of available \vn{mat6\_calc\_method}\
switches for a given element type. D denotes the default method.  X
denotes an available method.}

\label{t:mat6_methods}
\end{table}

\vfill \break
