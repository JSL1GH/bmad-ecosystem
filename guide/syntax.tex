\chapter{Lattice File Syntax}

%---------------------------------------------------------------------------
\section{Lattice Files and Digested Files}
\label{s:lattice_files}

The \bmad\ software library comes with a routine to read in (parse) a
lattice definition file (or files). The syntax that a lattice file
must conform to is modeled after the lattice input format of the \mad\
program.  Essentially, a \bmad\ lattice file is similar to a \mad\
lattice file except that a \bmad\ file has no ``action'' commands
(commands tell the program to calculate the Twiss parameters,
etc.). Interacting with the user to determine what actions a program
should take is left to the program and is not part of \bmad\ (although
\bmad\, of course, provides the routines to do many calculations). A
program is not required to use the \bmad\ parser routine but if it
does the following chapters describes how to construct a valid lattice
file.

Normally the \bmad\ parser routine will create what is called a
``digested file'' after it has parsed a lattice file so that when a
program is run and the same lattice file is to be read in again, to save
time, the digested file can be used to load in the lattice information.
This digested file is in binary format and is not human readable. The
digested file will contain the transfer maps for all the elements. 
Using a digested file can save considerable time if some of the
elements in the lattice need to have Taylor maps computed.
(this occurs typically with map--type wigglers).

\bmad\ creates the digested file in the same area as the lattice file.
If \bmad\ is not able to create a digested file (typically because it
does not have write permission in the directory), an error message will
be generated but otherwise program operation will be normal.

Digested files can also be used for easy transport of lattices between
programs or between sessions of a program. For example, using one
program you might read in a lattice, make some adjustments (say to model
shifts in magnet positions) and then write out a digested version of the
lattice. This adjusted lattice can now be read in by another program to
do some custom analysis.

A ``secondary'' lattice file (or files) is a lattice file that is used to modify
the lattice that has already been read in via the ``primary'' lattice
file.  For example, a secondary lattice file can be used to set (or
reset) aperture limits for the elements of the lattice.  The term
secondary in this case refers not to the file but whether it is read
in when the lattice is first read in. For example, if the file
\vn{lattice_file} holds a lattice definition and \vn{aperture_file} is
the name of an aperture file then the two files may be read in simultaneously
by using a third file which calls the two
\begin{verbatim}
  ! This is a file that calls the two files
  call, file = 'lattice_file'
  call, file = 'aperture_file'
\end{verbatim}
In this case \vn{aperture_file} is considered part of the set of
primary lattice files.  The reason for making a distinction between
primary and secondary is that there are restrictions, discussed in
other parts of the manual, on any lattice file used as a secondary
file.


%---------------------------------------------------------------------------
\section{Lattice File Format}

Input for \bmad\ is free format. A \bmad\ lattice input file consists
of a sequence of statements. Normally a statement occupies a single
line in the file. Several statements may be placed on the same line by
inserting a semicolon (;) between them. A long statement can occupy
multiple lines by putting an ampersand (\&) at the end of each line of
a statement except for the last line of the statement. An
exclamation mark (!) denotes a comment and the exclamation mark and
everything after the exclamation mark on the line are ignored. Example:
\begin{example}
  ! This is a comment
  q0: quad, l = 0.6, &     ! Continued to the next line
            k1 = 1.4, tilt = pi/3
\end{example}
\bmad\ is case insensitive. Everything is converted to uppercase except
strings.

%---------------------------------------------------------------------------
\section{Variable Types}

There are five types of variables in \bmad: Reals, Integers, Switches, 
Logicals, and 
Strings. Reals are discussed below in more detail. Integers are just reals
that are evaluated to the nearest integer. Acceptable logical values are
\begin{example}
  .true.  .false.
   true    false
   t       f
\end{example}
For example
\begin{example}
  rf1[is_on] = False
\end{example}

\vskip0.1in
String literals can be quoted using double quotes (") or, if there are no
blanks or comma within a string, the quotes can be omitted. For example:
\begin{example}
  Q00W: Quad, type = "My Type", alias = Who_knows, &
                                  descrip = "Only the shadow knows"
\end{example}
Unlike everything else, strings are not converted to uppercase.

Switches are variables that take discrete values. For example:
\begin{example}
  beam, particle = positron                    
  q01w: quad, tracking\_method = bmad\_standard 
\end{example}
The name ``switch'' can refer to the variable (for example,
\vn{tracking_method}) or to a value that it can take (for example,
\vn{bmad_standard}). The name ``method'' is used interchangable with switch.

%---------------------------------------------------------------------------
\section{Arithmetic Expressions}

Arithmetic expressions can be used in a place where a real value is required.
The standard operators are defined:
\begin{ventry}{12em}
\item[$a + b$] Addition
\item[$a - b$] Subtraction
\item[$a \, \ast \, b$] Multiplication
\item[$a \; / \; b$] Division
\item[$a \, \land \, b$] Exponentiation
\end{ventry}
\vskip0.05in\noindent
The following functions are recognized by \bmad:
\begin{ventry}{acos(x)}
\item[sqrt(x)] Square Root 
\item[log(x)]  Logarithm
\item[exp(x)]  Exponential
\item[sin(x)]  Sine
\item[cos(x)]  Cosine
\item[tan(x)]  Tangent
\item[asin(x)] Arc sine
\item[acos(x)] Arc cosine
\item[atan(x)] Arc Tangent
\item[abs(x)]  Absolute Value
\end{ventry}


%---------------------------------------------------------------------------
\section{Constants}

Literal constants can be entered with or without a decimal point. An
exponent is marked with the letter E. For example
\begin{example}
  1, 10.35, 5E3, 314.159E-2
\end{example}
Symbolic constants can be defined using the syntax
\begin{example}
  parameter_name = expression
\end{example}
Alternatively, to be compatible with \mad, using ``:='' instead of ``='' is accepted
\begin{example}
  parameter_name := expression
\end{example}
Examples:
\begin{example}
  my_const = sqrt(10.3) * pi^3
  abc     := my_const * 23
\end{example}
Unlike \mad, \bmad\ uses immediate substitution so that all constants
in an expression must have been previously defined. For example, the
following is not valid:
\begin{example}
  abc      = my_const * 23      ! No: my_const needs to be defined first.
  my_const = sqrt(10.3) * pi^3
\end{example}
here the value of \vn{my_const} is not known when the line ``\vn{abc}
= $\ldots$'' is parsed. Once
defined, symbolic constants cannot be redefined. For example:
\begin{example}
  my_const = 1
  my_const = 2  ! No: my_const cannot be redefined.
\end{example}


%---------------------------------------------------------------------------
\section{Element Attributes}

Element attributes can be set or used in an algebraic expression
using the syntax
\begin{example}
  element-name[attribute-name]
\end{example}
For example:
\begin{example}
  b01w: sbend, l = 6.0, rho = 89.0   ! Define a bend element.
  bo1w[roll] = 6.5                   ! Set an attribute value.
  b01w[l] = 6.5                      ! Change an attribute value.
  b01w[l] = b01w[rho] / 12           ! OK to reset an attribute value.
  my_const = b01[rho] / b01[l]       ! Use of attribute values in an expression
\end{example}

%---------------------------------------------------------------------------
\section{Lattice Elements}

The syntax for defining a lattice element roughly follows \mad:
\begin{example}
  label: keyword [, attributes]
\end{example}
\tn{Overlay} and \tn{Group} elements have a slightly different syntax
\begin{example}
  label: keyword = \{ list \}, master-attribute [= value] [, attributes]
\end{example}
For example:
\begin{example}
  q01w: quad, type = "A String", l = 0.6, tilt = pi/2
  h10e: overlay = \{ b08e, b10e \}, hkick
\end{example}
