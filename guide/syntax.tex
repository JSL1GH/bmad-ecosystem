\chapter{Lattice File Syntax}

%---------------------------------------------------------------------------
\section{Lattice File Formats}
\label{s:lattice_file_formats}

The \bmad\ software library comes with routines to read in (parse) a
lattice definition file (or files). There are two input formats that
\bmad understands: The \bmad standard format and
XSIF\cite{b:xsif}. XSIF stands for ``Extended Standard Input Format.''
XSIF is essentially a subset of the MAD input format. Documentation
can be found at:
\begin{example}
  http://www-project.slac.stanford.edu/
              lc/ilc/TechNotes/LCCNotes/PDF/LCC-0060%20rev.1.pdf
\end{example}
One point that is not covered in the XSIF documentation is that \vn{beam} and 
\vn{beta0} definitions must have a corresponding \vn{use} statement separate 
from the \vn{use} statement that defines the lattice. For
example:
\begin{example}
  this_beam: beam, particle = electron, ...
  this_beta, beta0, betax = 3.45, ...
  this_lattice: line = ( ... )
  use, this_lattice
  use, this_beam
  use, this_beta
\end{example}
Another undocumented point is that for a \vn{MATRIX} element, unlike MAD, the
\vn{R$ii$} terms (the diagonal terms of the linear matrix) are not
unity by default. Thus
\begin{example}
  m: matrix
\end{example}
will give a zero linear matrix.

Throughout this manual if the lattice input format is mentioned it
will always pertain to the \bmad standard format unless explicitly
stated otherwise.

%----------------------------------------------------------------------------
\section{Bmad Lattice Files and Digested Files}
\label{s:lattice_files}

The syntax that a \bmad standard lattice file
must conform to is modeled after the lattice input format of the \mad\
program.  Essentially, a \bmad\ lattice file is similar to a \mad\
lattice file except that a \bmad\ file has no ``action'' commands
(action commands tell the program to calculate the Twiss parameters,
do tracking, etc.). 
Interacting with the user to determine what actions a program
should take is left to the program and is not part of \bmad\ (although
\bmad, of course, provides the routines to do many calculations). A
program is not required to use the \bmad\ parser routine but if it
does the following chapters describes how to construct a valid lattice
file.

Normally the \bmad\ parser routine will create what is called a
``digested file'' after it has parsed a lattice file so that when a
program is run and the same lattice file is to be read in again, to save
time, the digested file can be used to load in the lattice information.
This digested file is in binary format and is not human readable. The
digested file will contain the transfer maps for all the elements. 
Using a digested file can save considerable time if some of the
elements in the lattice need to have Taylor maps computed.
(this occurs typically with map--type wigglers).

\bmad\ creates the digested file in the same area as the lattice file.
If \bmad\ is not able to create a digested file (typically because it
does not have write permission in the directory), an error message will
be generated but otherwise program operation will be normal.

Digested files can also be used for easy transport of lattices between
programs or between sessions of a program. For example, using one
program you might read in a lattice, make some adjustments (say to model
shifts in magnet positions) and then write out a digested version of the
lattice. This adjusted lattice can now be read in by another program to
do some custom analysis.

A ``secondary'' lattice file (or files) is a lattice file that is used to modify
the lattice that has already been read in via the ``primary'' lattice
file.  For example, a secondary lattice file can be used to set (or
reset) aperture limits for the elements of the lattice.  The term
secondary in this case refers not to the file but whether it is read
in when the lattice is first read in. For example, if the file
\vn{lattice_file} holds a lattice definition and \vn{aperture_file} is
the name of an aperture file then the two files may be read in simultaneously
by using a third file which calls the two
\begin{example}
  ! This is a file that calls the two files
  call, file = 'lattice_file'
  call, file = 'aperture_file'
\end{example}
In this case \vn{aperture_file} is considered to be a
primary lattice file.  The reason for making a distinction between
primary and secondary is that there are restrictions, discussed in
other parts of the manual, on any lattice file used as a secondary
file.


%---------------------------------------------------------------------------
\section{Lattice File Format}

Input for \bmad\ is free format. A \bmad\ lattice input file consists
of a sequence of statements. Normally a statement occupies a single
line in the file. Several statements may be placed on the same line by
inserting a semicolon (;) between them. A long statement can occupy
multiple lines by putting an ampersand (\&) at the end of each line of
a statement except for the last line of the statement. An
exclamation mark (!) denotes a comment and the exclamation mark and
everything after the exclamation mark on the line are ignored. Example:
\begin{example}
  ! This is a comment
  q0: quad, l = 0.6, &     ! Continued to the next line
            k1 = 1.4, tilt = pi/3
\end{example}
\bmad\ is case insensitive. Everything is converted to uppercase except
strings.

%---------------------------------------------------------------------------
\section{Variable Types}

There are five types of variables in \bmad: Reals, Integers, Switches, 
Logicals, and 
Strings. Reals are discussed below in more detail. Integers are just reals
that are evaluated to the nearest integer. Acceptable logical values are
\begin{example}
  .true.  .false.
   true    false
   t       f
\end{example}
For example
\begin{example}
  rf1[is_on] = False
\end{example}

\vskip0.1in
String literals can be quoted using double quotes (") or, if there are no
blanks or comma within a string, the quotes can be omitted. For example:
\begin{example}
  Q00W: Quad, type = "My Type", alias = Who_knows, &
                                  descrip = "Only the shadow knows"
\end{example}
Unlike everything else, strings are not converted to uppercase.

Switches are variables that take discrete values. For example:
\begin{example}
  beam, particle = positron                    
  q01w: quad, tracking\_method = bmad\_standard 
\end{example}
The name ``switch'' can refer to the variable (for example,
\vn{tracking_method}) or to a value that it can take (for example,
\vn{bmad_standard}). The name ``method'' is used interchangeably with switch.

%---------------------------------------------------------------------------
\section{Arithmetic Expressions}

Arithmetic expressions can be used in a place where a real value is required.
The standard operators are defined: \hfil\break
\hspace*{0.15in}
\begin{tabular}{ll}
  $a + b$           & Addition        \\
  $a - b$           & Subtraction     \\
  $a \, \ast \, b$  & Multiplication  \\
  $a \; / \; b$     & Division        \\
  $a \, \land \, b$ & Exponentiation  \\
\end{tabular}

The following functions are recognized by \bmad: \hfil\break
\hspace*{0.15in}
\begin{tabular}{ll}
  sqrt(x) &  Square Root    \\
  log(x)  &  Logarithm      \\
  exp(x)  &  Exponential    \\
  sin(x)  &  Sine           \\
  cos(x)  &  Cosine         \\
  tan(x)  &  Tangent        \\
  asin(x) &  Arc sine       \\
  acos(x) &  Arc cosine     \\
  atan(x) &  Arc Tangent    \\
  abs(x)  &  Absolute Value \\
\end{tabular}


%---------------------------------------------------------------------------
\section{Constants}

Literal constants can be entered with or without a decimal point. An
exponent is marked with the letter E. For example
\begin{example}
  1, 10.35, 5E3, 314.159E-2
\end{example}
Symbolic constants can be defined using the syntax
\begin{example}
  parameter_name = expression
\end{example}
Alternatively, to be compatible with \mad, using ``:='' instead of ``='' is accepted
\begin{example}
  parameter_name := expression
\end{example}
Examples:
\begin{example}
  my_const = sqrt(10.3) * pi^3
  abc     := my_const * 23
\end{example}
Unlike \mad, \bmad\ uses immediate substitution so that all constants
in an expression must have been previously defined. For example, the
following is not valid:
\begin{example}
  abc      = my_const * 23      ! No: my_const needs to be defined first.
  my_const = sqrt(10.3) * pi^3
\end{example}
here the value of \vn{my_const} is not known when the line ``\vn{abc}
= $\ldots$'' is parsed. Once
defined, symbolic constants cannot be redefined. For example:
\begin{example}
  my_const = 1
  my_const = 2  ! No: my_const cannot be redefined.
\end{example}


%---------------------------------------------------------------------------
\section{Element Attributes}

The values of element attributes can be specified using the syntax
\begin{example}
  element-name[attribute-name]
\end{example}
Element attributes can be set or used in an algebraic expression:
\begin{example}
  b01w: sbend, l = 6.0, rho = 89.0   ! Define a bend element.
  bo1w[roll] = 6.5                   ! Set an attribute value.
  b01w[l] = 6.5                      ! Change an attribute value.
  b01w[l] = b01w[rho] / 12           ! OK to reset an attribute value.
  my_const = b01[rho] / b01[l]       ! Use of attribute values in an expression.
\end{example}
When setting an attribute value if more than one element has the
\vn{element-name} then all such elements will be set.  When setting an
attribute value if \vn{element-name} is the name of a type of element
then all elements of that type will be set. For example
\begin{example}
  rfcavity[tracking_method] = symp_lie_ptc ! Set all of one type of element.
\end{example}


%---------------------------------------------------------------------------
\section{Lattice Elements}

The syntax for defining a lattice element roughly follows \mad:
\begin{example}
  label: keyword [, attributes]
\end{example}
\tn{Overlay} and \tn{Group} elements have a slightly different syntax
\begin{example}
  label: keyword = \{ list \}, master-attribute [= value] [, attributes]
\end{example}
and \vn{I_Beam} elements have the syntax
\begin{example}
  label: keyword = \{ list \} [, attributes]
\end{example}  
For example:
\begin{example}
  q01w: quadrupole, type = "A String", l = 0.6, tilt = pi/2
  h10e: overlay = \{ b08e, b10e \}, hkick
\end{example}
