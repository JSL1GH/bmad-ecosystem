\chapter{Bmad Library Subroutine List}

Below are a list of \bmad\ and dcslib routines sorted by their
functionality.  Use the \vn{getf} and \vn{listf} (See section
\ref{s:getf}) scripts for more information on individual routines.
This list includes low level routines that are not generally used in
writing code for a program but may be useful in certain unique
situations.  Excluded from the list are low level routines that are
solely meant for \bmad\ internal use and specialized routines not of
general interest.


\toffset
\begin{center}
\begin{tabular}{|l|l|} \hline
{\em Routine Type} & {\em Section} \\ \hline
 	Reading/Writing Lattice Files           & \ref{r:read}       \\ \hline
 	Choosing a Lattice                      & \ref{r:lat}        \\ \hline
 	Twiss etc.                              & \ref{r:twiss}      \\ \hline
 	Matrices                                & \ref{r:mat}        \\ \hline
 	Routines called by \vn{make_mat6}       & \ref{r:mat6}       \\ \hline
 	Low level matrix routines               & \ref{r:low_mat}    \\ \hline
 	Tracking, Closed Orbit                  & \ref{r:track}      \\ \hline
 	Tracking Routines called by \vn{track1} & \ref{r:track1}     \\ \hline
 	Low Level Tracking Routines             & \ref{r:low_track}  \\ \hline
 	Particle Coordinate Stuff               & \ref{r:coord}      \\ \hline
 	Ring Geometry                           & \ref{r:geom}       \\ \hline
 	Interface to PTC                        & \ref{r:ptc}        \\ \hline
  \cpp interface                          & \ref{r:cpp}        \\ \hline
  Mad Tracking Routines                   & \ref{r:mad}        \\ \hline
 	Taylor Maps                             & \ref{r:taylor}     \\ \hline
  Macroparticle                           & \ref{r:macro}      \\ \hline
 	Long Range Beam--Beam Interaction       & \ref{r:lrbbi}      \\ \hline
 	Helper Routines: Informational          & \ref{r:info}       \\ \hline
 	Helper Routines: Elemental              & \ref{r:elem}       \\ \hline
 	Helper Routines: Transformational       & \ref{r:trans}      \\ \hline
 	Helper Routines: Multipoles             & \ref{r:multi}      \\ \hline
 	Helper Routines: Miscellaneous          & \ref{r:misc_help}  \\ \hline
 	Helper Routines: Low Level Stuff        & \ref{r:low_help}   \\ \hline
 	Overload Equal Sign Routines.           & \ref{r:equal}      \\ \hline
 	Linac Stuff (out of date)               & \ref{r:linac}      \\ \hline
 	CESR Specific                           & \ref{r:cesr}       \\ \hline
 	Obsolete                                & \ref{r:obs}        \\ \hline \hline
  Quick Plot                              & \ref{r:qp}         \\ \hline
  Nonlinear Optimizers                    & \ref{r:opti}       \\ \hline
  Matrix Routines in DCSLIB               & \ref{r:dcs_matrix} \\ \hline
  Miscellaneous DCSLIB Routines           & \ref{r:dcs_misc}   \\ \hline
\end{tabular}
\end{center}
\toffset

%------------------------------------------------------------------------
\section{Reading/Writing Lattice Files} 
\label{r:read}

\begin{description}

\item[bmad\_parser (in\_file, ring)] \Newline
Subroutine to parse (read in) a Bmad input file. 

\item[bmad\_parser2 (in\_file, ring)] \Newline
Subroutine to parse (read in) a Bmad input file to modify an existing lattice. 

\item[bmad\_to\_mad (mad\_file, ring, ix\_start, ix\_end)] \Newline 
Subroutine to write a mad lattice file using the information in
a ring\_struct. 

\item[read\_digested\_bmad\_file (in\_file\_name, ring, version)] \Newline
Subroutine to read in a digested file. 

\item[write\_bmad\_lattice\_file (lattice\_name, ring)] \Newline 
Subroutine to write a Bmad lattice file using the information in
a ring\_struct.

\item[write\_digested\_bmad\_file (digested\_name, ring, n\_files, file\_names)] \Newline
Subroutine to write a digested file. 

\item[xsif\_parser (xsif\_file, ring, make\_mats6)] \Newline 
     Subroutine to parse an XSIF (extended standard input format) lattice file.

\end{description}

%------------------------------------------------------------------------
\section{Choosing a Lattice}
\label{r:lat}

\begin{description}

\item[choose\_cesr\_lattice (lattice, lat\_file, current\_lat, ring)] \Newline
Subroutine to let the user choose a lattice. The subroutine will present a list to choose from. 

\item[get\_lattice\_list (lat\_list, num\_lats, directory)] \Newline
Subroutine to get the names of the lattices of the form: directory/bmad\_*.lat 

\end{description}

%------------------------------------------------------------------------
\section{Twiss etc}
\label{r:twiss}

\begin{description}

\item[calc\_z\_tune (ring)] \Newline
Subroutine to calculate the synchrotron tune from the full 6X6 1 turn matrix. 

\item[chrom\_calc (ring, delta\_e, chrom\_x, chrom\_y)] \Newline
Subroutine to calculate the chromaticities by computing the tune 
change when then energy is changed. 

\item[chrom\_tune (ring, delta\_e, target\_x, target\_y, err\_flag)] \Newline
Subroutine to set the sextupole strengths so that the ring 
has the desired chromaticities. 

\item[emitt\_calc (ring, what, mode)] \Newline
Subroutine to calculate the emittance, energy spread, and synchrotron integrals. 

\item[quad\_beta\_ave (ring, ix\_ele, beta\_x\_ave, beta\_y\_ave)] \Newline
Subroutine to compute the average betas in a quad.

\item[radiation\_integrals (ring, orb\_, mode)] \Newline
Subroutine to calculate the synchrotron radiation integrals, the emittance, and energy spread. 

\item[relative\_mode\_flip (ele1, ele2)] \Newline
Function to see if the modes of ELE1 are flipped relative to ELE2. 

\item[set\_tune (phi\_x\_set, phi\_y\_set, dk1, ring, orb\_, ok)] \Newline
Subroutine to Q\_tune a ring. This routine will set the tunes to within 0.001 radian (0.06 deg). 

\item[set\_z\_tune (ring)] \Newline
Subroutine to set the longitudinal tune by setting the RF voltages in the RF cavities. 

\item[twiss\_and\_track (ring, orb)] \Newline
Subroutine to calculate the Twiss and orbit parameters. 
This is not necessarily the fastest routine. 

\item[twiss\_and\_track\_partial (ele1, ele2, param, del\_s, ele3, start, end)] \Newline
Subroutine to propagate partially through ELE2 the Twiss parameters and the orbit. 

\item[twiss\_at\_element (ring, ix\_ele, start, end, average)] \Newline
Subroutine to return the Twiss parameters at the beginning, end, or the average of an element. 

\item[twiss\_propagate\_many (ring, ix\_start, ix\_end, direction)] \Newline
Subroutine to propagate the Twiss parameters from one element in the ring to another. 

\item[twiss\_and\_track\_at\_s (ring, s, ele, orb\_, here)] \Newline
Subroutine to calculate the Twiss parameters and orbit at a particular longitudinal position. 

\item[twiss\_at\_start (ring)] \Newline
Subroutine to calculate the Twiss parameters at the start of the ring. 

\item[twiss\_from\_tracking (ring, closed\_orb\_, d\_orb, error)] \Newline
Subroutine to compute from tracking, for every element in the ring, 
the Twiss parameters and the transfer matrices. 

\item[twiss\_propagate1 (ele1, ele2)] \Newline
Subroutine to propagate the Twiss parameters from the end of ELE1 to the end of ELE2. 

\item[twiss\_propagate\_all (ring)] \Newline
Subroutine to propagate the Twiss parameters from the start to the end. 

\item[twiss\_to\_1\_turn\_mat (twiss, phi, mat2)] \Newline
Subroutine to form the 2x2 1-turn transfer matrix from the Twiss parameters. 

\end{description}

%------------------------------------------------------------------------
\section{Matrices}
\label{r:mat}

\begin{description}

\item[c\_to\_cbar (ele, cbar\_mat)] \Newline
Subroutine to compute Cbar from the C matrix and the Twiss parameters. 

\item[cbar\_to\_c (cbar\_mat, ele)] \Newline
Subroutine to compute C coupling matrix from the Cbar matrix and the Twiss parameters. 

\item[clear\_ring\_1turn\_mats (ring)] \Newline
Clear the 1-turn matrices in the ring structure. 

\item[do\_mode\_flip (ele, ele\_flip)] \Newline
Subroutine to mode flip the Twiss parameters of an element 

\item[make\_g2\_mats (twiss, g\_mat, g\_inv\_mat)] \Newline
Subroutine to make the matrices needed to go from normal mode coords to 
coordinates with the beta function removed. 

\item[make\_g\_mats (ele, g\_mat, g\_inv\_mat)] \Newline
Subroutine to make the matrices needed to go from normal mode coords to 
coordinates with the beta function removed. 

\item[make\_mat6 (ele, param, c0, c1)] \Newline
Subroutine to make the 6x6 transfer matrix for an element. 

\item[make\_v\_mats (ele, v\_mat, v\_inv\_mat)] \Newline
Subroutine to make the matrices needed to go from normal mode coords to X-Y 
coords and vice versa. 

\item[mat6\_to\_taylor (mat6, vec0, bmad\_taylor)] \Newline
Subroutine to form a first order Taylor map from the 6x6 transfer matrix 
and the 0th order transfer vector. 

\item[mat\_inverse (mat, mat\_inv)] \Newline
Suroutine to take the inverse of a square matrix. 

\item[mat\_symplectify (mat\_in, mat\_symp)] \Newline
Subroutine to form a symplectic matrix that is approimately equal to the input matrix. 

\item[mat\_symp\_check (mat, error)] \Newline
Subroutine to check the symplecticity of a square matrix 

\item[mat\_symp\_decouple (t0, tol, stat, u, v, ubar, vbar, g, twiss1, twiss2, type\_out)] \Newline
Subroutine to find the symplectic eigen--modes of the one turn 4x4 coupled 
transfer matrix T0. 

\item[match\_ele\_to\_mat6 (ele, mat6, vec0)] \Newline 
Subroutine to make the 6 x 6 transfer matrix from the twiss parameters.

\item[multi\_turn\_tracking\_to\_mat (track, i\_dim, mat1, track0, chi)] \Newline
Subroutine to analyze 1-turn tracking data to find the 1-turn transfer matrix 
and the closed orbit offset.

\item[transfer\_matrix\_calc (ring, rf_on, mat6, ix1, ix2)] \Newline
Subroutine to calculate the transfer matrix between two elements. If
ix1 and ix2 are not present the full 1--turn matrix is calculated.

\item[one\_turn\_mat\_at\_ele (ele, phi\_a, phi\_b, mat4)] \Newline
Subroutine to form the 4x4 1-turn coupled matrix with the reference point 
at the end of an element. 

\item[ring\_make\_mat6 (ring, ix\_ele, coord\_)] \Newline
Subroutine to make the 6x6 linear transfer matrix for an element 

\item[taylor\_to\_mat6 (a\_taylor, c0, mat6, c1)] \Newline
Subroutine to calculate the linear (Jacobian) matrix about some trajectory from a Taylor map. 

\item[transfer\_mat2\_from\_twiss (twiss1, twiss2, mat)] \Newline
Subroutine to make a 2 x 2 transfer matrix from the Twiss parameters at the end points. 

\item[transfer\_mat\_from\_twiss (ele1, ele2, m)] \Newline 
Subroutine to make a 6 x 6 transfer matrix from the twiss parameters
at the beginning and end of the element.

\item[twiss\_from\_mat2 (mat, det, twiss, stat, tol, type\_out)] \Newline
Subroutine to extract the Twiss parameters from the one-turn 2x2 matrix 

\item[twiss\_from\_mat6 (mat6, ele, stable, growth\_rate)] \Newline
Subroutine to extract the Twiss parameters from the one-turn 6x6 matrix 

\item[twiss\_to\_1\_turn\_mat (twiss, phi, mat2)] \Newline
Subroutine to form the 2x2 1-turn transfer matrix from the Twiss parameters. 

\end{description}

%------------------------------------------------------------------------
\section{Routines called by make\_mat6}
\label{r:mat6}

\begin{description}

\item[make\_mat6\_bmad (ele, param, c0, c1)] \Newline
Subroutine to make the 6x6 transfer matrix for an element
using closed formulas.

\item[make\_mat6\_custom (ele, param, c0, c1)] \Newline
Dummy routine for making the 6x6 transfer matrices.

\item[make\_mat6\_symp\_lie\_ptc (ele, param, c0, c1)] \Newline
Subroutine to make the 6x6 transfer matrix for an element using
the PTC symplectic integrator.

\item[make\_mat6\_taylor (ele, param, c0, c1)] \Newline
Subroutine to make the 6x6 transfer matrix for an element
from a Taylor map.

\item[make\_mat6\_tracking (ele, param, c0, c1)] \Newline
Subroutine to make the 6x6 transfer matrix for an element by 
tracking 7 particle with different starting conditions.

\end{description}

%------------------------------------------------------------------------
\section{Low Level Matrix Routines}
\label{r:low_mat}  

\begin{description}

\item[drift\_mat6\_calc (mat6, length, start, end)] \Newline
Subroutine to calculate a drift transfer matrix with a possible kick. 

\item[init\_lr\_wake (lr\_wake, n\_term)] \Newline 
Subroutine to initialize a lr\_wake array.

\item[init\_sr\_wake (sr\_wake, n\_term)] \Newline 
Subroutine to initialize a sr\_wake array.

\item[init\_wake (wake, n\_sr, n\_lr)] \Newline 
Subroutine to initialize a wake struct.

\item[lr\_wake\_array\_size (ele) result (array\_size)] \Newline 
Function to return the size of ele%wake%lr.

\item[mat6\_dispersion (mat6, e\_vec)] \Newline
Subroutine to put the dispersion into ELE%MAT6 given the dispersionvector E\_VEC 

\item[sol\_quad\_mat6\_calc (ks, k1, length, mat6, orb)] \Newline
Subroutine to calculate the transfer matrix for a combination solenoid/quadrupole element. 

\item[sr\_wake\_array\_size (ele) result (array\_size)] \Newline 
Function to return the size of ele%wake%sr.

\item[tilt\_mat6 (mat6, tilt)] \Newline
Subroutine to transform a 6x6 transfer matrix to a new reference frame that is 
tilted in (x, Px, y, Py) with respect to the old reference frame. 

\end{description}

%------------------------------------------------------------------------
\section{Tracking, Closed Orbit}
\label{r:track}    

\begin{description}

\item[check\_aperture\_limit (orb, ele, param)] \Newline
Subroutine to check if an orbit is outside the aperture. 

\item[closed\_orbit\_calc (ring, closed\_orb, i\_dim, direction)] \Newline 
Subroutine to calculate the closed orbit at the beginning of the ring.

\item[closed\_orbit\_from\_tracking (ring, closed\_orb\_, i\_dim, 
eps\_rel, eps\_abs, init\_guess)] \Newline
Subroutine to find the closed orbit via tracking. 

\item[dynamic\_aperture (ring, track\_input, aperture)] \Newline
Subroutine to determine the dynamic aperture of a lattice via tracking. 

\item[lost\_particle\_info (lattice, orbit, ix\_lost, plane\_lost)] \Newline 
Subroutine to show where in an orbit a particle hit an aperture and was lost.

\item[multi\_turn\_tracking\_analysis (track, i\_dim, track0, ele, 
stable, growth\_rate, chi)] \Newline
Subroutine to analyze multi-turn tracking data to get the Twiss
parameters etc.

\item[multi\_turn\_tracking\_to\_mat (track, i\_dim, 
mat1, track0, chi)] \Newline
Subroutine to analyze 1-turn tracking data to find the 1-turn transfer
matrix and the closed orbit offset.

\item[\protect\parbox{6in}{offset\_particle (ele, param, coord, set, 
set\_canonical, \\
\hspace*{2in} set\_tilt, set\_multipoles, set\_hvkicks, s\_pos)}] \Newline
Subroutine to effectively offset an element by instead offsetting 
the particle position to correspond to the local element coordinates. 

\item[orbit\_amplitude\_calc (ele, orb, amp\_a, amp\_b, amp\_na, amp\_nb, particle)] \Newline
Routine to calculate the "invariant" amplitude of a particle at a 
particular point in its orbit. 

\item[setup\_radiation\_tracking (ring, closed\_orb, fluctuations\_on, damping\_on)] \Newline
Subroutine to compute synchrotron radiation parameters prior to tracking. 

\item[tilt\_coords (tilt\_val coord, set)] \Newline
Subroutine to effectively tilt (rotate in the x-y plane) an element by 
instead rotating the particle position with negative the angle. 

\item[track1 (start, ele, param, end)] \Newline
Subroutine to track through a single element. 

\item[track\_all (ring, orbit\_)] \Newline
Subroutine to track through the ring. 

\item[track\_beam (ring, beam, ix1, ix2)] \Newline 
     Subroutine to track a beam of macroparticles from the end of
     ring%ele\_(ix1) Through to the end of ring%ele\_(ix2).

\item[track\_many (ring, orbit\_, ix\_start, ix\_end, direction)] \Newline
Subroutine to track from one element in the ring to another. 

\item[twiss\_and\_track (ring, orb)] \Newline
See the Twiss section for more details. 

\item[twiss\_and\_track\_at\_s (ring, s, ele, orb\_, here)] \Newline
Subroutine to calculate the Twiss parameters and orbit at a particular longitudinal position. 

\item[twiss\_and\_track\_partial (ele1, ele2, param, del\_s, ele3, start, end)] \Newline
Subroutine to calculate the Twiss parameters and orbit at a particular position inside an element. 

\item[twiss\_from\_tracking (ring, closed\_orb\_, d\_orb, error)] \Newline
Subroutine to compute from tracking the Twiss parameters and the transfer matrices 
for every element in the ring. 

\end{description}

%------------------------------------------------------------------------
\section{Tracking Routines called by TRACK1}
\label{r:track1}   

Note: Generally you don't call these routines directly.

\begin{description}

\item[symp\_lie\_bmad (ele, param, start, end, calc\_mat6)] \Newline
Symplectic integration through an element to 0th or 1st order.

\item[track1\_adaptive\_boris (start, ele, param, end, s\_start, s\_end)] \Newline
Subroutine to do Boris tracking with adaptive step size control. 

\item[track1\_boris (start, ele, param, end, s\_start, s\_end)] \Newline
Subroutine to do Boris tracking.  

\item[track1\_bmad (start, ele, param, end)] \Newline
Particle tracking through a single element BMAD\_standard style. 

\item[track1\_custom (start, ele, param, end)] \Newline
Dummy routine for custom\_tracking.

\item[track1\_linear (start, ele, param, end)] \Newline
Particle tracking through a single element using the tranfer matrix.. 

\item[track1\_radiation (start, ele, param, end, edge)] \Newline
Subroutine to put in radiation damping and/or fluctuations. 

\item[track1\_runge\_kutta (start, ele, param, end)] \Newline
Subroutine to do tracking using Runge-Kutta integration. 

\item[track1\_symp\_lie\_ptc (start, ele, param, end)] \Newline
Particle tracking through a single element using a Hamiltonian and a 
symplectic integrator. 

\item[track1\_symp\_map (start, ele, param, end)] \Newline
Particle tracking through a single element using a partially inverted 
taylor map (In PTC/FPP this is called a genfield). 

\item[track1\_taylor (start, ele, param, end)] \Newline
Subroutine to track through an element using the elements taylor series. 

\item[track1\_wiedemann\_wiggler (start, ele, param, end)] \Newline
Subroutine to track through the body of a wiggler. 

\end{description}

%------------------------------------------------------------------------
\section{Low Level Tracking Routines}
\label{r:low_track}

\begin{description}

\item[odeint\_bmad (start, ele, param, end, s1, s2, rel\_tol, abs\_tol, h1, hmin)] \Newline
Subroutine to do Runge Kutta tracking. 

\item[track\_a\_accel\_sol (start, ele, param, end)] \Newline
Subroutine to track through an accel\_sol element.

\item[track1\_boris\_partial (start, ele, param, s, ds, end)] \Newline
Subroutine to track 1 step using boris tracking. 
This subroutine is used by track1\_boris and track1\_adaptive\_boris. 

\item[track\_a\_drift (orb, length)] \Newline
Subroutine to track through a drift. 

\item[track\_a\_bend (start, ele, param, end)] \Newline
Particle tracking through a bend element. 

\end{description}

%------------------------------------------------------------------------
\section{Particle Coordinate Stuff}
\label{r:coord}    

\begin{description}

\item[convert\_coords (in\_type\_str, coord\_in, ele, out\_type\_str, coord\_out)] \Newline
Subroutine to convert between lab frame, normal mode, normalized normal mode, 
and action-angle coordinates. 

\item[type\_coord (coord)] \Newline
Subroutine to type out a coordinate. 

\end{description}

%------------------------------------------------------------------------
\section{Ring Geometry}
\label{r:geom}     

\begin{description}

\item[ring\_geometry (ring)] \Newline
Subroutine to calculate the physical placement of all the elements in a ring. 
That is, the layout on the floor. 

\item[s\_calc (ring)] \Newline
Subroutine to calculate the longitudinal distance S for the elements in a ring. 

\end{description}

%------------------------------------------------------------------------
\section{Interface to PTC}
\label{r:ptc}      

\begin{description}

\item[concat\_real\_8 (y1, y2, y3)] \Newline
Subroutine to concatenate two real\_8 taylor series. 

\item[ele\_to\_fibre (ele, fiber, param, integ\_order, steps)] \Newline
Subroutine to convert a Bmad element to a PTC fibre element. 

\item[map\_coef(y, i, j, k, l, style)] \Newline
Function to return the coefficient of the map y(:) up to 3rd order. 

\item[kill\_gen\_field (gen\_field)] \Newline
Subroutine to kill a gen\_field. 

\item[kind\_name (this\_kind)] \Newline
Function to return the name of a PTC kind. 

\item[real\_8\_equal\_taylor (y8, bmad\_taylor)] \Newline
Subroutine to overload "=" in expressions real\_8 = bmad\_taylor 

\item[real\_8\_to\_taylor (y8, bmad\_taylor, switch\_z)] \Newline
Subroutine to convert from a real\_8 taylor map in Etienne's PTC to a taylor map in Bmad. 

\item[real\_8\_init (y, set\_taylor)] \Newline
Subroutine to allocate a PTC real\_8 variable. 

\item[remove\_constant\_taylor (taylor\_in, taylor\_out, c0, remove\_higher\_order\_terms)] \Newline
Subroutine to remove the constant part of a taylor series. 

\item[ring\_to\_layout (ring, ptc\_layout)] \Newline
Subroutine to create a PTC layout from a Bmad ring. 

\item[set\_ptc (param, taylor\_order, integ\_order, num\_steps, no\_cavity, exact\_calc)] \Newline
Subroutine to initialize PTC. 

\item[set\_taylor\_order (order, override\_flag)] \Newline
Subroutine to set the taylor order. 

\item[sort\_universal\_terms (ut\_in, ut\_sorted)] \Newline
Subroutine to sort the taylor terms from "lowest" to "highest". 

\item[taylor\_equal\_real\_8 (bmad\_taylor, y8)] \Newline
Subroutine to overload "=" in expressions bmad\_taylor = y8 

\item[taylor\_to\_real\_8 (bmad\_taylor, y8, switch\_z)] \Newline
Subroutine to convert from a taylor map in Bmad to a real\_8 taylor map in Etienne's PTC. 

\item[type\_layout (lay)] \Newline
Subroutine to print the global information in a PTC layout.

\item[type\_map1 (y, type0, n\_dim, style)] \Newline
Subroutine to type the transfer map up to first order. 

\item[type\_fibre (fib)] \Newline
Subroutine to print the global information in a fibre.

\item[type\_map (y)] \Newline
Subroutine to type the transfer maps of a real\_8 array. 

\item[type\_real\_8\_taylors (y, switch\_z)] \Newline
Subroutine to type out the taylor series from a real\_8 array. 

\item[taylor\_to\_genfield (bmad\_taylor, gen\_field, c0)] \Newline
Subroutine to construct a genfield (partially inverted map) from a taylor map. 

\item[universal\_to\_bmad\_taylor (u\_taylor, bmad\_taylor, switch\_z)] \Newline
Subroutine to convert from a universal\_taylor map in Etienne's PTC to a taylor map in Bmad. 

\item[vec\_bmad\_to\_ptc (vec\_bmad, vec\_ptc)] \Newline
Subroutine to convert from Bmad to PTC coordinates. 

\item[vec\_ptc\_to\_bmad (vec\_ptc, vec\_bmad)] \Newline
Subroutine to convert from PTC to Bmad coordinates. 

\end{description}

%------------------------------------------------------------------------
\section{C++ Interface}
\label{r:cpp}      
\index{C++ interface!routines}

\begin{description}

\item[amode\_to\_c (f\_amode, c\_amode)] \Newline 
Subroutine to convert a Bmad amode\_struct to a C++ C\_amode.

\item[arr2mat (arr, n1, n2) result (mat)] \Newline 
Function to take a an array and turn it into a matrix.

\item[bmad\_com\_to\_c (c\_bmad\_com)] \Newline 
Subroutine to convert the Bmad bmad\_com\_struct common block to 
a C++ C\_bmad\_com.

\item[c\_logic (logic) result (c\_log)] \Newline 
Function to convert from a fortran logical to a C logical.

\item[c\_str (str) result (c\_string)] \Newline 
Function to append a null (0) character at the end of a string (trimmed
of trailing blanks) so it will look like a C character array. 

\item[control\_to\_c (f\_control, c\_control)] \Newline 
Subroutine to convert a Bmad control\_struct to a C++ C\_control.

\item[coord\_to\_c (f\_coord, c\_coord)] \Newline 
Subroutine to convert a Bmad coord\_struct to a C++ C\_coord.

\item[ele\_to\_c (f\_ele, c\_ele)] \Newline 
Subroutine to convert a Bmad ele\_struct to a C++ C\_ele.

\item[em\_field\_to\_c (f\_em\_field, c\_em\_field)] \Newline 
Subroutine to convert a Bmad em\_field\_struct to a C++ C\_em\_field.

\item[f\_logic (logic) result (f\_log)] \Newline 
Function to convert from a fortran logical to a C logical.

\item[floor\_position\_to\_c (f\_floor\_position, c\_floor\_position)] \Newline 
Subroutine to convert a Bmad floor\_position\_struct to a C++ C\_floor\_position.

\item[linac\_mode\_to\_c (f\_linac\_mode, c\_linac\_mode)] \Newline 
Subroutine to convert a Bmad linac\_mode\_struct to a C++ C\_linac\_mode.

\item[lr\_wake\_to\_c (f\_lr\_wake, c\_lr\_wake)] \Newline 
Subroutine to convert a Bmad lr\_wake\_struct to a C++ C\_lr\_wake.

\item[mat2arr (mat) result (arr)] \Newline 
Function to take a matrix and turn it into an array.

\item[modes\_to\_c (f\_modes, c\_modes)] \Newline 
Subroutine to convert a Bmad modes\_struct to a C++ C\_modes.

\item[mode\_info\_to\_c (f\_mode\_info, c\_mode\_info)] \Newline 
Subroutine to convert a Bmad mode\_info\_struct to a C++ C\_mode\_info.

\item[orbit\_to\_c (f\_orbit, c\_orbit)] \Newline 
Subroutine to convert an a Bmad orbit\_struct to a C++ C\_orbit.

\item[param\_to\_c (f\_param, c\_param)] \Newline 
Subroutine to convert a Bmad param\_struct to a C++ C\_param.

\item[ring\_to\_c (f\_ring, c\_ring)] \Newline 
Subroutine to convert a Bmad ring\_struct to a C++ C\_ring.

\item[sr\_wake\_to\_c (f\_sr\_wake, c\_sr\_wake)] \Newline 
Subroutine to convert a Bmad sr\_wake\_struct to a C++ C\_sr\_wake.

\item[twiss\_to\_c (f\_twiss, c\_twiss)] \Newline 
Subroutine to convert a Bmad twiss\_struct to a C++ C\_twiss.

\item[taylor\_term\_to\_c (f\_taylor\_term, c\_taylor\_term)] \Newline 
Subroutine to convert a Bmad taylor\_term\_struct to a C++ C\_taylor\_term.

\item[taylor\_to\_c (f\_taylor, c\_taylor)] \Newline 
Subroutine to convert a Bmad taylor\_struct to a C++ C\_taylor.

\item[wake\_to\_c (f\_wake, c\_wake)] \Newline 
Subroutine to convert a Bmad wake\_struct to a C++ C\_wake.

\item[wig\_term\_to\_c (f\_wig\_term, c\_wig\_term)] \Newline 
Subroutine to convert a Bmad wig\_term\_struct to a C++ C\_wig\_term.

\end{description}

%------------------------------------------------------------------------
\section{Mad Tracking Routines}
\label{r:mad}      

\begin{description}

\item[make\_mat6\_mad (ele, param, map, c0, c1)] \Newline 
     Subroutine to make the 6x6 transfer matrix for an element from the 
     2nd order MAD transport map. The map is stored in ele%taylor.

\item[make\_mad\_map (ele, particle, map)] \Newline 
     Subroutine to make a 2nd order transport map a la MAD.

\item[mad\_add\_offsets\_and\_multipoles (ele, energy, map)] \Newline 
     Subroutine to add in the effect of element offsets and/or multipoles
     on the 2nd order transport map for the element.

\item[mad\_drift (ele, energy, map)] \Newline 
     Subroutine to make a transport map for a drift space.
     The equivalent MAD-8 routine is: TMDRF

\item[mad\_elsep (ele, energy, map)] \Newline 
     Subroutine to make a transport map for an electric separator. 
     The equivalent MAD-8 routine is: TMSEP

\item[mad\_sextupole (ele, energy, map)] \Newline 
     Subroutine to make a transport map for an sextupole.
     The equivalent MAD-8 routine is: TMSEXT

\item[mad\_sbend (ele, energy, map)] \Newline 
     Subroutine to make a transport map for a sector bend element.
     The equivalent MAD-8 routine is: TMBEND

\item[mad\_sbend\_fringe (ele, energy, into, map)] \Newline 
     Subroutine to make a transport map for the fringe field of a dipole.
     The equivalent MAD-8 routine is: TMFRNG

\item[mad\_sbend\_body (ele, energy, map)] \Newline 
     Subroutine to make a transport map for the body of a sector dipole.
     The equivalent MAD-8 routine is: TMSECT

\item[mad\_tmfoc (el, sk1, c, s, d, f) ] \Newline 
     Subroutine to compute the linear focussing functions.  
     The equivalent MAD-8 routine is: TMFOC

\item[mad\_quadrupole (ele, energy, map)] \Newline 
     Subroutine to make a transport map for an quadrupole element.
     The equivalent MAD-8 routine is: TMSEXT

\item[mad\_rfcavity (ele, energy, map)] \Newline 
     Subroutine to make a transport map for an rfcavity element.
     The equivalent MAD-8 routine is: TMRF

\item[mad\_solenoid (ele, energy, map)] \Newline 
     Subroutine to make a transport map for an solenoid.
     The equivalent MAD-8 routine is: TMSEXT

\item[mad\_sol\_quad (ele, energy, map)] \Newline 
     Subroutine to make a transport map for a combination solenoid/quadrupole.
     Note: There is no equivalent MAD-8 routine.

\item[mad\_tmsymm (te)] \Newline 
     subroutine to symmertrize the 2nd order map t.
     The equivalent MAD-8 routine is: tmsymm

\item[mad\_tmtilt (map, tilt)] \Newline 
     Subroutine to apply a tilt to a transport map.
     The equivalent MAD-8 routine is: TMTILT

\item[mad\_concat\_map2 (map1, map2, map3)] \Newline 
     Subroutine to concatinate two 2nd order transport maps.
         map3 = map2(map1)

\item[mad\_track1 (c0, map, c1)] \Newline 
     Subroutine to track through a 2nd order transfer map.
     The equivalent MAD-8 routine is: TMTRAK

\item[track1\_mad (start, ele, param, end)] \Newline 
     Subroutine to track through an element using a 2nd order transfer map.
     Note: If map does not exist then one will be created. 

\item[mad\_map\_to\_taylor (map, taylor)] \Newline 
     Subroutine to convert a mad order 2 map to a taylor map.

\item[taylor\_to\_mad\_map (taylor, map)] \Newline 
     Subroutine to convert a Taylor map to a mad order 2 map.
     If any of the Taylor terms have order greater than 2 they are ignored.

\item[make\_unit\_mad\_map (map)] \Newline 
     Subroutine to initialize a 2nd order transport map to unity.


\end{description}

%------------------------------------------------------------------------
\section{Taylor Map Routines}
\label{r:taylor}   

\begin{description}

\item[concat\_taylor (taylor1, taylor2, taylor3)] \Newline
Subroutine to concatenate two taylor series: taylor3(x) = taylor1(taylor2(x)) 

\item[ele\_to\_taylor (ele, orb0, param)] \Newline
Subroutine to make a Taylor map for an element. The order of the map is set by set\_ptc.

\item[equivalent\_eles (ele1, ele2) result (equiv)] \Newline 
Subroutine to see if to elements are equivalent in terms of attributes so
that their Taylor Maps would be the same. 

\item[init\_taylor (bmad\_taylor)] \Newline
Subroutine to initialize (nullify) a Bmad Taylor map. 

\item[kill\_taylor (bmad\_taylor)] \Newline
Subroutine to deallocate a Bmad Taylor map. 

\item[mat6\_to\_taylor (mat6, vec0, bmad\_taylor)] \Newline
Subroutine to form a first order Taylor map from the 6x6 transfer matrix 
and the 0th order transfer vector. 

\item[set\_taylor\_order (order, override\_flag)] \Newline
Subroutine to set the taylor order. 

\item[sort\_taylor\_terms (taylor\_in, taylor\_sorted)] \Newline
Subroutine to sort the taylor terms from "lowest" to "highest" of a Taylor series. 

\item[taylor\_coef (bmad\_taylor, exp)] \Newline 
Function to return the coefficient for a particular taylor term from a Taylor Series.

\item[taylor\_equal\_taylor (taylor1, taylor2)] \Newline
Subroutine to transfer the values from one taylor map to another: Taylor1 $\le$ Taylor2 

\item[taylors\_equal\_taylors (taylor1, taylor2)] \Newline 
Subroutine to transfer the values from one taylor map to another.

\item[taylor\_to\_mat6 (a\_taylor, c0, mat6, c1)] \Newline
Subroutine to calculate the linear (Jacobian) matrix about some trajectory from a Taylor map. 

\item[taylor\_inverse (taylor\_in, taylor\_inv)] \Newline
Subroutine to invert a taylor map. 

\item[taylor\_propagate1 (tlr, ele, param)] \Newline
Subroutine to track a real\_8 taylor map through an element. 
The alternative routine, if ele has a taylor series, is concat\_taylor. 

\item[track\_taylor (start, bmad\_taylor, end)] \Newline
Subroutine to track using a Taylor map. 

\item[transfer\_ele\_taylor (ele\_in, ele\_out, taylor\_order)] \Newline 
Subroutine to transfer a Taylor map from one element to another.

\item[transfer\_ring\_taylors (ring\_in, ring\_out, 
                                             type\_out, transfered\_all) ] \Newline 
Subroutine to transfer the taylor maps from the elements of one ring to
the elements of another. 

\item[type\_taylors (bmad\_taylor)] \Newline
Subroutine to print in a nice format a Bmad taylor map at the terminal. 

\item[type2\_taylors (bmad\_taylor, lines, n\_lines)] \Newline
Subroutine to write a Bmad taylor map in a nice format to a character array. 

\end{description}

%------------------------------------------------------------------------
\section{Macroparticle Routines}
\label{r:macro}    

\begin{description}

\item[calc\_bunch\_emittance (bunch, ele, x\_norm\_emit, y\_norm\_emit)] \Newline 
Subroutine to calculate the normalized emittances of a bunch.

\item[init\_macro\_distribution (beam, init, canonical\_out)] \Newline 
Subroutine to initialize a macroparticle distribution.
This routine uses the LIAR algorithm. See the Bmad manual for more details.

\item[mat\_to\_mp\_sigma (mat, sigma)] \Newline 
Subroutine to convert a sigma matrix. to a linear array of 
macroparticle sigmas.

\item[mp\_sigma\_to\_mat (sigma, mat)] \Newline 
Subroutine to convert a linear array of macroparticle sigmas to a 
sigma matrix. 

\item[mp\_to\_angle\_coords (mp, energy0)] \Newline 
Subroutine to convert macroparticle coords from 
(x, px, y, py, z, pz) to (x, x', y, y', z, E).

\item[mp\_to\_canonical\_coords (mp, energy0)] \Newline 
Subroutine to convert macroparticle coords from 
(x, x', y, y', z, E) to (x, px, y, py, z, pz).

\item[reallocate\_beam (beam, n\_bunch, n\_slice, n\_macro)] \Newline 
Subroutine to reallocate memory within a beam\_struct.

\item[track1\_beam (start, ele, param, end] \Newline
Subroutine to track a beam of macroparticles through an element.

\item[track\_beam (ring, beam, ix1, ix2)] \Newline 
Subroutine to track a beam of macroparticles from the end of
ring%ele\_(ix1) Through to the end of ring%ele\_(ix2).

\item[track1\_macroparticle (start, ele, param, end)] \Newline 
Subroutine to track a macroparticle through an element.


\end{description}

%------------------------------------------------------------------------
\section{Long Range Beam-Beam Interaction}
\label{r:lrbbi}    

\begin{description}

\item[init\_lrbbi(ring, oppos\_ring, lrbbi\_ele, ix\_lrbbi, ix\_oppos)] \Newline 
     Subroutine to calculate the basic parameters of a beambeam element. 
     Initializes the element and establishes the following values.

\item[insert\_lrbbi (ring, ring\_oppos, cross\_positions, ix\_lrbbi)] \Newline
Subroutine to create and insert beambeam elements at each parasitic crossing
point as specified form a list of crossing points.

\item[lrbbi\_crossings (n\_bucket, oppos\_buckets, cross\_positions)] \Newline
Subroutine to calculate the location of the parasitic crossings points 
given a bunch and an array of positions of the bunches it will cross. 

\item[make\_lrbbi(master\_ring, master\_ring\_oppos, ring, ix\_lrbbi, master\_ix\_lrbbi)] \Newline
Subroutine to turn elements marking parasitic crossings into beam-beam elements. 

\item[mark\_lrbbi(master\_ring, master\_ring\_oppos, ring, crossings)] \Newline
Subroutine to insert named markers into the ring structure at the positions of parasitic crossings. 

\end{description}

%------------------------------------------------------------------------
\section{Helper Routines: Informational}
\label{r:info}     

\begin{description}

\item[attribute\_index (key, name)] \Newline
Function to return the index of an attribute for a given element 
type and the name of the attribute 

\item[attribute\_name (key, index)] \Newline
Function to return the name of an attribute for a particular type of element. 

\item[check\_ring\_controls (ring, exit\_on\_error)] \Newline
Subroutine to check if the control links in a ring structure are valid. 

\item[check\_attrib\_free (ele, ix\_attrib, ring, err\_flag, err\_print\_flag)] \Newline
Subroutine to check if an attribute is free to vary.

\item[elements\_locator (key, ring, indx)] \Newline
Subroutine to locate all the elements of a certain kind in a ring. 

\item[element\_locator (ele\_name, ring, ix\_ele)] \Newline
Subroutine to locate an element in a ring. 

\item[equivalent\_eles (ele1, ele2) result (equiv)] \Newline 
Subroutine to see if twoo elements are equivalent in terms of their attributes so
that their Taylor Maps, if they existed, would be the same.

\item[find\_element\_ends (ring, ix\_ele, ix\_start, ix\_end)] \Newline
Subroutine to find the end points of an element. 

\item[type\_ele (ele, type\_zero\_attrib, type\_mat6, type\_twiss, 
type\_control)] \Newline
Subroutine to print the contents of an element at the terminal. 

\item[type2\_ele (ele, type\_zero\_attrib, type\_mat6, type\_twiss, 
type\_control, lines, n\_lines)] \Newline
Like \vn{type_ele} but the output is stored in a string array. 

\item[type\_twiss (ele, frequency\_units)] \Newline
Subroutine to type out the Twiss parameters from an element. 

\item[type2\_twiss (ele, frequency\_units, lines, n\_lines)] \Newline
Like \vn{type_twiss} but the output is stored in a string array. 

\end{description}

%------------------------------------------------------------------------
\section{Helper Routines: Elemental}
\label{r:elem}     

These routine are for adding elements, moving elements, etc.

\begin{description}

\item[add\_superimpose (ring, super\_ele, ix\_super)] \Newline
Subroutine to make a superimposed element. 

\item[attribute\_bookkeeper (ele, param)] \Newline
Subroutine to make sure the attributes of an element are self-consistent. 

\item[change\_basis (coord, ref\_energy, ref\_z, to\_cart, time\_disp)] \Newline
Subroutine to convert accelerator coordinates (x, x', y, y', z, z') to
Cartesian coordinates and time derivatives (x, x\_dot, y, y\_dot, z,
z\_dot) or vice-versa.

\item[create\_group (ring, ix\_ele, contrl)] \Newline
Subroutine to create a group control element. 

\item[create\_i\_beam (ring, ix\_i\_beam, ix\_slave\_)] \Newline 
     Subroutine to add the controller information to slave elements of
     an i\_beam\_lord.

\item[create\_overlay (ring, ix\_overlay, attrib\_name, , contl)] \Newline
Subroutine to add the controller information to slave elements of an 
overlay\_lord. 

\item[compress\_ring (ring, ok)] \Newline
Subroutine to compress the ele\_(*) and control\_(*) arrays to remove
elements no longer used.

\item[insert\_element (ring, insert\_ele, insert\_index)] \Newline
Subroutine to Insert a new element into the regular part of the ring structure. 

\item[make\_hybrid\_ring (ring\_in, use\_ele, remove\_markers, ring\_out, ix\_out)] \Newline
Subroutine to concatenate together elements to make a hybrid ring 

\item[new\_control (ring, ix\_ele)] \Newline
Subroutine to create a new control element. 

\item[\protect\parbox{6in}{pointer\_to\_attribute (ele, attrib\_name, do\_allocation, 
\\ \hspace*{2in} ptr\_attrib, ix\_attrib, err\_flag, err\_print\_flag)}] \Newline
Returns a pointer to an attribute of an element with name attrib\_name. 

\item[set\_ele\_attribute (ring, i\_ele, attrib\_name, attrib\_value, 
err\_flag, make\_mat6\_flag, orbit\_)] \Newline
Subroutine to set the attribute of an element and propagate the change to any slave elements. 

\item[split\_ring (ring, s\_split, ix\_split, split\_done)] \Newline
Subroutine to split a ring at a point.

\item[update\_hybrid\_list (ring, n\_in, use\_ele)] \Newline
Subroutine used to specify a list of element that should not be
hyberdized by \vn{make_hybrid_ring}.

\end{description}

%------------------------------------------------------------------------
\section{Helper Routines: Transformational}
\label{r:trans}    

\begin{description}

\item[adjust\_control\_struct (ring, ix\_ele)] \Newline
Subroutine to adjust the control structure of a ring so that 
extra control elements can be added. 

\item[allocate\_ring\_ele\_(ring, des\_size)] \Newline 
Subroutine to allocate or re-allocate the ring%ele\_(:) pointer in a ring.

\item[control\_bookkeeper (ring, ix\_ele)] \Newline
Subroutine to calculate the combined strength of the attributes for
controlled elements.

\item[deallocate\_ring\_pointers (ring)] \Newline 
Subroutine to deallocate the pointers in a ring.

\item[init\_ele (ele)] \Newline
Subroutine to initialize an element. 

\item[init\_ring (ring, n)] \Newline 
Subroutine to initialize a Bmad ring.

\item[lattice\_bookkeeper (ring)] \Newline 
Subroutine to do bookkeeping for the entire lattice.

\item[reallocate\_coord (coord\_, n\_coord)] \Newline 
Subroutine to reallocate an allocatable  coord\_struct array to at least:
coord\_(0:n\_coord).

\item[reverse\_ele (ele)] \Newline
Subroutine to "reverse" an element for backward tracking. 

\item[ring\_reverse (ring\_in, ring\_rev)] \Newline
Subroutine to construct a ring structure with the elements in reversed 
order. This may be used for backward tracking through the ring. 

\item[set\_design\_linear (ring)] \Newline
Subroutine to set only those elements on that constitute the "design" 
lattice. That is, only quadrupoles, bends and wigglers will be set on. 

\item[set\_on\_off (key, ring, switch, orb\_)] \Newline
Subroutine to turn on or off a set of elements (quadrupoles,
rfcavities, etc.) in a ring.

\item[transfer\_ele (ele1, ele2)] \Newline 
     Subroutine to set ele2 = ele1. 
     This is a plain transfer of information not using the overloaded equal.

\item[transfer\_eles (ele1, ele2)] \Newline 
     Subroutine to set ele2(:) = ele1(:). 
     This is a plain transfer of information not using the overloaded equal.

\item[transfer\_ele\_taylor (ele\_in, ele\_out, taylor\_order)] \Newline 
     Subroutine to transfer a Taylor map from one element to another.

\item[transfer\_ring (ring1, ring2)] \Newline 
     Subroutine to set ring2 = ring1. 
     This is a plain transfer of information not using the overloaded equal.

\item[transfer\_ring\_parameters (ring\_in, ring\_out)] \Newline
Subroutine to transfer the ring parameters (such as ring\%name, 
ring\%param, etc.) from one ring to another. 

\item[transfer\_ring\_taylors (ring\_in, ring\_out, 
                        type\_out, transfered\_all) ] \Newline 
Subroutine to transfer the taylor maps from the elements of one ring to
the elements of another. 

\end{description}

%------------------------------------------------------------------------
\section{Helper Routines: Multipoles}
\label{r:multi}    

\begin{description}

\item[multipole\_ab\_to\_kt (an, bn, knl, tn)] \Newline
Subroutine to convert ab type multipoles to kt (MAD standard) multipoles. 

\item[multipole\_ele\_to\_ab (ele, particle, a, b, use\_ele\_tilt)] \Newline
Subroutine to put the scaled element multipole components (normal and skew) into 2 vectors. 

\item[multipole\_ele\_to\_kt (ele, particle, knl, tilt, use\_ele\_tilt)] \Newline
Subroutine to put the scaled element multipole components (strength and tilt) into 2 vectors. 

\item[multipole\_init] \Newline
 Subroutine to initialize the multipole arrays within an element.

\item[multipole\_kick (knl, tilt, n, coord)] \Newline
Subroutine to put in the kick due to a multipole. 

\item[multipole\_kt\_to\_ab (knl, tn, an, bn)] \Newline
Subroutine to convert kt (MAD standard) multipoles to ab type multipoles. 

\end{description}

%------------------------------------------------------------------------
\section{Helper Routines: Miscellaneous}
\label{r:misc_help}

\begin{description}

\item[c\_multi (n, m)] \Newline
Subroutine to compute multipole factors: 
c\_multi(n, m) = +/- ("n choose m")/n! 

\item[compute\_element\_energy (ring)] \Newline
Subroutine to compute the reference energy for each element in a ring 
structure. 

\item[custom\_emitt\_calc (ele, param, c0, c1)] \Newline
Dummy routine for the emittance calculation for CUSTOM elements. 

\item[custom\_radiation\_integrals (ring, ir, orb\_)] \Newline
Dummy routine for the radiation\_integrals calculation for CUSTOM elements. 

\item[em\_field (ele, param, s\_pos, here, field)] \Newline
Subroutine to calculate the E and B fields for an element. 

\item[energy\_to\_kinetic (energy, particle, gamma, kinetic, beta, p0c, brho)] \Newline
Subroutine to calculate the kinetic energy, etc. from a particle's energy. 

\item[field\_interpolate\_3d (position, field\_mesh, deltas)] \Newline
Function to interpolate a 3d field. 

\item[name\_to\_list (ring, ele\_names, use\_ele)] \Newline
Subroutine to make a list of the elements in a ring 
whose name matches the names in the ele\_names list. 

\item[order\_super\_lord\_slaves (ring, ix\_lord)] \Newline
Subroutine to make the slave elements of a super\_lord in order. 

\item[release\_rad\_int\_cache (ix\_cache)] \Newline 
     Subroutine to release the memory associated with caching wiggler values.

\item[wiggler\_vec\_potential (ele, energy, here, vec\_pot)] \Newline
Subroutine to calculate the normalized vector potential at a point for a wiggler.

\end{description}

%------------------------------------------------------------------------
\section{Helper Routines: Low Level Stuff}
\label{r:low_help} 

\begin{description}

\item[adjust\_super\_lord\_s\_position (ring, ix\_lord)] \Newline
Subroutine to adjust the positions of the slaves of a 
super\_lord due to changes in the lord's s\_offset. 

\item[bracket\_index (s\_, s, ix)] \Newline
Subroutine to find the index ix so that s\_(ix) $\le$ s $<$ s\_(ix+1). 
If s $<$ s\_(1) then ix = 0 

\item[deallocate\_ele\_pointers (ele)] \Newline
Subroutine to deallocate the pointers in an element. 

\item[dispersion\_to\_orbit (ele, disp\_orb)] \Newline
Subroutine to make an orbit vector proportional to the dispersion. 

\item[em\_field\_custom] \Newline
Dummy routine that will generate an error if called. 

\item[field\_rk\_custom] \Newline
Dummy routine that will generate an error if called. 

\item[makeup\_group\_slaves (ring, ix\_slave)] \Newline
Subroutine to calculate the attributes of group slave elements.

\item[makeup\_super\_slave (ring, ix\_slave)] \Newline
Subroutine to calculate the attributes of overlay slave elements. 

\item[orbit\_to\_dispersion (orb\_diff, ele)] \Newline
Subroutine to take an orbit vector difference and calculate the dispersion. 

\item[superimpose\_key (key1, key2) result (key12)] \Newline 
Function to decide what the element key (key12) should be when
an element with key1 is superimpsed upon with an element.

\item[twiss\_decoupled\_propagate (ele1, ele2)] \Newline
Subroutine to propagate the Twiss parameters from end of ele1 to end of ele2. 

\end{description}

%------------------------------------------------------------------------
\section{Overloading the equal sign}
\label{r:equal}    

\begin{description}

\item[coord\_equal\_coord (coord1, coord2)] \Newline
Subroutine that is used to set one coord\_struct equal to another. 

\item[ele\_equal\_ele (ele1, ele2)] \Newline
Subroutine that is used to set one element equal to another. 
This routine takes care of the pointers in ele1. 

\item[ele\_vec\_equal\_ele\_vec (ele1, ele2)] \Newline
Subroutine that is used to set one element vector equal to another. 
This routine takes care of the pointers in ele1. 

\item[real\_8\_equal\_taylor (y8, bmad\_taylor)] \Newline
Subroutine to overload "=" in expressions real\_8 (PTC) = bmad\_taylor.

\item[ring\_equal\_ring (ring1, ring2)] \Newline
Subroutine that is used to set one ring equal to another. 
This routine takes care of the pointers in ring1. 

\item[ring\_vec\_equal\_ring\_vec (ring1, ring2)] \Newline
Subroutine that is used to set one ring array equal to another. 
This routine takes care of the pointers in ring1(:). 

\item[taylor\_equal\_real\_8 (bmad\_taylor, y8)] \Newline
Subroutine to overload "=" in expressions bmad\_taylor = real\_8 (PTC) 

\item[universal\_equal\_universal (universal1, universal2)] \Newline
Subroutine that is used to set one PTC universal\_taylor 
structure equal to another. 

\end{description}

%------------------------------------------------------------------------
\section{Linac}
\label{r:linac}    

Note: These routines are antiquated: Do not use.

\begin{description}

\item[accel\_sol\_mat\_calc (ls, c\_m, c\_e, gamma\_old, gamma\_new, 
b\_x, b\_y, coord, mat4, vec\_st)] \Newline
Subroutine to calculate the 4x4 transfer matrix (excluding steerings) for a 
segment of an accelerating solenoid. 

\item[b\_field\_loop (coord, ele, s\_pos, b\_loop)] \Newline
Subroutine to calculate the magnetic field vector due to a 
circular current loop. 

\item[b\_field\_mult (ring, coord, first, last, s\_pos, b\_vector)] \Newline
Subroutine to calculate the magnetic field vector due to multiple 
circular current loops. 

\item[hypergeom (hgcx, arg)] \Newline
Function to calculate a particular hypergeometric function 

\end{description}

%------------------------------------------------------------------------
\section{CESR Specific}
\label{r:cesr}

These routines are specific to the Cornell CESR storage ring and
outside of Cornell are not of general interest.

\begin{description}

\item[bmad\_to\_cesr (ring, cesr)] \Newline
Subroutine to transfer information from the ring structure returned from 
\vn{Bmad_Parser} to a structure for the CESR ring.

\item[bmad\_to\_db (ring, db)] \Newline
Subroutine to return information on the database that pertains to CESR elements. 

\item[\protect\parbox{6in}{cesr\_crossings (i\_train, j\_car, species, n\_trains\_tot, 
\\ \hspace*{2in}n\_cars, cross\_positions, n\_car\_spacing, train\_spacing)}] \Newline
Subroutine to calculate all parasitic crossing points for a bunch at a given location 
with oppositely circulating bunches of known spacing. 

\item[cesr\_loc\_decode(string, array, num)] \Newline 
Subroutine to decode a list of locations in CESR.

\item[cesr\_loc\_encode(list, ew\_encode, sense, string)] \Newline 
Subroutine to encode a list of locations into an output string.

\item[cesr\_locator (str\_in, prefix, ix\_pre, loc, err\_flag)] \Newline 
Subroutine to parse a character string for a location in the CESR ring.

\item[cesr\_elements\_get (name, n\_found, ele)] \Newline 
Subroutine to find the location of elements from [CESR.SURVEY]RING\_MASTER.DAT

\item[choose\_cesr\_lattice (lattice, lat\_file, current\_lat, ring)] \Newline
Subroutine to let the user choose a lattice. The subroutine will present a list to choose from. 

\item[create\_vsp\_volt\_elements (ring, ele\_type)] \Newline
Subroutine to create elements corresponding to the 6 database elements in CSR VSP VOLT. 

\item[db\_group\_to\_bmad (ing\_name, ing\_num, biggrp\_set, 
ring, con\_, n\_con, ok, type\_err)] \Newline
Subroutine to take a database group element and find the elements 
controlled along with the coefficients. 

\item[db\_group\_to\_bmad\_group (group\_name, group\_num, i\_biggrp, 
ring, ix\_ele, ok, type\_err)] \Newline
Subroutine to set up a database group knob in a Bmad ring structure. 

\item[identify\_db\_node (db\_name, db, dp\_ptr, ok, type\_err)] \Newline
Subroutine to find which array in DB is associated with DB\_NAME. 

\item[lattice\_to\_bmad\_file\_name (lattice, bmad\_file\_name)] \Newline
Subroutine to convert a lattice name to the appropriate Bmad file name. 

\item[\protect\parbox{6in}{quad\_calib (lattice, k\_theory, k\_base, len\_quad, 
\\ \hspace*{2in} cu\_per\_k\_gev, quad\_rot, dk\_gev\_dcu, cu\_theory)}] \Newline
Subroutine to return the calibration constants for the CESR quads. 

\item[read\_butns\_file (butns\_num, butns, db, ok)] \Newline
Subroutine to read in the information in a BUTNS.nnnnn file. 

\item[\protect\parbox{6in}{ring\_to\_quad\_calib (ring, cesr, k\_theory, k\_base, 
\\ \hspace*{2in} len\_quad, cu\_per\_k\_gev, quad\_rot, dk\_gev\_dcu, cu\_theory)}] \Newline
Subroutine to return the calibration constants for the CESR quads. 

\end{description}

%------------------------------------------------------------------------
\section{Obsolete}
\label{r:obs}      

\begin{description}

\item[closed\_orbit\_at\_start (ring, co, i\_dim, iterate)] \Newline
Subroutine to calculate the closed orbit at the beginning of the ring. 

\item[mat\_unit (mat, size, psize)] \Newline 
Routine to create a unit matrix.

\item[set\_on (key, ring, on\_switch, orb\_)] \Newline
Subroutine to turn on or off a set of elements (quadrupoles, rfcavities, etc.) in a ring. 

\item[twiss\_at\_s (ring, s, ele)] \Newline
Obsolete. Use twiss\_and\_track\_at\_s instead. 

\end{description}

%------------------------------------------------------------------------
\section{Quick Plot Routines}
\label{r:qp}      


%--------------------------------------
\subsection{Page Routines}

\begin{description}

\item[qp\_open\_page (page\_type, i\_chan, x\_len, y\_len, units)] \Newline 
     Subroutine to Initialize a page (window) for plotting.

\item[qp\_select\_page (iw)] \Newline 
     Subroutine to switch to a particular page for drawing graphics.

\item[qp\_close\_page] \Newline 
     Subroutine to finish plotting on a page.

\end{description}

%--------------------------------------
\subsection{Calculational Routines}

\begin{description}

\item[qp\_calc\_and\_set\_axis (axis, data\_min, data\_max, ... ] \Newline
     Subroutine to calculate a "nice" plot scale given the minimum and maximum
     of the data. 

\item[\protect\parbox{6in}{qp\_calc\_axis\_params (data\_min, data\_max, div\_min, 
\\ \hspace*{2in} div\_max, how, places, axis\_min, axis\_max, divisions)}] \Newline 
     Subroutine to calculate a "nice" plot scale given the minimum and maximum
     of the data. This is similar to calc\_axis\_scale.

\item[qp\_calc\_axis\_places (axis\_min, axis\_max, divisions, places)] \Newline 
     Subroutine to calculate the number of decimal places needed to display the
     axis numbers.

\item[\protect\parbox{6in}{qp\_calc\_axis\_scale (data\_min, data\_max, divisions, how,
\\ \hspace*{2in} places, axis\_min, axis\_max, niceness\_score)}] \Newline 
     Subroutine to calculate a "nice" plot scale given the minimum and maximum
     of the data. 

\item[qp\_calc\_minor\_div (delta, div\_max, divisions)] \Newline 
     Subroutine to calculate the number of minor divisions an axis should have.

\item[qp\_convert\_rectangle\_rel (rect1, rect2)] \Newline 
     Subroutine to convert a "rectangle" (structure of 4 points) from
     one set of relative units to another

\end{description}

%--------------------------------------
\subsection{Drawing Routines}

\begin{description}

\item[qp\_clear\_page] \Newline 
     Subroutine to clear all drawing from the page.

\item[qp\_clear\_box] \Newline 
     Subroutine to clear all drawing from the current box.
     That is, white out the box region.

\item[qp\_draw\_arc (x0, y0, r\_x, r\_y, ang1, ang2, 
                     units, width, color, style, clip) ] \Newline 
     Subroutine to plot a section of an ellipse.

\item[qp\_draw\_axes] \Newline 
     Subroutine to plot the axes, title, etc. of a plot.

\item[qp\_draw\_data (x, y, draw\_line, symbol\_every, clip)] \Newline
     Subroutine to plot data, axes with labels, a grid, and a title.

\item[qp\_draw\_graph (x, y, x\_lab, y\_lab, title, 
                  draw\_line, draw\_symbol, clip, symbol\_every) ] \Newline 
     Subroutine to plot data, axes with labels, a grid, and a title.

\item[qp\_draw\_graph\_title (title)] \Newline 
     Subroutine to draw the title for a graph.

\item[qp\_draw\_grid] \Newline 
     Subroutine to draw a grid on the current graph.

\item[qp\_draw\_histogram (x\_dat, y\_dat, x\_lab, y\_lab, title)] \Newline 
     Subroutine to plot data, axes with labels, a grid, and a title.

\item[qp\_draw\_legend (lines, x, y, units)] \Newline 
     Subroutine to draw a legend.

\item[qp\_draw\_main\_title (lines, justify)] \Newline 
     Subroutine to plot the main title at the top of the page.

\item[qp\_draw\_polyline (x, y, units, width, color, style, clip)] \Newline 
     Subroutine to draw a polyline.

\item[qp\_draw\_polyline\_basic (x, y, units) ] \Newline 
     Subroutine to draw a polyline. See also qp\_draw\_polyline

\item[qp\_draw\_rectangle (x1, x2, y1, y2, units, color, width,
                                             style, clip) ] \Newline 
     Subroutine to draw a rectangular box.

\item[qp\_draw\_line (x1, x2, y1, y2, units, width, color, style, clip)] \Newline 
     Subroutine to draw a line.

\item[qp\_draw\_symbol (x, y, units, type, height, color, 
                                fill, line\_width, clip) ] \Newline 
     Draws a symbol at (x, y) 

\item[qp\_draw\_symbols (x, y, units, type, height, color,
            fill, line\_width, clip, symbol\_every) ] \Newline 
     Draws a symbol at the (x, y) points. 

\item[qp\_draw\_text (text, x, y, units, justify, height
        color, angle, ...) ] \Newline 
     Subroutine to draw text.

\item[qp\_draw\_text\_basic (text, x, y, units, justify, angle)] \Newline 
     Subroutine to display on a plot a character string.
     See also: qp\_draw\_text.

\item[qp\_draw\_x\_axis (who, y\_pos)] \Newline 
     Subroutine to draw a horizontal axis.

\item[qp\_draw\_y\_axis (who, x\_pos)] \Newline 
     Subroutine to draw a horizontal axis.

\item[qp\_to\_axis\_number\_text (axis, ix\_n, text)] \Newline 
     Subroutine to form the text string for an axis number.

\end{description}

%--------------------------------------
\subsection{Set Routines}

\begin{description}

\item[qp\_calc\_and\_set\_axis (axis, data\_min, data\_max, ... ] \Newline
     Subroutine to calculate a "nice" plot scale given the minimum and maximum
     of the data. 

\item[qp\_set\_axis (axis, a\_min, a\_max, ...)] \Newline
    Subroutine to set (but not plot) the min, max and divisions for the axes of the graph.

\item[qp\_set\_box (ix, iy, ix\_tot, iy\_tot) ] \Newline 
     Subroutine to set the box on the physical page.
     This routine divides the page into a grid of boxes. 

\item[qp\_set\_default (default\_draw\_units, default\_set\_units)] \Newline 
     Subroutine to set the default units for drawing and setting.

\item[qp\_set\_graph (title)] \Newline 
     Subroutine to set certain graph attributes

\item[qp\_set\_graph\_limits] \Newline 
     Subroutine to calculate the offsets for the graph.
     This subroutine also sets the PGPLOT window size equal to the graph size.

\item[qp\_set\_layout (x\_axis, y\_axis, x2\_axis, y2\_axis, ...] \Newline 
     Subroutine to set varias attributes. This routine can be used
     in place of other qp\_set\_* routines.

\item[qp\_set\_line (who, line)] \Newline 
     Subroutine to set the default line attributes.

\item[qp\_set\_margin (x1\_marg, x2\_marg, y1\_marg, y2\_marg, units)] \Newline 
     Subroutine to set up the margins from the sides of the box (see QP\_SET\_BOX)
     to the edges of the actual graph.

\item[qp\_set\_pgplot\_color (ix\_color) ] \Newline 
     Subroutine to set the color in pgplot taking into account that GIF
     inverts the black for white.

\item[qp\_set\_page\_border (x1\_b, x2\_b, y1\_b, y2\_b, units)] \Newline 
     Subroutine to set the border around the physical page.

\item[qp\_set\_clip (clip)] \Newline 
     Subroutine to set the default clipping state.

\item[qp\_subset\_box (ix, iy, ix\_tot, iy\_tot, x\_marg, y\_marg)] \Newline 
     Subroutine to set the box for a graph. This is the same as
     qp\_set\_box but the boundaries of the page are taken to be the box boundaries.

\item[qp\_set\_symbol (symbol)] \Newline 
     Subroutine to set the type and size of the symbols used in plotting data.
     See the pgplot documentation for more details.

\item[qp\_set\_symbol\_attrib (type, height, color, fill, line\_width, clip)] \Newline 
     Subroutine to set the type and size of the symbols used in plotting data.

\item[qp\_set\_line\_attrib (who, width, color, style, clip)] \Newline 
     Subroutine to set the default line attributes.

\item[qp\_set\_graph\_attrib (draw\_grid, draw\_title)] \Newline 
     Subroutine to set attributes of the current graph.

\item[qp\_set\_text\_attrib (who, height, color, background, 
                                uniform\_spacing, spacing\_factor) ] \Newline 
     Subroutine to set the default text attributes.

\end{description}

%--------------------------------------
\subsection{Informational Routines}

\begin{description}

\item[qp\_get\_axis (axis, a\_min, a\_max, div, ... ) ] \Newline
     Subroutine to get the min, max, divisions etc. for the X and Y axes.

\item[qp\_get\_layout\_attrib (who, x1, x2, y1, y2, units)] \Newline 
     Subroutine to get the attributes of the layout.

\item[qp\_text\_len (text)] \Newline 
     Function to find the length of a text string.

\end{description}

%--------------------------------------
\subsection{Conversion Routines}

\begin{description}

\item[qp\_from\_inch\_rel (x\_inch, y\_inch, x, y, units)] \Newline 
     Subroutine to convert from a relative position (an offset) in inches
     to other units.

\item[qp\_from\_inch\_abs (x\_inch, y\_inch, x, y, units)] \Newline 
     Subroutine to convert to absolute position (x, y) from inches referenced
     to the Left Bottom corner of the page

\item[qp\_to\_datum\_abs (x, y, x\_dat, y\_dat, units)] \Newline 
     Subroutine to convert an (x, y) point on the page to data units.

\item[qp\_to\_datum\_rel (x, y, x\_dat, y\_dat, units)] \Newline 
     Subroutine to convert an (x, y) delta to data units.

\item[qp\_to\_data\_abs (x, y, x\_dat, y\_dat, units)] \Newline 
     Subroutine to convert (x, y) points on the page to data units.

\item[qp\_to\_data\_rel (x, y, x\_dat, y\_dat, units)] \Newline 
     Subroutine to convert (x, y) deltas to data units.

\item[qp\_to\_inch\_rel (x, y, x\_inch, y\_inch, units)] \Newline 
     Subroutine to convert a relative (x, y) into inches.

\item[qp\_to\_inch\_abs (x, y, x\_inch, y\_inch, units)] \Newline 
     Subroutine to convert an absolute position (x, y) into inches referenced
     to the left bottom corner of the page.

\end{description}

%--------------------------------------
\subsection{Miscellaneous Routines}

\begin{description}

\item[qp\_read\_data (iu, err\_flag, x, ix\_col, y, iy\_col, z, iz\_col, 
                                                               t, it\_col) ] \Newline 
     Subroutine to read columns of data.

\end{description}

%--------------------------------------
\subsection{Low Level Routines}

\begin{description}

\item[qp\_justify (justify)] \Newline 
     Function to convert a justify character string to a real value
     representing the horizontal justification. 

\item[qp\_save\_state (buffer)] \Newline 
     Subroutine to save the current attributes. 
     Use qp\_restore\_state to restore the saved state.

\item[qp\_restore\_state] \Newline 
     Subroutine to restore saved attributes. 
     Use qp\_save\_state to restore the saved state.

\item[qp\_init\_struct (qp)] \Newline 
     Subroutine to initialize the qp\_struct.

\item[qp\_split\_units\_string (u\_type, region, corner, units)] \Newline 
     Subroutine to split a units string into its components.

\item[qp\_translate\_to\_color\_index (name, index)] \Newline 
     Subroutine to translate from a string to a color index.

\end{description}

%------------------------------------------------------------------------
\section{Nonlinear Optimizers}
\label{r:opti}      

\begin{description}

\item[opti\_lmdif (vec, n, merit, eps) result(this\_opti)] \Newline 
     Function which tries to get the merit function(s) as close to zero as possible
     by changing the values in vec. Multiple merit functions can be used.

\item[initial\_lmdif] \Newline 
     Subroutine that clears out previous saved values of the optimizer.

\item[suggest\_lmdif (xv,fv,eps,itermx,iend,reset\_flag)] \Newline 
     Reverse communication subroutine. 

\item[opti\_de (v\_best, generations, population, merit\_func, v0, v\_del)] \Newline 
     Differential Evolution for Optimal Control Problems.
     This optimizer is based upon the work of Storn and Price. 

\end{description}

%------------------------------------------------------------------------
\section{Matrix Routines in DCSLIB}
\label{r:dcs_matrix}      

\begin{description}

\item[mat\_det (mat, det)] \Newline 
     Subroutine to take the determinant of a square matrix

\item[mat\_make\_unit (mat)] \Newline 
     routine to create a unit matrix.

\item[mat\_rotation (mat, angle, bet\_1, bet\_2, alph\_1, alph\_2)] \Newline 
     Subroutine to construct a 2x2 rotation matrix for translation from
     point 1 to point 2.

\item[mat\_type (mat, nunit, header)] \Newline 
     Subroutine to output matrices to the terminal or to a file

\end{description}

%------------------------------------------------------------------------
\section{Miscellaneous DCSLIB Routines}
\label{r:dcs_misc}      

\begin{description}

\item[abs\_sort (array, index, n)] \Newline 
  Subroutine to sort by absolute value.

\item[bbi\_kick (x, y, r, kx, ky)] \Newline 
Subroutine to compute the normalized kick due to the beam-beam
interaction using the normalized position for input.

\item[ran\_gauss (harvest)] \Newline 
Subroutine to return a Gaussian distributed random number with unit sigma.

\item[ran\_seed (seed)] \Newline 
Subroutine to seed the random number generator. 

\item[ran\_seed\_get (seed)] \Newline 
Subroutine to return the seed used for the random number generator.

\item[ran\_uniform (harvest)] \Newline 
Subroutine to return a random number uniformly distributed in the 
interval [0, 1]. This routine uses the same algorithm as ran from

\item[modulo2\_real (x, amp)] \Newline 
Function to return
modulo2\_real = x + 2 * n * amp

\item[modulo2\_int (x, amp)] \Newline 
Function to return
modulo2\_int = x + 2 * n * amp

\item[reallocate\_string (str, l\_str, n)] \Newline 
Function to reallocate a string array.

\item[reallocate\_integer (inte, n)] \Newline 
Function to reallocate a integer.

\item[reallocate\_real (re, n)] \Newline 
Function to reallocate a rea;

\item[reallocate\_logical (logic, n)] \Newline 
Function to reallocate a string array.

\item[reassociate\_string (str, l\_str, n)] \Newline 
Function to reassociate an array of strings.

\item[reassociate\_integer (inte, n)] \Newline 
Function to reassociate an array of integers.

\item[reassociate\_real (re, n)] \Newline 
Function to reassociate an array of reals.

\item[reassociate\_logical (logic, n)] \Newline 
Function to reassociate a string array.

\item[skip\_header (unit\_, error\_flag)] \Newline 
Subroutine to find the first line of data in a file. 

\item[string\_trim(in\_string, out\_string, word\_len)] \Newline 
Subroutine to trim a string of leading blanks and/or tabs and also to return the
length of the first word.

\item[spline\_akima (spline, stat)] \Newline 
Given a set of (x,y) points we want to interpolate between the points.
This subroutine computes the semi-hermite cubic spline developed by akima

\item[spline\_evaluate (spline, x, ok, y, dy)] \Newline 
Subroutine to evaluate a spline at a set of points.

\end{description}
