\chapter{Maintaining and Compiling Bmad: SVN and Gmake}
\label{c:svn_gmake}
\index{SVN}
\index{Gmake}

\index{Tao}
The Bmad distribution is stored in a \svn repository. \svn
(Subversion) is a widely used system for maintaining
documents. That is, by using \svn one can keep track of past
versions of documents, can keep a log of who, when, and why changes
occurred, can coordinate multiple people working on the same document,
etc.  Documentation on \svn can be obtained on Unix or Linux by
using the \vn{svn help} command. Documentation is also available on
the web at
\begin{example}
  http://subversion.tigris.org
\end{example}
In the case of \bmad, most of the
documents are code files but the \bmad and \tao documentation is
also maintained under \svn.

\index{GNU}
\vn{Gmake} is the \vn{GNU} version of the \vn{make} system. Gmake is a
system whereby, after changes to program or library files are made,
only those files that need recompiling are recompiled. Considering the
time it can take to compile this represents an enormous savings in
time. Actually \vn{gmake} is more general than this but for the
purposes of this discussion the interested reader is referred to the
\vn{Gmake} documentation which can be obtained on Unix or Linux by
using the \vn{man gmake} or \vn{man make} command.

\svn and \vn{gmake} are very sophisticated systems and this
documentation only gives some of the basics to enable someone to
develop programs based upon \bmad.

%----------------------------------------------------------------------------
\section{Setting up SVN}
\label{s:svn_setup}
\index{SVN!setup}

\index{SVN!repository}
A ``repository'' is the place where \svn keeps the information
about the files (called ``sources'') it is maintaining. The repository
contains all the information to permit extracting previous versions of
the sources at any time based on either a symbolic revision tag, or a
date in the past.

You don't need to setup a \svn repository for \bmad (it already
exists) but \svn can, in general, be useful for projects of all
stripes from writing a book to maintaining code. Therefore, this
section gives a brief overview of how to setup your own \svn
repository.

The \svn repository is setup by creating a ``root'' directory
to hold it using the command
\begin{example}
  svnadmin create <repository_root_dir> 
\end{example}
\vn{<repository_root_dir>} is the root directory name. \svn will create
\vn{<repository_root_dir>} and initialize it. For example:
\begin{example}
  svn /home/dcs/svn_root
\end{example}

\begin{figure}[tb]
  \begin{centering}
  \includegraphics{svn.eps}
  \caption{A) Example Project before Importing to \svn. B) Project when checked--out.}
  \label{f:svn}
  \end{centering}
\end{figure}

When starting a project, the first step is to store the initial version of the 
files that are to be maintained by \svn using the command
\begin{example}
  svn import <import_dir> <repository_project_dir> import -m "<comment>" 
\end{example}
Everything in <import_dir> and subdirectories will be put into \svn in the
directory \vn{<repository_project_dir>}. \vn{<repository_project_dir>} must
be a sub-directory of \vn{<repository_root_dir>}.
\vn{<repository_project_dir>} must be an absolute path name. If the \svn
repository is local then \vn{<repository_project_dir>} must be have
\vn{file://} prepended to its name. For importing via the internet the
string \vn{https://} or \vn{http://} must be prepended.

The name of \vn{<import_dir>}
is not used by \svn in the import process but
subdirectory names are preserved in the import. \vn{<comment>} is the
comment string associated with the initial source
files.  An
example import is shown in Figure~\ref{f:svn}A which shows the
directory tree for a directory called \vn{original_dir}.  Assuming that
\vn{original_dir} is the working directory the files in this directory
can be imported using the command
\begin{example}
    svn import . file:///home/dcs/svn_root/books/my_novel -m "start here"
\end{example}
This command imports the 4 files in \vn{original_dir} into the repository and
associates these with the directory \vn{books/my_novel}. If there are multiple
projects then each one can be imported using a different \vn{<repository_project_dir>} 
for each project. 

Note: Since \svn will import all the files it finds it is important
that ``extraneous'' files not be present. For example, compiled object
files should not be put in the repository and should therefore be
deleted before an import. If necessary. the files to be imported can be
copied to a temporary directory for the import.

%----------------------------------------------------------------------------
\section{Using SVN}
\label{s:svn_use}
\index{SVN}

Once a project has been set in the repository,
a local copy of the files in the
repository can be checked out by using the command
\begin{example}
  svn co <repository_project_dir> <local_project_dir>
\end{example}
This will make a directory \vn{<local_project_dir>} with everything in it.
Following the example of the previous section the command
\begin{example}
  svn co file:///home/dcs/svn_root/books/my_novel my_novel
\end{example}
will create a \vn{my_novel} directory in your working directory as shown in
Figure~\ref{f:svn}B. The name \vn{my_novel} has replaced the name
\vn{original_dir} as the root of the files. There has also been added a
new directory named \vn{.svn} which contains information necessary for maintanance.
The files in the \vn{.svn} directory should never be touched since
this could cause \svn to misbehave. 

You are fee to modify the files you have checked out from the
repository. The files in the repository will not be affected by this.
At some point you may want to put your modified files into the
repository. The command to check--in the files is
\begin{example}
  svn ci -m <comment> <file_or_dir_name>
\end{example}
If \vn{<file_or_dir_name>} is a directory then \svn will check--in all
files of that directory and any sub--directories under it. If
\vn{<file_or_dir_name>} is not present then the current working
directory is used. \vn{<comment>} is a comment associated with the
modified files. If you omit the \vn{-m <comment>} option then \svn
will pop up an emacs window for you to type a comment in.
For example, if \vn{mad/file1} has been modified
and if \vn{mad} is the current directory, the command
\begin{example}
  svn ci -m "My First Revision"
\end{example}
will check-in \vn{file1} to the repository. The information printed to
the terminal when this command is executed looks like:
\begin{example}
  Sending    file1
  Transmitting file data ...
  Committed revision 2.
\end{example}
The new state of this project is labeled revision \vn{2} which can be seen by using the command
\begin{example}
  svn log -r <version> <file>
\end{example}
The \vn{-r <version>} tells \svn what version you want to see the log
of. If \vn{<version>} is not present then the latest is taken. If
\vn{-r <version>} is not present then the entire log for \vn{file} is
given. For example, using the command 
\begin{example}
  svn log file1
\end{example}
will produce:
\begin{example}
  RCS file: /home/dcs/dcs/temp/svnroot/mad/file1,v
  Working file: file1
  head: 1.2
  branch:
  locks: strict
  access list:
  symbolic names:
          garbage2: 1.1.1.1
          garbage1: 1.1.1
  classword substitution: kv
  total revisions: 3;     selected revisions: 3
  description:
  ----------------------------
  revision 1.2
  date: 2005/03/25 01:02:15;  author: dcs;  state: Exp;  lines: +1 -0
  My First Revision
  ----------------------------
  revision 1.1
  date: 2005/03/24 20:27:07;  author: dcs;  state: Exp;
  branches:  1.1.1;
  Initial revision
  ----------------------------
  revision 1.1.1.1
  date: 2005/03/24 20:27:07;  author: dcs;  state: Exp;  lines: +0 -0
  start here
  =============================================================================
\end{example}
The initial version was labeled \vn{1.1.1.1}. Since branching is not
being used here \svn automatically made another version labeled
\vn{1.1} but this did not do anything with the file contents. When the
local \vn{file1} was revised and the \vn{svn ci file1} command was
issued the new version was labeled \vn{1.2}. latter versions will be
labeled \vn{1.$n$} where $n$ will be increased by 1 for each new
version. Notice that each file has a separate revision number so that,
at any point in time, the latest revision numbers for the files will
not, in general, all be the same. The \vn{start here} line in the log
under revision 1.1.1.1 comes from the \vn{-m} comment in the \vn{svn
import} command (see the example in the previous section) used to
create the \vn{mad} repository. The \vn{Initial revision} line in the
log is generated by \svn. The \vn{My First Revision} line in the log
comes from the \vn{svn ci} command.  The \vn{lines: +1 -0} under
\vn{revision 1.2} in the log show that 1 line has been added and no
lines deleted in this revision from the last.

If you want to know what files have been modified from what is in the
repository you use the command
\begin{example}
  svn diff <file_name>
\end{example}
The output of this command is similar to the Unix \vn{diff} command.
For example, if the version of \vn{file1} in the repository has the lines
\begin{example}
  Original 1
  Original 2
\end{example}
and the local \vn{file1} is modified so that these lines are replaced by
\begin{example}
  New A
  New B
  New C
\end{example}
then the diff command will produce the output
\begin{example}
  Index: file1
  ===================================================================
  RCS file: /home/dcs/svn_root/mad/file1,v
  retrieving revision 1.2
  diff -r1.2 file1
  37,38c37,39
  < Original 1
  < Original 2
  ---
  > New A
  > New B
  > New C
\end{example}
The \vn{diff -r1.2 file1} shows that the difference is between version
1.2 of \vn{file1} in the repository and the local \vn{file1} The
\vn{37,38c37,39} descriptor means that in the repository version of
\vn{file1} the lines \vn{Original 1} and \vn{original 2} where at
lines 37 through 39. In the new file the lines \vn{New A} through
\vn{New C} are at lines 37 through 39. If multiple sections of a file
are modified then the \vn{diff} output will contain multiple blocks of
a descriptor followed by the lines from the repository file that were
modified or deleted followed by the corresponding lines from the local
file.  If the descriptor contains a \vn{d} then this means that the
local file has had lines deleted from it. If the descriptor has a
\vn{a} then the local file has had lines added to it. To look at the
difference between two versions in the repository use the \vn{-r
<version>} option. In the current example, to see the difference
between versions 1.1 and the latest (1.2) of \vn{file1} the command
would be
\begin{example}
  svn diff -r1.1 -r file1
\end{example}

A \vn{svn co}, as discussed above, will make a local copy of the latest
version of each file of a project. This is normally what is wanted but
in some cases what is needed are the files from a certain point. For
example, you might want the files for a date just before some
revisions where made to check against the latest version. 

The \vn{svn co} command has an option to do this but finding what date
is needed could be problematical. A way around this is to tag all
the files in the project with a given tag string. \svn can then
retrieve the files associated with a given tag string. Tag the
latest versions of the files in the repository uses the command
\begin{example}
  svn -d <repository_root_dir> rtag <tag> <project_or_file_name>
\end{example}
Tags must not contain any spaces. For example, the command
\begin{example}
  svn rtag tag_number_1 mad
\end{example}
will tag all the \vn{mad} project files. [It is always assumed in the
examples that the working directory is \vn{mad} so the \vn{-d} option
does not have to be used.] To see the tags associated with a file use
the command
\begin{example}
  svn status -v <file>
\end{example}
Thus if the \vn{mad} project has been tagged as above the command
\begin{example}
  svn status -v file1
\end{example}
Produces:
\begin{example}
  =================================================================
  File: file1             Status: Up-to-date
  
     Working revision:    1.2     Fri Mar 25 01:02:15 2005             
     Repository revision: 1.2     /home/dcs/svn_root/mad/file1,v
     Sticky Tag:          (none)
     Sticky Date:         (none)
     Sticky Options:      (none)
  
     Existing Tags:
          tag_number_1                    (revision: 1.2)
          garbage2                        (revision: 1.1.1.1)
          garbage1                        (branch: 1.1.1)
\end{example}

To check out the files associated with a certain tag use the command
\begin{example}
  svn -d <repository_root_dir> co -r <tag> <project_or_file_name>
\end{example}
Note that this command can also be used to check--out files with a
given version number. by using the version number in place of
\vn{<tag>}.

As the project develops files will be added and other files will be
deleted. The command to add a file to svn is
\begin{example}
  svn add <file>
\end{example}
The file must already exist. \svn will not actually add the file to
the repository until a \vn{svn ci} is issued. For example, if a file
\vn{new_file} is added to the \vn{this_dir} directory then it is added
with the commands
\begin{example}
  svn add this_dir/new_file
  svn ci
\end{example}
[Again it is assumed that \vn{mad} is the working directory.] A common
mistake here is to forget to a \vn{svn add}. \vn{svn ci} will not warn
you about added files that are not in the repository. To see the
status of all the files in your area use the command
\begin{example}
  svn -n update
\end{example}
For example, if no \vn{svn add} had been done for \vn{new_file} then
the \vn{svn -n update} command would produce
\begin{example}
  svn update: Updating .
  svn update: Updating this_dir
  ? this_dir/new_file
\end{example}
The \vn{?} indicates that \vn{new_file} is not in the repository. The
\vn{-n} option is important in that it prevents \vn{svn} from actually
updating the repository (see below). Notice that having a local file
with no corresponding repository file is not necessarily an error
since there may be local files that are not meant to be in the
repository. For example, compiled object files are generally never but
in the repository.

The command to delete a file is
\begin{example}
  svn delete <file>
\end{example}
The file must have been deleted before you run this command. The file
will not actually be deleted from the repository until you do a
\vn{svn ci}.

Multiple people may check--out the same project and make revisions
(and one person may check--out multiple copies of a project in
multiple areas). The command to update your local copy of a project
after someone else (or you in another local copy) has made changes to
the repository is
\begin{example}
  svn update
\end{example}
As \svn updates you local files it prints information on what it is
doing. For example, if someone else has added the file \vn{other_file}
to the \vn{this_dir} directory then a \vn{svn update} will print
\begin{example}
  svn update: Updating .
  svn update: Updating this_dir
  U other_file
\end{example}
The letter before a file name indicates the status:
\begin{example}
  U -- The local file was brought up-to-date.
  P -- The local file was brought up-to-date via a patch. The effect is the same as U.
  A -- The local file is on the list of files to be added to the repository
          at the next svn ci.
  R -- The file is on the list of files to be removed from the repository
          at the next svn ci.
  M -- The local file has been modified since it was checked out. 
          Nothing is done to it.
  C -- A conflict: You have modified the local file while the same file
          from another source has been checked into the repository.
          The files will be merged.
  ? -- The local file has no corresponding file in the repository.
\end{example}
In the case of a conflict \svn will merge the repository file with
your local file. It does this by taking considering the version of the
file that you checked out from the repository. Call this the \vn{base}
version. \svn then looks at the difference blocks for 1) the local
file and the base version (call this a \vn{local} difference block)
and 2) the latest version in the repository and the base version (call
this a \vn{repository} difference block). If a \vn{repository}
difference block does not overlap any of the \vn{local} difference
blocks the difference block is used to modify the local file. If a
\vn{repository} difference block does overlap a \vn{local} difference
block then the merged file will contain both blocks and it is up to
you to edit the file and to resolve the conflict. The important point
here is that \svn {\it never} deletes any changes you have made. You
can never loose work you have done my updating. When there is a
conflict the local file will have a section that looks like
\begin{example}
  This part of the file was not modified.
  ... etc ...
  <<<<<<< file1
  This part of the file was locally modified
  ... etc ...
  =======
  This part of the file was modified by someone else
  ... etc ...
  >>>>>>> 1.3
  ... etc ...
\end{example}
The ``\vn{<{<}<{<}<{<}<} \vn{file1}'', ``\vn{=======}'', and ``\vn{>{>}>{>}>{>}> 1.3}''
lines are added by \svn to delineate the text coming from the local
modification from the text from the repository modification.

If there is a conflict between a file in the repository and a local
file then \svn will not let you do a \vn{svn ci} on the project. What
needs to be done first is a \vn{svn update} after which you can do a
\vn{svn ci}. If you want to just check--in one file even when there is
a conflict with another file you can do a \vn{svn ci <file>} to just
check in that file. You can never check-in a local file that has a
conflict with the repository.

The repository can also be accessed remotely (something akin to ftp)
by setting two environmental variables on the remote system
\begin{example}
  setenv SVN_RSH ssh
  setenv SVNROOT :ext:<user>@<repository_root_dir>
\end{example}
In this case \vn{<repository_root_dir>} must contain the computer name. For example:
\begin{example}
  setenv SVN_RSH ssh
  setenv SVNROOT :ext:dcs@cesr66.lepp.cornell.edu/home/dcs/svn_root
\end{example}
You will be asked to supply a password but other than that will
behave exactly like the repository was on the local disk.


%----------------------------------------------------------------------------
\Section{Using SVN with Bmad}

The \svn repository for \bmad contains \bmad and the associated
libraries (\sref{s:libs}). Periodically all the libraries are checked
out and compiled. This is called a \vn{release}. Typically the release
root directory is named after the creation date. For example, one release is:
\begin{example}
  /home/cesrulib/cesr_libs/OSF1_alpha/cesr_2005_0320_d
\end{example}
This is a release for the OSF True64 computers built on March 20,
2005. There needs to be different releases for different platforms,
and even with different compilers on the same platform, since the
compiled binary files will be different. Thus, at this time, there are
different releases on Linux for the two compilers in use
(Lahey--Fujitsu and Intel). It is important that if you are developing on
different platforms, or even developing with different compilers, that
you keep your binaries separate as well.

The latest release always has a soft link named \vn{devel}. There is
also a \vn{current} soft link that points to the last "stable" release
that is felt to be (relatively) bug free. The advantage to using the
\vn{devel} version over \vn{current} is that you get the latest bug
fixes (if any). The disadvantage is that it might not be as
stable. Typically people use the \vn{devel} release.

To initialize for \bmad, the \vn{CESRLIB} environmental variable needs
to be set to the desired release root directory and the appropriate
command file must be run. This command file is different for the
\vn{bash} and \vn{tcsh} shells. For example, with \vn{tcsh}, to run
the devel release put the following lines in your \vn{.login} file:
\begin{example}
  setenv CESRLIB devel
  source /home/cesrulib/bin/cesrdef
\end{example}
For \vn{bash} use
\begin{example}
    CESRLIB=devel
    . /home/cesrulib/bin/cesrdefs
\end{example}
Other releases can be used by setting \vn{CESRLIB} appropriately. To
see the names of all the releases look at the directory appropriate
for the compiler and platform which at present are
\begin{example}
  /home/cesrulib/cesr_libs/Linux_alpha       # Linux    Lahey
  /home/cesrulib/cesr_libs/Linux_i686        # Linux    Intel
  /home/cesrulib/cesr_libs/OSF1_alpha        # OSF      Intel
  /home/cesrulib/cesr_libs/CYGWIN_NT_i686    # Windows  Intel
  /home/cesrulib/cesr_libs/VMS_alpha         # VMS      HP
\end{example}

To see the logicals that are setup by the \vn{cesrdef(s)} command file
use the following command:
\begin{example}
  printenv | grep CESR
\end{example}
This will produce something like
\begin{example}
  CESRLIB=devel
  CESR_PLATFORM=OSF1_alpha
  CESR_BASE=/home/cesrulib/cesr_libs/OSF1_alpha
  CESR_CURRENT=/home/cesrulib/cesr_libs/OSF1_alpha/current
  CESR_DEVEL=/home/cesrulib/cesr_libs/OSF1_alpha/devel
  CESR_DOC=/home/cesrulib/cesr_libs/doc
  CESR_SVNROOT=/home/cesrulib/cesr_libs/svnroot
  CESR_REL=/home/cesrulib/cesr_libs/OSF1_alpha/devel
  CESR_CONFIG=/home/cesrulib/cesr_libs/OSF1_alpha/devel/config
  CESR_SVNSRC=/home/cesrulib/cesr_libs/OSF1_alpha/devel/svnsrc
  CESR_EXE=/home/cesrulib/cesr_libs/OSF1_alpha/devel/bin
  CESR_GMAKE=/home/cesrulib/cesr_libs/OSF1_alpha/devel/Gmake
  CESR_LIB=/home/cesrulib/cesr_libs/OSF1_alpha/devel/lib
  CESR_MOD=/home/cesrulib/cesr_libs/OSF1_alpha/devel/modules
  CESR_RUN=/home/cesrulib/cesr_libs/OSF1_alpha/devel/run
  CESR_UTIL=/home/cesrulib/cesr_libs/OSF1_alpha/devel/util
  CESR_INC=/home/cesrulib/cesr_libs/OSF1_alpha/devel/svnsrc/include
  CESR_PKG=/home/cesrulib/cesr_libs/OSF1_alpha/devel/packages
  CESR_CONST=/home/cesrulib/constants
\end{example}

The source code for the local libraries (\vn{Bmad}, \vn{cesr_utils},
\vn{recipes_f-90_LEPP}, and \vn{dcslib}) is in \vn{CESR_SVNSRC}. The
source code for the outside libraries (\vn{forest}, \vn{recipes},
\vn{PGPLOT}, and \vn{xsif}) is in \vn{CESR_PKG}. The
\vn{recipes_f-90_LEPP} library is the specially modified version of
Numerical Recipes (\sref{s:libs}) that can handle either single or
double precision reals. This is not to be confused with the original
single precision version (which is never compiled) \vn{recipes_f-90}
which is in \vn{CESR_PKG}. 

A web based viewer has been setup for \bmad. It can be accessed at
\begin{example}
  http://www.lns.cornell.edu/~cesrulib
\end{example}

Some programs are also maintained in the the \svn repository. some of
these are compiled and linked with a release. The executables are in
\vn{CESR_BIN}. The most notable is \vn{bmadz} which is the CESR
storage ring lattice design program.

If you just link against a release you don't need to check--out and
compile any of the \bmad source code. If you do need to do this the
next section will explain how this is done.

For people outside Wilson Laboratory who need a local copy of \bmad
there are what are called \vn{distributions}. A \vn{distribution} is
made by checking out the \bmad distribution and taring it into one
file for portability. \vn{Distributions} may be obtained from the
\bmad web page (\sref{s:libs}).

%----------------------------------------------------------------------------
\section{Compiling and Linking Bmad Programs}
\label{s:compile}

\begin{figure}[tb]
  \begin{centering}
  \includegraphics{devel-dir.eps}
  \caption[Standard Directory Structure for Bmad Programs.]
{Example of a directory structure for developing Bmad programs. Standardized
names are shown in bold. Italicized names are arbitrary.}
  \label{f:devel_dir}
  \end{centering}
\end{figure}

To facilitate the automatic compiling and linking of programs there is
a standard directory structure, an example of which is shown in
Figure~\ref{f:devel_dir}. In Figure~\ref{f:devel_dir} names in italics
have been arbitrarily chossen for the purposes of this example. Names
in bold are standardized names that will be the same between different
implementations of this directory structure.

\vn{ifort_dir} is the root development directory.  In
Figure~\ref{f:devel_dir} \vn{prog1} and \vn{prog2}
are directories for developing programs. Although only two program
directories are shown, there is no limit as to their number. Code
files can be put in a program directory or in sub--directories. The
\vn{lib} directory of for compiled libraries, the \vn{modules}
directory is for compiled Fortran modules, and the \vn{bin} directory
is for executable files. There can also be local copies of the
\vn{bmad} library and it subsidiary libraries (\sref{s:libs}).

\index{Gmake}
A program directory will always have a \vn{Makefile} file that is used
by \vn{gmake} to compile and link programs. Any local libraries will
also have their own \vn{Makefile} files. Program makefiles are
different from library makefiles and even two program makefiles can 
be different (see below).

Any given program directory can have one or multiple programs within
it. If it has only one program then to compile and link the program
use the command
\begin{example}
  gmake
\end{example}
the default \vn{gmake} behavior in this case is to name the executable
file after the program directory name and not the program file
name. For example, in Figure~\ref{f:devel_dir}, the executable made
from \vn{test.f90} in \vn{prog2} is
\vn{bin/prog2}. There are actually two different executables:
A \vn{production} executable and a \vn{debug} one. The \vn{debug}
executable has a \vn{_g} appended to the name so in this example its
name is \vn{bin/prog2_g}.  The production executable will run
much faster than the debug version (roughly a factor of 3 or so). The
debug version, however, can be used with a debug program to examine
the program as it is running.  The debug version of the program, just
like the production version, can be run without a debugger and this is
sometimes useful since the debug version will catch errors such as an
array index out of bounds that the production version would not.

Along with the executables, \vn{gmake} will make a \vn{.map} file for
each executable which shows where each routine that is part of the
program came from. The \vn{.map} files are are sometimes helpful in
debugging a program. For example, \vn{bin/prog2_g.map} is the
map file associated with \vn{bin/prog2_g}.

To save time, if only the \vn{production} executable is needed, the command
\begin{example}
  gmake production
\end{example}
can be used. To create only the debug version use
\begin{example}
  gmake debug
\end{example}
If there is more than one program in a program directory then the
\vn{gmake} syntax is
\begin{example}
  gmake MAIN_FILE=<program_file_name>
\end{example}
In this case the executable file will be named after the program file
name.

\index{.depend}
\vn{gmake} tries to cut compile and link time by only compiling and/or
linking when file are "out-of-date". Thus \vn{gmake} will only relink
the executable if the creation date of the executable is prior to the
creation dates of the object files that are linked. The dependency
rules that \vn{gmake} uses to decide if one file is dependent upon
another file are kept in a series of files in the \vn{.depend}
directory in a program directory. These dependency files are updated
whenever program files are changed but sometimes \vn{gmake} can become
confused (say if a local library is deleted that the local program
files depend upon) and if this happens the best way to reset things is
via the command
\begin{example}
  gmake clean
\end{example}
This removes the executables, object files and \vn{.depend} directory.

Generally one does not have to worry too much about how \vn{Gmake}
uses a \vn{Makefile} to compile programs but some knowledge is
essential. The operation of the \vn{Makefile} is to set some flags and
then, at the end of the \vn{Makefile}, a second makefile called
\vn{M.tail} is included. It is actually \vn{M.tail} that does all the
work. The \vn{Makefile} is divided up into documented sections.
One such section is:
\begin{example}
  #--------------------------------------------------------------
  # Provide the list of libraries required for linking this job.
  # All lists should be space delimited.
  #
  # LOCAL_LIBS    Local user-supplied libraries
  # CESR_LIBS     CESR libraries
  # PKG_LIBS      CESR outside packages libraries
  # CERN_LIBS     CERN libraries
  #
  # NOTE:  Search order is 
  #        1) locallib area  (typically ../lib)
  #        2) EXTRA_LIB area (optionally specified by the user)
  #        3) CESR_LIB area  (library area for currently specified 
  #                           CESR release)
  #        4) PKG_LIB area   (library area for outside CESR 
  #                           packages)
  #        5) CERN_LIB area  (CERN libraries)
  #--------------------------------------------------------------
  LOCAL_LIBS := 
  CESR_LIBS  := bmad dcslib cesr_utils recipes_f-90_LEPP
  PKG_LIBS   := forest pgplot
  CERN_LIBS  :=
  SYS_LIBS   :=
\end{example}
This section sets the libraries to be linked to the program. Often
link failures can be traced to missing libraries or libraries out of
order. For example, since the \vn{Bmad} library depends upon
\vn{dcslib}, \vn{bmad} must come first in the \vn{CESR_LIBS} list.

Another section in the \vn{Makefile} sets where the executable resides
\begin{example}
  #-------------------------------------------------------------
  # Generate the executable name - the default is \$(JOB) unless  
  # MAIN_FILE has been explicitly specified
  #-------------------------------------------------------------
  ifeq "$(strip $(MAIN_FILE))" ""
          EXE := ../bin/\$(JOB)
  else
    EXE := ../bin/\$(basename \$(notdir \$(MAIN_FILE)))
  endif
\end{example}
\vn{\$(JOB)} is the program directory. 

The standard debug program is called \vn{totalview}. \vn{totalview} is
put out by a company called Etnus and documentation on totalview can
be obtained from the web at
\begin{example}
  http://www.etnus.com
\end{example}

Local copies of \bmad and/or its subsidiary libraries are only
generally only needed in special circumstances. Problems can arise
with local libraries if they are not keep up-to-date with the
repository versions. For this reason it is best to remove local
libraries if they are no longer needed. The command for this is
\begin{example}
  gmake clean
\end{example}
Just removing the library code directory is not enough since modules
in the \vn{modules} directory and the library itself in the \vn{lib}
directory will remain. When compiling libraries it must be remembered
that there is a definite order to the compilation. This is due to the
fact that since Fortran modules are compiled, if a library has a
module that is used by a file in another library, the first library
must be compiled first. The order of libraries is
\begin{example}
  bmad
  dcslib
  recipes_f-90_LEPP
  cesr_utils, forest, XSIF 
\end{example}
The bottom most libraries must be compiled first.
