\chapter{The Ele\_struct}
\label{c:ele_struct}

This chapter describes the \tn{ele_struct} which is the structure that
holds all the information about an individual element: quadrupoles,
separators, wigglers, etc. This structure is somewhat
complicated. However, in practice, a lot of the complexity is
generally hidden  by the \bmad\ bookkeeping routines.

Part of the substructure of the \tn{ele_struct} is shown
in figure~\ref{f:ele_struct} (use \vn{getf} to see the entire structure 
definition). Some of the components of the \vn{ele_struct} like \vn{%name}, 
\vn{%tracking_method}, etc.\ have an obvious correspondence with 
attributes set in the lattice file and will not be discussed further.

\begin{figure}[htb]
\centering
\small
\begin{verbatim}
  type ele_struct
    character(16) name                ! name of element
    character(16) type                ! type name
    character(16) alias               ! Another name
    type (twiss_struct)  x, y, z      ! Twiss parameters at end of element
    type (floor_position_struct) position
    real(rp) value(n_attrib_maxx)     ! attribute values
    real(rp) vec0(6)                  ! 0th order transport vector
    real(rp) mat6(6,6)                ! 1st order transport matrix
    real(rp) c_mat(2,2)               ! 2x2 C coupling matrix
    real(rp) gamma_c                  ! gamma associated with C matrix
    real(rp) s                        ! longitudinal position at the end
    real(rp), pointer :: a(:) => null()  ! skew multipole component
    real(rp), pointer :: b(:) => null()  ! normal multipole component
    type (taylor_struct) :: taylor(6) ! Taylor terms
    type (wake_struct) wake           ! Wakefields
    integer key                       ! key value
    integer sub_key                   ! For wigglers: map_type$, periodic_type$
    integer control_type              ! SUPER_SLAVE$, OVERLAY_LORD$, etc.
    integer mat6_calc_method          ! bmad_standard$, taylor$, etc.
    integer tracking_method           ! bmad_standard$, taylor$, etc.
    integer field_calc                ! Used with integrators (Runge-Kutta et. al)
    integer num_steps                 ! number of slices for DA_maps
    integer integration_ord           ! For Etiennes' PTC: 2, 4, or 6.
    logical symplectify               ! Symplectify mat6 matrices.
    logical exact_rad_int_calc        ! Exact radiation integral calculation?
    logical field_master              ! Calculate strength from the field value?
    logical is_on                     ! For turning element on/off.
  end type
\end{verbatim}
\caption[The \tn{ele\_struct}.]{The \tn{ele\_struct}. Only part of the 
  substructure is shown.}
\label{f:ele_struct}
\end{figure}

%--------------------------------------------------------------------------
\section{Initialization and Element Key}

The \vn{%key} integer component gives the type of element (\vn{quadrupole},
\vn{RFcavity}, etc.). In general to get the correct index for an element type
just add a ``\$'' suffix to the type name. The \vn{key_name} array convets
from integer to the appropriate string. For example
\begin{example}
  type (ele_struct) ele
  call init_ele (ele)                      ! Initialize
  ele%key = wiggler\$                       ! Turn the element into a quadruple
  print *, 'This element: ', key_name(ele%key)  ! Prints: 'WIGGLER'
\end{example}
The call to \vn{init_ele} is needed since this element is being made up
from scratch.  The elements that are part of a \vn{ring_stuct} variable
will get automatically initalized.

%--------------------------------------------------------------------------
\section{Twiss Parameters, etc.}

There are a class of components of the \vn{ele_struct} whose values 
vary along the length of the element. In such a case the value of the 
component will be the value at the exit edge of the element. The 
components are:
\begin{example}
  type (twiss_struct)  x, y, z          ! Twiss parameters
  type (floor_position_struct) position ! Floor position
  real(rp) c_mat(2,2)                   ! Coupling c matrix
  real(rp) gamma_c                      ! Coupling parameter
\end{example}
To get the Twiss parameters, floor position, etc.\ for the beginning
of the element you need to look at the preceding element in the
\vn{ring%ele_(:)} array 
\begin{example}
  ring%ele_(i-1)%x%beta  ! Beta_x at beginning of ith element.
\end{example}
To get the parameters at a position within an element you can use the
routines \vn{twiss_and_track_at_s} or \vn{twiss_and_track_partial}.

The \vn{%x}, \vn{%y}, and \vn{%z} components are themselves
\vn{twiss_struct} structures that hold the Twiss parameters for the
$a$, $b$ and $z$ modes respectively. Yes it is known that the labeling
is misleading. Unfortunately it is a bit entrenched now. The definition of
the \vn{twiss_struct} structure is
\begin{example}
  type twiss_struct
    real(rp) beta, alpha, gamma, phi, eta, etap
    real(rp) eta_lab, etap_lab   ! dispersion along the x or y axis
    real(rp) sigma
  end type 
\end{example} 
The $a$ mode is the ``nearly horizontal'' mode and the $b$ mode is the
``nearly vertical'' mode. Remember: The Twiss parameters are
associated with the normal modes. With coupling there is no Twiss
parameter associated solely with the horizontal axis.  \vn{eta} and
\vn{etap} are also the normal mode dispersion and dispersion derivative.
The true horizontal and vertical dispersions are given by \vn{eta_lab}
and \vn{etap_lab}.

%--------------------------------------------------------------------------
\section{Attribute Values: Dependent and Otherwise}
\label{s:ele_dep}

Most of the real valued attributes of an element are held in the
\vn{%value(:)} array. For example, the value of the \vn{k1} attribute
for a quadrupole element is stored in \vn{%value(k1\$)} where
\vn{k1\$} is an integer parameter. In general to get the correct index
in \vn{%value(:)} for a given attribute just add a ``\$" as a
suffix. To convert from an attribute name to its index in the
\vn{%value} array use the \vn{attribute_index} routine.  To go back
from an index in the \vn{%value} array to a name use the
\vn{attribute_name} routine
\begin{example}
  type (ele_struct) ele
  ele%key = quadrupole$  ! Set element to be a quadrupole
  print *, 'Index for Quad K1:  ', attribute_index(ele, 'K1') ! prints: `4' (= k1\$)
  print *, 'Name for Quad k1\$: ', attrbute_name (ele, k1\$)   ! prints: `K1' 
\end{example}
The list of attributes in the \vn{%value(:)} array for a given element
type is given in the writeup for the different element in
Chapter~\ref{c:elements}. The real valued attribute that are {\em not}
found in the \vn{%value(:)} array are
\begin{example}
  an, bn                                  ! ab_multipole components
  knl tn                                  ! multipole components
  \{out: coef, e1, e2, e3, e4, e5, e6\}     ! taylor term for a Taylor element
  term(i) = Wig_term                      ! Wiggler term
\end{example}

\vn{attribute_bookkeeper} is the routine that makes sure the dependent
variables (See Section~\ref{s:depend}) of an element are keep
up--to--date. \vn{attribute_bookkeeper} is called behind the scenes
when \vn{make_mat6} is called to make transfer matrices. The general
rule is that elment attributes are changed, and if you don't call
\vn{make_mat6}, \vn{ring_make_mat6}, or \vn{control_bookkeeper}
(Section~\ref{s:ring_control}) then you must call
\vn{attribute_bookkeeper}.

If you are designing a program that will let a user decide what
attribute to vary use the routine \vn{pointer_to_attribute} which will
return an error flag if the attribute to be varied should not be. For
example, trying to vary the strength of a bend by varying the \vn{rho}
attribute is an exercise in futility. An example
\begin{example}
  type (ring_struct) ring
  character(16) attrib_name, ele_name
  real(rp), pointer :: attrib_ptr
  real(rp) set_value
  logical err_flag
  integer ix_attrib, ie
  ...
  write (*, '(a)', advance = 'no') ' Name of element to vary: '
  accept '(a)', ele_name
  write (*, '(a)', advance = 'no') ' Name of attribute to vary: '
  accept '(a)', attrib_name
  write (*, '(a)', advance = 'no') ' Value to set attribute at: '
  accept *, set_value
  do ie = 1, ring%n_ele_max
    if (ring%ele_(ie)%name == ele_name) then
      call pointer_to_attribute (ring%ele_(ie), attrib_name, &
                            .false., attrib_ptr, ix_attrib, err_flag)
      if (err_flag) exit      ! Do nothing on an error
      attrib_ptr = set_value  ! Set the attribute
    endif
  enddo
\end{example}

\vn{%b_field_master} is the logical within appropriate elements that sets 
whether it is the strength or field that is the 
independent variable. See Section~\ref{s:depend} for more details.

%--------------------------------------------------------------------------
\section{Transfer Maps}

The first order transfer map through a element is stored in \vn{vec0}
and \vn{mat6}. Thus with \vn{Linear} tracking the appropriate formula is
\begin{example}
  orbit_out = %vec0 + %mat6 * orbit_in
\end{example}
The \bmad\ routines that compute \vn{%mat6} (for example \vn{ring_make_mat6})
take a reference orbit as an argument and the resulting \vn{%mat6} matrix
is the Jacobian about the reference orbit.

%--------------------------------------------------------------------------
\section{Taylor Maps}

\vn{taylor_order} is the order of the Taylor map (see section
\ref{s:taylor_phys}). The map itself is stored in
\vn{%taylor(1:6)}. Each \vn{%taylor(i)} is a \vn{taylor_struct}
structure that defines a Taylor series. The structure is defined as
\begin{example}
  type taylor_struct
    real (rp) ref
    type (taylor_term_struct), pointer :: term(:) => null()
  end type
\end{example}
Each Taylor series is an array of \vn{taylor_term_struct} term defined as
\begin{example}
  type taylor_term_struct
    real(rp) :: coef
    integer :: exp(6)
  end type
\end{example}

To see if there is a Taylor map associated with an element you check the
association status of \vn{%taylor(1)%term}.
As an example the following finds the order of a Taylor map.
\begin{example}
  type (ele_struct) ele
  ...
  if (associated(ele%taylor(1)%term) then  ! Taylor map exists
    taylor_order = 0
    do i = 1, 6
      do j = 1, size(ele%taylor(i)%term)
        taylor_order = max(taylor_order, sum(ele%taylor(i)%term(j)%exp)
      enddo
    enddo
  else  ! Taylor map does not exist
    taylor_order = -1  ! flag non-existance
  endif
\end{example}

The Taylor map is made up around some reference phase space point
corresponding to the coordinates at the enntrance of the element.
This reference point is saved in \vn{%taylor(1:6)%ref}.  Once a Taylor map is
made the reference point is not needed in subsequent
calculations. However, The Taylor map itself will depend upon what
reference point is chosen.


%--------------------------------------------------------------------------
\section {Multipoles}

The multipole components of an element (See setion~\ref{s:fields}) are
stored in the pointers \vn{%a(:)} and \vn{%b(:)}. If \vn{%a} and
\vn{%b} are allocated they always have a range \vn{%a(0:n_pole_maxx)}
and \vn{%b(0:n_pole_maxx)}. Currently \vn{n_pole_maxx} = 20. If the
element is a \vn{multipole} then \vn{%a(n)} is taken to be the
integrated multipole strength \vn{KnL}, and \vn{%b(n)} is taken to be
the tilt \vn{Tn}. Routines for manipulating multipoles can be found in
Section~\ref{r:multi}.

%--------------------------------------------------------------------------
\section{General Use Components}

There are three components of an \vn{ele_struct} that are gauranteed
to never be used by any \bmad\ routine and so are available for use by
someone writing a program. These components are
\begin{example}
   real(rp), pointer :: r(:) => null()  ! For general use. Not used by \bmad. 
   integer ix_pointer                   ! For general use. Not used by \bmad.
   logical logic                        ! For general use. Not used by \bmad.
\end{example}

%--------------------------------------------------------------------------
\section{Initialization and Pointers}

Generally most \tn{ele_struct} elements are part of a
\tn{ring_struct} variable so you generally don't have to worry about
allocation/deallocation issues directly. In case you do have a local
\tn{ele_struct} variable within a subroutine then you either have to
deallocate the pointers within it with a call to
\rn{deallocate_ele_pointers} or you use the save attribute.
\begin{example}
  type (ele_struct), save :: ele     ! Either this at the beginning ...
  ...
  call deallocate_ele_pointers (ele) ! ... Or do this at the end.
\end{example}

\noindent
The equal sign in the assignment
\begin{example}
  ele1 = ele2
\end{example}
is overloaded by the routine \vn{ele_equal_ele} to ensure that the
pointers of \vn{ele1} do not point to the same memory locations as the
pointers of \vn{ele2}.

