\chapter{The Ele\_struct}
\label{c:ele_struct}
\index{Ele_struct|textbf}

This chapter describes the \vn{ele_struct} which is the structure that
holds all the information about an individual element: quadrupoles,
separators, wigglers, etc. 
Part of the substructure of the \vn{ele_struct} is shown
in figure~\ref{f:ele_struct} (use \vn{getf} to see the entire structure 
definition). This structure is somewhat
complicated, however, in practice, a lot of the complexity is
generally hidden  by the \bmad bookkeeping routines.

\begin{figure}[htb]
\centering
\small
\begin{verbatim}
  type ele_struct
    character(16) name                ! name of element
    character(16) type                ! type name
    character(16) alias               ! Another name
    character(200), pointer :: descrip => null()     ! For general use
    type (twiss_struct)  x, y, z      ! Twiss parameters at end of element
    type (floor_position_struct) position
    real(rp) value(n_attrib_maxx)     ! attribute values
    real(rp) vec0(6)                  ! 0th order transport vector
    real(rp) mat6(6,6)                ! 1st order transport matrix
    real(rp) c_mat(2,2)               ! 2x2 C coupling matrix
    real(rp) gamma_c                  ! gamma associated with C matrix
    real(rp) s                        ! longitudinal position at the end
    real(rp), pointer :: a(:) => null()           ! skew multipole component
    real(rp), pointer :: b(:) => null()           ! normal multipole component
    type (wake_struct), pointer :: wake => null() ! Wakefields
    type (taylor_struct) :: taylor(6)             ! Taylor terms
    integer key                       ! key value
    integer sub_key                   ! For wigglers: map_type$, periodic_type$
    integer control_type              ! SUPER_SLAVE$, OVERLAY_LORD$, etc.
    integer mat6_calc_method          ! bmad_standard$, taylor$, etc.
    integer tracking_method           ! bmad_standard$, taylor$, etc.
    integer field_calc                ! Used with integrators (Runge-Kutta et. al)
    integer num_steps                 ! number of slices for DA_maps
    integer integrator_order           ! For Etiennes' PTC: 2, 4, or 6.
    logical symplectify               ! Symplectify mat6 matrices.
    logical exact_rad_int_calc        ! Exact radiation integral calculation?
    logical field_master              ! Calculate strength from the field value?
    logical is_on                     ! For turning element on/off.
  end type
\end{verbatim}
\caption[The \vn{ele\_struct}.]{The \vn{ele\_struct}. Only part of the 
  substructure is shown.}
\label{f:ele_struct}
\end{figure}

%--------------------------------------------------------------------------
\section{String components}

\vnes{%name}, \vnes{%type}, \vnes{%alias}, and \vnes{%descrip} are character arrays
within an \vn{ele_struct}. All of these have a direct correspondence with
the \vn{name}, \vn{type}, \vn{alias}, and \vn{descrip} element attributes in
an input lattice file. The \vnr{bmad_parser} routine will convert 
\vn{name}, \vn{type}, and \vn{alias} attributes to uppercase before loading them
into an \vn{ele_struct}. \bmad generally ignores these character arrays. 
Notice that \vn{%descrip} is a pointer so if you make use of it in a program 
make sure that it is allocated before hand.

%--------------------------------------------------------------------------
\section{Initialization and Element Key}
\index{Ele_struct!initialization}

The \vnes{%key} integer component gives the type of element
(\vn{Quadrupole}, \vn{RFcavity}, etc.). In general to get the
corresponding integer parameter for an element class just add a ``\$''
character to the type name. For example \vn{quadrupole\$} is the integer
parameter for \vn{quadrupole} elements. The \vn{key_name} array convets from
integer to the appropriate string. For example
\begin{example}
  type (ele_struct) ele
  call init_ele (ele)                  ! Initialize
  if (ele%key == wiggler\$) then       ! Test if element is a wiggler.
  print *, 'This element: ', key_name(ele%key) ! Prints, for example, 'WIGGLER'
\end{example}
The call to \vn{init_ele} is needed for any \vn{ele_struct} defined
outside of a \vn{ring_struct} structure.

\index{Wiggler}
\index{Rbend}
\index{Sbend}
The \vnes{%sub_key} component is only used for \vn{Wiggler} and \vn{Rbend} and
\vn{Sbend} elements. For \vn{Wiggler} elements, \vnes{%sub_key} is either set to
\begin{example}
  map_type$ or
  periodic_type$
\end{example}
depending upon tye type of wiggler. For bends the parser routines
turn all \vn{Sbend}s into \vn{Rbend}s. To keep track of what they
were in the input lattice file, the \vn{%sub_key} is set to
\begin{example}
  sbend$ or
  rbend$
\end{example}
whatever is appropriate.

%--------------------------------------------------------------------------
\section{Twiss Parameters, etc.}
\label{s:ele_twiss}
\index{Ele_struct!Twiss}
\index{Ele_struct!global coordinates}
\index{Coordinates!global!in ele_struct}

For variables like the Twiss parameters that vary along the length of an
element the rule is that the value stored in the \vn{ele_struct} is
the value at the exit end of the element. Such variables are:
\index{Ele_struct!%s}
\index{Ele_struct!%gamma_c}
\index{Ele_struct!%c_mat}
\index{Ele_struct!%x}
\begin{example}
  type (twiss_struct)  x, y, z          ! Twiss parameters
  type (floor_position_struct) position ! Floor position
  real(rp) c_mat(2,2)                   ! Coupling c matrix
  real(rp) gamma_c                      ! Coupling parameter
  real(rp) s                            ! Longitudinal positon
\end{example}
To get the Twiss parameters, floor (global) position, etc.\ for the beginning
of the element you need to look at the preceding element in the
\vn{ring%ele_(:)} array 
\begin{example}
  ring%ele_(i-1)%x%beta  ! Beta_x at beginning of ith element.
\end{example}
To get the parameters at a position within an element you can use the
routines \vn{twiss_and_track_at_s} or \vn{twiss_and_track_partial}.

\index{Normal Mode!in Ele_struct}
The \vnes{%x}, \vnes{%y}, and \vnes{%z} components are
\vn{twiss_struct} structures that hold the Twiss parameters for the
$a$, $b$ and $z$ modes respectively. [Yes it is known that the labeling
is misleading. Unfortunately it is a bit entrenched now.] The definition of
the \vn{twiss_struct} structure is
\index{Ele_struct!twiss_struct substruct}
\begin{example}
  type twiss_struct
    real(rp) beta, alpha, gamma, phi, eta, etap
    real(rp) eta_lab, etap_lab   ! dispersion along the x or y axis
    real(rp) sigma
  end type 
\end{example} 
\vn{eta} and \vn{etap} are also the normal mode dispersion and dispersion derivative.
The true horizontal and vertical dispersions are given by \vn{eta_lab}
and \vn{etap_lab}. The relationship between the normal mode and lab dispersions 
is given by \Eq{etaavx}.

\vn{%c_mat} is the coupling \vn{C} matrix given by \Eq{vgicc1} and \vn{%gamma_c}
is the $\gamma$ factor in \Eq{vgicc1}. There are several routines to manipulate
the coupling factors. For example:
\begin{example}
  C_to_Cbar(ele, cbar_mat)             ! Form Cbar(2,2) matrix
  Make_V_Mats(ele, v_mat, v_inv_mat)   ! Form V matrices.
\end{example}
See \sref{r:mat} for a complete listing of such routines.

%--------------------------------------------------------------------------
\section{Attribute Values: Dependent and Otherwise}
\label{s:ele_dep}
\index{Ele_struct!attribute values}

Most of the real valued attributes of an element are held in the
\vnes{%value(:)} array. For example, the value of the \vn{k1} attribute
for a quadrupole element is stored in \vn{%value(k1\$)} where
\vn{k1\$} is an integer parameter. In general to get the correct index
in \vn{%value(:)} for a given attribute just add a ``\$" as a
suffix. To convert from an attribute name to its index in the
\vn{%value} array use the \vn{attribute_index} routine.  To go back
from an index in the \vn{%value} array to a name use the
\vn{attribute_name} routine. Example:
\begin{example}
  type (ele_struct) ele
  call init_ele (ele)    ! Initialize element
  ele%key = quadrupole$  ! Set element to be a quadrupole
  ele%value(k1$) = 0.3                                        ! Set K1 value
  print *, 'Index for Quad K1:  ', attribute_index(ele, 'K1') ! prints: `4' (= k1\$)
  print *, 'Name for Quad k1\$: ', attrbute_name (ele, k1\$)    ! prints: `K1' 
\end{example}
The list of attributes for a given element
type is given in the writeup for the different element in
Chapter~\ref{c:elements}. 

Certain real valued attributes are {\em not}
found in the \vnes{%value(:)} array. For example, multipole components
are stored in the \vnes{%a(:)} and \vnes{%b(:)} arrays. The full list
of real attributes not in \vn{%value(:)} is:
\begin{center}
\begin{tabular}{|l|l|} \hline
  {\em Attribute} & {\em Component in Ele\_struct} \\ \hline
  a$n$, b$n$      & \%a(:), \%b(:)     \\ \hline
  K$n$L, T$n$     & \%a(:), \%b(:)     \\ \hline
  Taylor term     & \%taylor(:)        \\ \hline
  wakes           & \%wake             \\ \hline
  wiggler terms   & \%wig\_term(:)      \\ \hline
\end{tabular}
\end{center}

\vn{attribute_bookkeeper} is the routine that makes sure that the
dependent variables (See \sref{s:depend}) of an element are
keep up--to--date. \vn{attribute_bookkeeper} is called behind the
scenes when \vnf{make_mat6} is called to make transfer matrices and when
\vnf{track1} is called to track through an element. As a general rule,
to be safe, when elment attributes are changed,
call \vnf{attribute_bookkeeper}. If the element is part of a \vn{Ring_struct}
(as it is in most cases), the routine \vnf{control_bookkeeper} (which calls
\vn{attribute_bookkeeper}) should be called instead.

In designing a program that will let a user input what
attribute to vary, the routine \vn{pointer_to_attribute} 
is a covienient way to obtain from the user input a pointer
that points to the approbriate attribute.
For example:
\begin{example}
  type (ring_struct) ring
  character(16) attrib_name, ele_name
  real(rp), pointer :: attrib_ptr
  real(rp) set_value
  logical err_flag
  integer ix_attrib, ie
  ...
  write (*, '(a)', advance = 'no') ' Name of element to vary: '
  accept '(a)', ele_name
  write (*, '(a)', advance = 'no') ' Name of attribute to vary: '
  accept '(a)', attrib_name
  write (*, '(a)', advance = 'no') ' Value to set attribute at: '
  accept *, set_value
  do ie = 1, ring%n_ele_max
    if (ring%ele_(ie)%name == ele_name) then
      call pointer_to_attribute (ring%ele_(ie), attrib_name, &
                            .false., attrib_ptr, ix_attrib, err_flag)
      if (err_flag) exit      ! Do nothing on an error
      attrib_ptr = set_value  ! Set the attribute
    endif
  enddo
\end{example}

\vn{%b_field_master} is the logical within appropriate elements that sets 
whether it is the strength or field that is the 
independent variable. See \sref{s:depend} for more details.

%--------------------------------------------------------------------------
\section{Positional Offsets}
\index{X_offset}
\index{Y_offset}
\index{X_pitch}
\index{Y_pitch}
\index{Tilt}
\index{X_offset_tot}
\index{Y_offset_tot}
\index{X_pitch_tot}
\index{Y_pitch_tot}
\index{Tilt_tot}

The positional offsets for an element are stored in:
\begin{example}
  %value(x_offset\$)
  %value(y_offset\$)
  %value(x_pitch\$)
  %value(y_pitch\$)
  %value(tilt\$)
\end{example}
\index{I_Beam}
If the element is supported by an \vn{I_Beam} then the \vn{I_Beam}
offsets are added on and the total offset with respect to the
reference coordinate system is stored in:
\begin{example}
  %value(x_offset_tot\$)
  %value(y_offset_tot\$)
  %value(x_pitch_tot\$)
  %value(y_pitch_tot\$)
  %value(tilt_tot\$)
\end{example}

The important point is that to vary the position of an individual
element the values of \vn{%value(x_offset\$)}, etc. are changed and to
read the position of an element a program should look at
\vn{%value(x_offset_tot\$)}, etc.

%--------------------------------------------------------------------------
\section{Transfer Maps}
\index{Ele_struct!transfer maps}
\index{Transfer map!in ele_struct}

The first order transfer map through a element is stored in \vn{vec0}
and \vn{mat6}. Thus with \vn{Linear} tracking the appropriate formula is
\begin{example}
  orbit_out = %vec0 + %mat6 * orbit_in
\end{example}
The \bmad routines that compute \vn{%mat6} (for example \vn{ring_make_mat6})
take a reference orbit as an argument and the resulting \vn{%mat6} matrix
is the Jacobian about the reference orbit.

%--------------------------------------------------------------------------
\section{Taylor Maps}
\index{Ele_struct!Taylor maps}
\index{Taylor map!structure in ele_struct}

\vn{taylor_order} is the order of the Taylor map
(see~\sref{s:taylor_phys}). The map itself is stored in
\vn{%taylor(1:6)}. Each \vn{%taylor(i)} is a \vn{taylor_struct}
structure that defines a Taylor series. The structure is defined as
\begin{example}
  type taylor_struct
    real (rp) ref
    type (taylor_term_struct), pointer :: term(:) => null()
  end type
\end{example}
Each Taylor series is an array of \vn{taylor_term_struct} term defined as
\begin{example}
  type taylor_term_struct
    real(rp) :: coef
    integer :: exp(6)
  end type
\end{example}

To see if there is a Taylor map associated with an element the
association status of \vn{%taylor(1)%term} needs to be checked.
As an example the following finds the order of a Taylor map.
\begin{example}
  type (ele_struct) ele
  ...
  if (associated(ele%taylor(1)%term) then  ! Taylor map exists
    taylor_order = 0
    do i = 1, 6
      do j = 1, size(ele%taylor(i)%term)
        taylor_order = max(taylor_order, sum(ele%taylor(i)%term(j)%exp)
      enddo
    enddo
  else  ! Taylor map does not exist
    taylor_order = -1  ! flag non-existance
  endif
\end{example}

The Taylor map is made up around some reference phase space point
corresponding to the coordinates at the enntrance of the element.
This reference point is saved in \vn{%taylor(1:6)%ref}.  Once a Taylor map is
made the reference point is not needed in subsequent
calculations. However, The Taylor map itself will depend upon what
reference point is chosen (\sref{s:taylor_phys}).

%--------------------------------------------------------------------------
\section {Wakefields}
\index{Wakefields!in ele_struct}

See \sref{s:wakefields} for the equations used in wakefield
calculations.  Wakefields are stored in the \vnes{%wake} struct:
\begin{example}
  type wake_struct
    character(200) :: sr_file = ' '
    character(200) :: lr_file = ' '
    type (sr1_wake_struct), pointer :: sr1(:) => null()
    type (sr2_wake_struct), pointer :: sr2_long(:) => null()
    type (sr2_wake_struct), pointer :: sr2_trans(:) => null()
    type (lr_wake_struct), pointer :: lr(:) => null()
    real(rp) :: z_cut_sr = 0    ! cutoff between sr1 and sr2
  end type
\end{example}
Since \vn{%wake} is a pointer its association status must be tested
before any of its sub--components are accessed.
\begin{example}
  type (ele_struct) ele
  ...
  if (associated(ele%wake)) then
    ...
\end{example}

\bmad observes the following rule: If \vn{%wake} is associated then it
is assumed that all the sub--components (\vn{%wake%sr1}, etc.) are
associated. This simplifies programming in that you do not have to
test directly the association status of the sub--components.

The short--range wake is parameterized using three arrays:
\vn{%wake%sr1}, \vn{%wake%sr2_long}, and
\vn{%wake%sr2_trans}. \vn{%wake%sr1} is the tabular form of the
short--range wake (see~\sref{s:wiggler}). The structure definition
for \vn{%wake%sr1} is
\begin{example}
  type sr1_wake_struct     ! Tabular short-Range Wake struct
    real(rp) z             ! Distance behind the leading particle
    real(rp) long          ! Longitudinal wake in V/C/m
    real(rp) trans         ! Transverse wake in V/C/m^2
  end type
\end{example}
All \vn{%wake%sr1(0:)%z} will be negative. Notice that the array lower
bounds is zero since \vn{%wake%sr1(0)%z} = 0. Wakefield kicks are
applied using \Eqs{delvp} and \eq{pelqxw}.

\vn{%wake%sr2_long} gives
the psudo--modes for the short--range longitudinal wake and
\vn{%wake%sr2_trans} gives the psudo--modes for the short--range
transverse wake. Their structure definitions are
\begin{example}
  type sr2_wake_struct  ! Psudo-mode short-Range Wake struct 
    real(rp) amp        ! Amplitude
    real(rp) damp       ! Dampling factor.
    real(rp) freq       ! Frequency in Hz
    real(rp) phi        ! Phase in radians/2pi
    real(rp) norm_sin   ! non-skew sin-like component of the wake
    real(rp) norm_cos   ! non-skew cos-like component of the wake
    real(rp) skew_sin   ! skew sin-like component of the wake
    real(rp) skew_cos   ! skew cos-like component of the wake
  end type
\end{example}
The wakefield kick is calculated from \Eq{wadzk}.  \vn{%amp},
\vn{%damp}, \vn{%freq}, and \vn{%phi} are the input parameters from
the lattice file. the last four components (\vn{%norm_sin}, etc.)
store the accumulated wake: Before the bunch passes through these are
set to zero and as each particle passes through the cavity the
contribution to the wake due to the particle is calculated and added
the components.

\vn{%wake%z_cut_sr} is the cutoff between where the tabular and
psudo--mode forms of the wake are applied. If the longitudinal
distance between two particles is smaller in magnitude then
\vn{%wake%z_cut_sr} then the tabular wake is applied. Otherwise the
psudo--mode wake is applied. \vnr{bmad_parser} will automatically set
\vn{%wake%z_cut_sr} to the value of \vn{%wake%sr1(n)%z} where \vn{n}
is the last element in the array (largest in magnitude z value).


The \vn{%wake%lr} array stores the long--range wake modes. The
structure definition is:
\begin{example}
  type lr_wake_struct   ! Long-Range Wake struct 
    real(rp) freq       ! Actual Frequency in Hz
    real(rp) freq_in    ! Input frequency in Hz
    real(rp) R_over_Q   ! Strength in V/C/m^2
    real(rp) Q          ! Quality factor
    real(rp) angle      ! polarization angle (radians/2pi).
    integer m           ! Order (1 = dipole, 2 = quad, etc.)
    real(rp) norm_sin   ! non-skew sin-like component of the wake
    real(rp) norm_cos   ! non-skew cos-like component of the wake
    real(rp) skew_sin   ! skew sin-like component of the wake
    real(rp) skew_cos   ! skew cos-like component of the wake
    logical polarized   ! Polaraized mode?
  end type
\end{example}
\index{Freq_spread}
This is similar to the \vn{sr2_wake_struct}. \vn{%freq_in} is the
actual frequency in the input file. \vnr{bmad_parser} will set
\vn{%freq} to \vn{%freq_in} except when the \vn{freq_spread} attribute
is non-zero in which case \vn{bmad_parser} will vary \vn{%freq} as
explained in \sref{s:lcav}. \vn{%polarized} is a logical that
indecates whether the the mode has a polarization angle. If so, then
\vn{%angle} is the polarization angle.

%--------------------------------------------------------------------------
\section {Multipoles}
\index{Ele_struct!multipoles}

\index{Multipole!an, bn!in ele_struct}
\index{Multipole!KnL, Tn!in ele_struct}
The multipole components of an element (See \sref{s:fields}) are
stored in the pointers \vnes{%a(:)} and \vnes{%b(:)}. If \vn{%a} and
\vn{%b} are allocated they always have a range \vn{%a(0:n_pole_maxx)}
and \vn{%b(0:n_pole_maxx)}. Currently \vn{n_pole_maxx} = 20. For a
\vn{Multipole} element, the \vn{%a(n)} array stores the integrated
multipole strength \vn{KnL}, and the \vn{%b(n)} array stores the tilt
\vn{Tn}.

A list of \bmad routines for manipulating multipoles can be found in
\sref{r:multi}.

%--------------------------------------------------------------------------
\section{General Use Components}
\index{Ele_struct!components not used by Bmad}

\index{Ele_struct!%r}
\index{Ele_struct!%ix_pointer}
\index{Ele_struct!%logic}
There are three components of an \vn{ele_struct} that are gauranteed
to never be used by any \bmad routine and so are available for use by
someone writing a program. These components are
\begin{example}
   real(rp), pointer :: r(:) => null()  ! For general use. Not used by \bmad. 
   integer ix_pointer                   ! For general use. Not used by \bmad.
   logical logic                        ! For general use. Not used by \bmad.
\end{example}

%--------------------------------------------------------------------------
\section{Initialization and Pointers}
\index{Ele_struct!initialization}
\index{Ele_struct!pointer components}

Generally most \vn{ele_struct} elements are part of a \vn{ring_struct}
variable and elements in a \vn{ring_struct} are handled by the
\vn{ring_struct} allocation/deallocation routines (see
\sref{s:ring:point}). In case you do have a local
\vn{ele_struct} variable within a subroutine or function then you either have to
deallocate the pointers within it with a call to
\vn{deallocate_ele_pointers} or you use the save attribute.
\begin{example}
  type (ele_struct), save :: ele     ! Either do this at the beginning ...
  ...
  call deallocate_ele_pointers (ele) ! ... Or do this at the end.
\end{example}

\noindent
The equal sign in the assignment
\begin{example}
  ele1 = ele2
\end{example}
is overloaded by the routine \vn{ele_equal_ele} to ensure that the
pointers of \vn{ele1} do not point to the same memory locations as the
pointers of \vn{ele2}.

