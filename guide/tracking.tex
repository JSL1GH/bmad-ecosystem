\chapter{Tracking}
\label{c:tracking}
\index{Tracking}

\bmad can do two types of tracking. One type uses a single particle
and tracks its coordinates throughout the lattice. The other type
takes a beam distribution and tracks the centroids and sigmas of
``macroparticles''. Discussion of macroparicle tracking will be
deferred until the last section of this chapter.

%----------------------------------------------------------------
\section{The coord\_struct}
\index{Coord_struct}

For single particle tracking the starting point is the
\vn{coord_struct} whose definition is 
\begin{example}
  type coord_struct
    real(rp) vec(6)   ! (x, p_x, y, p_y, z, p_z)
  end type
\end{example}
The \vn{coord_struct} defines the phase
space vector of the particle at a certain longitudinal location.

To get an orbit, that is, the particle position at every element in a
lattice, you will need an array of \vn{coord_struct}s. Since the
number of elements in the lattice is not known in advance the array
must be declared to be allocatable.
\begin{example}
  type (coord_struct), allocatable :: orbit(:)
\end{example}
An example of how to do multi-turn tracking (assuming a circular lattice) is
\begin{example}
  type (ring_struct) lattice             ! lattice to track through
  type (coord_struct), allocatable :: orbit(:)
  ...
  call bmad_parser ('this_lattice', lattice)
  ...
  call reallocate_coords (orbit, lattice%n_ele_max)
  orbits(0)%vec = (/ 0.01, 0.2, 0.3, 0.4, 0.0, 0.0 /) ! initialization
  do i = 1, n_turns
    call track_all (lattice, orbit)
    orbit(0) = orbit(lattice%n_ele_use)
  end do
\end{example}
\vn{orbit(n)} holds the particle's position at the exit end of the
$n$\Th element. With \vn{ring%n_ele_max} elements in the lattice
(\sref{s:ring_ele}) the \vn{orbit(:)} array needs to be made this
large. The call to \vn{reallocate_coords} does this allocation. Since
\vn{ring%ele_(0)} is essentually a marker element \vn{orbit(0)} is the
orbit at the start of the lattice.  \vn{track_all} takes \vn{orbit(0)}
and tracks through the list of lattice elements until it gets to the
last trackable element \vn{lattice%n_ele_use} (\sref{s:ring_ele}).

If you are writing a routine where the \vn{coord_struct} array is
local (not passed as an argument to the routine) then you have to
decide how to cleanup the allocated \vn{coord_struct} memory at the
end of the routine. In general you have two choices: 1) Deallocate
the array. This is the cleanest solution but it can be slow since you
have to allocate afresh each time the routine is called. 2) Use the
save attribute so that the array stays around until the next time the
routine is called 
\begin{example}
  type (coord_struct), allocatable, save :: orb(:) 
\end{example}
Saving the \vn{coord_stuct} is faster but leaves memory tied up. 

%----------------------------------------------------------------
\section{Tracking Through the Elements}

The routine \vnr{track1} is the routine that tracks through one
element in the lattice. The routine \vnr{track_all} calls \vn{track1}
in a loop over all elements to track through the entire
lattice. Alternatively the routine \vnr{track_many} can be used to
track through a selective number of elements or to track backwards
(See \sref{s:reverse_track}). The routines used for tracking
and closed orbit calculations are listed in Section~\ref{r:track}.

\index{Param_struct!lost}
\index{Param_struct!ix_lost}
\index{Tracking!example}
The \vn{track_all} routine serves as a good example of how tracking
works. \vn{track_all} tracks a particle through a lattice from
beginning to end. Its code, condensed slightly, is shown in
Figure~\ref{f:track_all}.  The \vn{reallocate_coord} call (line~13) is
done in case the number of elements in the lattice has changed. The
call to \vn{track1} (line~18) tracks through one element from the exit
end of the $n-1$\St\ element to the exit end of the $n$\Th
particle. \vn{lattice%param%lost} is a logical that signals the
calling routine whether a particle has been lost.  This generally
happens when the particle's position is larger then the aperture. When
a particle is lost \vn{lattice%param%ix_lost} is used to record in
what element the loss occured.

\begin{figure}[htb]
\begin{centering}
\small
\begin{listing}{1}
  subroutine track_all (lattice, orbit)
    use bmad_struct
    use bmad_interface
    implicit none
    type (ring_struct)  lattice
    type (coord_struct), allocatable :: orbit(:)
    integer n

  ! Init

    lattice%param%lost = .false.
    if (size(orbit) < lattice%n_ele_max+1) &
                    call reallocate_coord (orbit, lattice%n_ele_max)

  ! Track through the elements and check for lost particles.

    do n = 1, lattice%n_ele_use
      call track1 (orbit(n-1), lattice%ele_(n), lattice%param, orbit(n))
      if (lattice%param%lost) then
        lattice%param%ix_lost = n
        return
      endif
    enddo
  end subroutine
\end{listing}
\caption{Condensed track\_all code.}
\end{centering}
\label{f:track_all}
\end{figure}

%----------------------------------------------------------------
\section{Closed Orbit}
\index{Closed orbit}

For a circular lattice the closed orbit may be calculated using
\vn{closed_orbit_calc}. By default this routine will track in the
forward direction which is acceptable unless the particle you are
trying to simulate is traveling in the reverse direction and there is
radiation damping on. In this case you must tell
\vn{closed_orbit_calc} to do backward tracking. This routine works by
iteratively converging on the closed orbit using the 1--turn matrix to
calculate the next guess. On rare occasions if the nonlinearities are
strong enough, this can fail to converge. An alternative routine is
\vn{closed_orbit_from_tracking} which tries to do things in a more
robust way but with a large speed penelty.

%----------------------------------------------------------------
\section{Apertures}
\index{Tracking!apertures}

\index{Param_struct!aperture_limit_on}
\index{Bmad_com_struct!max_aperture_limit}
The logical \vn{lattice%param%aperture_limit_on} determines if element
apertures (See \sref{s:limit}) are used to determine if a
particle has been lost in tracking.  The default
\vn{lattice%param%aperture_limit_on} is True.  Even if this is False
there is a ``hard'' aperture limit set by
\vn{bmad_com%max_aperture_limit}. This hard limit is used to prevent
floating point overflows. The default hard aperture limit is 1000
meters. Additionally, even if a particle is within the hard limit,
some routines will mark a particle as lost if the tracking calculation
will result in an overflow.

\index{Param_struct!end_lost_at}
\index{Param_struct!lost}
\index{Param_struct!ix_lost}
\index{Element!entrance end}
\index{Element!exit end}
\vn{lattice%param%lost} is the logical to check to see if a particle has
been lost. \vn{lattice%param%ix_lost} gives the index of the element
at which a particle is lost and \vn{%param%end_lost_at} gives which
end the particle was lost at. The possible values for
\vn{lattice%param%end_lost_at} are:
\begin{example}
  entrance_end$
  exit_end$
\end{example}
When tracking forward, if a particle is lost at the exit end of an
element then the place where the orbit was outside the aperture is at
\vn{orbit(ix)} where \vn{ix} is the index of the element where the
particle is lost (given by \vn{lattice%param%ix_lost}). If the
particle is lost at the entrance end then the appropriate index is one
less (remember that \vn{orbit(i)} is the orbit at the exit end of an
element). To sort this out and to determine in what plane the particle
is lost in use the routine \vnr{lost_particle_info}.

%----------------------------------------------------------------
\section {Tracking Methods}

\index{Ele_struct!%tracking_method}
For each element the method of tracking may be set either via the
input lattice file (see \sref{s:tkm}) or directly in the
program by setting the \vn{%tracking_method} attribute of an element
\begin{verbatim}
  type (ele_struct) ele
  ...
  ele%tracking_method = boris$  ! for boris tracking
\end{verbatim}
To form the corresponding parameter to a given tracking method just
put ``\$'' after the name. For example, the \vn{bmad_standard}
tracking method is specified by the \vn{bmad_standard\$}
parameter.

\index{Ele_struct!%mat6}
It should be noted that except for \vntm{Linear} tracking, none of the
\bmad tracking routines make use of the \vn{ele%mat6} transfer
matrix. The reverse, however, is not true.  The transfer matrix
routines (\vn{lattice_make_mat6}, etc.)  will do tracking.

\index{Synchrotron radiation!calculating}
\bmad simulates radiation damping and excitation by applying a kick
just before and after each element. To turn on radiation damping
and/or excitation use the \vnr{setup_radiation_tracking} routine.

%----------------------------------------------------------------
\section{Macroparticle Tracking}
\index{Macroparticles!tracking}
\index{Tracking!Macroparticles}

The definition of the \vn{macro_struct} structure that defines a
macroparticle is shown in Figure~\ref{f:macro_struct}.  
\begin{figure}[htb]
\centering
\small
\begin{verbatim}
  type macro_struct
    type (coord_struct) r   ! Center of the macroparticle
    real(rp) sigma(21)      ! Sigma matrix.
    real(rp) :: sig_z = 0   ! longitudinal macroparticle length.
    real(rp) k_loss         ! loss factor (V/m). scratch variable for tracking.
    real(rp) charge         ! charge in a macroparticle (Coul).
    integer :: iz = 0       ! index to ordering of particles in z.
  end type
\end{verbatim}
\caption{The \vn{macro\_struct}\ that defines a macroparticle.}
\label{f:macro_struct}
\end{figure}

\vn{%r} is the
coordinates of the macroparticle center. \vn{%sigma(:)} holds the
sigma matrix. Since the $6 \times 6$ sigma matrix is symmetric only 21
elements need to be stored. Symbolic constants \vn{s$ij$\$} ($i$, $j$
= $1, \ldots, 6$) are defined to map to between the linear
\vn{%sigma(:)} array and the matrix. Example
\begin{example}
  type (macro_struct) macro
  sigma_z = sqrt(macro%sigma(s55\$))
\end{example}
To convert \vn{%sigma(:)} into an actual matrix use the
\vn{mp_sigma_to_mat} routine.

\index{LIAR}
\bmad uses canonical phase space
coordinates(See \sref{s:phase_space_coords}). The LIAR program uses
``angle'' phase space coordinates
\begin{equation}
  (x, x', y, y', -z, E)
\end{equation}
The notation can be confusing here since in LIAR's notation positive
$z$ is in the opposite direction to the \bmad convention. Thus in
LIAR's notation the LIAR phase space coordinates are
\begin{equation}
  (x, x', y, y', z, E)
\end{equation}
To convert between \bmad and LIAR coordinates there are two routines
called \vn{mp_to_angle_coords} and \vn{mp_to_canonical_coords}.

macroparticles are grouped into slices, a number of slices make up a
bunch, and a number of bunches make up a beam. Initialization of a
\vn{beam_struct} structure can be done via the
\vn{init_macro_distribution} which implements the LIAR initialization
algorithm (See \sref{s:macro}). Once a beam is initialized,
tracking can be performed using \vn{track_beam}. An example program is
shown in figure~\ref{f:macro_program}. 

The equal sign in the assigments
\begin{example}
  beam1 = beam2
  bunch1 = bunch2
  slice1 = slice2
\end{example}
is overloaded by the routines \vn{beam_equal_beam}, \vn{bunch_equal_bunch} and
\vn{slice_equal_slice} to ensure that the pointers of \vn{beam1}, \vn{bunch1}
and \vn{slice1} do not point to the same memory locations as the pointers of 
\vn{beam2}, \vn{bunch2} and \vn{slice2}.

the \vn{init} variable (line 11) holds the information to initialize
the macroparticle distribution. The values of the components in the
\vn{init} variable are set using a namelist read (line 24). An example
of an input file that can be used to set \vn{init} is shown in
figure~\ref{f:beam_init}. Line 23 sets the initial reference energy of
the beam to be the reference energy at the start of the linac so this
does not have to be set in the input file.  The
\vn{init_macro_distribution} routine (line 27) initializes the
\vn{beam} variable. The \vn{beam} variable is a container that holds
the macroparticles that make up the beam. The \vn{track_beam} routine
tracks these macroparticles through to the end of the linac. If it is
desired to track only through part of the linac then \vn{track_beam}
has optional arguments that allow this. lines 30 through 41 print out
some horizontal parameters from the position at the end of the linac.

\begin{figure}
\begin{listing}{1}
program macroparticle_test

  use bmad
  use macroparticle_mod

  implicit none

  type (ring_struct) lattice
  type (beam_struct) beam
  type (macroparticle_struct) mp
  type (macro_init_struct) init

  integer i, j, k, n

  namelist / beam_init / init

!

  bmad_com%use_liar_lcavity = .true.
  call bmad_parser ('test.bmad', lattice)

  open (1, file = 'test.init', status = 'old')
  init%E_0 = lattice%ele_(0)%value(beam_energy$)
  read (1, nml = beam_init)
  close (1)

  call init_macro_distribution (beam, init, .true.)
  call track_beam (lattice, beam)

  print *
  print '(13x, a)', "x          x'    sig(1,1)    sig(1,2)    sig(2,2)"
  do i = 1, size(beam%bunch)
    do j = 1, size(beam%bunch(i)%slice)
      do k = 1, size(beam%bunch(i)%slice(j)%macro)
        mp = beam%bunch(i)%slice(j)%macro(k)
        call mp_to_angle_coords (mp, lattice%ele_(n)%value(beam_energy$))
        print '(3i2, 1p, 5e12.4)', i, j, k, mp%r%vec(1), mp%r%vec(2), &
                  mp%sigma(s11$), mp%sigma(s12$), mp%sigma(s22$)
      enddo
    enddo
  enddo

end program
\end{listing}
\caption{Example program showing macroparticle tracking.}
\label{f:macro_program}
\end{figure}

\begin{figure}
\begin{listing}{1}
\&beam_init
  init%x%beta      = 4
  init%x%alpha     = 0.16
  init%x%norm_emit = 4.d-6  ! normalized emittance
  init%y%beta      = 16
  init%y%alpha     = 4
  init%y%norm_emit = 1.0d-8 ! normalized emittance
  init%center      = -5e-3, 1.0e-4, 1.0e-3, 0e-6, 0.0, 0.0
  init%sig_e       = 10e-3
  init%sig_z       = 10e-6
  init%sig_e_cut   = 3
  init%sig_z_cut   = 3
  init%n_bunch     = 1
  init%n_slice     = 2
  init%n_macro     = 1
  init%n_part      = 1e12
/
\end{listing}
\caption{Example beam initialization file.}
\label{f:beam_init}
\end{figure}

\break

%----------------------------------------------------------------
\section{Reverse Tracking}
\label{s:reverse_track}
\index{Tracking!reverse}

There are two ways to do reverse tracking in which the particle goes
in the direction of decreasing \vn{s}. The first way is to use the
\vnr{track_many} routine. See the \vn{track_many} routine for more
details. The advantage of using \vn{track_many} is that it is
simple. The disadvantage is that it can slow things down some since
each element goes through a reversal process every time it is tracked
through. If a program is doing a lot of tracking the other option
is to form a reversed lattice with the elements in the reverse order
and track through that. The routine \vnr{ring_reverse} will do
this. One must be somewhat careful since the reversed lattice uses a
reversed coordinate system. The transformation between the reversed
and unreversed lattices is
\Begineq
  (x, p_x, y, p_y, z, p_z) -> (x, -p_x, y, -p_y, -z, p_z)
\Endeq
See the \vn{ring_reverse} routine for more details.

Generally tracking backwards is simply the reverse of tracking
forwards (time reversal symmetry). That is, if you start at some
place, track forward for some distance and then track back to the
starting place the ending orbit will be equal to the starting
orbing. However, it should always be kept in mind that radiation
damping or excitation breaks this symmetry.
