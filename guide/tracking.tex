\chapter{Tracking}
\label{s:tm}

\bmad\ can do two types of tracking. One type uses a single particle 
and tracks its coordinates throughout the lattice. The other type
takes a beam distribution and tracks the centroids and sigmas of
``macro particles''.  This latter type of tracking is associated with
LINACs and wakefields and is discussed in another chapter.

\chapter{The Coord\_struct}

For single particle tracking the starting point is the
\tn{coord_struct} whose definition is shown
in~\ref{f:coord_struct}. The \tn{coord_struct} defines the phase
space vector of the particle at a certain location.

\begin{figure}[tb]
\centering
\small
\begin{verbatim}
  type coord_struct
    real(rp) vec(6)   ! (x, p_x, y, p_y, z, p_z)
  end type
\end{verbatim}
\caption{Definition of the \tn{coord\_struct}.}
\label{f:coord_struct}
\end{figure}

To get an orbit, that is, the particle position at every element in a lattice
you will need an array of \tn{coord_struct}'s. Since
the number of elements in the lattice is not known in advance the
array must be declared to be allocatable. 
\begin{verbatim}
  type (coord_struct), allocatable :: coords(:)
\end{verbatim}
You cannot, in general, use a pointer to an array since the BMAD
subroutines expect an allocatable array and Fortran does not allow you
to mix and match.

Example: To track a particle through a lattice:
\begin{verbatim}
  type (ring_struct) ring             ! lattice to track through
  type (coord_struct), allocatable :: coord(:)
  ...
  call reallocate_coords (coord, ring%n_ele_max)
  coords(0)%vec = (/ 0.01, 0.0, 0.0, 0.0, 0.0, 0.0 /) ! initialization
  call track_all (ring, coord)
\end{verbatim}
\rn{Track_all} takes \vn{coord(0)} and propagates it through the lattice from
the 0\Th element through \vn{ring%n_ele_ring}.  Each \vn{coord(i)}
is associated with \vn{ring%ele_(i)} and is the particle position at
the end of the element. \rn{reallocate_coords} simply does an
allocation. Its advantage over just allocating directly is that it
checks if the allocation is needed and if not then it does
nothing. This can save time. Since \rn{track_all}, like many \bmad\
routines, will reallocate if needed, only one call to
\rn{reallocate_coords} is needed initially even if there are repeated calls
to \rn{track_all}.

If you are writing a subroutine where the \tn{coord_struct} array is
local then you have to decide what to do at the end of the
subroutine. You have two choices: 1) Deallocate the array. This is the
cleanest solution but it can be slow since you have to allocate afresh
each time the subroutine is called. 2) use the save attribute so that
the array stays around until the next time the subroutine is called.
\begin{verbatim}
  type (coord_struct), allocatable, save :: orb(:) 
  ...
  call allocate_coord (orb_, ring%n_ele_ring)
\end{verbatim}
This is faster but leaves memory tied up. 

Note: The \bmad\ tracking routines never use the \vn{ele%mat6}
transfer matrix to do tracking.

For each element the method of tracking may be set either via the
input lattice file or directly in the program by setting the
\vn{%tracking_method} attribute of an element
\begin{verbatim}
  type (ele_struct) ele
  ...
  ele%tracking_method = boris$  ! for boris tracking
\end{verbatim}

