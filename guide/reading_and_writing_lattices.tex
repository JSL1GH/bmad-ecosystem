\chapter{Reading and Writing Lattices}

%----------------------------------------------------------------------------
\section{Reading in Lattices}
\index{Lattice files!reading}

The subroutine to read in an XSIF lattice file is \vn{xsif_parser}.
There are two subroutines in \bmad\ to read in a \bmad standard
lattice file: \vn{bmad_parser} and \vn{bmad_parser2}.

\vn{bmad_parser} is used to initialize a \vn{ring_struct}
structure from scratch using the information from a lattice
file. Unless told otherwise, after reading in the lattice
\vn{bmad_parser} will compute the 6x6 transfer matrices for each
element. Normally you want to do this but there are exceptions where
you don't need it and for particular lattices the computation can take
a long time (especially if there are Taylor maps to be
computed). Notice that \vn{bmad_parser} does {\em not} compute any
Twiss parameters.

\vn{bmad_parser2} is typically used after \vn{bmad_parser} if there is
additional information that needs to be added to the lattice. For
example, aperture limits for the elements are often stored in a
separate file. In this case there are two possibilities: The first is
to use \vn{bmad_parser2}
\begin{verbatim}
  call bmad_parser ('lattice_file', ring)       ! read in a lattice.
  call bmad_parser2 ('aperture_file', ring)     ! read in the aperture limits.
\end{verbatim}
The second alternative is to create a third file that calls the first two
\begin{verbatim}
 ! This is a file to be called by bmad_parser
 call, file = 'lattice_file'
 call, file = 'aperture_file'
\end{verbatim}
and then just use \vn{bmad_parser} to parse this third file.

%----------------------------------------------------------------------------
\section{Digested Files}
\index{Lattice files!digested files}

Since parsing can be slow, once \vn{bmad_parser} has transfered the
information from a lattice file into the \vn{ring_struct} it will make
what is called a digested file. A digested file is an image of the
\vn{ring_struct} in binary form. When \vn{bmad_parser} is called it
(actually it is a the subroutine \vn{read_digested_bmad_file} that
does all the work) first looks in the same directory as the lattice
file for a digested file whose name is of the form
\begin{verbatim}
  'digested_' // LAT_FILE   ! for single precision BMAD 
  'digested8_' // LAT_FILE  ! for double precision BMAD 
\end{verbatim}
where \vn{LAT_FILE} is the lattice file name. If it finds the digested
file it checks that the file is not out--of--date. It can do this
since the digested file stores the names and the dates of all the
lattice files that were used when the digested file was made. The
\bmad\ version number stored in the digested file is also checked. The
\bmad\ version number is a global parameter that is increased (not too
frequently) each time the structure of the \vn{ring_struct} or
\vn{ele_struct} is modified. If the \bmad\ version number in the
digested file does not agree with the current or the digested file is
out--of--date a warning will be printed and the digested file will not
be used.

\index{Transfer map!Taylor!with digested files}
Since computing Taylor Maps can be very time intensive,
\vn{bmad_parser} tries to reuse Taylor Maps it finds in the digested
file even if the lattice file has been changed in the meantime. To
make sure that everything is OK it will check that the attribute
values of an element needing a Taylor map are the same as the
attribute values of a corresponding element in the digested file
before it reuses the map. Element names are not a factor in this
decision.

This leads to the following trick: If you want to read in a lattice
where there is no corresponding digested file, and if there is another
digested file that has elements with the correct Taylor Maps, then to
save on the map computation time simply make a copy of the digested
file with the digested file name corresponding to the first lattice.

The digested file is in binary format and is not human readable but it
provides a convenient mechanism for transporting lattices between
programs. For example, say you have read in a lattice, changed
some parameters in the \vn{ring_struct}, and now you want to do some
analysis on this modified \vn{ring_struct} using a different program. The 
answer is to have the first program create a digested file
\begin{example}
  call write_digested_bmad_file ('digested_file_of_mine', ring)
\end{example}
and then read the digested file in with the second program
\begin{example}
  call read_digested_bmad_file ('digested_file_of_mine', ring)
\end{example}
An alternative to writing a digested file is to write a lattice file
using \vn{write_bmad_lattice_file}

%----------------------------------------------------------------------------
\section{Writing MAD files}
\index{Lattice files!MAD files}
\index{MAD}

\MAD--8 compatable lattice files can be created using the routine \vnr{bmad_to_mad}:
\begin{example}
  type (ring_struct) lat             ! lattice
  ...
  call bmad_to_mad ('lat.mad', lat)  ! create MAD file
\end{example}

Since \MAD has no concept of things such as \vn{overlay}s and \vn{group}s, such 
information is lost in translation.

