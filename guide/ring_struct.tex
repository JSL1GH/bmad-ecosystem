\chapter{The Ring\_struct}


%----------------------------------------------------------------------------
\section{overview}

\tn{ring_struct} is the structure that holds all the information 
about a lattice.  The definition of \tn{ring_struct} is shown in
figure~\ref{f:ring_struct}. Despite its name, \bmad\
makes no assumption about whether an \tn{ring_struct} is circular as
with a storage ring or open as with a LINAC.

\begin{figure}[tb]
\centering
\begin{verbatim}
type ring_struct
  type (mode_info_struct)  x, y, z  ! tunes, etc.
  character*16 name            ! Name in USE statement
  character*40 lattice         ! Lattice
  character*80 input_file_name ! Lattice input file name
  character*80 title           ! general title
  type (param_struct) param    ! parameters
  integer version              ! Version number
  integer n_ele_ring           ! number of physical ring elements
  integer n_ele_symm           ! symmetry point for rings w/symmetry
  integer n_ele_use            ! number of elements used
  integer n_ele_max            ! Index of last element used
  integer n_ele_maxx           ! Index of last element allocated
  integer n_control_array      ! last index used in CONTROL_ array
  integer n_ic_array           ! last index used in IC_ array
  integer input_taylor_order   ! As set in the input file
  integer ic_(n_control_maxx)  ! index to %control_(:)
  type (ele_struct), pointer :: ele_(:)    ! Array of ring elements
  type (ele_struct)  ele_init              ! For use by any program
  type (control_struct)  control_(n_control_maxx)  ! control list
end type
\end{verbatim}
\caption{Definition of the \tn{ring\_struct}.}
\label{f:ring_struct}
\end{figure}

The array \vn{%ele(:)} holds the elements of the lattice. The array
is always allocated so that the lower bound index is zero. \vn{%ele(0:)}
is divided up into two parts: A ``physical'' part (also called
the ``regular'' part) and a ``control''
part (also called the ``lord'' part). The physical part of this array holds
the elements that are tracked through. The control part holds the
superimpose, overlay and group elements. The extent of these parts is
given in table~\ref{tab:part_extent}. \vn{%ele(0)} is essentially a marker
element. \vn{%ele(0)%mat6} is always the unit matrix.

\begin{table}[tb]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
              & \multicolumn{2}{c|} {\em index n}         \\ \hline
{\em section} & {\em min}          & {\em max}            \\ \hline
physical      & 0                  & \vn{%n_ele_ring}     \\ \hline
control       & \vn{%n_ele_ring}+1 & \vn{%n_ele_max}      \\ \hline
\end{tabular} 
\caption{Extent of the physical and control parts 
of the array \vn{\%ele(n)}.}
\end{center}
\label{tab:part_extent}
\end{table}

Other indexes within the \tn{ring_struct} are
\begin{description}
\item[\tt\%n\_ele\_maxx] 
The index of the upper bound of the \vn{%ele(:)} array.
The lower bound is always 0 so the total size of the \vn{%ele(:)}
array is \vn{%n_ele_maxx}+1.
\item[\tt\%n\_ele\_symm] Back in the days when the CESR ring was E/W 
symmetric \vn{%n_ele_symm} designated the symmetry point (roughly at
\vn{%n_ele_ring}/2).  Currently this is seldom used.
\item[\%n\_ele\_use] This designates what part of the physical ring to track 
through. This is the same as \vn{%n_ele_ring} except if there is a
symmetry point and \vn{%n_ele_symm} is non--zero. In this case
\vn{%n_ele_use} = \vn{%n_ele_symm}.
\end{description}

Local \tn{ring_struct} variables must have the save attribute or the
pointers within must be appropriately deallocated before leaving the
routine.

%----------------------------------------------------------------------------
\section{Pointers}

Since the \tn{ring_struct} has pointers within it (plural since the
\tn{ele_struct} has pointers within it) there is an extra burden on
the programmer to make sure that allocation and deallocation is done
properly. To this end the equal sign has been overloaded by the
routine \rn{ring_equal_ring} so that when one writes
\begin{verbatim}
    ring1 = ring2
\end{verbatim}
the pointers will be handled properly. The result will be that ring1
will hold the same information as ring2 but the pointers in ring1 will
point to different locations in physical memory so that changes to one
ring will not affect the other.

Initial allocation of the pointers in \tn{ring_struct} is generally
handled by \rn{bmad_parser} and \rn{ring_equal_ring} and so typically not a
concern of most programmers. Deallocation problems can arise when a
subroutine has a local \tn{ring_struct} variable. 



Generally allocation is handled

How to allocate \tn{coord_struct} arrays. see the tracking section
