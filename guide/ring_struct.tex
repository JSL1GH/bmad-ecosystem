\chapter{The ring\_struct}
\label{c:ring_struct}
\index{Ring_struct|textbf}

The \vn{ring_struct} is the structure that holds of all the information 
about a lattice.   Despite its name, \bmad\
makes no assumption about whether an \vn{ring_struct} is circular as
with a storage ring or open as with a LINAC.

%----------------------------------------------------------------------------
\section{Elements Within the ring\_struct}
\label {s:ring_ele}

\begin{figure}[htb]
\centering
\begin{verbatim}
type ring_struct
  type (mode_info_struct)  x, y, z  ! tunes, etc.
  character*16 name            ! Name in USE statement
  character*40 lattice         ! Lattice name
  character*80 input_file_name ! Lattice input file name
  character*80 title           ! From TITLE statement
  type (param_struct) param    ! parameters
  integer version              ! Version number for digested files
  integer n_ele_use            ! number of physical lattice elements
  integer n_ele_max            ! Index of last element used
  integer n_control_array      ! last index used in CONTROL_ array
  integer n_ic_array           ! last index used in IC_ array
  integer input_taylor_order   ! As set in the input file
  integer ic_(n_control_maxx)  ! index to %control_(:)
  type (ele_struct), pointer :: ele_(:)    ! Array of lattice elements
  type (ele_struct)  ele_init              ! For use by any program
  type (control_struct)  control_(n_control_maxx)  ! control list
  real(rp), pointer :: beam_energy ! = %ele_(0)%value(beam_energy$)
end type
\end{verbatim}
\caption{Definition of the \vn{ring\_struct}.}
\label{f:ring_struct}
\end{figure}

\index{Ring_struct!%ele_(:)}
\index{Ring_struct!%n_ele_use}
\index{Ring_struct!%n_ele_max}
\index{Ele_struct!in ring_struct} 
The definition of the \vn{ring_struct} is shown in
Figure~\ref{f:ring_struct}. The array \vn{%ele_(:)} holds the elements
of the lattice. This array is always allocated with zero as the lower
bound.  \vn{%ele_(0)} is a marker element with the name
\vn{BEGINNING}.  \vn{%ele_(0)%mat6} is always the unit
matrix. \vn{%ele_(0:)} is divided up into two parts: A ``physical''
part (also called the ``regular'' part) and a ``control'' part (also
called the ``lord'' part). The physical part of this array holds the
elements that are tracked through. The control part holds the
\vnec{Overlay} and \vnec{Group} elements, and those elements that are
``mangled'' when elements are superimposed upon other elements.  The
bounds of these two parts is given in Table~\ref{tab:part_extent}.
\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
              & \multicolumn{2}{c|} {\em index n}         \\ \hline
{\em section} & {\em min}          & {\em max}            \\ \hline
physical      & 0                  & \vn{%n_ele_use}     \\ \hline
control       & \vn{%n_ele_use}+1 & \vn{%n_ele_max}      \\ \hline
\end{tabular} 
\caption{Bounds of the regular and control parts 
of the array \vn{\%ele(:)}.}
\end{center}
\label{tab:part_extent}
\end{table}

\index{Ring_struct!%ele_init}
The \vn{%ele_init} component within the \vn{ring_struct} is not used
by \bmad\ and is available for general program use.

%----------------------------------------------------------------------------
\section{Param\_struct Structure}
\index{Param_struct}

The \vn{%param} variable within the \vn{ring_struct} is a
\vn{param_struct} structure whose definition is shown in
Figure~\ref{f:param_struct}
\begin{figure}[htb]
\centering
\begin{verbatim}
  type param_struct
    real(rp) n_part             ! Particles/bunch (for BeamBeam elements).
    real(rp) total_length       ! total_length of lattice
    real(rp) growth_rate        ! growth rate/turn if not stable
    real(rp) t1_with_RF(6,6)    ! Full 1-turn 6x6 matrix
    real(rp) t1_no_RF(6,6)      ! Transverse 1-turn 4x4 matrix (RF off).
    integer particle            ! +1 = positrons, -1 = electrons
    integer ix_lost             ! If lost at what element?
    integer end_lost_at         ! entrance_end$ or exit_end$
    integer lattice_type        ! linac_lattice$, circular_lattice$, etc...
    integer ixx                 ! Integer for general use
    logical stable              ! is closed lattice stable?
    logical aperture_limit_on   ! use apertures in tracking?
    logical lost                ! for use in tracking
  end type
\end{verbatim}
\caption{Definition of the \vn{param\_struct}.}
\label{f:param_struct}
\end{figure}

\index{Param_struct!%n_part}
\vn{%param%n_part} is the number of particles in a bunch and is used
by \vnec{BeamBeam} element to determine the strength of the beambeam
interaction. \vn{%param%n_part} is also used by \vnec{Lcavity} elements for wakefield
calculations. 

\index{Param_struct!%lost}
\index{Param_struct!%end_lost_at}
\index{Param_struct!%aperture_limit_on}
When tracking particles thorugh a lattice the variable
\vn{%param%aperture_limit_on} determines if apertures are checked.
\vn{%param%lost} is used to signal if a particle is lost and
\vn{%param%ix_lost} gives the index of the element at which a particle
is lost. Additionally, \vn{%param%end_lost_at} is used to indicate at
which end the particle was lost at. See Chapter~\ref{c:tracking} for
more details.

\index{Param_struct!%t1_with_RF}
\index{Param_struct!%t1_no_RF}
\index{Param_struct!%stable}
\vn{%param%t1_with_RF} and \vn{%param%t1_no_RF} are the 1--turn transfer
matrices from the start of the lattice to the end. \vn{%param%t1_with_RF}
is the full transfer matrix with RF on. \vn{%param%t1_no_RF} is the
transverse transfer matrix with RF off. \vn{%param%t1_no_RF} is used to
compute the Twiss parameters. When computing the Twiss parameters
\vn{%param%stable} is set according to whether the matrix is stable or
not. If the matrix is not stable the Twiss parameters cannot be
computed. If unstable, \vn{%param%growth_rate} will be set to the
growth rate per turn of the unstable mode.  \vn{%param%t1_with_RF} and
\vn{%param%t1_no_RF} are set by various routines. Other routines use
these matrices as input for calculations.


%----------------------------------------------------------------------------
\section{Elements Controlling Other Elements}
\label{s:ring_control}

Generally a programmer does not have to worry about how the lord
elements in the \vn{%ele_(:)} array control other elements. The
bookkeeping routine \vn{control_bookkeeper} takes care of that. This
routine is automatically called when the transfer matrices for the
elements are computed by \vn{ring_make_mat6}. If \vn{ring_make_mat6}
is not called then \vn{control_bookkeeper} needs to be
called. \vn{control_bookkeeper} will call \vn{attribute_bookkeeper} so
the attribute bookkeeping will be taken care of too (see
Section~\ref{s:depend}). Example:
\begin{example}
  type (ring_struct) lattice
  ! ... 
  lattice%ele_(i)%value(k1$) = k1_now   ! change an attribute
  call control_bookkeeper (lattice, i)  ! do bookkeeping
\end{example}
If multiple elements are modified then the \vn{lattice_bookkeeper} will
do bookkeeping for the entire lattice.

The element control information is stored in the \vn{%control_(:)} array, 
Each element of this array is a \vn{control_struct} structure 
\begin{example}
  type control_struct
    real(rp) coef                ! control coefficient
    integer ix_lord                ! index to lord element
    integer ix_slave               ! index to slave element
    integer ix_attrib              ! index of attribute controlled
  end type
\end{example}
\vn{%ix_lord} and \vn{%ix_slave} give the indices in the \vn{%ele_(:)}
array of a lord element and an element it controls. A lord element
\vn{%ele_(i_lord)} has assigned to it a block \vn{%control_(:)}
elements.  The following example prints the names and controlled
attributes of the slaves of a particular lord element. If the lord is
an \vnec{Overlay} or \vnec{Group} then \vn{%control_(:)%ix_attrib} and 
\vn{%control_(:)%coef} give the attribute index of the controlled
attribute and the appropriate  coefficient 
\begin{example}
  type (ring_struct) lattice
  ...
  ix1 = lattice%ele_(i_lord)%ix1_slave  ! start of block
  ix2 = lattice%ele_(i_lord)%ix2_slave  ! end of block
  print *, 'Slaves for lord: ', lattice%ele_(i_lord)%name
  do i = ix1, ix2
    i_slave = lattice%control_(i)%ix_slave
    if (lattice%ele_(i_lord)%control_type == super_lord$) then
      print *, '  ', i, '  ', lattice%ele_(i_slave)%name
    else   ! must be overlay or slave
      ixa = lattice%control_(i)%ix_attrib
      attrib_name = attribute_name (lattice%ele_(i_slave), ixa)
      print *, '  ', i, '  ', lattice%ele_(i_slave)%name, attrib_name
    endif
  enddo
\end{example}

Going backward from a slave to its lords goes through one level of
indirection using the \vn{%ic_} array as shown in the next example
\begin{example}
  ix1 = lattice%ele_(i_slave)%ic1_lord
  ix2 = lattice%ele_(i_slave)%ic2_lord
  print *, 'Lords for slave: ', lattice%ele_(i_slave)%name
  do i = ix1, ix2
    ix = lattice%ic_(i)
    i_lord = lattice%control_(ix)%ix_lord
    print *, '  ', i, '  ', lattice%ele_(i_lord)%name
  enddo
\end{example}
For historical reasons, since a \vnec{Group} element only makes changes
in the values of the attributes it controls, \vn{Group} elements are
not included in the list of lords generated by the above example.

%----------------------------------------------------------------------------
\section{Pointers}
\label{s:ring:point}
\index{Ring_struct!pointers}

Since the \vn{ring_struct} has pointers within it there is an extra burden on
the programmer to make sure that allocation and deallocation is done
properly. To this end the equal sign has been overloaded by the
routine \vn{ring_equal_ring} so that when one writes
\begin{example}
    type (ring_struct) lattice1, lattice2
    ! ... some calculations ...
    lattice1 = lattice2
\end{example}
the pointers in the \vn{ring_structs} will be handled properly. The
result will be that lattice1 will hold the same information as
\vn{lattice2} but the pointers in \vn{lattice1} will point to
different locations in physical memory so that changes to one lattice
will not affect the other.

Initial allocation of the pointers in a \vn{ring_struct} variable is
generally handled by the \vnr{bmad_parser} and \vn{ring_equal_ring}
routines.  Once allocated, local \vn{ring_struct} variables must have
the save attribute or the pointers within must be appropriately
deallocated before leaving the routine.
\begin{example}
  type (ring_struct), save :: lattice     ! Either do this at the start or ...
  ...
  call deallocate_ring_pointers (lattice) ! ... Do this at the end.
\end{example}
Using the save attribute will generally be faster but will use more
memory. Typically using the save attribute will be the best choice.
