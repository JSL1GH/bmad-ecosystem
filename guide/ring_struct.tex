\chapter{The ring\_struct}
\label{c:ring_struct}

The \tn{ring_struct} is the structure that holds of all the information 
about a lattice.   Despite its name, \bmad\
makes no assumption about whether an \tn{ring_struct} is circular as
with a storage ring or open as with a LINAC.

%----------------------------------------------------------------------------
\section{Elements Within the ring\_struct}

\begin{figure}[htb]
\centering
\begin{verbatim}
type ring_struct
  type (mode_info_struct)  x, y, z  ! tunes, etc.
  character*16 name            ! Name in USE statement
  character*40 lattice         ! Lattice name
  character*80 input_file_name ! Lattice input file name
  character*80 title           ! From TITLE statement
  type (param_struct) param    ! parameters
  integer version              ! Version number for digested files
  integer n_ele_ring           ! number of physical ring elements
  integer n_ele_use            ! number of elements used
  integer n_ele_max            ! Index of last element used
  integer n_ele_maxx           ! Index of last element allocated
  integer n_control_array      ! last index used in CONTROL_ array
  integer n_ic_array           ! last index used in IC_ array
  integer input_taylor_order   ! As set in the input file
  integer ic_(n_control_maxx)  ! index to %control_(:)
  type (ele_struct), pointer :: ele_(:)    ! Array of ring elements
  type (ele_struct)  ele_init              ! For use by any program
  type (control_struct)  control_(n_control_maxx)  ! control list
end type
\end{verbatim}
\caption{Definition of the \tn{ring\_struct}.}
\label{f:ring_struct}
\end{figure}

The definition of the \tn{ring_struct} is shown in
Figure~\ref{f:ring_struct}. The array \vn{%ele(:)} holds the elements of
the lattice. This array is always allocated with zero as the lower bound.
\vn{%ele(0)} is a marker element with the name \vn{BEGINNING}.
\vn{%ele(0)%mat6} is always the unit matrix. \vn{%ele(0:)} is divided up
into two parts: A ``physical'' part (also called the ``regular'' part)
and a ``control'' part (also called the ``lord'' part). The physical
part of this array holds the elements that are tracked through. The
control part holds the overlay and group elements, and those elements
that are ``mangled'' when elements are superimposed upon other elements.
The bounds of these two parts is given in Table~\ref{tab:part_extent}.
\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
              & \multicolumn{2}{c|} {\em index n}         \\ \hline
{\em section} & {\em min}          & {\em max}            \\ \hline
physical      & 0                  & \vn{%n_ele_ring}     \\ \hline
control       & \vn{%n_ele_ring}+1 & \vn{%n_ele_max}      \\ \hline
physical size & 0                  & \vn{%n_ele_maxx}     \\ \hline
\end{tabular} 
\caption{Bounds of the regular and control parts 
of the array \vn{\%ele(:)}.}
\end{center}
\label{tab:part_extent}
\end{table}
Note \vn{%n_ele_use} is identical to \vn{%n_ele_ring}

The \vn{%ele_init} component within the \vn{ring_struct} is not used
by \bmad\ and is available for general program use.

%----------------------------------------------------------------------------
\section{Param\_struct Structure}

The \vn{%param} variable within the \vn{ring_struct} is a
\vn{param_struct} structure whose definition is shown in
Figure~\ref{f:param_struct}
\begin{figure}[htb]
\centering
\begin{verbatim}
  type param_struct
    real(rp) beam_energy        ! beam energy in eV
    real(rp) n_part             ! Particles/bunch (for BeamBeam elements).
    real(rp) charge             ! Macroparticle charge (used by LCavities).
    real(rp) total_length       ! total_length of ring
    real(rp) growth_rate        ! growth rate/turn if not stable
    real(rp) t1_mat6(6,6)       ! Full 1-turn 6x6 matrix
    real(rp) t1_mat4(4,4)       ! Transverse 1-turn 4x4 matrix (RF off).
    integer particle            ! +1 = positrons, -1 = electrons
    integer iy                  ! Not currently used.
    integer ix_lost             ! If lost at what element?
    integer lattice_type        ! linac_lattice$, circular_lattice$, etc...
    integer ixx                 ! Integer for general use
    logical stable              ! is closed ring stable?
    logical aperture_limit_on   ! use apertures in tracking?
    logical lost                ! for use in tracking
  end type
\end{verbatim}
\caption{Definition of the \tn{param\_struct}.}
\label{f:param_struct}
\end{figure}

\vn{%param%n_part} is the number of particles in a bunch and is used
by \vn{BeamBeam} element to determine the strength of the beambeam
interaction. \vn{%param%charge} is the charge of a particle or
macroparticle and is used by \vn{LCavity} elements for wakefield
calculations. The two variables are independent and setting one will not
affect the other. 

\vn{%param%lost} is set by tracking routines to signal if a particle
is lost. \vn{%param%aperture_limit_on} determines is apertures are
checked to begin with. \vn{%param%ix_lost} gives the index of the
element at which a particle is lost.

\vn{%param%t1_mat6} and \vn{%param%t1_mat4} are the 1--turn transfer
matrices from the start of the lattice to the end. \vn{%param%t1_mat6}
is the full transfer matrix with RF on. \vn{%param%t1_mat4} is the
transverse transfer matrix with RF off. \vn{%param%t1_mat4} is used to
compute the Twiss parameters. When computing the Twiss parameters
\vn{%param%stable} is set according to whether the matrix is stable or
not. If the matrix is not stable the Twiss parameters cannot be
computed. If unstable, \vn{%param%growth_rate} will be set to the
growth rate per turn of the unstable mode.  \vn{%param%t1_mat6} and
\vn{%param%t1_mat4} are set by various routines. Other routines use
these matrices as input for calculations.




%----------------------------------------------------------------------------
\section{Elements Controlling Other Elements}
\label{s:ring_control}

Generally a programmer does not have to worry about how the lord
elements in the \vn{%ele(:)} array control other elements. The
bookkeeping routine \vn{control_bookkeeper} takes care of that. This
routine is automatically called when the transfer matrices for the
elements are computed by \vn{ring_make_mat6}. If \vn{ring_make_mat6}
is not called then \vn{control_bookkeeper} needs to be
called. \vn{control_bookkeeper} will call \vn{attribute_bookkeeper} so
the attribute bookkeeping will be taken care of too (see
Section~\ref{s:depend}).

The element control information is stored in the \vn{%control_(:)} array, 
Each element of this array is a \vn{control_struct} structure 
\begin{example}
  type control_struct
    real(rp) coef                ! control coefficient
    integer ix_lord                ! index to lord element
    integer ix_slave               ! index to slave element
    integer ix_attrib              ! index of attribute controlled
  end type
\end{example}
\vn{%ix_lord} and \vn{%ix_slave} give the indices in the \vn{%ele_(:)}
array of a lord element and an element it controls. A lord element
\vn{%ele_(i_lord)} has assigned to it a block \vn{%control_(:)}
elements.  The following example prints the names and controlled
attributes of the slaves of a particular lord element. If the lord is
an \vn{overlay} or \vn{group} then \vn{%control_(:)%ix_attrib} and 
\vn{%control_(:)%coef} give the attribute index of the controlled
attribute and the appropriate  coefficient 
\begin{example}
  type (ring_struct) ring
  ...
  ix1 = ring%ele_(i_lord)%ix1_slave  ! start of block
  ix2 = ring%ele_(i_lord)%ix2_slave  ! end of block
  print *, 'Slaves for lord: ', ring%ele_(i_lord)%name
  do i = ix1, ix2
    i_slave = ring%control_(i)%ix_slave
    if (ring%ele_(i_lord)%control_type == super_lord$) then
      print *, '  ', i, '  ', ring%ele_(i_slave)%name
    else   ! must be overlay or slave
      ixa = ring%control_(i)%ix_attrib
      attrib_name = attribute_name (ring%ele_(i_slave), ixa)
      print *, '  ', i, '  ', ring%ele_(i_slave)%name, attrib_name
    endif
  enddo
\end{example}

Going backward from a slave to its lords goes through one level of
indirection using the \vn{%ic_} array as shown in the next example
\begin{example}
  ix1 = ring%ele_(i_slave)%ic1_lord
  ix2 = ring%ele_(i_slave)%ic2_lord
  print *, 'Lords for slave: ', ring%ele_(i_slave)%name
  do i = ix1, ix2
    ix = ring%ic_(i)
    i_lord = ring%control_(ix)%ix_lord
    print *, '  ', i, '  ', ring%ele_(i_lord)%name
  enddo
\end{example}
For historical reasons, since a \vn{group} element only makes changes
in the values of the attributes it controls, \vn{group} elements are
not included in the list of lords generated by the above example.

%----------------------------------------------------------------------------
\section{Pointers}

Since the \tn{ring_struct} has pointers within it there is an extra burden on
the programmer to make sure that allocation and deallocation is done
properly. To this end the equal sign has been overloaded by the
routine \rn{ring_equal_ring} so that when one writes
\begin{example}
    ring1 = ring2
\end{example}
the pointers will be handled properly. The result will be that ring1
will hold the same information as \vn{ring2} but the pointers in
\vn{ring1} will point to different locations in physical memory so
that changes to one ring will not affect the other.

Initial allocation of the pointers in a \tn{ring_struct} variable is generally
handled by the \rn{bmad_parser} and \rn{ring_equal_ring} routines.
Once allocated,
local \tn{ring_struct} variables must have the save attribute or the
pointers within must be appropriately deallocated before leaving the
routine.
\begin{example}
  type (ring_struct), save :: ring     ! Either do this at the start or ...
  ...
  call deallocate_ring_pointers (ring) ! ... Do this at the end.
\end{example}
Using the save attribute will generally be faster but will use more
memory. Typically using the save attribute will be the best choice.
