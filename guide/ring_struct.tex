\chapter{The ring\_struct}
\label{c:ring_struct}
\index{Ring_struct|textbf}

The \vn{ring_struct} is the structure that holds of all the information 
about a lattice.   Despite its name, \bmad\
makes no assumption about whether an \vn{ring_struct} is circular as
with a storage ring or open as with a LINAC.

%----------------------------------------------------------------------------
\section{Elements Within the ring\_struct}
\label {s:ring_ele}

\begin{figure}[htb]
\centering
\begin{verbatim}
type ring_struct
  type (mode_info_struct)  x, y, z  ! tunes, etc.
  character*16 name            ! Name in USE statement
  character*40 lattice         ! Lattice name
  character*80 input_file_name ! Lattice input file name
  character*80 title           ! From TITLE statement
  type (param_struct) param    ! parameters
  integer version              ! Version number for digested files
  integer n_ele_use            ! number of physical lattice elements
  integer n_ele_max            ! Index of last element used
  integer n_control_array      ! last index used in CONTROL_ array
  integer n_ic_array           ! last index used in IC_ array
  integer input_taylor_order   ! As set in the input file
  integer ic_(n_control_maxx)  ! index to %control_(:)
  type (ele_struct), pointer :: ele_(:)    ! Array of lattice elements
  type (ele_struct)  ele_init              ! For use by any program
  type (control_struct)  control_(n_control_maxx)  ! control list
  real(rp), pointer :: beam_energy ! = %ele_(0)%value(beam_energy$)
end type
\end{verbatim}
\caption{Definition of the \vn{ring\_struct}.}
\label{f:ring_struct}
\end{figure}

\index{Ring_struct!%ele_(:)}
\index{Ring_struct!%n_ele_use}
\index{Ring_struct!%n_ele_max}
\index{Ele_struct!in ring_struct} 
\index{I_Beam}
\index{Overlay}
\index{Group}
The definition of the \vn{ring_struct} is shown in
Figure~\ref{f:ring_struct}. The array \vn{%ele_(:)} holds the elements
of the lattice. This array is always allocated with zero as the lower
bound.  \vn{%ele_(0)} is a marker element with the name
\vn{BEGINNING}.  \vn{%ele_(0)%mat6} is always the unit
matrix. \vn{%ele_(0:)} is divided up into two parts: A ``physical''
part (also called the ``regular'' part) and a ``control'' part (also
called the ``lord'' part). The physical part of this array holds the
elements that are tracked through. The control part holds the
\vn{Overlay}, \vn{I_Beam} and \vn{Group} elements, and those elements that are
``mangled'' when elements are superimposed upon other elements.  The
bounds of these two parts is given in Table~\ref{tab:part_extent}.
\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
              & \multicolumn{2}{c|} {\em index n}         \\ \hline
{\em section} & {\em min}          & {\em max}            \\ \hline
physical      & 0                  & \vn{%n_ele_use}     \\ \hline
control       & \vn{%n_ele_use}+1 & \vn{%n_ele_max}      \\ \hline
\end{tabular} 
\caption{Bounds of the regular and control parts 
of the array \vn{\%ele(:)}.}
\end{center}
\label{tab:part_extent}
\end{table}

\index{Ring_struct!%ele_init}
The \vn{%ele_init} component within the \vn{ring_struct} is not used
by \bmad\ and is available for general program use.

%----------------------------------------------------------------------------
\section{Param\_struct Structure}
\index{Param_struct}

The \vn{%param} variable within the \vn{ring_struct} is a
\vn{param_struct} structure whose definition is shown in
Figure~\ref{f:param_struct}
\begin{figure}[htb]
\centering
\begin{verbatim}
  type param_struct
    real(rp) n_part             ! Particles/bunch (for BeamBeam elements).
    real(rp) total_length       ! total_length of lattice
    real(rp) growth_rate        ! growth rate/turn if not stable
    real(rp) t1_with_RF(6,6)    ! Full 1-turn 6x6 matrix
    real(rp) t1_no_RF(6,6)      ! Transverse 1-turn 4x4 matrix (RF off).
    integer particle            ! +1 = positrons, -1 = electrons
    integer ix_lost             ! If lost at what element?
    integer end_lost_at         ! entrance_end$ or exit_end$
    integer lattice_type        ! linac_lattice$, circular_lattice$, etc...
    integer ixx                 ! Integer for general use
    logical stable              ! is closed lattice stable?
    logical aperture_limit_on   ! use apertures in tracking?
    logical lost                ! for use in tracking
  end type
\end{verbatim}
\caption{Definition of the \vn{param\_struct}.}
\label{f:param_struct}
\end{figure}

\index{Param_struct!%total_length}
\vn{%param%total_length} is the length of the lattice that a beam
tracks through
\begin{example}
  %param%total_length = %ele_(n_use)%s - %ele_(0)%s
\end{example}
Normally \vn{%ele_(0)%s} = 0 so \vn{%param%total_length} =
\vn{%ele_(n_use)%s} but this is not always the case.

\index{Param_struct!%n_part}
\index{BeamBeam}
\index{Lcavity}
\vn{%param%n_part} is the number of particles in a bunch and is used
by \vn{BeamBeam} element to determine the strength of the beambeam
interaction. \vn{%param%n_part} is also used by \vn{Lcavity} elements
for wakefield calculations.

\index{Param_struct!%lost}
\index{Param_struct!%end_lost_at}
\index{Param_struct!%aperture_limit_on}
When tracking particles through a lattice the variable
\vn{%param%aperture_limit_on} determines if apertures are checked.
\vn{%param%lost} is used to signal if a particle is lost and
\vn{%param%ix_lost} gives the index of the element at which a particle
is lost. Additionally, \vn{%param%end_lost_at} is used to indicate at
which end the particle was lost at. See Chapter~\ref{c:tracking} for
more details.

\index{Param_struct!%t1_with_RF}
\index{Param_struct!%t1_no_RF}
\index{Param_struct!%stable}
\vn{%param%t1_with_RF} and \vn{%param%t1_no_RF} are the 1--turn transfer
matrices from the start of the lattice to the end. \vn{%param%t1_with_RF}
is the full transfer matrix with RF on. \vn{%param%t1_no_RF} is the
transverse transfer matrix with RF off. \vn{%param%t1_no_RF} is used to
compute the Twiss parameters. When computing the Twiss parameters
\vn{%param%stable} is set according to whether the matrix is stable or
not. If the matrix is not stable the Twiss parameters cannot be
computed. If unstable, \vn{%param%growth_rate} will be set to the
growth rate per turn of the unstable mode.  \vn{%param%t1_with_RF} and
\vn{%param%t1_no_RF} are set by various routines. Other routines use
these matrices as input for calculations.


%----------------------------------------------------------------------------
\section{Finding Elements and Changing Their Value}
\label{s:ring_ele_change}

\bmad has two routines for searching for an element in a lattice:
\begin{example}
  \vnr{element_locator}(ele_name, ring, ix_ele) ! locate by name
  \vnr{elements_locator}(key, ring, indx)        ! locate by key
\end{example}
\vn{element_locator} searches the \vn{ring%ele_(:)} array for an
element of the correct name. Alternatively, \vn{elements_locator}
searches for all elements of a given key and returns an array of
indexes. To see how simple searching a lattice is consider the heart
of \vn{element_locator}:
\begin{example}
  do ix_ele = 0, ring%n_ele_max
    if (ring%ele_(ix_ele)%name == ele_name) return
  enddo
\end{example}

Once an element or elements are identified in the lattice,
changing an element attribute generally involves changing values in the 
\vn{ring%ele_(i)%value(:)} array. This is done using the 
\vnr{set_ele_attribute} routine. For example:
\begin{example}
  type (ring_struct) lat
  logical err_flag, make_xfer_mat
  ...
  call element_locator ('Q01W', lat, ix_ele)
  call set_ele_attribute (lat, ix_ele, 'K1', 0.1_rp, err_flag, make_xfer_mat)
\end{example}
\index{Overlay}
This example sets the \vn{K1} attribute of an element named \vn{Q01W}.
\vn{set_ele_attribute} checks whether this element is actually free to
be varied and sets the \vn{err_flag} logical accordingly. An element's
attribute may not be freely varied if, for example, the attribute is
controlled via an \vn{Overlay}.

\index{Bmad_com_struct!auto_bookkeeper}
There is a global variable \vn{bmad_com%auto_bookkeeper} that 
controls whether bookkeeping routines are called by routines that do tracking
and routines that calculate transfer matrices. 
This is done to make sure that the control 
and attribute information in a lattice is
up--to--date. Since this bookkeeping needs only be done when element attributes
are changed, this can lead to a significant waste of time. Setting 
\vn{bmad_com%auto_bookkeeper} to \vn{.false.} turns off this
automatic bookkeeping.
As a result, if an attribute value is changed directly the appropriate bookkeeping
routines need to be called:
\begin{example}
  type (ring_struct) lat
  bmad_com%auto_bookkeeper = .false.
  lat%ele_(ix_ele)%value(k1$) = 0.1
  call control_bookkeeper (lat, ix_ele)
\end{example}
Alternatively, if multiple elements are modified, then \vn{lattice_bookkeeper} can be
used to do bookkeeping for the entire lattice:
\begin{example}
  type (ring_struct) lat
  ... set some attributes ...
  call lattice_bookkeeper (lat)
\end{example}

%----------------------------------------------------------------------------
\section{Elements Controlling Other Elements}
\label{s:ring_control}

Generally anyone using \bmad routines will not need to bother with
the details of how elements control other elements (\sref{s:ring_ele_change}).
It is always safer to use the bookkeeping routines provided by \bmad rather 
than directly manipulating the control information. The following is thus
meant for those unusual situations where knowledge of how \bmad implements
control is needed.

The element control information is stored in the \vn{%control_(:)} array, 
Each element of this array is a \vn{control_struct} structure 
\begin{example}
  type control_struct
    real(rp) coef                ! control coefficient
    integer ix_lord                ! index to lord element
    integer ix_slave               ! index to slave element
    integer ix_attrib              ! index of attribute controlled
  end type
\end{example}
\index{I_Beam}
\index{Overlay}
\index{Group}
\vn{%ix_lord} and \vn{%ix_slave} give the indices in the \vn{%ele_(:)}
array of a lord element and an element it controls. A lord element
\vn{%ele_(i_lord)} has assigned to it a block \vn{%control_(:)}
elements.  The following example prints the names and controlled
attributes of the slaves of a particular lord element. If the lord is
an \vn{Overlay} or \vn{Group} then \vn{%control_(:)%ix_attrib} and 
\vn{%control_(:)%coef} give the attribute index of the controlled
attribute and the appropriate  coefficient 
\begin{example}
  type (ring_struct) lattice
  ...
  ix1 = lattice%ele_(i_lord)%ix1_slave  ! start of block
  ix2 = lattice%ele_(i_lord)%ix2_slave  ! end of block
  print *, 'Slaves for lord: ', lattice%ele_(i_lord)%name
  do i = ix1, ix2
    i_slave = lattice%control_(i)%ix_slave
    if (lattice%ele_(i_lord)%control_type == super_lord$) then
      print *, '  ', i, '  ', lattice%ele_(i_slave)%name
    else   ! must be overlay or slave
      ixa = lattice%control_(i)%ix_attrib
      attrib_name = attribute_name (lattice%ele_(i_slave), ixa)
      print *, '  ', i, '  ', lattice%ele_(i_slave)%name, attrib_name
    endif
  enddo
\end{example}

Going backward from a slave to its lords goes through one level of
indirection using the \vn{%ic_} array as shown in the next example
\begin{example}
  ix1 = lattice%ele_(i_slave)%ic1_lord
  ix2 = lattice%ele_(i_slave)%ic2_lord
  print *, 'Lords for slave: ', lattice%ele_(i_slave)%name
  do i = ix1, ix2
    ix = lattice%ic_(i)
    i_lord = lattice%control_(ix)%ix_lord
    print *, '  ', i, '  ', lattice%ele_(i_lord)%name
  enddo
\end{example}
\index{Group}
For historical reasons, since a \vn{Group} element only makes changes
in the values of the attributes it controls, \vn{Group} elements are
not included in the list of lords generated by the above example.

%----------------------------------------------------------------------------
\section{Pointers}
\label{s:ring:point}
\index{Ring_struct!pointers}

Since the \vn{ring_struct} has pointers within it there is an extra burden on
the programmer to make sure that allocation and deallocation is done
properly. To this end the equal sign has been overloaded by the
routine \vn{ring_equal_ring} so that when one writes
\begin{example}
    type (ring_struct) lattice1, lattice2
    ! ... some calculations ...
    lattice1 = lattice2
\end{example}
the pointers in the \vn{ring_structs} will be handled properly. The
result will be that lattice1 will hold the same information as
\vn{lattice2} but the pointers in \vn{lattice1} will point to
different locations in physical memory so that changes to one lattice
will not affect the other.

Initial allocation of the pointers in a \vn{ring_struct} variable is
generally handled by the \vnr{bmad_parser} and \vn{ring_equal_ring}
routines.  Once allocated, local \vn{ring_struct} variables must have
the save attribute or the pointers within must be appropriately
deallocated before leaving the routine.
\begin{example}
  type (ring_struct), save :: lattice     ! Either do this at the start or ...
  ...
  call deallocate_ring_pointers (lattice) ! ... Do this at the end.
\end{example}
Using the save attribute will generally be faster but will use more
memory. Typically using the save attribute will be the best choice.
