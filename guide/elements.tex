\chapter{Elements}
\label{c:elements}
\index{Element|textbf}

A lattice is made up of a collection of elements --- quadrupoles,
bends, etc. This chapter discusses the various classes of elements
available in \bmad except for \vn{group}s and \vn{overlay}s which are
discussed \cref{c:control}

\index{MAD}
Most element classes available in \mad are provided in \bmad.
Additionally, \bmad provides a number of element classes that are not
available in \mad.  A word of caution: In some cases where both \mad
and \bmad provide the same element class, there will be an overlap of 
the attributes available but the two sets of attributes will not be the same.
The list of element classes known to \bmad is shown in Table~\ref{t:elements}.

\begin{table}[h]
\centering
{\tt
\begin{tabular}{|l|l||l|l|} \hline
  {\it Element}   & {\it Section}     & {\it Element} & {\it Section}    \\ \hline
  AB\_Multipole   & \ref{s:ab_m}      &  Monitor      & \ref{s:monitor}  \\ \hline
  Accel\_Sol      & \ref{s:accel_sol} &  Multipole    & \ref{s:mult}     \\ \hline
  BeamBeam        & \ref{s:bbi}       &  Octupole     & \ref{s:oct}      \\ \hline
  Bend\_Sol\_Quad & \ref{s:bsq}       &  Overlay      & \ref{s:overlay}  \\ \hline
  Custom          & \ref{s:custom}    &  Patch        & \ref{s:patch}    \\ \hline
  Drift           & \ref{s:drift}     &  Quadrupole   & \ref{s:quad}     \\ \hline
  Ecollimator     & \ref{s:col}       &  Rbend        & \ref{s:bend}     \\ \hline
  ElSeparator     & \ref{s:elsep}     &  Rcollimator  & \ref{s:col}      \\ \hline
  Group           & \ref{s:group}     &  RFcavity     & \ref{s:rfcav}    \\ \hline
  HKicker         & \ref{s:hvkicker}  &  Sbend        & \ref{s:bend}     \\ \hline
  Hybrid          & \ref{s:hybrid}    &  Sextupole    & \ref{s:sex}      \\ \hline
  I\_Beam         & \ref{s:i_beam}    &  Solenoid     & \ref{s:sol}      \\ \hline
  Instrument      & \ref{s:monitor}   &  Sol\_Quad    & \ref{s:sq}       \\ \hline
  Kicker          & \ref{s:kicker}    &  Taylor       & \ref{s:tay}      \\ \hline
  Lcavity         & \ref{s:lcav}      &  VKicker      & \ref{s:hvkicker} \\ \hline
  Marker          & \ref{s:mark}      &  Wiggler      & \ref{s:wiggler}  \\ \hline
  Match           & \ref{s:match}     &               &                  \\ \hline
  
\end{tabular}
}
\caption{Table of \bmad element classes.}
\label{t:elements}\center
\end{table}

\vfil
\break

%-----------------------------------------------------------------
\section{AB\_Multipole}
\label{s:ab_m}
\index{AB_Multipole|textbf}

\begin{center}
\tt 
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  a$n$, b$n$ = Real  &  \ref{s:multip} &  type = String    & \ref{s:string} & tracking\_method = Switch    & \ref{s:tkm}   \\ \hline
  tilt       = Real  &  \ref{s:offset} &  alias = String   & \ref{s:string} & mat6\_calc\_method = Switch  & \ref{s:xfer}  \\ \hline
  x\_offset  = Real  &  \ref{s:offset} &  descrip = String & \ref{s:string} & x\_limit = Real              & \ref{s:limit} \\ \hline
  y\_offset  = Real  &  \ref{s:offset} &  is\_on = Logical & \ref{s:is_on}  & y\_limit = Real              & \ref{s:limit} \\ \hline
  s\_offset  = Real  &  \ref{s:offset} &  beam\_energy$^*$ & \ref{s:energy} & aperture = Real              & \ref{s:limit} \\ \hline
  lrad       = Real  &  \ref{s:multip} &  p0c$^*$          & \ref{s:energy} & aperture\_at = Switch        & \ref{s:limit} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

An \vn{AB_Multipole} is a thin multipole lens up to 20th order. The only
difference between this and a \vn{Multipole} is the input format. See~\sref{s:multip} for more details. For \vn{a$n$}
and \vn{b$n$}, $n$ is in the range 0 through 20.

\index{Lrad}
\vn{lrad} is a fictitious length that is used for synchrotron radiation
computations but does not affect any tracking or transfer map calculations. 

Like a \mad \vn{multipole}, An \vn{AB_Multipole} will affect the
reference orbit if there is a dipole component. 

Example:
\begin{example}
  abc: ab_multipole, a2 = 0.034e-2, b3 = 5.7, a11 = 5.6e6/2
\end{example}

%-----------------------------------------------------------------
\section{Accel\_Sol}
\label{s:accel_sol}
\index{Accel_Sol|textbf}

An \vn{Accel_Sol} element is a combination LINAC RF accelerating
section with a solenoid on top of it. For historical reasons this
element is not currently available but could be revived if there is
any demand for it.

%-----------------------------------------------------------------
\section{BeamBeam}
\label{s:bbi}
\index{BeamBeam|textbf}

\begin{center} 
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  sig\_x   = Real       &                 & type = String    & \ref{s:string} & tracking\_method = Switch    & \ref{s:tkm}    \\ \hline
  sig\_y   = Real       &                 & alias = String   & \ref{s:string} & mat6\_calc\_method = Switch  & \ref{s:xfer}   \\ \hline
  sig\_z   = Real       &                 & descrip = String & \ref{s:string} & x\_limit    = Real           & \ref{s:limit}  \\ \hline
  charge   = Real       &                 & x\_pitch = Real  & \ref{s:offset} & y\_limit    = Real           & \ref{s:limit}  \\ \hline
  n\_slice = Integer    &                 & y\_pitch = Real  & \ref{s:offset} & aperture    = Real           & \ref{s:limit}  \\ \hline
  x\_offset = Real      & \ref{s:offset}  & tilt = Real      & \ref{s:offset} & aperture\_at = Switch        & \ref{s:limit}  \\ \hline
  y\_offset = Real      & \ref{s:offset}  & is\_on = Logical & \ref{s:is_on}  & symplectify = Logical        & \ref{s:symp}   \\ \hline
  s\_offset = Real      & \ref{s:offset}  & beam\_energy$^*$ & \ref{s:energy} & bbi\_constant$^*$            &                \\ \hline
                        &                 & p0c$^*$          & \ref{s:energy} &                              &                \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

A \vn{BeamBeam} element simulates an interaction with an opposing
(``strong'') beam traveling in the opposite direction. The strong beam
is assumed to be Gaussian in shape. In the \vn{bmad_standard}
calculation the beam--beam kick is computed using the
Bassetti--Erskine complex error function formula\cite{b:talman}

\index{n_part!in BeamBeam element}
\index{Charge}
\vn{n_part} is the nominal number of particles of the strong
beam. \vn{n_part} is set using the \vn{parameter} command
(\sref{s:param}) and is thus common to all \vn{BeamBeam} elements.  To
vary the number of particles in an individual \vn{BeamBeam} element use the
\vn{charge} attribute. The default is \vn{charge} = -1 which indicates
that the strong beam has the opposite charge of the weak beam.

\index{Sig_x}
\index{Sig_y}
\index{Sig_z}
\index{X_offset}
\index{Y_offset}
\vn{sig_x}, \vn{sig_y}, \vn{sig_z} are the strong beam's sigmas. 
\vn{x_offset} and \vn{y_offset} are used to offset the
\vn{BeamBeam} element. Note that in \mad the attributes used to
offset the strong beam are called \vn{xma} and \vn{yma}.

\index{X_pitch}
\index{Y_pitch}
\vn{x_pitch} and \vn{y_pitch} gives the beam--beam interaction a
crossing angle. This is the full crossing angle, not the half-angle.

\index{N_slice}
The strong beam is divided up into \vn{n_slice} equal charge (not equal
thickness) slices. The default for \vn{n_slice} is 1. Propagation
through the strong beam involves a kick at the charge center of each
slice with drifts in between the kicks. The kicks are calculated using
the standard Bassetti--Erskine formula.  Even though the strong beam can
have a finite \vn{sig_z} the length of the element is always considered
to be zero. This is achieved by adding drifts at either end of any
tracking so that the longitudinal starting point and ending point are
identical. The longitudinal $s$--position of the
\vn{BeamBeam} element is at the center of the strong bunch. For example,
with \vn{n_slice} = 2 the calculation would proceed as follows:
\begin{example}
  0) Start with the reference particle at the center of the strong bunch.
  1) Propagate (drift) backwards to the center of the first slice.
  2) Apply the beam--beam kick due to the first slice.
  3) Propagate (drift) forwards to the center of the second slice.
  4) Apply the beam--beam kick due to the second slice.
  5) Propagate (drift) backwards to end up with the reference particle
     at the center of the strong bunch.
\end{example}

\index{BBI_constant}
\vn{bbi_constant}: $ C_{bbi} = 
N \, m_e \, r_e / (2 \, \pi \, \gamma \, (\sigma_x + \sigma_y))$ 
is a measure of the beam--beam interaction strength. For example,
in the linear region near $x = y = 0$ the horizontal component of the
beam--beam kick is approximately 
$k_x = -4\, \pi \, x \, C_{bbi} / \sigma_x$ and the
horizontal beam--beam tune shift is 
$dQ_x = C_{bbi} \, \beta_x / \sigma_x$.

Example:
\begin{example}
  bbi: beambeam, sig\_x = 3e-3, sig\_y = 3e-4, x\_offset = 0.05
\end{example}

%-----------------------------------------------------------------
\section{Bend\_Sol\_Quad}
\label{s:bsq}
\index{Bend_Sol_Quad|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S  & {\sl Attribute} & \S \\ \hline
  l        = Real      & \ref{s:l}      & type = String     & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}    \\ \hline
  g\DAG    = Real      &                & alias = String    & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}   \\ \hline
  ks                   &                & descrip = String  & \ref{s:string} & x\_offset  = Real           & \ref{s:offset} \\ \hline
  dks\_ds              &                & hkick    = Real   & \ref{s:kick}   & y\_offset  = Real           & \ref{s:offset} \\ \hline
  x\_quad              &                & vkick    = Real   & \ref{s:kick}   & s\_offset  = Real           & \ref{s:offset} \\ \hline
  y\_quad              &                & x\_limit = Real   & \ref{s:limit}  & x\_pitch = Real             & \ref{s:offset} \\ \hline
  quad\_tilt           &                & y\_limit = Real   & \ref{s:limit}  & y\_pitch = Real             & \ref{s:offset} \\ \hline
  bend\_tilt           &                & aperture = Real   & \ref{s:limit}  & rel\_tol = Real             & \ref{s:integ}  \\ \hline
  angle\DDAG = Real    & \ref{s:depend} & a$n$, b$n$ = Real & \ref{s:multip} & abs\_tol = Real             & \ref{s:integ}  \\ \hline
  rho\DDAG = Real      & \ref{s:depend} & radius = Real     & \ref{s:multip} & num\_steps = Integer        & \ref{s:integ}  \\ \hline
  tilt     = Real      & \ref{s:offset} & is\_on = Logical  & \ref{s:is_on}  & integration\_ord = Integer  & \ref{s:integ}  \\ \hline
  k1       = Real      &                & symplectify       & \ref{s:symp}   & field\_calc = Switch        & \ref{s:integ}  \\ \hline
  beam\_energy$^*$     & \ref{s:energy} & p0c$^*$           & \ref{s:energy} &                             &                \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. \DAG May be a dependent. \DDAG Settable dependent. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

\vn{Bend_Sol_Quad} is a combination Bend, Solenoid, and Quadrupole
with the solenoid strength varying linearly with longitudinal position.
This enables the simulation of solenoid edge fields. The magnetic
field is:
\begin{alignat}{1}
  \frac{q \, B_x}{P_0} &= -g_y + k_{1n} (y - y_q) - k_{1s} (x - x_q) - \frac{dks/ds}{2} \, x \CRNO
  \frac{q \, B_y}{P_0} &=  g_x + k_{1n} (x - x_q) + k_{1s} (y - y_q) - \frac{dks/ds}{2} \, y \CR
  \frac{q \, B_s}{P_0} &=  k_s + dks/ds                        \nonumber
\end{alignat}
\index{X_quad}
\index{Y_quad}
\index{Quad_tilt}
\index{Tilt}
The reference trajectory is along the solenoid centerline. The
quadrupole field is offset from the solenoid by (\vn{x_quad},
\vn{y_quad}). The quadrupole and bend have individual tilts
\vn{quad_tilt} and \vn{bend_tilt} respectively.  \vn{tilt} gives an
overall tilt. Thus the normal and skew quadrupole components $k_{1n}$,
and $k_{1s}$ are given by
\begin{example}
  k_1n = k1 * cos (2*(tilt + quad_tilt))
  k_1s = k1 * sin (2*(tilt + quad_tilt))
\end{example}
and the dipole bend components ($g_x$, $g_y$) are given by
\begin{example}
  g_x = g * cos (tilt + bend_tilt)
  g_y = g * sin (tilt + bend_tilt)
\end{example}
Dipole edge fields have not been implemented since it is not clear where
the entrance and exit faces of the bend should be and how they are aligned
with the solenoid.

\index{Dks_ds}
To simulate a real solenoid you will need at least three
\vn{bend_sol_quad} elements: The middle element is the body of the
solenoid with the linear solenoid strength \vn{dks_ds} = 0 and the two
end elements have nonzero \vn{dks_ds} to simulate the solenoid edges.

Currently, tracking through a \vn{Bend_Sol_Quad} is via symplectic integration only.
\vn{bmad_standard} tracking is not an option since there is a possibility in
the future to implement tracking via a closed formula. 
Example:
\begin{example}
  bsq: bend_sol_quad, l = 3.7, ks = -2.3, dks_ds = 4.7, g = 1/87
\end{example}


%-----------------------------------------------------------------
\section{Bends: Rbend and Sbend}
\label{s:bend}
\index{Sbend|textbf}
\index{Rbend|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S  & {\sl Attribute} & \S \\ \hline
  l        = Real      & \ref{s:l}      & type = String     & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}    \\ \hline
  g\DAG    = Real      &                & alias = String    & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}   \\ \hline
  delta\_g = Real      &                & descrip = String  & \ref{s:string} & x\_offset  = Real           & \ref{s:offset} \\ \hline
  e1       = Real      &                & h1 = Real         &                & y\_offset  = Real           & \ref{s:offset} \\ \hline
  e2       = Real      &                & h2 = Real         &                & s\_offset  = Real           & \ref{s:offset} \\ \hline
  b\_field\DAG = Real  &                & x\_limit = Real   & \ref{s:limit}  & x\_pitch = Real             & \ref{s:offset} \\ \hline
  l\_chord$^*$         &                & y\_limit = Real   & \ref{s:limit}  & y\_pitch = Real             & \ref{s:offset} \\ \hline
  rho\DDAG = Real      & \ref{s:depend} & aperture = Real   & \ref{s:limit}  & rel\_tol = Real             & \ref{s:integ}  \\ \hline
  angle\DDAG = Real    & \ref{s:depend} & hick     = Real   & \ref{s:kick}   & abs\_tol = Real             & \ref{s:integ}  \\ \hline
  tilt     = Real      & \ref{s:offset} & vkick    = Real   & \ref{s:kick}   & num\_steps = Integer        & \ref{s:integ}  \\ \hline
  roll     = Real      & \ref{s:offset} & fint     = Real   &                & integration\_ord = Integer  & \ref{s:integ}  \\ \hline
  k1       = Real      &                & fintx    = Real   &                & field\_calc = Switch        & \ref{s:integ}  \\ \hline
  hgap     = Real      &                & radius   = Real   & \ref{s:multip} & symplectify                 & \ref{s:symp}   \\ \hline
  hgapx    = Real      &                & a$n$, b$n$ = Real & \ref{s:multip} & is\_on = Logical            & \ref{s:is_on}  \\ \hline
  beam\_energy$^*$     & \ref{s:energy} & p0c$^*$           & \ref{s:energy} & aperture\_at = Switch       & \ref{s:limit}  \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. \DAG May be a dependent. \DDAG Settable dependent. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

\index{E1}
\index{E2}
\vn{Rbend} and \vn{Sbend} are dipole bends. The difference between
the two is the way the \vn{l}, \vn{e1}, and \vn{e2} attributes are interpreted.
\begin{figure}
  \centering
  \subfigure[rbend]
  {
    \includegraphics{rbend_coords.psfig}
    \label{rbend}
  }
  \hspace{1cm}
  \subfigure[sbend]
  {
    \includegraphics{sbend_coords.psfig}
    \label{sbend}
  }
  \caption{Coordinate systems for (a) \vn{Rbend}\ and (b) \vn{Sbend}\ 
  elements.}
\end{figure}

  \begin{description}
  \item[l, l\_chord]  
\index{L}
\index{L_chord}
For a \vn{Rbend} \vn{l} is the chord length and not the arc length as
it is for a \vn{Sbend}.  After reading in a lattice, \bmad will
internally convert all \vn{Rbend}s into \vn{Sbend}s so internally
\vn{l} will become the path length. The chord length will be stored in
the \vn{l_chord} attribute.
  \item[h1, h2]
\index{H1}
\index{H2}
The attributes \vn{h1} and \vn{h2} are the curvature of the entrance
and exit pole faces. They are present for compatibility with MAD but
are not yet implemented in terms of tracking and other calculations.
  \item[e1, e2]
\index{E1}
\index{E2}
the rotation angle of the entrance pole face is \vn{e1} and at the exit
face it is \vn{e2}. An \vn{Sbend} with an \vn{e1} = \vn{e2} =
\vn{angle}/2 is equivalent to an \vn{Rbend} with \vn{e1} = \vn{e2} =
0.
  \item[angle]
\index{Angle}
The total design bend angle. A positive \vn{angle} represents a
bend towards negative $x$ values (see Figure~\ref{f:local_coords}).
  \item[k1]
\index{K1}
The quadrupole strength.
  \item[g, delta\_g, rho]
\index{G}
\index{Rho}
\index{Delta_g}
The design bending radius which determines the reference coordinate
system is \vn{rho} (see \sref{s:ref}).  \vn{g} = 1/\vn{rho} is
the curvature function and is proportional to the design dipole
magnetic field. The true field strength is given by
\vn{g}~+~\vn{delta_g} so changing \vn{delta_g} leaves the design orbit
unchanged but varies a particle's orbit.
  \item[fint, fintx, hgap, hgapx]
\index{Fint}
\index{Fintx}
The field integrals for the entrance and
exit pole faces are give by \vn{fint} and \vn{fintx} respectively
\Begineq
  F_{int} = \int_{pole} \! \! ds \, \frac{B_y(s) (B_0 - B_y(s))}
  {2 H_{gap} B_0^2}
\Endeq
with a similar equation for \vn{fintx}. \vn{hgap} and \vn{hgapx} are
the half gaps at the entrance and exit faces. If \vn{fint} or
\vn{fintx} is given without a value then a value of 0.5 is used. If
\vn{fint} or \vn{fintx} is not present then the default value of 0 is
used.
  \item[tilt]
\index{Tilt}
The roll angle about the longitudinal axis at the entrance face of the
bend is given by \vn{tilt}.  \vn{tilt} = 0 bends the reference
trajectory in the $-x$ direction.  If the \vn{tilt} attribute is given
without any value then the value $\pi/2$ will be used. This makes for
a downward vertical ($-y$) bend.
  \end{description}


Note: \vn{g}, \vn{angle}, and \vn{l} are mutually dependent. If any two are
specified for an element \bmad will calculate the appropriate value
for the third.  After reading in a lattice, \vn{angle} is considered a
dependent variable.

Example:
\begin{example}
  b03w: sbend, l = 0.6, k1 = 0.003, fint  ! gives fint = 0.5, fintx = 0
\end{example}

%-----------------------------------------------------------------
\section{Collimators: Ecollimator and Rcollimator}
\label{s:col}
\index{Ecollimator|textbf}
\index{Rcollimator|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real       & \ref{s:l}      & type = String    & \ref{s:string} & tracking\_method = Switch    & \ref{s:tkm}   \\ \hline
  num\_steps = Integer  & \ref{s:integ}  & alias = String   & \ref{s:string} & mat6\_calc\_method = Switch  & \ref{s:xfer}  \\ \hline
  rel\_tol = Real       & \ref{s:integ}  & descrip = String & \ref{s:string} & symplectify = Logical        & \ref{s:symp}  \\ \hline
  abs\_tol = Real       & \ref{s:integ}  & x\_limit = Real  & \ref{s:limit}  & integration\_ord = Integer   & \ref{s:integ} \\ \hline
  x\_offset  = Real     & \ref{s:offset} & y\_limit = Real  & \ref{s:limit}  & field\_calc = Switch         & \ref{s:integ} \\ \hline
  y\_offset  = Real     & \ref{s:offset} & beam\_energy$^*$ & \ref{s:energy} & aperture = Real              & \ref{s:limit} \\ \hline
                        &                & p0c$^*$          & \ref{s:energy} & aperture\_at = Switch        & \ref{s:limit} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

An \vn{Ecollimator} is a drift with elliptic collimation.
A \vn{Rcollimator} is a drift with rectangular collimation.
The aperture is considered to be at the end edge of the element.
Example:
\begin{example}
  d21: ecollimator, l = 4.5, x_limit = 0.09/2, y_limit = 0.05/2
\end{example}

%-----------------------------------------------------------------
\section{Custom}
\label{s:custom}
\index{Custom|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S  & {\sl Attribute} & \S \\ \hline
  l        = Real           & \ref{s:l}      & type = String    & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}   \\ \hline
  val1,$\ldots$val12 = Real &                & alias = String   & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}  \\ \hline
  delta\_e   = Real         & \ref{s:offset} & descrip = String & \ref{s:string} & integration\_ord = Integer  & \ref{s:integ} \\ \hline
  x\_offset  = Real         & \ref{s:offset} & is\_on = Logical & \ref{s:is_on}  & field\_calc = Switch        & \ref{s:integ} \\ \hline
  y\_offset  = Real         & \ref{s:offset} & x\_limit = Real  & \ref{s:limit}  & rel\_tol = Real             & \ref{s:integ} \\ \hline
  s\_offset  = Real         & \ref{s:offset} & y\_limit = Real  & \ref{s:limit}  & abs\_tol = Real             & \ref{s:integ} \\ \hline
  x\_pitch = Real           & \ref{s:offset} & aperture = Real  & \ref{s:limit}  & num\_steps = Integer        & \ref{s:integ} \\ \hline
  y\_pitch = Real           & \ref{s:offset} & beam\_energy$^*$ & \ref{s:energy} & symplectify = Logical       & \ref{s:symp}  \\ \hline
  tilt     = Real           & \ref{s:offset} & p0c$^*$          & \ref{s:energy} & aperture\_at = Switch       & \ref{s:limit} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

A \vn{Custom} element is an element whose properties are defined
outside of the standard \bmad subroutine library. That is, to use a
custom element some programmer must write the appropriate custom
routines which are then linked with the \bmad subroutines into a
program. \bmad will call the custom routines at the appropriate time
to do tracking, transfer matrix calculations, etc. See the programmer
who wrote the custom routines for more details! See 
\sref{s:custom_ele} on how to write custom routines.

\vn{delta_e} is the energy gain of the {\it reference} particle
between the starting edge of the element and the ending edge.

Example:
\begin{example}
  c1: custom, l = 3, val4 = 5.6, val12 = 0.9, num_steps = 12, tracking_method = boris
\end{example}

%-----------------------------------------------------------------
\section{Drift}
\label{s:drift}
\index{Drift|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real       & \ref{s:l}     & type = String    & \ref{s:string} & tracking\_method = Switch    & \ref{s:tkm}   \\ \hline
                        &               & alias = String   & \ref{s:string} & mat6\_calc\_method = Switch  & \ref{s:xfer}  \\ \hline
  rel\_tol = Real       & \ref{s:integ} & descrip = String & \ref{s:string} &                              &               \\ \hline
  abs\_tol = Real       & \ref{s:integ} & x\_limit = Real  & \ref{s:limit}  & symplectify = Logical        & \ref{s:symp}  \\ \hline
  num\_steps = Integer  & \ref{s:integ} & y\_limit = Real  & \ref{s:limit}  & integration\_ord = Integer   & \ref{s:integ} \\ \hline
  beam\_energy$^*$      & \ref{s:energy}& aperture = Real  & \ref{s:limit}  & field\_calc = Switch         & \ref{s:integ} \\ \hline
  p0c$^*$               & \ref{s:energy}&                  &                & aperture\_at = Switch        & \ref{s:limit} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

A \vn{Drift} element is a space free and clear of any fields.
Example:
\begin{example}
  d21: drift, l = 4.5
\end{example}

%-----------------------------------------------------------------
\section{Elseparator}
\label{s:elsep}
\index{Elseparator|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real    & \ref{s:l}      & type = String    & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}    \\ \hline
  hkick    = Real    & \ref{s:kick}   & alias = String   & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}   \\ \hline
  vkick    = Real    & \ref{s:kick}   & descrip = String & \ref{s:string} & integration\_ord = Integer  & \ref{s:integ}  \\ \hline
  gap      = Real    &                & is\_on = Logical & \ref{s:is_on}  & field\_calc = Switch        & \ref{s:integ}  \\ \hline
  x\_offset  = Real  & \ref{s:offset} & x\_limit = Real  & \ref{s:is_on}  & rel\_tol = Real             & \ref{s:integ}  \\ \hline
  y\_offset  = Real  & \ref{s:offset} & y\_limit = Real  & \ref{s:limit}  & abs\_tol = Real             & \ref{s:integ}  \\ \hline
  s\_offset  = Real  & \ref{s:offset} & aperture = Real  & \ref{s:limit}  & num\_steps = Integer        & \ref{s:integ}  \\ \hline
  x\_pitch = Real    & \ref{s:offset} &                  &                & symplectify = Logical       & \ref{s:symp}   \\ \hline
  y\_pitch = Real    & \ref{s:offset} & voltage$^*$      &                & a$n$, b$n$ = Real           & \ref{s:multip} \\ \hline
  tilt     = Real    & \ref{s:offset} & e\_field$^*$     &                & radius = Real               & \ref{s:multip} \\ \hline
  p0c$^*$            & \ref{s:energy} & beam\_energy$^*$ & \ref{s:energy} & aperture\_at = Switch       & \ref{s:limit}  \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

A \vn{ElSeparator} is an electrostatic separator.

\index{Hkick}
\index{Vkick}
\index{Gap}
For an \vn{Elseparator}, the kick is determined by \vn{hkick} and
\vn{vkick}. The \vn{gap} for an \vn{Elseparator} is used to compute
the electric field for a given kick. The voltage is a dependent
attribute determined by:
\begin{example}
  e\_field (V/m) = sqrt(hkick^2 + vkick^2) * beam\_energy / L
  voltage (V) = e\_field * gap  
\end{example}

Example:
\begin{example}
  h_sep: elsep, l = 4.5, hkick = 0.003, gap = 0.11
\end{example}

%-----------------------------------------------------------------
\section{Hkicker and Vkicker}
\label{s:hvkicker}
\index{Hkicker|textbf}
\index{Vkicker|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S & {\sl Attribute} & \S &  {\sl Attribute} & \S \\ \hline
  l        = Real       & \ref{s:l}       & type = String    & \ref{s:string} & tracking\_method = Switch    & \ref{s:tkm}   \\ \hline
  kick     = Real       & \ref{s:kick}    & alias = String   & \ref{s:string} & mat6\_calc\_method = Switch  & \ref{s:xfer}  \\ \hline
  tilt     = Real       & \ref{s:offset}  & descrip = String & \ref{s:string} & integration\_ord = Integer   & \ref{s:integ} \\ \hline
  rel\_tol = Real       & \ref{s:integ}   & x\_limit = Real  & \ref{s:limit}  & field\_calc = Switch         & \ref{s:integ} \\ \hline 
  abs\_tol = Real       & \ref{s:integ}   & y\_limit = Real  & \ref{s:limit}  & symplectify = Logical        & \ref{s:symp}  \\ \hline
  num\_steps = Integer  & \ref{s:integ}   & aperture = Real  & \ref{s:limit}  & is\_on = Logical             & \ref{s:is_on} \\ \hline
  beam\_energy$^*$      & \ref{s:energy}  & p0c$^*$          & \ref{s:energy} & aperture\_at = Switch        & \ref{s:limit} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

\index{Kick}
\index{Hkick}
\index{Vkick}
A \vn{Hkicker} is a horizontal bend and a \vn{Vkicker} is a vertical
bend.  Note that \vn{Hkicker} and \vn{Vkicker} elements use the
\vn{kick} attribute while a \vn{kicker} uses the \vn{hkick} and \vn{vkick} 
attributes. Example:
\begin{example}
  h_kick: hkicker, l = 4.5, kick = 0.003
\end{example}

%-----------------------------------------------------------------
\section{Hybrid}
\label{s:hybrid}
\index{Hybrid|textbf}

A \vn{Hybrid} element is an element that is formed by concatenating
other element together. \vn{Hybrid} elements are not part of the input
lattice file but are created by a program, usually for speed purposes.

%-----------------------------------------------------------------
\section{I\_Beam}
\label{s:i_beam}
\index{I_Beam|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  x\_offset  = Real     & \ref{s:offset}  &   x\_pitch  = Real     & \ref{s:offset}  &  type = String    & \ref{s:string}  \\ \hline
  y\_offset  = Real     & \ref{s:offset}  &   y\_pitch  = Real     & \ref{s:offset}  &  alias = String   & \ref{s:string}  \\ \hline
  s\_offset  = Real     & \ref{s:offset}  &   tilt      = Real     & \ref{s:offset}  &  descrip = String & \ref{s:string}  \\ \hline
  i\_beam = List        &                 &                        &                 &                   &                 \\ \hline
\end{tabular}
\end{center}
\toffset

An \vn{I_Beam} is a support structure that orients the elements that
are attached to it in space.

\index{X_offset}
\index{Y_pitch}
\index{Tilt}
When an \vn{I_Beam} overlays an element, then that elements
orientation attributes (\vn{x_offset}, \vn{y_pitch}, \vn{tilt}, etc.) 
give the orientation of
the element with respect to the \vn{I_Beam}. An example will make this clear:
\begin{example}
  q1: quad, l = 10
  q2: quad, l = 5, x_offset = 0.2, x_pitch = 0.01
  ib: i_beam = \{q1, q2\}, x_pitch = 0.1, x_offset = 0.3
  this_line: line = (q1, q2)
  use, this
\end{example}
\index{Overlay}
In this example \vn{ib} supports elements \vn{q1} and \vn{q2}. The
center of \vn{ib} is at $s = 7.5$ (\vn{ib} starts at $s = 0$ which is
the beginning of \vn{q1} and ends at $s = 15$ which is the end of
\vn{q2}). Like other elements, pitch is calculated from the center of
an \vn{I_Beam} element (see Sec.~\ref{s:offset}). The center of
\vn{q2} is at $s = 12.5$ so the distance between the center of \vn{ib}
and \vn{q2} is $ds = 5$. The pitch of \vn{ib} produces an offset at
the center of \vn{q2} of $0.5 = 0.1 * 5$. This, added to the offsets
of \vn{ib} and \vn{q2}, give the total offset of \vn{q2} to be $1.0 =
0.5 + 0.3 + 0.2$. The total \vn{x_pitch} of \vn{q2} is $0.11 = 0.1 +
0.01$. From the above example it can be seen that an \vn{I_Beam} looks
similar to an \vn{Overlay} (see Sec.~\ref{s:overlay}). It would,
however, take six \vn{Overlays} to simulate the effect of a single
\vn{I_Beam}.

The \vn{I_Beam} statement syntax is:
\begin{example}
  beam_name: I_BEAM = \{ele1, ele2, ... \}, ...
\end{example}
An \vn{I_Beam} element will be created for each \vn{ele1} element in
the lattice. The elements \vn{ele2}, \vn{ele3}, etc. do not have to be
consecutive but, if more than one \vn{I_Beam} is to be created, need
to be in order of increasing \vn{s}.
For example:
\begin{example}
  q1: quad
  q2: quad
  s0: sextupole
  s1: sextupole
  ib: i_beam = \{q1, s1, q2\}
  this_line: line = (q1, s0, s1, q2, ..., q1, s0, s1, q2)
  use, this
\end{example}
In this example two \vn{I_Beam} elements will be created.

Note to programmers: The total horizontal offset of any element is
stored in the element component \vn{%value(x_offset_tot\$)}. Similarly
the total tilt is stored in \vn{%value(tilt_tot\$)}, etc.

%-----------------------------------------------------------------
\section{Instrument and Monitor}
\label{s:monitor}
\index{Instrument|textbf}
\index{Monitor|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S  & {\sl Attribute} & \S \\ \hline
  l        = Real       & \ref{s:l}      & type = String    & \ref{s:string} & tracking\_method = Switch    & \ref{s:tkm}    \\ \hline
  rel\_tol = Real       & \ref{s:integ}  & alias = String   & \ref{s:string} & mat6\_calc\_method = Switch  & \ref{s:xfer}   \\ \hline
  abs\_tol = Real       & \ref{s:integ}  & descrip = String & \ref{s:string} & aperture\_at = Switch        & \ref{s:limit}  \\ \hline
  num\_steps = Integer  & \ref{s:integ}  & x\_limit = Real  & \ref{s:limit}  & symplectify = Logical        & \ref{s:symp}   \\ \hline
  x\_offset = Real      & \ref{s:offset} & y\_limit = Real  & \ref{s:limit}  & integration\_ord = Integer   & \ref{s:integ}  \\ \hline
  y\_offset = Real      & \ref{s:offset} & aperture = Real  & \ref{s:limit}  & field\_calc = Switch         & \ref{s:integ}  \\ \hline
  x\_pitch  = Real      & \ref{s:offset} & is\_on = Logical & \ref{s:is_on}  & beam\_energy$^*$             & \ref{s:energy} \\ \hline 
  y\_pitch  = Real      & \ref{s:offset} & tilt             & \ref{s:offset} & p0c$^*$                      & \ref{s:energy} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

\index{X_offset}
\index{Y_offset}
\index{X_pitch}
\index{Y_pitch}
\index{Tilt}
\bmad treats \vn{Instrument} and \vn{Monitor} elements exactly like a
\vn{Drift}.  The \vn{offset}, \vn{pitch}, and \vn{tilt} attributes are
not used by any \bmad routines. If these attributes are used by a
program they are typically used to simulate such things as measurement
offsets. The \vn{is_on} attribute is also not used by \bmad
proper. Example:
\begin{example}
  d21: instr, l = 4.5
\end{example}

%-----------------------------------------------------------------
\section{Kicker}
\label{s:kicker}
\index{Kicker|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S & {\sl Attribute} & \S&  {\sl Attribute} & \S \\ \hline
  l        = Real       & \ref{s:l}       & type = String      & \ref{s:string} & tracking\_method = Switch    & \ref{s:tkm}    \\ \hline
  hkick    = Real       & \ref{s:kick}    & alias = String     & \ref{s:string} & mat6\_calc\_method = Switch  & \ref{s:xfer}   \\ \hline
  vkick    = Real       & \ref{s:kick}    & descrip = String   & \ref{s:string} & integration\_ord = Integer   & \ref{s:integ}  \\ \hline
  h\_displace = Real    &                 & x\_limit = Real    & \ref{s:limit}  & field\_calc = Switch         & \ref{s:integ}  \\ \hline 
  v\_displace = Real    &                 & y\_limit = Real    & \ref{s:limit}  & symplectify = Logical        & \ref{s:symp}   \\ \hline
  rel\_tol = Real       & \ref{s:integ}   & aperture = Real    & \ref{s:limit}  & is\_on = Logical             & \ref{s:is_on}  \\ \hline
  abs\_tol = Real       & \ref{s:integ}   & beam\_energy$^*$   & \ref{s:energy} & aperture\_at = Switch        & \ref{s:limit}  \\ \hline
  num\_steps = Integer  & \ref{s:integ}   & p0c$^*$            & \ref{s:energy} & tilt     = Real              & \ref{s:offset} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

\index{Hkick}
\index{Vkick}
\index{H_displace}
\index{V_displace}
A \vn{Kicker} can deflect a beam in both planes. Note that a
\vn{Kicker} uses the \vn{hkick} and \vn{vkick} attributes while
\vn{Hkicker} and \vn{Vkicker} elements use the \vn{kick} attribute. 
In addition a \vn{Kicker} can apply a displacement to a particle
using the \vn{h_displace} and \vn{v_displace} attributes.
Example:
\begin{example}
  a_kick: kicker, l = 4.5, hkick = 0.003
\end{example}

%-----------------------------------------------------------------
\section{Lcavity}
\label{s:lcav}
\index{Lcavity|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real       & \ref{s:l}      & type = String     & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}   \\ \hline
  rf\_frequency = Real  &                & alias = String    & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}  \\ \hline
  gradient      = Real  &                & descrip = String  & \ref{s:string} & integration\_ord = Integer  & \ref{s:integ} \\ \hline
  phi0          = Real  &                & is\_on = Logical  & \ref{s:is_on}  & field\_calc = Switch        & \ref{s:integ} \\ \hline
  dphi0         = Real  &                & x\_limit = Real   & \ref{s:limit}  & rel\_tol = Real             & \ref{s:integ} \\ \hline
  e\_loss    = Real     &                & y\_limit = Real   & \ref{s:limit}  & abs\_tol = Real             & \ref{s:integ} \\ \hline
  x\_offset  = Real     & \ref{s:offset} & aperture = Real   & \ref{s:limit}  & num\_steps = Integer        & \ref{s:integ} \\ \hline
  y\_offset  = Real     & \ref{s:offset} & hkick    = Real   & \ref{s:kick}   & lr\_wake\_file = String     &               \\ \hline
  s\_offset  = Real     & \ref{s:offset} & vkick    = Real   & \ref{s:kick}   & sr\_wake\_file = String     &               \\ \hline
  x\_pitch = Real       & \ref{s:offset} & e\_loss  = Real   &                & aperture\_at = Switch       & \ref{s:limit} \\ \hline
  y\_pitch = Real       & \ref{s:offset} & energy\_start$^*$ & \ref{s:energy} & delta\_e$^*$                &               \\ \hline
  freq\_spread = Real   &                & beam\_energy$^*$  & \ref{s:energy} & p0c$^*$                     & \ref{s:energy}\\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

An \vn{Lcavity} is a LINAC accelerating cavity.
Tracking through an \vn{Lcavity} is modeled using the equations
developed by Rosenzweig and Serafini\cite{b:rosenzweig}. The
attributes specific to an \vn{Lcavity} are 
\index{Gradient}
\index{Phi0}
\index{Dphi0}
\index{E_loss}
\index{Rf_frequency}
\index{Delta_e}
\index{Sr_wake_file}
\index{Lr_wake_file}
\begin{example}
  gradient     ! Accelerating gradient (V/m).
  phi0         ! Phase (radians/2\(\pi\)) of the reference particle with 
               !   respect to the RF. phi0 = 0 is on crest.
  dphi0        ! Used to shift the phase with respect to a multipass lord.
  e_loss       ! Loss parameter for short range wakefields (V/Coulomb).
  rf_frequency ! Rf frequency (Hz).
  delta_e      ! Nominal change in energy of an on-crest particle
  sr_wake_file ! Short range wake field definition file.
  lr_wake_file ! Long range wake field definition file.
\end{example}
The dependent variable \vn{delta_e} attribute can be used in place of
\vn{gradient} as discussed in \sref{s:depend}.

The kick felt by a particle is 
\begin{example}
  dE = gradient * L * cos(twopi * (phi - z * rf_frequency / c_light)) - 
                                                   e_loss * n_part * e_charge 
\end{example}
This is consistent with MAD and LIAR. Note: The MAD8 documentation 
for an \vn{Lcavity} has a wrong sign. Essentially the MAD8 documentation gives
\begin{example}
  dE = gradient * L * cos(twopi * (phi + z * rf_frequency / c_light)) ! WRONG
\end{example}
This is incorrect. The \vn{e_loss} attribute represents the energy loss due to 
short--range wakefields. \vn{n_part} is set using the \vn{parameter} statement 
(\sref{s:param}) and represents the number of particles in a bunch. 

The energy change of the reference particle is just the energy change for a 
particle with $z = 0$. Thus
\begin{example}
  dE(reference) = gradient * L * cos(twopi * phi) - e_loss * n_part * e_charge
\end{example}

\index{Multipass}
In the above equations \vn{phi} = \vn{phi0} + \vn{dphi0}. \vn{dphi0}
is only to be used to shift the phase with respect to a \vn{multipass}
lord. See \sref{s:multipass}.

Note: The transfer matrix for an \vn{Lcavity} with finite
\vn{gradient} is never symplectic.

\index{Wakefields!in Lcavity}
The formulas used to compute the wakefield are given in
\sref{s:wakefields}.  The input file name for the short--range
wakefields is specified using the \vn{sr_wake_file} attribute. The
file gives both monopole longitudinal and dipole transverse
wakes. Comment lines may be included by starting a line with an
exclamation mark (!). Blank lines are also ignored.  An example input
file is:
\begin{example}
  !    z           Wz             Wt
  !   [m]       [V/C/m]       [V/C/m^2]
   0.000E+00  1.61125E+15   0.00000E+00     1 
  -1.000E-05  1.44516E+15   1.30560E+15     2 
  -2.000E-05  1.38148E+15   2.50665E+15     3 
  .. etc ..
  -1.970E-03  3.49958E+14   7.95507E+16   198 
  -1.980E-03  3.48606E+14   7.97253E+16   199  
  -1.990E-03  3.47263E+14   7.98989E+16   200
     END_SECTION


  ! Pseudo Wake modes:
  !                      Amp       damp          k      phase
  ! Longitudinal:      [V/C/m]     [1/m]      [1/m]     [rad]  
  ! Transverse:      [V/C/m^2]     [1/m]      [1/m]     [rad]  

  &short_range_modes
    longitudinal(1) = 3.23e14     1.23e3     3.62e3     0.123
    longitudinal(2) = 6.95e13     5.02e2     1.90e3    -1.503
    .. etc ..
    transverse(1) =   4.23e14     2.23e3     5.62e3     0.789
    transverse(2) =   8.40e13     5.94e2     1.92e3     1.455
     .. etc ..
    z_max = -1.3e-3
  /
\end{example}
The file is divided into two sections with a line containing the word
\vn{END_SECTION} marking the division between the sections.  Wakes can
be specified via a table of wake versus longitudinal position $z$
and/or using a set of ``pseudo'' modes (\sref{s:wakefields}). The
first section gives the wake vs $z$ table, and the second section
gives the longitudinal monopole and transverse dipole pseudo modes.
The range of the table is from $0$ to $z_{cut}$ where $z_{cut}$ is the
$z$ value in the last line of the table. If the longitudinal distance
$dz$ between two particles is within the range of the table then the
table will be used to calculate the wake kick for this pair. If $dz$
is larger than $z_{cut}$ the pseudo modes will be used. The pseudo
modes are valid from $z_{cut}$ to \vn{z_max}. 

In the first section with the table of wake vs. $z$, the first column
is the longitudinal distance $z$. $z$ must start at 0 and must
increment by the a constant amount from row to row. $z$ is negative
since the wake extends behind a particle. To be backward compatible
with the Liar program, \bmad accepts positive $z$ and will internally
convert to negative $z$. The second column is the longitudinal wake
function in $V/C/m$. The third column is the transverse wake in
$V/C/m^2$. Any additional columns are ignored.  Wakefield formulas are
to be found in \sref{s:wakefields}.  The wakefield file is only used
with macroparticle tracking.  When the short--range wakefield file is
used with macroparticle tracking the \vn{e_loss} attribute is
ignored. However, even in this case, a finite \vn{e_loss} value will
affect the reference energy. Since the quantities like quadrupole k1
strengths and bend strengths are referenced to the reference energy,
The value of \vn{e_loss} will affect the results even with a
short--range wakefield file.

The input file name for the long--range wakefields is specified using
the \vn{lr_wake_file} attribute. The file gives the
wake modes by specifying the frequency (in Hz), R/Q (in
$\Omega$/meter$^{2m}$), Q, and m (order number), and optionally the
poarization angle (in radians/2pi) for each cavity mode. The input
uses Fortran90 namelist syntax: The data begins with the string
\vn{\&long_range_modes} and ends with a \vn{/}. Everything outside is
ignored. Each mode is labeled \vn{lr(i)} where \vn{i} is the mode
index. An example input file is:
\begin{example}
              Freq       R/Q      Q       m  Polarization_Angle
              [Hz]  [Ohm/m^(2m)]             [Radians/2pi]
  &long_range_modes
    lr(1) = 1.6506e9    0.76    7.0e4     1
    lr(2) = 1.6991e9   11.21    5.0e4     1     0.15
  /
\end{example}
If no polarization angle is given the mode is taken to be unpolarized.

\vn{freq_spread} is used to randomly spread out the mode frequencies
among different cavities. The spread is Gaussian in shape with an RMS
of \vn{freq_spread} * $F$ where $F$ is the frequency of a mode.

\vn{delta_e} is a dependent attribute and is
defined to be
\begin{example}
  delta_e = gradient * L
\end{example}

Example:
\begin{example}
  rf1: lcav, l = 4.5, gradient = 1.2e6, sr\_wake\_file = "sr1.dat"
\end{example}

%-----------------------------------------------------------------
\section{Marker}
\label{s:mark}
\index{Marker|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  tracking\_method = Switch    & \ref{s:tkm}    &  type = String    & \ref{s:string} & x\_limit = Real       & \ref{s:limit}  \\ \hline 
  mat6\_calc\_method = Switch  & \ref{s:xfer}   &  alias = String   & \ref{s:string} & y\_limit = Real       & \ref{s:limit}  \\ \hline 
  x\_offset = Real             & \ref{s:energy} &  descrip = String & \ref{s:string} & aperture = Real       & \ref{s:limit}  \\ \hline 
  y\_offset = Real             & \ref{s:energy} &  is\_on = Logical & \ref{s:is_on}  & aperture\_at = Switch & \ref{s:limit}  \\ \hline
                               &                & p0c$^*$           & \ref{s:energy} & beam\_energy$^*$      & \ref{s:energy} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

\index{X_offset}
\index{Y_offset}
\index{Is_on}
A \vn{Marker} is a zero length element meant to mark a position. The
\vn{x_offset} and \vn{y_offset} attributes are not used by any \bmad
routines. Typically if these attributes are used by a program they are
used to simulate things like BPM offsets. The \vn{is_on} attribute is
also not used by \bmad proper. Example:
\begin{example}
  mm: mark, type = "BPM"
\end{example}

%-----------------------------------------------------------------
\section{Match}
\label{s:match}
\index{Match|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  beta\_x0  = Real &               & beta\_x1  = Real &                & tracking\_method = Switch   & \ref{s:tkm}    \\ \hline
  alpha\_x0 = Real &               & alpha\_x1 = Real &                & mat6\_calc\_method = Switch & \ref{s:xfer}   \\ \hline
  eta\_x0   = Real &               & eta\_x1   = Real &                & x\_limit = Real             & \ref{s:limit}  \\ \hline
  etap\_x0  = Real &               & etap\_x1  = Real &                & y\_limit = Real             & \ref{s:limit}  \\ \hline
  beta\_y0  = Real &               & beta\_y1  = Real &                & aperture = Real             & \ref{s:limit}  \\ \hline
  alpha\_y0 = Real &               & alpha\_y1 = Real &                & aperture\_at = Switch       & \ref{s:limit}  \\ \hline
  eta\_y0   = Real &               & eta\_y1   = Real &                & type = String               & \ref{s:string} \\ \hline
  etap\_y0  = Real &               & etap\_y1  = Real &                & alias = String              & \ref{s:string} \\ \hline
  dphi\_x   = Real &               & beam\_energy$^*$ & \ref{s:energy} & descrip = String            & \ref{s:string} \\ \hline
  dphi\_y   = Real &               & p0c$^*$          & \ref{s:energy} & is\_on = Logical            & \ref{s:is_on}  \\ \hline
  l         = Real & \ref{s:l}     &                  &                &                             &                \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

\index{Beta_x0}
\index{Beta_y0}
\index{Beta_x1}
\index{Beta_y1}
\index{Dphi_x}
\index{Dphi_y}
A \vn{Match} element is used to match the Twiss parameters between two
points. That is, the transfer map for a match element, which is just a
linear matrix, is calculated such that if the Twiss parameters at the
exit end of the element preceding the \vn{match} element are given by
\vn{beta_x0}, \vn{beta_y0}, etc., then the computed Twiss parameters
at the exit end of the \vn{match} element will be \vn{beta_x1},
\vn{beta_y1}, etc. \vn{dphi_x} and \vn{dphi_y} are the phase advances
in radians.

\index{L}
The attribute \vn{l} is not used in the transfer matrix
calculation. It is sometimes needed by a program for other
computations. For example, to compute the time it takes to go through
a match element.

Example:
\begin{example}
  mm: match, beta_x0 = 12.5, beta_y0 = 3.4, eta_x0 = 1.0, ...
\end{example}

%-----------------------------------------------------------------
\section{Multipole}
\label{s:mult}
\index{Multipole|textbf}

\index{Multipole!KnL, Tn}
\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  K$n$L, T$n$ = Real &  \ref{s:multip} &  type = String       & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}   \\ \hline
  tilt       = Real  &  \ref{s:offset} &  alias = String      & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}  \\ \hline
  x\_offset  = Real  &  \ref{s:offset} &  descrip = String    & \ref{s:string} & x\_limit = Real             & \ref{s:limit} \\ \hline
  y\_offset  = Real  &  \ref{s:offset} &  is\_on = Logical    & \ref{s:is_on}  & y\_limit = Real             & \ref{s:limit} \\ \hline
  s\_offset  = Real  &  \ref{s:offset} &  beam\_energy$^*$    & \ref{s:energy} & aperture = Real             & \ref{s:limit} \\ \hline
  lrad       = Real  &                 &  p0c$^*$             & \ref{s:energy} & aperture\_at = Switch       & \ref{s:limit} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

A \vn{Multipole} is a thin multipole lens up to 20th order. The only
difference between this and an \vn{AB_Multipole} is the input format. See the 
Magnetic fields section \ref{s:multip} for more details.

\index{Lrad}
\vn{lrad} is a fictitious length that is used for synchrotron radiation
computations but does not affect any tracking or transfer map calculations. 

Like a \mad \vn{multipole}, A \bmad \vn{Multipole} will affect the
reference orbit if there is a dipole component. 
Example:
\begin{example}
  m1: multipole, k1l = 0.034e-2, t1, k3l = 4.5, t3 = 0.31*pi
\end{example}

%-----------------------------------------------------------------
\section{Octupole}
\label{s:oct}
\index{Octupole|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real        & \ref{s:l}      & type = String     & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}    \\ \hline
  k3\DAG   = Real        &                & alias = String    & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}   \\ \hline
  b\_gradient\DAG = Real &                & descrip = String  & \ref{s:string} & integration\_ord = Integer  & \ref{s:integ}  \\ \hline
  x\_offset  = Real      & \ref{s:offset} & is\_on = Logical  & \ref{s:is_on}  & field\_calc = Switch        & \ref{s:integ}  \\ \hline
  y\_offset  = Real      & \ref{s:offset} & x\_limit = Real   & \ref{s:limit}  & rel\_tol = Real             & \ref{s:integ}  \\ \hline
  s\_offset  = Real      & \ref{s:offset} & y\_limit = Real   & \ref{s:limit}  & abs\_tol = Real             & \ref{s:integ}  \\ \hline
  x\_pitch = Real        & \ref{s:offset} & aperture = Real   & \ref{s:limit}  & num\_steps = Integer        & \ref{s:integ}  \\ \hline
  y\_pitch = Real        & \ref{s:offset} & a$n$, b$n$ = Real & \ref{s:multip} & radius = Real               & \ref{s:multip} \\ \hline
  tilt                   & \ref{s:offset} & hkick    = Real   & \ref{s:kick}   & symplectify = Logical       & \ref{s:symp}   \\ \hline
  beam\_energy$^*$       & \ref{s:energy} & vkick    = Real   & \ref{s:kick}   & aperture\_at = Switch       & \ref{s:limit}  \\ \hline
  p0c$^*$                & \ref{s:energy} &                   &                &                             &                \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. \DAG May be a dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

An \vn{Octupole} has a cubic field dependence.
The \vn{Bmad_Standard} calculation treats an octupole using a kick--drift--kick model.

\index{Tilt}
If the \vn{tilt} attribute is present without a value then a value of 
$\pi/8$ is used.
Example:
\begin{example}
  oct1: octupole, l = 4.5, k3 = 0.003, tilt ! same as tilt = pi/8
\end{example}

%-----------------------------------------------------------------
\section{Patch}
\label{s:patch}
\index{Patch|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  x\_offset  = Real  & \ref{s:offset} &  type = String      & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}   \\ \hline
  y\_offset  = Real  & \ref{s:offset} &  alias = String     & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}  \\ \hline
  z\_offset  = Real  & \ref{s:offset} &  descrip = String   & \ref{s:string} & x\_limit = Real             & \ref{s:limit} \\ \hline
  tilt = Real        & \ref{s:offset} &  x\_pitch   = Real  & \ref{s:offset} & y\_limit = Real             & \ref{s:limit} \\ \hline
  de\_offset = Real  &                &  y\_pitch   = Real  & \ref{s:offset} & aperture = Real             & \ref{s:limit} \\ \hline
  beam\_energy$^*$   & \ref{s:energy} &  is\_on = Logical   & \ref{s:is_on}  & aperture\_at = Switch       & \ref{s:limit} \\ \hline
  p0c$^*$            & \ref{s:energy} &                     &                &                             &               \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

\index{X_offset}
A \vn{Patch} offsets the reference orbit. This is a generalization of
\mad's \vn{yrot} and \vn{srot} elements. For example, a positive
\vn{x_offset} offsets the reference orbit after the \vn{patch} in the
positive $x$--direction relative to the reference orbit before the
\vn{patch}.
Example:
\begin{example}
  pt: patch, x\_offset = 3.2
\end{example}

%-----------------------------------------------------------------
\section{Quadrupole}
\label{s:quad}
\index{Quadrupole|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real        & \ref{s:l}      & type = String      & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}   \\ \hline
  k1\DAG   = Real        &                & alias = String     & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}  \\ \hline
  b\_gradient\DAG = Real &                & descrip = String   & \ref{s:string} & integration\_ord = Integer  & \ref{s:integ} \\ \hline
                         &                & is\_on = Logical   & \ref{s:is_on}  & field\_calc = Switch        & \ref{s:integ} \\ \hline
  x\_offset  = Real      & \ref{s:offset} & x\_limit = Real    & \ref{s:limit}  & rel\_tol = Real             & \ref{s:integ} \\ \hline
  y\_offset  = Real      & \ref{s:offset} & y\_limit = Real    & \ref{s:limit}  & abs\_tol = Real             & \ref{s:integ} \\ \hline
  s\_offset  = Real      & \ref{s:offset} & aperture = Real    & \ref{s:limit}  & num\_steps = Integer        & \ref{s:integ} \\ \hline
  x\_pitch = Real        & \ref{s:offset} & hkick    = Real    & \ref{s:kick}   & a$n$, b$n$ = Real           & \ref{s:multip}\\ \hline
  y\_pitch = Real        & \ref{s:offset} & vkick    = Real    & \ref{s:kick}   & radius = Real               & \ref{s:multip}\\ \hline
  tilt     = Real        & \ref{s:offset} & beam\_energy$^*$   & \ref{s:energy} & symplectify = Logical       & \ref{s:symp}  \\ \hline
                         &                & p0c$^*$            & \ref{s:energy} & aperture\_at = Switch       & \ref{s:limit} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. \DAG May be a dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

\index{Tilt}
A \vn{Quadrupole} has a linear field dependence.
If the \vn{tilt} attribute is present without a value then a value of $\pi/4$
is used.
Example:
\begin{example}
  q03w: quad, l = 0.6, k1 = 0.003, tilt  ! same as tilt = pi/4
\end{example}

%-----------------------------------------------------------------
\section{RFcavity}
\label{s:rfcav}
\index{RFcavity|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real     & \ref{s:l}      & type = String      & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}   \\ \hline
  harmon   = Real     &                & alias = String     & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}  \\ \hline
  voltage  = Real     &                & descrip = String   & \ref{s:string} & integration\_ord = Integer  & \ref{s:integ} \\ \hline
  phi0     = Real     &                & rf\_frequency = Real &              & field\_calc = Switch        & \ref{s:integ} \\ \hline
  dphi0    = Real     &                & x\_limit = Real    & \ref{s:limit}  & rel\_tol = Real             & \ref{s:integ} \\ \hline
  x\_offset  = Real   & \ref{s:offset} & y\_limit = Real    & \ref{s:limit}  & abs\_tol = Real             & \ref{s:integ} \\ \hline
  y\_offset  = Real   & \ref{s:offset} & aperture = Real    & \ref{s:limit}  & num\_steps = Integer        & \ref{s:integ} \\ \hline
  s\_offset  = Real   & \ref{s:offset} & hkick    = Real    & \ref{s:kick}   & is\_on = Logical            & \ref{s:is_on} \\ \hline
  x\_pitch = Real     & \ref{s:offset} & vkick    = Real    & \ref{s:kick}   & symplectify = Logical       & \ref{s:symp}  \\ \hline
  y\_pitch = Real     & \ref{s:offset} & beam\_energy$^*$   & \ref{s:energy} & aperture\_at = Switch       & \ref{s:limit} \\ \hline
                      &                & p0c$^*$            & \ref{s:energy} &                             &               \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

An \vn{RFcavity} is an RF cavity without acceleration generally used
in a storage ring.

The \vn{phi0} attribute here is identical to the \vn{lag} attribute of
\mad. The kick felt by a particle is 
\begin{example}
  dE = voltage * sin(twopi * (phi + z * rf_frequency / c_light))
\end{example}
\index{Multipass}
Here \vn{phi} = \vn{phi0} + \vn{dphi0}. \vn{dphi0}
is only to be used to shift the phase with respect to a \vn{multipass}
lord. See \sref{s:multipass}.

If \vn{harmon} is non--zero then \vn{rf_frequency} is a dependent
attribute calculated by
\begin{example}
  rf_frequency = harmon * c_light / L_lattice 
\end{example}
where \vn{L_lattice} is the total lattice length.

Example:
\begin{example}
  rf1: rfcav, l = 4.5, harmon = 1281, voltage = 5e6
\end{example}

%-----------------------------------------------------------------
\section{Sextupole}
\label{s:sex}
\index{Sextupole|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real        & \ref{s:l}      & type = String      & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}   \\ \hline
  k2\DAG   = Real        &                & alias = String     & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}  \\ \hline
  b\_gradient\DAG = Real &                & descrip = String   & \ref{s:string} & integration\_ord = Integer  & \ref{s:integ} \\ \hline
  x\_offset  = Real      & \ref{s:offset} & is\_on = Logical   & \ref{s:is_on}  & field\_calc = Switch        & \ref{s:integ} \\ \hline
  y\_offset  = Real      & \ref{s:offset} & x\_limit = Real    & \ref{s:limit}  & rel\_tol = Real             & \ref{s:integ} \\ \hline
  s\_offset  = Real      & \ref{s:offset} & y\_limit = Real    & \ref{s:limit}  & abs\_tol = Real             & \ref{s:integ} \\ \hline
  x\_pitch = Real        & \ref{s:offset} & aperture = Real    & \ref{s:limit}  & num\_steps = Integer        & \ref{s:integ} \\ \hline
  y\_pitch = Real        & \ref{s:offset} & hkick    = Real    & \ref{s:kick}   & aperture\_at = Switch       & \ref{s:limit} \\ \hline
  tilt     = Real        & \ref{s:offset} & vkick    = Real    & \ref{s:kick}   & radius = Real               & \ref{s:multip}\\ \hline
  beam\_energy$^*$       & \ref{s:energy} & a$n$, b$n$ = Real  & \ref{s:multip} & symplectify = Logical       & \ref{s:symp}  \\ \hline
  p0c$^*$                & \ref{s:energy} &                    &                &                             &               \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. \DAG May be a dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

A \vn{Sextupole} is an element with a magnetic field that varies quadratically with transverse offset. The \vn{Bmad_Standard} calculation treats a sextupole using a kick--drift--kick model.

If the \vn{tilt} attribute is present without a value then a value of 
$\pi/6$ is used.
Example:
\begin{example}
  q03w: quad, l = 0.6, k1 = 0.003, tilt  ! same as tilt = pi/6
\end{example}

%-----------------------------------------------------------------
\section{Solenoid}
\label{s:sol}
\index{Solenoid|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real        & \ref{s:l}      & type = String      & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}   \\ \hline
  ks\DAG   = Real        &                & alias = String     & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}  \\ \hline
  b\_gradient\DAG = Real &                & descrip = String   & \ref{s:string} & integration\_ord = Integer  & \ref{s:integ} \\ \hline
  x\_offset  = Real      & \ref{s:offset} & is\_on = Logical   & \ref{s:is_on}  & field\_calc = Switch        & \ref{s:integ} \\ \hline
  y\_offset  = Real      & \ref{s:offset} & x\_limit = Real    & \ref{s:limit}  & rel\_tol = Real             & \ref{s:integ} \\ \hline
  s\_offset  = Real      & \ref{s:offset} & y\_limit = Real    & \ref{s:limit}  & abs\_tol = Real             & \ref{s:integ} \\ \hline
  x\_pitch   = Real      & \ref{s:offset} & aperture = Real    & \ref{s:limit}  & num\_steps = Integer        & \ref{s:integ} \\ \hline
  y\_pitch   = Real      & \ref{s:offset} & hkick    = Real    & \ref{s:kick}   & aperture\_at = Switch       & \ref{s:limit} \\ \hline
  beam\_energy$^*$       & \ref{s:energy} & vkick    = Real    & \ref{s:kick}   & radius = Real               & \ref{s:multip}\\ \hline
  p0c$^*$                & \ref{s:energy} & a$n$, b$n$ = Real  & \ref{s:multip} & symplectify = Logical       & \ref{s:symp}  \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. \DAG May be a dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

A \vn{Solenoid} is an element with a longitudinal magnetic field.
Example:
\begin{example}
  cleo_sol: solenoid, l = 2.6, ks = 1.5*beam[energy]
\end{example}

%-----------------------------------------------------------------
\section{Sol\_Quad}
\label{s:sq}
\index{Sol_Quad|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real     & \ref{s:l}      & type = String     & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}   \\ \hline
  ks\DAG   = Real     &                & alias = String    & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}  \\ \hline
  k1       = Real     &                & descrip = String  & \ref{s:string} & integration\_ord = Integer  & \ref{s:integ} \\ \hline
  b\_field\DAG = Real &                & is\_on = Logical  & \ref{s:is_on}  & field\_calc = Switch        & \ref{s:integ} \\ \hline
  x\_offset  = Real   & \ref{s:offset} & x\_limit = Real   & \ref{s:limit}  & rel\_tol = Real             & \ref{s:integ} \\ \hline
  y\_offset  = Real   & \ref{s:offset} & y\_limit = Real   & \ref{s:limit}  & abs\_tol = Real             & \ref{s:integ} \\ \hline
  s\_offset  = Real   & \ref{s:offset} & aperture = Real   & \ref{s:limit}  & num\_steps = Integer        & \ref{s:integ} \\ \hline
  x\_pitch = Real     & \ref{s:offset} & hkick    = Real   & \ref{s:kick}   & a$n$, b$n$ = Real           & \ref{s:multip}\\ \hline
  y\_pitch = Real     & \ref{s:offset} & vkick    = Real   & \ref{s:kick}   & radius = Real               & \ref{s:multip}\\ \hline
  tilt     = Real     & \ref{s:offset} & beam\_energy$^*$  & \ref{s:energy} & symplectify = Logical       & \ref{s:symp}  \\ \hline
                      &                & p0c$^*$           & \ref{s:energy} & aperture\_at = Switch       & \ref{s:limit} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. \DAG May be a dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

A \vn{Sol_Quad} is a combination solenoid/quadrupole.
Example:
\begin{example}
  sq02: sol_quad, l = 2.6, k1 = 0.632, ks = 1.5*beam[energy]
\end{example}

%-----------------------------------------------------------------
\section{Taylor}
\label{s:tay}
\index{Taylor|textbf}

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  $\{ \tt \mbox{out:}\,  coef, \, e1 \, e2 \, e3 \, e4 \, e5 \, e6 \}$ 
                              &              & type = String    & \ref{s:string} & x\_limit = Real       & \ref{s:limit} \\ \hline  
  tracking\_method = Switch   & \ref{s:tkm}  & alias = String   & \ref{s:string} & y\_limit = Real       & \ref{s:limit} \\ \hline
  mat6\_calc\_method = Switch & \ref{s:xfer} & descrip = String & \ref{s:string} & aperture = Real       & \ref{s:limit} \\ \hline
  symplectify = Logical       & \ref{s:symp} & beam\_energy$^*$ & \ref{s:energy} & is\_on = Logical      & \ref{s:is_on} \\ \hline
                              &              &                  &                & aperture\_at = Switch & \ref{s:limit} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

A \vn{Taylor} is a Taylor map. This can be used in place of the \mad 
\vn{matrix} element.

A term in a Taylor map is of the form
\Begineq
  x_j({\rm out}) = C \cdot \Pi_{i = 1}^6 \, x_i^{e_i}({\rm in})
\Endeq
where $\Bf x = (x, p_x, y, p_y, z, p_z)$. For example a term
in a Taylor map that was
\Begineq
  p_y({\rm out}) = 2.73 \cdot y^2({\rm in}) \, p_z({\rm in})
\Endeq
would be written as
\begin{example}
  \{4: 2.73, 0, 0, 2, 0, 0, 1\}
\end{example}

By default a \vn{Taylor} element starts out as the unit map. 
That is, a \vn{Taylor} element starts with the following 6 terms
\begin{example}
  \{1: 1.0, 1 0 0 0 0 0\}
  \{2: 1.0, 0 1 0 0 0 0\}
  \{3: 1.0, 0 0 1 0 0 0\}
  \{4: 1.0, 0 0 0 1 0 0\}
  \{5: 1.0, 0 0 0 0 1 0\}
  \{6: 1.0, 0 0 0 0 0 1\}
\end{example}
Note: A term in a \vn{Taylor} element will override any previous term
that is identical except for \vn{coef}. For example
\begin{example}
  tt: Taylor, \{1:  0.0   1, 0, 0, 0, 0, 0\} 
\end{example}
This will override the default \vn{\{1: 1.0, 1 0 0 0 0 0\}} term.

Example \vn{Taylor} element definition:
\begin{example}
  tt: Taylor, \{4:  2.73, 0, 0, 2, 0, 0, 1\}, &
              \{2: -2.73, 2, 0, 0, 0, 0, 1\}
\end{example}

%-----------------------------------------------------------------
\section{Wiggler} 
\label{s:wiggler}
\index{Wiggler|textbf} 

\begin{center}
\tt
\begin{tabular}{|l|l||l|l||l|l|} \hline
  {\sl Attribute} & \S  & {\sl Attribute} & \S & {\sl Attribute} & \S \\ \hline
  l        = Real       & \ref{s:l}      & type = String      & \ref{s:string} & tracking\_method = Switch   & \ref{s:tkm}   \\ \hline
  b\_max   = Real       &                & alias = String     & \ref{s:string} & mat6\_calc\_method = Switch & \ref{s:xfer}  \\ \hline
  n\_pole  = Real       &                & descrip = String   & \ref{s:string} & integration\_ord = Integer  & \ref{s:integ} \\ \hline
  term(i) = Wig\_Term   &                & x\_offset  = Real  & \ref{s:offset} & field\_calc = Switch        & \ref{s:integ} \\ \hline
  polarity = Real       &                & y\_offset  = Real  & \ref{s:offset} & rel\_tol = Real             & \ref{s:integ} \\ \hline
  hkick    = Real       & \ref{s:kick}   & s\_offset  = Real  & \ref{s:offset} & abs\_tol = Real             & \ref{s:integ} \\ \hline
  vkick    = Real       & \ref{s:kick}   & x\_pitch = Real    & \ref{s:offset} & num\_steps = Integer        & \ref{s:integ} \\ \hline
  x\_limit = Real       & \ref{s:limit}  & y\_pitch = Real    & \ref{s:offset} & a$n$, b$n$ = Real           & \ref{s:multip}\\ \hline
  y\_limit = Real       & \ref{s:limit}  & tilt     = Real    & \ref{s:offset} & radius  = Real              & \ref{s:multip}\\ \hline
  aperture = Real       & \ref{s:limit}  & is\_on = Logical   & \ref{s:is_on}  & symplectify = Logical       & \ref{s:symp}  \\ \hline
  beam\_energy$^*$      & \ref{s:energy} & k1$^*$             &                & rho$^*$                     &               \\ \hline
                        &                &                    &                & aperture\_at = Switch       & \ref{s:limit} \\ \hline
  \multicolumn{6}{l}{\small $^*$Dependent attribute. See Chapter~\ref{c:attrib}} \\
\end{tabular}
\end{center}
\toffset

A \vn{Wiggler} is a periodic array of alternating bends.

There are two types of wigglers. Those that that are described using a
magnetic field map (``map type'') and those that are described assuming
a periodic field (``periodic type''). The periodic type is defined by
specifying \vn{b_max} and \vn{n_pole}. For the "map" type wigglers the
field is given by a sum of terms as outlined in
\sref{s:wiggler_phys}.

For the "periodic" type wigglers the attributes are: 
\begin{example}  
  \vn{b_max}  ! Maximum magnetic field (in T) on the wiggler centerline. 
  \vn{n_pole} ! The number of poles. The period is then L / (2 * N_POLE). 
\end{example}

Example:
\begin{example}
  wig1: wiggler, l = 1.6, b_max = 2.1, n_pole = 7  ! periodic type wiggler
  wig2: wiggler, l = 1.6, \&                       ! map type wiggler
           term(1) = \{ 0.03, 3.00, 4.00, 5.00, 0.63\}
\end{example}

