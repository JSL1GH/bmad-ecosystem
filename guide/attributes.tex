\chapter {Element Attributes}
\label{c:attrib}
\index{Element attribute}

%-----------------------------------------------------------------
\section{Dependent and Independent Attributes} 
\label{s:depend} 
\index{Element attribute!dependent and independent}

For convenience, \bmad computes the values of some attributes based
upon the values of other attributes. These dependent variables are
listed in Table~\ref{t:dependent}. Also shown in
Table~\ref{t:dependent} are the independent variables they are
calculated from.  In the table \vn{n_part} and \vn{l_lattice} (lattice
length) are lattice attributes, not element attributes. The first two
are set by the \vns{parameter} statement (See
Section~\ref{s:param}). \vn{l_lattice} is calculated when the
lattice is read in.

\begin{table}[h]
\centering {
\begin{tabular}{|l|l|l|} \hline
{\em Element}       & {\em Dependent Variables}  & {\em Independent Variables}  \\ \hline
 \vnec{BeamBeam}     & \vnea{bbi_const}           & 
         \vnea{charge}, \vnea{sig_x}, \vnea{sig_y}, \vnea{beam_energy}, \vnea{n_part} \\ \hline
 \vnec{Elseparator}  & \vnea{e_field}, \vnea{voltage}   & 
         \vnea{hkick}, \vnea{vkick}, \vnea{gap}, \vnea{l}, \vnea{beam_energy}    \\ \hline
 \vnec{Lcavity}      & \vnea{e_loss}, \vnea{delta_e}    & 
         \vnea{gradient}, \vnea{l}                           \\ \hline
 \vnec{Rbend}, \vnec{Sbend} & \vnea{rho}, \vnea{angle}, \vnea{l_chord} & 
         \vnea{g}, \vnea{l}                                  \\ \hline
 \vnec{Wiggler} (periodic type) & \vnea{k1}, \vnea{rho}             & 
         \vnea{b_max}, \vnea{beam_energy}                    \\ \hline
\end{tabular}
}
\caption[Table of dependent variables.]{Table of dependent variables and 
  the independent variables 
they are calculated from.}
\label{t:dependent}
\end{table}

\index{Lattice!expansion}
No attempt should be made to set or vary within a program dependent
attributes. It should be remarked that this is not an iron clad rule.
If a program properly bypasses \bmad's attribute bookkeeping routine
then anything is possible. Before lattice expansion \bmad allows the
setting of a select group of dependent variables if the appropriate
independent is left unspecified.  The list of settable dependent
variables is given in Table~\ref{t:dep_except}.  After reading in the
lattice \bmad will set the appropriate independent variable based
upon the value of the dependent variable. \vnea{harmon} is the exception in 
that it will never be set by the bookkeeping routine.
\begin{table}[h]
\centering {
\begin{tabular}{|l|l|l|} \hline
{\em Element}   & {\em Dependent Variable Set}  & 
                      {\em Independent Variables Not Set} \\ \hline
  \vnec{Lcavity}            & \vnea{delta_e}       & \vnea{gradient}  \\ \hline
  \vnec{Rbend}, \vnec{Sbend} & \vnea{rho}           & \vnea{g}         \\ \hline
  \vn{Rbend}, \vn{Sbend}   & \vnea{angle}         & \vnea{g}         \\ \hline
  \vnec{RFcavity}           & \vnea{rf_frequency}  & \vnea{harmon}    \\ \hline
\end{tabular}
}
\caption {Dependent variables that can be set in a primary lattice file.}
\label{t:dep_except}
\end{table}

The normal attribute used to vary the strength of, say, a
\vn{quadrupole} is \vn{k1}.  It is sometimes convenient to be able to
vary the magnetic field strength directly instead. To do this \bmad has
a rule that if the appropriate field attribute appears with non-zero value in the
primary lattice file then it becomes a independent variable and the strength attribute
becomes a dependent variable as tabulated in Table~\ref{t:dep_field}.
\begin{table}[h]
\centering {
\begin{tabular}{|l|l|l|} \hline
  {\em Element} & {\em Strength Attribute} & {\em Field Attribute} \\ \hline
  \vnec{Sbend}, \vnec{Rbend} &   \vnea{g}      &  \vnea{b_field}       \\ \hline
  \vnec{Solenoid}           &   \vnea{ks}     &  \vnea{b_field}       \\ \hline
  \vnec{Quadrupole}         &   \vnea{k1}     &  \vnea{b_gradient}    \\ \hline
  \vnec{Sextupole}          &   \vnea{k2}     &  \vnea{b_gradient}    \\ \hline
  \vnec{Octupole}           &   \vnea{k3}     &  \vnea{b_gradient}    \\ \hline
\end{tabular}
}
\caption {Field and Strength Attributes.}
\label{t:dep_field}
\end{table}

%-----------------------------------------------------------------
\section{Type, Alias and Descrip Attributes}
\label{s:string}
\index{Element attribute!type|textbf}
\index{Element attribute!alias|textbf}
\index{Element attribute!descrip|textbf}

\vn{type}, \vn{alias}, and \vn{descrip} are labels to be attached 
to an element. \bmad routines do not use these labels except 
when printing element information. \vn{type}
and \vn{Alias} can be up to 16 characters in length and \vn{descrip}
can be up to 200 characters. The attribute strings can be enclosed in
double quotation marks ("). The attribute strings may contain
blanks. If the attribute string does not contain a blank then the
quotation marks may be omitted. In this case the first comma (,) or
the end of the line marks the end of the string. Example:
\begin{example}
  Q00W: Quad, type = "My Type", alias = Who_knows, &
                                  descrip = "Only the shadow knows"
\end{example}

%-----------------------------------------------------------------
\section{Offset, Pitch, Tilt, and Roll Attributes}
\label{s:offset}
\index{Element attribute!offset|textbf}
\index{Element attribute!pitch|textbf}
\index{Element attribute!roll|textbf}
\index{Element attribute!tilt|textbf}

There are up to 7 attributes that can offset a physical element
from the reference orbit. They are
\begin{example}
  x_offset
  y_offset
  s_offset
  x_pitch
  y_pitch
  tilt
  roll
\end{example}
The exception here is the \vnec{Pitch} element which uses these
attributes to modify the reference orbit itself.

\vn{x_offset} translates an element in the local $x$--direction
as shown in Figure~\ref{f:pitch}. Similarly, \vn{y_offset} and 
\vn{s_offset} translate an element along the local $y$ and 
$z$--directions respectively. For a bend it is assumed that
the bend angle is small and the rotation of the local reference
axes through the bend is ignored.

The \vn{x_pitch} attribute rotates an element about the $y$--axis
so that the exit face of the element is displaced in the 
$+x$--direction as shown in figure~\ref{f:pitch}. Similarly
the \vn{y_pitch} attribute rotates an element about the $x$--axis
so that the exit face of the element is displaced in the 
$+y$--direction. The rotations
are about the center of the element which is in contrast to the 
\vn{dtheta} and \vn{dphi} misalignments of \MAD which rotate
around the entrance point. In terms of rotation angle
\begin{example}
  x_pitch =  dtheta
  y_pitch = -dphi
\end{example}
In both \bmad and \mad offsets are applied before pitches.
\begin{figure}
  \centering
  \includegraphics{pitch.psfig}
  \caption{Geometry of Pitch and Offset attributes}
  \label{f:pitch}
\end{figure}

\begin{figure}
  \centering
  \includegraphics{tilt.psfig}
  \caption{Geometry of a Tilt}
  \label{f:tilt}
\end{figure}

The tilt attribute rotates the element in the $(x, y)$ plane as
shown in figure~\ref{f:tilt}. For a bend the rotation axis is the
$z$-axis at the entrance face. The reference orbit is also rotated
with the element. A bend with a tilt of $\pi/2$ will bend a beam
upward vertically. The \vn{hkick} and \vn{vkick} attributes are
not affected by \vn{tilt} except for \vn{Kicker} and \vn{ElSeparator}
elements
Like MAD, \bmad allows the use of the \vn{tilt} attribute without
a value to designate a skew element. For example
\begin{example}
  q1: quad, l = 0.6, x_offset = 0.03, y_pitch = 0.001, tilt
\end{example}
Default tilts can be used for \vn{rbend}, \vn{sbend}, \vn{sol_quad},
\vn{quadrupole}, \vn{sextupole}, and \vn{octupole} elements.
The default tilt is $\pi/n$ where $n$ is the number of poles of the
element (bends have 2, quadrupoles have 4, etc.) 


The \vn{roll} attribute is only used for bends
and rotates the bend, along an axis that runs through the entrance
point and exit point as shown in figure~\ref{f:roll}. A \vn{roll} 
does not affect the reference orbit. The major effect of a \vn{roll}
is to give a vertical kick to the beam.
\begin{figure}
  \centering
  \includegraphics{roll.psfig}
  \caption{Geometry of a Roll}
  \label{f:roll}
\end{figure}


%-----------------------------------------------------------------
\section{Hkick, Vkick, and Kick Attributes}
\label{s:kick}
\index{Element attribute!hkick|textbf}
\index{Element attribute!vkick|textbf}
\index{Element attribute!kick|textbf}

\vn{kick}, \vn{hkick}, and \vn{vkick} attributes are the integrated
kick of an element in radians. \vn{kick} is only used for \vnec{Hkicker}
and \vn{Vkicker} elements. All other elements that can kick use 
\vn{hkick} and \vn{vkick}. The \vn{tilt} attribute will only rotate
a kick for \vnec{Hkicker}, \vnec{Vkicker}, \vnec{Elseparator} and \vnec{Kicker}
elements. This rule was implemented so that, for example, the 
\vn{hkick} attribute for a skew quadrupole
would represent a horizontal steering.

%-----------------------------------------------------------------
\section{Aperture and Limit Attributes}
\label{s:limit}
\index{Element attribute!aperture|textbf}
\index{Element attribute!limit|textbf}
\index{Element attribute!aperture_at|textbf}

\begin{figure}
  \centering
  \includegraphics{apertures.psfig}
  \caption{Apertures for ecollimator and rcollimator elements}
  \label{f:limit}
\end{figure}

\vn{x_limit}, \vn{y_limit} specify the half--width of the aperture of
an element as shown in figure~\ref{f:limit}. Notice that an \vnec{Ecollimator}
has a elliptical aperture while a \vnec{Rcollimator} and all other elements
have rectangular apertures. A zero \vn{x_limit} or
\vn{y_limit} is interpreted as no aperture in the $x$ or $y$
direction. \vn{x_offset} and \vn{y_offset} move the aperture but not
pitches or tilts.

An \vn{aperture} attribute supersedes
any \vn{x_limit} and \vn{y_limit} values and sets \vn{x_limit} and
\vn{y_limit} equal to the value of \vn{aperture}.

\index{Element!entrance end}
\index{Element!exit end}
\index{Tracking!apertures}
By default the aperture is evaluated at the exit face only of the
element. This can be changed by setting the \vn{aperture_at} attribute.
Possible settings for \vn{aperture_at} are:
\begin{example}
  entrance_end
  exit_end  ! default
  both_ends
\end{example}
Note that the entrance and exit ends of an element are independent of
which direction particles are tracked through an element. Thus if a
particle is tracked backwards it enters an element at the ``exit end''
and exits at the ``entrance end''.

Example:
\begin{example}
  q1: quad, l = 0.6
  q1[x_limit] = 0.03
  q1[y_limit] = 0.03
  q1[aperture] = 0.03  ! equivalent to the proceeding 2 lines.  
  q1[aperture_at] = both_ends
\end{example}

%-----------------------------------------------------------------
\section{Transfer Maps via Integration}
\label{s:integ}
\index{Transfer map}

One way to create a transfer map through an element is to divide the
element up into slices and then to propagate the transfer map slice by
slice.  There are several ways to do this integration. The \vntm{Boris} and
\vntm{Runge_Kutta} methods integrate the equations of motion to give the
0\Th order Taylor map which just represents a particle's orbit.  Symplectic
integration\index{Symplectic!integration}
using Lie algebraic techniques, on the other hand, can
generate Taylor maps to any order.  The \vnea{num_steps} attribute determines
the number of slices. This is applicable to \vn{Boris},
\vntm{Symp_Lie_Bmad}, and \vntm{Symp_Lie_PTC} integration.

\vnea{integration_ord} is the order of the integration formula for 
\vn{Symp_Lie_PTC}. Possible values are
\begin{example}
  integration_ord = 2 (default), 4, or 6
\end{example}
Essentially, an integration order of $n$ means that the error in an 
integration step scales as $dz^{n+1}$ where $dz$ is the slice thickness.
For a given number of steps a higher order will give more accurate results
but a higher order integrator will take more time per step. It turns out
that for wigglers, after adjusting \vnea{num_steps} for a given accuracy, 
the order 2 integrator is the fastest. This is not surprising given the
highly nonlinear nature of a wiggler. Note that \vntm{Symp_Lie_Bmad} always
uses a order 2 integrator.

\vntm{Adaptive_Boris} and \vntm{Runge_Kutta} use adaptive step
control independent of \vnea{num_steps}. These methods use the \vnea{rel_tol} and
\vnea{abs_tol} attributes to try to keep the estimated error of the integration
such that
\begin{example}
  error < abs_tol + |orbit| * rel_tol
\end{example}
lowering the error bounds makes for greater accuracy (as long as round-off 
doesn't hurt) but for slower tracking. 

\vntm{Boris}, \vntm{Adaptive_Boris}, and \vntm{Runge_Kutta} tracking all use
as input the electric and magnetic fields of an element. How the EM fields
are calculated is determined by the \vnea{field_calc} attribute for an element.
Possible values for \vn{field_calc} are:
\begin{example}
  Bmad_Standard     ! This is the default
  Custom
\end{example}
\vnec{Custom} means that the field calculations are done outside of the
\bmad software. A program doing \vnec{Custom} field calculations will
need the appropriate custom routine. See \S\ref{s:custom_field} for more
details.

\vntm{Boris} (Both \vn{Boris} and \vntm{Adaptive_Boris}) tracking does not
assume that a particle is relativistic so \vn{Boris} tracking can be
used with non--relativistic particles. The phase space coordinates
used in \vn{Boris} tracking are not the usual \bmad coordinates Rather
what is used is
\begin{example}
    (x, p_x/p_0, y, p_y/p_0, s-ct, dE/(cP_0))
\end{example}
At high energy $s-ct = z$ which is the distance of the particle from the 
reference particle and $cP_0 = vE_0/C = E_0$ so that $dE/cP_0 = dE/E$ giving
the standard \bmad coordinates.


%-----------------------------------------------------------------
\section{Length Attributes}
\label{s:l}

\vnea{l} is, for all elements except \vnec{Rbend}s, the path length 
of the reference particle.
Note that for \vnec{Wiggler}s this is not the same as the path length for
a particle with the reference energy starting on the reference orbit.

%-----------------------------------------------------------------
\section{Symplectify Attribute}
\label{s:symp}
\index{Element attribute!symplectify}

A linear transport matrix may be non--symplectic for a number of reasons.
For example, the linear matrix that comes from expanding a Taylor Map
around any point that is not the origin of the map is generally not 
symplectic. The transfer matrix for an element can be symplectified by
setting the \vn{symplectify} attribute to True. See section \ref{s:symp_method}
for details on how a matrix is symplectified. The default value of \vn{symplectify} 
if it is not present is \vn{False}. If it is present without a value then
it defaults to true. Examples:
\begin{example}
  s1: sextupole, l = 0.34                       ! symplectify = False
  s1: sextupole, symplectify = True, l = 0.34   ! symplectify = True
  s1: sextupole, symplectify, l = 0.34          ! symplectify = True
\end{example}

%-----------------------------------------------------------------
\section{Is\_on Attribute}
\label{s:is_on}

The \vnea{is_on} attribute is used to turn an element off. Turning
an element off essentially converts it into a drift. This is not
generally used in a lattice file but a program can use the attribute
for, say, calculating the Twiss parameters which needs to be done
with the RF cavities off. Example
\begin{example}
  q1: quad, l = 0.6, k1 = 0.95
  q1[is_on] = False
\end{example}
Note: \vn{is_on} does not affect any apertures that are set.