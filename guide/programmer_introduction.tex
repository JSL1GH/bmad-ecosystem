\chapter{Introduction to BMAD programming}
\label{c:program_info}

Routine calculations like tracking and Twiss parameter can be fairly
simple using \bmad\. To get the general feel for things before
getting into the nitty--gritty details in subsequent chapters, this
chapter analyzes a simple program.

%-----------------------------------------------------------------------------
\section{A First Program}

Consider the simple test program shown in Figure~\ref{f:program}.
This program is provided with the \bmad distribution, in a file called
\vn{test.f90} which is in a directory called \vn{simple_program}

\begin{figure}
\begin{listing}{1}
program test

  use bmad                 ! Define the structures we need to know about.
  implicit none
  type (ring_struct) ring  ! This structure holds the lattice info
  integer i, ix
  character(200) lat_file

! Read in a lattice and print info on the first 11 elements

  lat_file = "bmad_test.lat"
  call bmad_parser (lat_file, ring)    ! Read in a lattice.
  call twiss_at_start (ring)           ! Calculate starting Twiss params.
  call twiss_propagate_all (ring)      ! Propagate Twiss parameters
  print *, ' Ix  Name              Ele_type                   S      Beta_x'
  do i = 0, 10
    print '(i4, 2x, a, 2x, a, 2f12.4)', i, ring%ele_(i)%name, &
                    key_name(ring%ele_(i)%key), &
                    ring%ele_(i)%s, ring%ele_(i)%x%beta
  enddo

! Find the CLEO_SOL element and print information on it.

  do ix = 1, ring%n_ele_max
    if (ring%ele_(ix)%name == 'CLEO_SOL') then
      print *
      print *, '!---------------------------------------------------------'
      print *, '! Information on element: CLEO_SOL', ix
      print *
      call type_ele (ring%ele_(ix), .false., 0, .false., 0, .true., ring)
    endif
  enddo

end program
\end{listing}
\caption{A simple first program}
\label{f:program}
\end{figure}

Compiling and linking the program uses the \vn{gmake} command (the
following assumes that you are in the correct directory and that the
appropriate system logicals have been setup). The linker makes two
executable versions of the program and these are found in \vn{../bin}.
In this case, since there is only one program file in the directory, and
since a simple \vn{gmake} command was used, the executable files are
named after the directory and are \vn{../bin/simple_program} and
\vn{../bin/simple_program_g}. The former program is the regular 
distribution executable. The latter program is a debug version
which can be used with a debugger but whose execution time is longer.

Running the program with the command \vn{../bin/simple_program}
gives the output as shown in Figure~\ref{f:output}.

\begin{figure}
\begin{listing}{1}
  Ix  Name              Ele_type                   S      Beta_x
   0  BEGINNING         INIT_ELEMENT          0.0000      0.9381
   1  IP_L0             MARKER                0.0000      0.9381
   2  CLEO_SOL\3        SOLENOID              0.6223      1.3500
   3  DET_00W           MARKER                0.6223      1.3500
   4  CLEO_SOL\4        SOLENOID              0.6380      1.3710
   5  Q00W\CLEO_SOL     SOL_QUAD              1.7550      7.8619
   6  Q00W\             QUADRUPOLE            2.1628     16.2350
   7  D003              DRIFT                 2.4934     27.4986
   8  DET_01W           MARKER                2.4934     27.4986
   9  D004              DRIFT                 2.9240     46.6018
  10  Q01W              QUADRUPOLE            3.8740     68.1771

 !---------------------------------------------------------
 ! Information on element: CLEO_SOL 871

  Element Name: CLEO_SOL
  Key: SOLENOID
  Attribute values [Only non-zero values shown]:
      1   L                =  3.51000E+00
      7   KS               = -8.50234E-02
     31   BEAM_ENERGY      =  5.28900E+09
     34   B_FIELD          = -1.50000E+00
  S:       1.7550

  Tracking_method:  BMAD_Standard
  Mat6_calc_method: BMAD_Standard
  Field_calc:       BMAD_Standard
  Integration_ord:    2
  Num_steps:          1
  Symplectify:        F

  Control_type: SUPER_LORD
  Slaves: Number:   6
      Name            Ring_index  Attribute       Coefficient
      Q00E\CLEO_SOL          865  --------          3.182E-01
      CLEO_SOL\1             866  --------          4.460E-03
      CLEO_SOL\2             868  --------          1.773E-01
      CLEO_SOL\3               2  --------          1.773E-01
      CLEO_SOL\4               4  --------          4.460E-03
      Q00W\CLEO_SOL            5  --------          3.182E-01
\end{listing}
\caption{Output from a simple first program}
\label{f:output}
\end{figure}

%-----------------------------------------------------------------------------
\section{Explanation of the Simple\_Program}

A line by line explanation of the simple test program follows.  As
always use \vn{getf} to get full information on the routines and
structures used by the program. The \cs{use bmad} statement at line 3
defines the \bmad\ structures (types) and defines the interfaces
(argument lists) for the \bmad\ subroutines. In particular, the
\tn{ring_struct} structure (line 5) holds all of the lattice
information: The list of elements, their attributes,
etc. \rn{bmad_parser} (line 12) is the routine which parses a lattice
file and transfers the information to a
\tn{ring_struct} variable.

After \rn{bmad_parser} (line 12) is called the program uses the
routine \rn{twiss_at_start} (line 13) to multiply the transfer
matrices of the individual elements together to form the 1--turn
matrix from the start of the ring back to the start. From this matrix
\rn{twiss_at_start} calculates the Twiss parameters at the start of
the lattice and puts the information into the \vn{ring} variable. The
next call, to \rn{twiss_propagate_all} (line 14), takes the starting
Twiss parameters and, using the transfer matrices of the individual
elements, calculates the Twiss parameters at all the elements. Again
the results of the calculation are stored in \vn{ring}. 

The program is now ready to print out the results of the calculation
which it does on lines 16 through 20 of the program and lines 1 through 12
of the output. \vn{ring} has within it an array
\vn{ring%ele_(0:)}.  Each element of the array holds the information
about an individual element as explained in
Chapter~\ref{c:ele_struct}. \vn{ring%ele_(0)} is basically a marker
element to denote the beginning of the array. \vn{ring%ele_(i)%key} is
an integer denoting what type of element (quadrupole, wiggler, etc.)
it is. \vn{key_name} is an array that translates the key of an element
to a string. \vn{ring%ele_(i)%s} is the longitudinal position at the
exit end of the i\Th\ element. \vn{ring%ele_(i)%x%beta} is the
$a$--mode (nearly horizontal mode) beta.

The next section of the program, lines 24 through 32, looks for an
element with the name \vn{CLEO_SOL} and when it finds it the program
calls \vn{type_ele} to type out the element's attributes and other
information as shown on lines 14 through 41 of the Output (more on this later).

This brings us to the lattice file used for the input to the program.
The name of the lattice file is 
  \begin{example}
  bmad_test.lat
  \end{example} 
if you look at this file you will find a call to another file
  \begin{example}
  call, file=bmad_test.layout
  \end{example}
It is in this second file
that the layout of the lattice is defined. In particular, the \vn{line} used
to define the element order looks like
\begin{example}
  cesr: line = (IP_L0, d001, DET_00W, d002, Q00W, d003, ...
\end{example}
If you compare this to the listing of the elements in
Figure~\ref{f:output} you will find differences. For example, element
\#2 in the program listing is named \vn{CLEO_SOL\\3}. From the
definition of the \vn{cesr} line this should be \vn{d001} which, if
you look up its definition in \vn{bmad_test.layout} is a drift.  The
answer comes when you look at the definition of the \vn{CLEO_SOL}
element which appears in \vn{bmad_test.lat}
\begin{example}
  ks_solenoid    := -1.0e-9 * clight * solenoid_tesla / beam[energy]
  cleo_sol: solenoid, l = 3.51, ks = ks_solenoid, superimpose 
\end{example}
The solenoid is 3.51 meters long and it is superimposed upon the
lattice with its center as $s = 0$ by default. When \vn{bmad_parser}
constructs the lattice list of elements the superposition of
\vn{IP_L0} which is a zero--length marker with a solenoid leaves a
zero--length marker. The superposition of the \vn{d001} drift with the
solenoid gives a solenoid with the same length as the drift. Since
this is a ``new'' element \vn{bmad_parser} makes up a name that
reflects that it is basically a section of the solenoid it came from.
Since the \vn{CLEO_SOL} element only covers part of the \vn{Q00W} quadrupole
\vn{bmad_parser} breaks the quadrupole into two pieces. One piece that
is inside the solenoid is a \vn{sol_quad} and the piece outside the
solenoid is a regular quadrupole. See Section~\ref{s:super} for more
details. Since the center of the \vn{CLEO_SOL} is a $s = 0$ half of it
extends to negative $s$. In this situation \vn{bmad_parser} will wrap
this half back and superimpose it on the elements at the end of the lattice
list near $s = s_{lat}$ where $s_{lat}$ is the length of the lattice.
As explained in Chapter~\ref{c:ring_struct} the
lattice list that is used for tracking extends from \vn{ring%ele_(0)} through
\vn{ring%ele_(n)} where \vn{n = ring%n_ele_use}. The \vn{CLEO_SOL} element 
is put in the section of \vn{ring%ele_(n)} with \vn{n >
ring%n_ele_use} since it is not an element to be tracked through. The
\vn{Q00W} quadrupole also gets put in this part of the list.  The
bookkeeping information that the \vn{cleo_sol\\3} element is derived
from the \vn{cleo_sol} is put in the \vn{cleo_sol} element as shown in
lines 33 through 41 of the output.  It is now possible in the program
to vary, say, the strength of the \vn{ks} attribute of the
\vn{CLEO_SOL} and have the \vn{ks} attributes of the dependent
(``\vn{super_slave}'') elements updated with one subroutine call. For
example:
  \begin{example}
  ring%ele_(871)%value(ks$) = ring%ele_(871)%value(ks$) * 1.01 
  call control_bookkeeper (ring, 871)
  \end{example}
\bmad\ takes care of the bookkeeping. In fact \vn{control_bookkeeper} is
automatically called when transfer matrices are remade so the direct call
to \vn{control_bookkeeper} may not be necessary.

