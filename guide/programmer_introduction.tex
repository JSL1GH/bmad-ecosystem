\chapter{Introduction to BMAD programming}

\section{The BMAD Distribution}

The \bmad\ software uses other software packages. \bmad, along with
the packages it uses, is bundled together to form what is called the
CESR distribution. The CESR distribution also includes example lattice
files and example programs. The CESR distribution includes a
customized version of the Numerical Recipes Fortran90 software
library\cite{b:nr}. It is the obligation of anyone who uses \bmad\ to
make sure that they have the appropriate license for Numerical
Recipes.

Also included in the distribution is the PGPLOT plotting package
developed by Tim Pearson of Caltech.  PGPLOT is freely available for
non-commercial use. Note, however, that PGPLOT is not public--domain
software and is copyrighted by the California Institute of Technology
further documentation can be found at
\begin{example}
    http://www.astro.caltech.edu/~tjp/pgplot
\end{example}
The advantage of PGPLOT is that it provides a set of
device--independent plotting routines making it very flexible and
portable. To simplify the interface, a set of wrapper subroutines
called Quick\_Plot are included in the CESR distribution. This is
discussed later.

The other package used by \bmad\ is FPP/PTC written by Etienne
Forest. This software can do various differential and lie algebraic
operations as well as truncated power series algebra. further
documentation can be found at
\begin{example}
    http://bc1.lbl.gov/CBP_pages/educational/TPSA_DA/Introduction.html
\end{example}

%-----------------------------------------------------------------------------
\section{A First Program}

Let us start with a simple test program that is provided with the
\bmad\ distribution. The test program, shown in figure~\ref{f:program}
is in a file called
\vn{test.f90} and is in a directory called \vn{simple_program}

\begin{figure}
\begin{verbatim}
program test

  use bmad                 ! Define the structures we need to know about.
  implicit none
  type (ring_struct) ring  ! This structure holds the lattice info
  integer i, ix
  character(200) lat_file

! Read in a lattice and print info on the first 11 elements

  lat_file = "../bmad/lat/bmad_L9A18A000-_MOVEREC.lat"
  call bmad_parser (lat_file, ring)    ! Read in a lattice.
  call twiss_at_start (ring)           ! Calculate starting Twiss params.
  call twiss_propagate_all (ring)      ! Propagate Twiss parameters
  print *, ' Ix  Name              Ele_type                   S      Beta_x'
  do i = 0, 10
    print '(i4, 2x, a, 2x, a, 2f12.4)', i, ring%ele_(i)%name, &
                    key_name(ring%ele_(i)%key), &
                    ring%ele_(i)%s, ring%ele_(i)%x%beta
  enddo

! Find the CLEO_SOL element and print information on it.

  do ix = 1, ring%n_ele_max
    if (ring%ele_(ix)%name == 'CLEO_SOL') then
      print *
      print *, '!---------------------------------------------------------'
      print *, '! Information on element: CLEO_SOL', ix
      print *
      call type_ele (ring%ele_(ix), .false., 0, .false., 0, .true., ring)
    endif
  enddo

end program
\end{verbatim}
\caption{A simple first program}
\label{f:program}
\end{figure}

Compiling and linking the program uses the \vn{gmake} command (the
following assumes that you are in the correct directory and that the
appropriate system logicals have been setup). The linker makes two
executable versions of the program and these are found in \vn{../bin}.
In this case, since there is only one program file in the directory, and
since a simple \vn{gmake} command was used, the executable files are
named after the directory and are \vn{../bin/simple_program} and
\vn{../bin/simple_program_g}. The latter program is a debug version
which can be used with a debugger but whose execution time is longer.

running the program with the command \vn{../bin/simple_program}
gives the output as shown in figure~\ref{f:output}

\begin{figure}
\begin{verbatim}
  Ix  Name              Ele_type                   S      Beta_x
   0  BEGINNING         INIT_ELEMENT          0.0000      0.9381
   1  IP_L0             MARKER                0.0000      0.9381
   2  CLEO_SOL\3        SOLENOID              0.6223      1.3500
   3  DET_00W           MARKER                0.6223      1.3500
   4  CLEO_SOL\4        SOLENOID              0.6380      1.3710
   5  Q00W\CLEO_SOL     SOL_QUAD              1.7550      7.8619
   6  Q00W\             QUADRUPOLE            2.1628     16.2350
   7  D003              DRIFT                 2.4934     27.4986
   8  DET_01W           MARKER                2.4934     27.4986
   9  D004              DRIFT                 2.9240     46.6018
  10  Q01W              QUADRUPOLE            3.8740     68.1771

 !---------------------------------------------------------
 ! Information on element: CLEO_SOL 871

  Element Name: CLEO_SOL
  Key: SOLENOID
  Attribute values [Only non-zero values shown]:
      1   L                =  3.51000E+00
      7   KS               = -8.50234E-02
     31   BEAM_ENERGY      =  5.28900E+09
     34   B_FIELD          = -1.50000E+00
  S:       1.7550

  Tracking_method:  BMAD_Standard
  Mat6_calc_method: BMAD_Standard
  Field_calc:       BMAD_Standard
  Integration_ord:    2
  Num_steps:          1
  Symplectify:        F

  Control_type: SUPER_LORD
  Slaves: Number:   6
      Name            Ring_index  Attribute       Coefficient
      Q00E\CLEO_SOL          865  --------          3.182E-01
      CLEO_SOL\1             866  --------          4.460E-03
      CLEO_SOL\2             868  --------          1.773E-01
      CLEO_SOL\3               2  --------          1.773E-01
      CLEO_SOL\4               4  --------          4.460E-03
      Q00W\CLEO_SOL            5  --------          3.182E-01
\end{verbatim}
\caption{Output from a simple first program}
\label{f:output}
\end{figure}

%-----------------------------------------------------------------------------
\section{Getf and Listf}
\label{s:getf}

As can be seen there is a lot going on behind the scenes even for this
simple program. This shows that programming with \bmad\ can be both easy
and hard. Easy in the sense that a lot can be done with just a few
lines. The hard part comes about since there are many details that
have to be kept in mind in order to make sure that the subroutines
are calculating what you want them to calculate.

To help with the details all \bmad\ subroutines have in their source (.f90)
files a comment block that explains the arguments needed by the
subroutines and explains what the subroutine does. To help quickly
access these comments there are two perl scripts that are supplied
with the \bmad\ distribution that are invoked with the commands
\cmd{listf} and \cmd{getf}.

The \cmd{getf} command is used to locate routines and structures.
and to type out information on them
The form of the command is
\begin{verbatim}
    getf <name>
\end{verbatim}
This searches for any routine or structure with the name
\vn{<name>}. \vn{<name>} may contain the wild--cards ``*'' and ``\%'' where
``*'' matches to any number of characters and ``\%'' matches to any
single character. For example:
\begin{verbatim}
    getf bmad_parser
    getf ring_struct
    getf twiss_at_%
\end{verbatim}
The third line in this example will match to the routine \rn{twiss_at_s} but not
the routine \rn{twiss_at_start}.

The \cmd{listf} command is like the \cmd{getf} command except that only
the file name where a routine or structure is found is printed. The
header comments that are in the source code files and the structure
definitions will not be printed. The \cmd{listf} command is useful if you
want to just find out where a routine or structure definition lives.

The way \vn{getf} and \vn{listf} work is that they search a list of
directories to find the \bmad\, \vn{dcslib}, and \vn{cesr_utils}
libraries. Currently the other libraries, the ones not developed at cornell,
in the CESR distribution are not searched. This is primarily due to 
the fact that, to save time, \vn{getf} and \vn{listf} make assumptions
about file layout that the other libraries violate. This may change is there
is a demand for it.

%-----------------------------------------------------------------------------
\section{Explanation of the Simple\_Program}

A line by line explanation of the simple test program follows. It is
assumed that you are familiar with Fortran90.  The \cs{use bmad}
statement defines the \bmad\ structures (types) and defines the
interfaces (argument lists) for the \bmad\ subroutines. In particular,
the \tn{ring_struct} structure holds all the lattice information: The
list of elements, their attributes, etc. \rn{bmad_parser} is the
routine to parse a particular lattice file and transfer the
information to a \tn{ring_struct}. 

After \rn{bmad_parser} is called the program uses the routine
\rn{twiss_at_start} to multiply the transfer matrices of the individual
elements together to form the 1--turn matrix from the start of the ring
back to the start. From this matrix \rn{twiss_at_start} calculates the
Twiss parameters at the start of the lattice. The next call to
\rn{twiss_propagate_all} takes the starting Twiss parameters and using
the transfer matrices of the individual elements calculates the Twiss
parameters at all the elements. We are now ready for the print out the
calculation. \vn{ring} has within it an array \vn{ring%ele_(0:)} that
contains the information on each individual element. \vn{ring%ele_(0)}
is basically a marker element to denote the beginning of the array.
\vn{ring%ele_(i)%key} is an integer denoting what type of element
(quadrupole, wiggler, etc.) it is. \vn{ring%ele_(i)%s} is the
longitudinal position at the end of an element. \vn{ring%ele_(i)%x%beta}
is the $a$--mode (nearly horizontal mode) beta.

The next section of the program looks for an element with the name \vn{CLEO_SOL}
and when it is finds the program calls \vn{type_ele} to type out the element's 
attributes and other information. 

This brings us to the programs output.
The lattice file used by the example program is 
\begin{example}
  ../bmad/lat/bmad_L9A18A000-_MOVEREC.lat
\end{example} 
This file calls another file
\begin{example}
  ../bmad/layout/bmad_CESR_RECMOVE.layout
\end{example}
It is in this second file
that the layout of the lattice is defined. In particular the \vn{line} used
to define the layout look like
\begin{example}
  cesr: line = (IP_L0, d001, DET_00W, d002, Q00W, d003, ...
\end{example}
No sign of a solenoid here. The solenoid \vn{CLEO_SOL} is defined in
the first lattice file and is superimposed upon
the lattice. The definition of \vn{CLEO_SOL} from the lattice file is
\begin{example}
  ks_solenoid    := -1.0e-9 * clight * solenoid_tesla / beam[energy]
  cleo_sol: solenoid, l = 3.51, ks = ks_solenoid, superimpose 
\end{example}
The solenoid is 3.51 meters long and it is superimposed upon the lattice
with its center as $s = 0$ by default. This means that half of the
solenoid wraps around to the end of the lattice list. \vn{bmad_parser}
constructs the appropriate lattice list that it track through and stores
the \vn{CLEO_SOL} element in the part of the lattice list that doesn't
get tracked through (along with elements \vn{Q00E} and \vn{Q00W}) as
explained in Section~\ref{s:super}. It is now possible for the program
to vary, say, the strength of the \vn{ks} attribute of the \vn{CLEO_SOL}
and have the \vn{ks} attributes of the dependent (``\vn{super_slave}'')
elements updated with one subroutine call. This kind of element controlling
other elements will be covered in later chapters and is a very useful
feature of \bmad.

%-----------------------------------------------------------------------------
\section{Programming Conventions}

\bmad\ subroutines follow the following conventions:

\begin{description}

\item[\$ Denotes Parameter] A ``\$'' at the end of a name denotes an 
integer parameter. For example, in the above program, to check
whether an element is a quadrupole one would write:
\begin{verbatim}
  if (ring%ele_(i)%key == quadrupole$) ...
\end{verbatim}
Checking the source code one would find in the module \tn{bmad_struct}
\begin{verbatim}
  integer, parameter :: drift$ = 1, sbend$ = 2, quadrupole$ = 3, group$ = 4
\end{verbatim}
One should always use the parameter name instead of the integer it represents.
That is, one should never write
\begin{verbatim}
  if (ring%ele_(i)%key == 3) ...  ! DO NOT DO THIS!
\end{verbatim}
For one, using the name makes the code clearer. However, more
importantly, the integer value of the parameters may at times be
shuffled for paractical internal reasons. The use of the integer value
could thus lead to disastrous results.  

\item[ Type names have a \_struct suffix]. 
For example: \tn{ring_struct}, \tn{ele_struct}, etc. Structures without a 
\tn{_struct} are inevitably part of Etienne's PTC package.

\end{description}
