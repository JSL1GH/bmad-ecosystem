#!/home/cesrulib/EXT/Python-2.5.1/Linux/python
#-*-python-*-  ###############################
# Runs once a minute via cron, determines
# if any fix-build control files exist in the
# Fixes/control area.
# 
# Checks ownership of any control files
# against list of users who are
# permitted to spawn builds.
#
# If the owner is allowed, this will parse
# the file, and then spawn appropriate builds
# across each supported platform area in the
# Fixes directory.
##############################################

import os, sys, string, shutil, time, sets, ConfigParser
import subprocess as sub
#============================================================================
# Set up Configuration Parser
#============================================================================
cfg_file = "/home/cesrulib/bin/util/BUILD_SYSTEM.conf"
config   = ConfigParser.ConfigParser()
config.optionxform = lambda x: x   # <-Obtain values without changing case --
config.read(cfg_file)              #  overrides default ConfigParser behavior

#=== Paths ==================================================================
util_dir    = config.get("Paths", "UTIL_DIR")
repository  = config.get("Repository", "path")
src_url     = config.get("Repository", "URL") + "trunk/src/"
hooks_dir   = repository + "/hooks"
fixes_root  = config.get("Paths", "FIXES_DIR")
ctrl_dir    = fixes_root + "/control"
staging_dir = fixes_root + "/staging"

#=== Support Scripts ========================================================
master      = util_dir + '/' + config.get("Scripts", "master")

#============================================================================
# External module search path set up and importation
#============================================================================
sys.path.append( util_dir + "/3rd-party")
from standout import StandOut    # StandOut module is for advanced logging capabilities.

sys.path.append( hooks_dir )
import email_list_gen            # Local custom script for authorization
                                 # file querying.

#============================================================================
#   VARIABLE SETUP
#============================================================================
platforms  = {} # Dictionary holding platform names and build host names.
for plat in config.options("Platforms"):
    if config.get("Platforms", plat).split(",")[0].strip() == "FULL":
        host = config.get("Platforms", plat).split(",")[1].strip()
        #platforms.append( [plat, host] )
        platforms[plat] = host

#===================
# Support functions
#===================
def is_valid_module(module):
    line = os.popen("svn info " + src_url + module).readline()
    if line[0:4] == "Path":
        return True
    else:
        return False

def is_valid_user(username):
    uchk_cmd = "ypcat passwd | grep " + username
    uchk = sub.Popen( uchk_cmd, shell=True, stdout=sub.PIPE, stderr=sub.STDOUT )
    (outstream, errstream) = uchk.communicate()
    uchkval = uchk.wait()
    if uchkval == 0:
        return True
    else:
        return False

#============================================================================
# Main section
#============================================================================
dirlist = os.listdir( ctrl_dir )
# For every file that happens to exist in the control directory
for file in dirlist:
    origname = ctrl_dir + "/" + file
    fullname = origname
    statinfo = os.stat( ctrl_dir + "/" + file )
    user     = file.split("-")[0]
    adds     = []  # To hold list of addresses made from all usernames in all requested modules
    addstring = "" # To hold string version of the above, for mail command line purposes
    statuid  = statinfo.st_uid
    statuid  = int(statuid)
    textuid  = os.popen( "id -u " + user ).readline().strip()
    textuid  = int(textuid)

    nameline = os.popen("finger " + user).readline()
    Fullname = nameline.split(":")[2].strip()
    Name     = nameline.split(":")[2].split()[0]

    # If the file hasn't already been parsed for build initiation,
    if file[-8:] != "BUILDING" and file[-5:] != "ERROR" and file[-8:] and file[-6:] != "NOAUTH" and file[-8:] != "CHECKING":
        print time.asctime()
        if textuid != statuid:
            print "Problem authenticating user ", Fullname, " ("+user+")."
            newname = origname + "_ERROR"
            os.rename( fullname, newname )
            fullname = newname
            sys.exit(1)
        else:
            print "Dead drop authenticated."
            print "A FIXES build was requested by " + Fullname +" ("+user+").\n"

            f = open(fullname, 'r')
            line = f.readline()
            f.close()
            newname = origname + "_CHECKING"
            os.rename( fullname, newname )
            fullname = newname
            llist     = line.split(";")
            modules   = llist[0].strip().split(":")
            tmp_aux_users = llist[1].strip().split(":")
            
            
            print "Verifying requests..."
            for module in modules:
                module = module.strip()
                if is_valid_module(module):
                    print module + " is valid"
                    tmpadds = email_list_gen.get_email_list( "/trunk/src/"+module )
                    for address in tmpadds:
                        if address not in adds:
                            adds.append(address)
                else:
                    print "Module existence could not be verified."
                    newname = origname + "_ERROR"
                    os.rename( fullname, newname )
                    fullname = newname
                    sys.exit(3)
            print "All modules verified.\n"


            print "Verifying supplemental notification list..."
            aux_users = list(sets.Set(tmp_aux_users)) #Remove duplicate entries
            for aux_user in aux_users:
                aux_user = aux_user.strip()
                if aux_user == "":
                    aux_users.remove( aux_user )
                    continue
                if is_valid_user( aux_user ):
                    print aux_user + " is OK"
                else:
                    aux_users.remove( aux_user )
                    print "User",aux_user,"does not exist for supplemental notification.\n"
                        


            print "\nChecking for authorization..."
            for module in modules:
                module = module.strip()
                if email_list_gen.has_perms( user, module, "w" ):
                    print "Authorized for ", module
                else:
                    print "User not authorized for writes in", module
                    newname = origname + "_NOAUTH"
                    os.rename( fullname, newname )
                    fullname = newname
                    mail = os.popen("mail -s \"Fixes build request\" " + user+"@mail.lepp.cornell.edu", 'w')
                    mail.write("Hello " + Name + ",\n\n")
                    mail.write("The fixes build you requested has failed because you do not\n")
                    mail.write("have write permission in one or more of the following modules:\n\n")
                    for module in modules:
                        mail.write(module + '\n')
                    sys.exit(2)
        print "\nStarting build..."

        newname = origname + "_BUILDING"
        os.rename( fullname, newname )
        fullname = newname

        # Compose build command and spawn master build process
        bld_cmd = [ master, "-lin", "-osf", "-fixes", "FIX="+file+"_BUILDING" ]
        build = sub.Popen( bld_cmd, stdout=sub.PIPE, stderr=sub.STDOUT )
        (outstream, errstream) = build.communicate()
        bldval = build.wait()
        if bldval != 0:
            print "ERROR: Build failed."
            newname = origname + "_ERROR"
            os.rename( fullname, newname )
            fullname = newname
            # Mail just the initiating user here and inform of build failure
            # Librarian account will receive the output of this script which will show messages to that effect.
            
            sys.exit(20)
            

        print "\nAll modules built successfully."
        # Set flag file here saying that the build was successful.
        os.system("touch "+fixes_root+"/FIXES_OPERATIONAL")


        # Copy files from the staging area to the official fixes area.
        for platform in platforms:
            os.popen("rsync -avz " + staging_dir+'/'+platform+' '+ fixes_root)
        print "All files copied from staging to production area.\n"


        # Form list of unique e-mail addresses
        adds.append(user+"@mail.lepp.cornell.edu")
        for auser in aux_users:
            tmpadd = auser+"@mail.lepp.cornell.edu"
            adds.append(tmpadd)

        uniqadds = list(sets.Set(adds))  # Uniqueify the list
        for add in uniqadds:
            addstring = addstring + add + ' '
        print addstring
        #mail = os.popen("mail -s \"Fixes build request\" " + addstring, 'w')

        # Open a pipe to the mail program and
        # write the message body to the pipe.
        mail = os.popen("mail -s \"Fixes build request\" " + user+"@mail.lepp.cornell.edu", 'w')
        mail.write("Greetings!\n\n")
        s = ""
        many = False
        if len(modules) > 1:
            many = True
            s='s'
        mail.write("This is an automatically generated message to inform you that ")
        mail.write("the fixes build requested by "+ Name +" ("+user+") for the module"+s+ " ")
        for module in modules:
            if many and module != modules[-1]:
                if module == modules[-2]:
                    mail.write( module.strip() + ", and " )
                else:
                    mail.write( module.strip() + ", " )
            else:
                mail.write( module.strip() )
        #mail.write(" has completed on the platforms")
        mail.write(" has completed.\n\n")
        mail.write("To incorporate the fixes just made available into local ")
        mail.write("projects, once must use the 'FIXES=Y' flag when building code.\n\n")
        mail.write("The build system will recognize this and link against \n")
        mail.write("the new library or libraries in lieu of the official version"+s+".\n\n")
        mail.write(" -END OF LINE-")
        exitcode = mail.close()
        if exitcode:
            print "Exit code: %s" % exitcode
        else:
            print "A notification message has been sent to the development group and any supplemental users."
            os.remove(fullname)



