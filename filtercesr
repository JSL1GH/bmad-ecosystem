#!/usr/bin/perl -w

###########################################################
# ussage: ./filtercesr absrelname libname, must be run from unix
# it converts all dependancies for release to vms format.
###########################################################
# $F90_LMOD_RULE and $F90_MOD_RULE -- string variables, they define rule of the compilation
# of the modules on VMS system. 
$F90_LMOD_RULE ="\t\@\$(ECHO) \"F90_LMOD_RULE: Compiling :  \$< --> \$\@\"
\t\$(CPP) \$(CPPFLAG) \$(LIST_INCS) \$<
\t\$(FC)  \$(FFLAGS) \$(F90FLAGS) \$(LIST_INCS) \$(OFLAG) \$(notdir \$(patsubst %.f90,%.i,\$<))
\t\$(AR) \$(LIBRARY) \$(notdir \$(patsubst %.f90,%.obj,\$<))
\t\$(RM) \$(notdir \$(patsubst %.f90,%.obj,\$<));*
\t\$(RM) \$(notdir \$(patsubst %.f90,%.i,\$<));*\n";
$F90_MOD_RULE="\t\@\$(ECHO) \"F90_MOD_RULE: Compiling :  \$< --> \$\@\"
\t\$(CPP) \$(CPPFLAG) \$(LIST_INCS) \$<
\t\$(FC)  \$(FFLAGS) \$(F90FLAGS) \$(LIST_INCS) \$(OFLAG) \$(notdir \$(patsubst %.f90,%.i,\$<))
\t\$(CP) \$(notdir \$(patsubst %.f90,%.obj,\$<));* \$(locallib)
\t\$(RM) \$(notdir \$(patsubst %.f90,%.obj,\$<));*
\t\$(RM) \$(notdir \$(patsubst %.f90,%.i,\$<));*\n";

###########################################################
$absrelname=$ARGV[0];
$cvssrc="cvssrc";
$cvssrcdot="cvssrc.";
if ($absrelname=~m/packages/g){$cvssrc=""; $cvssrcdot=""}
if ($absrelname=~m/PACKAGES/g){$cvssrc=""; $cvssrcdot=""}
$libname=$ARGV[1];
print "Converting to VMS-style dependencies for $libname \n";
gendepfullname();

if ($libname eq "recipes_f-90_LEPP"){$libname="recipes_f_90_LEPP"}

else
   {}
$lib_depfile=">$libname.depvms";
open (DEPFILE,"$lib_depfile")|| die "can not open file $lib_depfile";

#system "ls -Ra $absrelname/$cvssrc/$libname | grep  '\.depend:' >> dependir.tmp";
#open (FILE01, 'dependir.tmp' )|| die "can't open file:dirdepen.tmp";

#while ($x = <FILE01>){  # for each 
#    chomp $x;
#    chop $x;
#    system "ls -Ra $x | grep  '\.d' >> depdircont.tmp";
    system "ls -Ra .depend | grep  '\.d' | grep -v ':' >> depdircont.tmp";
    open (FILE02, 'depdircont.tmp' )|| die "can't open file: depdircont.tmp";
    while ($y=<FILE02>){        # for every .d file in the .depend directory...
#	print ".depend directory file : $y \n";
#        filterf ("$x/$y");
	filterf (".depend/$y");
    }
    if ($libname ne "c_utils"){
#        filterf ("$absrelname/$cvssrc/$libname/.f90_module_rules");
	filterf ("./.f90_module_rules");
    }
    close(FILE02) || die "couldn't close file:dirdepcont.tmp";
    system "rm depdircont.tmp";
#}

#close(FILE01) || die "couldn't close file: dependir.tmp";
system "rm dirdepen.tmp";

close(DEPFILE) || die "couldn't close file: $lib_depfile";



###########################################################################
#   Subroutines follow
###########################################################################
# this subroutine converts the dependancy file content to the VMS-format
# and prints to file <DEPFILE>
# example: filterf ( vms.depend); 
# 
sub filterf { 
open (FILE0, $_[0]) || die "can't open file:$_[0]";
while (<FILE0>){
    if (/d:/){
       @words=split(/:\s*/,$_);
       @targets=split " ",$words[0];
       @prereqs= split " ",$words[1];
       rm_usr_include();
       rm_include_readline();
       rm_include_cxx();
       rm_home_packages_modules();
       rm_home_modules();
       rm_home_packages();
       take_care_of_some_variables();
       if ($#prereqs >= 0){ 
           convertP(@targets);
           print DEPFILE ": ";
           convertP(@prereqs);
           print DEPFILE "\n";
       }
   }
    elsif (/\$\(F90_LMOD_RULE\)/) {
        print DEPFILE $F90_LMOD_RULE;
    }
    elsif (/\$\(F90_MOD_RULE\)/) {
        print DEPFILE $F90_MOD_RULE;
    }
}
close(FILE0) || die "couldn't close file:$ARGV[0]";
}



#this subroutine convert's and print's the string from
#unix to vms file-format.
sub convertP {local($varP,$i,@smlist,@prereqs); 
  @prereqs=@_; 
  foreach $varP (@prereqs){
      if ($varP !~ /\// && $varP !~ /\$/ && $varP !~ /\.m/  && $varP !~ /\.o/ && $varP !~ /\.d/ ){
          print "varP  =  $varP\n";
	  print "listfilek{varP}  =  $listfilek{$varP}\n";
          print DEPFILE "$listfilek{$varP}$varP";
          next;
      }
    $varP=~ s/\.mod/\.f90\$\$mod/;
    $varP=~ s/\)\//\)/;
    $varP=~ s/\.o/\.obj/;
    if ($varP !~ /\.d/){
      if ($varP =~ /\$\(/) {print DEPFILE " $varP";}
      else{
        $varP=~ s/\B\///;
        $varP=~ s/\B\./-\./;
        $varP=~ s/\.\./-\./;
        @smlist=split(/\//,$varP);
        if ($#smlist==0){print DEPFILE$smlist[0];}
        else{
        print DEPFILE " [$smlist[0]";
        for ($i=1;$i<$#smlist;$i++){
           print DEPFILE ".", $smlist[$i];
           }   
        
        print DEPFILE "]$smlist[$#smlist]";
    }
      }
    }
  }
}


#this subroutine removes all /usr/include/* fields
sub rm_usr_include {
    local($varP,$smlist);
    foreach $varP (@prereqs){
        if ($varP =~ /\/usr\/include/){
            $varP = " ";
        }
    }
    $smlist = join " ",@prereqs;
    @prereqs =  split " " ,$smlist;
}        



#this subroutine removes all /include/readline* fields
sub rm_include_readline {
    local($varP,$smlist);
    foreach $varP (@prereqs){
        if ($varP =~ /\/include\/readline/){
            $varP = " ";
        }
    }
    $smlist = join " ",@prereqs;
    @prereqs =  split " " ,$smlist;
} 



#this subroutine removes all /include/cxx* fields
sub rm_include_cxx {
    local($varP,$smlist);
    foreach $varP (@prereqs){
        if ($varP =~ /\/include\/cxx/){
            $varP = " ";
        }
    }
    $smlist = join " ",@prereqs;
    @prereqs =  split " " ,$smlist;
} 



#this subroutine removes absolute path /home..../packages/modules/
#and chenges it to $(PKG_MOD)
sub rm_home_packages_modules {
    local($varP,$smlist);
    foreach $varP (@prereqs){
        $varP =~ s/\/home.*\/packages\/modules\//\$\(PKG_MOD\)/g;
    }
    $smlist = join " ",@prereqs;
    @prereqs =  split " " ,$smlist;
}          



#this subroutine removes absolute path /home..../modules/
#and changes it to $(MOD_OUT_DIR)
sub rm_home_modules {
    local($varP,$smlist);
    foreach $varP (@prereqs){
        $varP =~ s/\/home.*\/modules\//\$\(MOD_OUT_DIR\)/g;
    }
    $smlist = join " ",@prereqs;
    @prereqs =  split " " ,$smlist;
}
        


#this subroutine removes absolute path /home..../packages
#and changes it to $(PBASE)
#also it changes $(PBASE)/include/ to
# $(PBASE).include]
sub rm_home_packages {
    local($varP,$smlist);
    foreach $varP (@prereqs){
        $varP =~ s/\/home.*\/packages\//\$\(PBASE\)\//g;
        if ($varP =~ /\$\(PBASE\)/) {$varP =~ s/\/include\//\.include\]/};
        if ($varP =~ /\$\(PBASE\)/) {$varP =~ s/\//\./g};
    }
    $smlist = join " ",@prereqs;
    @prereqs =  split " " ,$smlist;
}



#this subroutine does the following:
#NA 1. It changes $(CESR_INC)/            to [--.include]
#NA 2.    -||-    $(CESR_MOD)/            to $(MOD_OUT_DIR)
#3.    -||-    $(CESR_PKG)/modules/    to $(PBASE).modules]
#4.    -||-    $(CESR_PKG)/cfortran/include/   $(PBASE).cfortran.include]
sub take_care_of_some_variables {
    local($varP,$smlist);
    foreach $varP (@prereqs){
#        $varP =~ s/\$\(CESR_INC\)\//\[--\.include\]/g;
#        $varP =~ s/\$\(CESR_MOD\)\//\$\(MOD_OUT_DIR\)/g;
        $varP =~ s/\$\(CESR_PKG\)\/modules\//\$\(PBASE\)\.Modules\]/g;
        $varP =~ s/\$\(CESR_PKG\)\/cfortran\/include\//\$\(PBASE\)\.cfortran\.include\]/g;
        $varP =~ s/\.\.\/c_utils\/include\//\$\(CLBASE\)\.cvssrc\.c_utils\.include\]/g;
    }
    $smlist = join " ",@prereqs;
    @prereqs =  split " " ,$smlist;
}


        
# This subroutine generates a hash listfilek with info about the exact directory
# location of all the source files in the cesr release library
# example: $listfilek{file.f90} gives vms-format directory where file.f90 lives.
sub gendepfullname {
    print "gendepfullname called\n";
#    local ($x,$snd);
    system "ls -Ra $absrelname/$cvssrc/$libname |grep ':'|grep -v CVS > subdir_list.tmp";
    open (FILE04,"subdir_list.tmp") || die "cannot open file subdir_list.tmp";
    while ($subdir = <FILE04>){           # for each subdirectory of a library dir...
        chomp($subdir);
        chop($subdir);
        $subdir=~s/.*$libname/\/$libname/g;
        system "ls  $absrelname/$cvssrc/$subdir |grep -v CVS > tmp03.tmp"; # grab a list of every file in subdir
        open (BASELIST_FILE,"tmp03.tmp") || die "cannot open file tmp03.tmp";
        while ($file = <BASELIST_FILE>){            # for each file in subdir, convert it's full name to VMS-friendly format
            chomp($file);
            $listfilek{$file}="$subdir";
            $listfilek{$file}=~s/\B\//\$(CLBASE)\.$cvssrcdot/g;		# replace 
            $listfilek{$file}=~s/\//\./g;   				# replace / with .
            $listfilek{$file}=~s/\-/\_/g;				# replace - with _ if it exists
            $listfilek{$file}=~s/\B\$\(CLBASE\)\.cvssrc\./\[--\./g;	# replace 
            $listfilek{$file}="$listfilek{$file}]$file";
#	    print "$listfilek{$file}\n";
        }
        close (BASELIST_FILE)|| die "can not close file tmp03.tmp";
    }
    system "rm tmp03.tmp";
    close (FILE04)|| die "can not close file subdir_list.tmp";
    system "rm subdir_list.tmp";
}














