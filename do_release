#!/bin/sh
#
#-------------------------------------------------------------------------
#
# This is the master script to build new code releases across the  
# supported computer systems at CLASSE.  
# 
# Supporting scripts:  - M.release makefile
#                      - build_release script to execute individual builds
#                      - test_release script to validate the functionality 
#                        of the code builds (not yet implemented)
#                      - tag_release script to tag releases in the CVS 
#                        repository 
#                            (this is taken care of by a call to
#                             the tagging routine in M.release)
#                         This standalone script does what it should though,
#                         in the event a tag not conforming to the 
#                         release tag/rotation convention is desired.
#                      - rel_disk_total script to compute disk space used
#                        to store the resulting release
#
# usage : do_release [options] [var defs] <lib_tag> <pkg_tag> [<SGL/DBL>]
#         arguments:
#          <SGL/DBL>      specify double or single precision
#                         (default is DBL)
#
#         flags:
#          -cesr          Build a cesr release
#          -pkg           Build a packages release (not capable of standalone
#                                          package production?)
#          -build_only    if you want to forgo the checkout and
#                         creation of necessary dirs, add 
#                         -build_only flag.  In this case, 
#                         <lib_tag> must contain the full name 
#                         of the release
#          -dump          Dump the configuration information for this 
#                         script
#          -tagr          Tag release in CVS after building (special cases
#                                                   implemented, see below)
#          -tagp          packages release tagging (not implemented)
#          -osf           Run OSF1 build
#          -lnx           Run Linux builds
#          -vms           Prepare release for transfer to VMS_alpha
#          -win           Automatic windows builds not yet operational
#          -nobs          Suppress periodic build-status messages
#          -ntly          Run a NIGHTLY build, rotating the library
#                          links after completion.
#          -devel         Run a DEVEL build, rotate release and apply 
#                          CVS tag consisting of the release name.
#          -curr          Run a CURRENT build, rotate release and apply 
#                          CVS tag consisting of the release name
#                          followed by "_current".
#          -test          Perform executable testing on build products,
#                          detailed results will be logged to build_status 
#                          files and summarized in the output of this script.
#          
#         variables:
#           REL=<release_name>  Specify a specific CESR release
#                               to build against.  Expects only base 
#                               directory name (NO path).
#           PKG=<packages_name> Specify a specific packages release
#                               to build against.  Expects only base 
#                               directory name (NO path).
#           TAG=<release_tag>   Specify a custom tag for the release
#                                (rename this to "LBL"? as it acts 
#                                like a release name label, not a CVS tag)
#           GMAKE=<gmake_dir>   Specify a custom CESR_GMAKE directory.
#                               Expects FULL path.
#           UTIL=<util_dir>     Specify a custom CESR_UTIL  directory
#                               to build against.  Expects FULL path.
#           BIN=<bin_dir>       Specify a custom CESR_BIN directory
#                               Expects FULL path.
#           BRANCH=<branch name> Specify the name of a branch from which
#                               to draw modules from in order to build
#                               a release.  Required modules not present 
#                               in the branch will be automatically taken
#                               from the trunk of the repository.
#
# examples: do_release -cesr PKG=packages_2003_0728_d DBL 
#           do_release -cesr -build_only cesr_yyyy_mmdd_d DBL
#
#           do_release -tagr REL=cesr_2003_0728_d DBL 
#                        #  tagging only #
#           do_release -cesr -tagr PKG=packages_2003_0728_d DBL
#                        #building  release then tagging#
#           do_release -cesr PKG=packages_2006_0228_d -devel -lnx -DBL
#                        build release, tag in CVS as a devel
#                        release and rotate filesystem links
#                        to point at this devel release 
#   do_release -cesr -dump -osf -lnx -vms -win -nobs -ntly PKG=packages_2006_0228_d DBL
#       Build release, dump lots of status info, on all platforms, suppress 
#       console messages during actual building, rotate release as nightly when done.
########################################################################################
#
# $Id$
#
# $Log$
# Revision 1.37  2007/01/03 20:29:47  cesrulib
# Finishing tweaks to get VMS preparation tasks to complete correctly.
#
# Modifications added to allow a release to be built using code from a branch.
# Code from the branch (the name of which is specified on the command line)
# replaces congruent code from the mainline and then a release is built with the
# resultant.
#
# Revision 1.36  2006/12/20 14:15:17  cesrulib
# Mostly restored to the way it was prior to VMS dependency-generation
# experimentation.
#
# Revision 1.35  2006/12/14 20:03:27  cesrulib
# Revert last change.  build_release call cannot detatch from tty because
# dependencies need to be tallied before the code tree is zipped up for
# export.
#
# Revision 1.33  2006/11/21 15:51:32  cesrulib
# Bug fixes
#
# Revision 1.32  2006/11/20 22:09:02  cesrulib
# Now allows for a completely isolated packages release to be built without
# an accompanying CESR libraries release being built at the same time.
# Changes to logging appropriate for the above adjustments
#
# Revision 1.31  2006/11/09 16:12:50  cesrulib
# Adjusted log output behavior for VMS prep job.
# Minor internal documentation tweak.
#
# Revision 1.30  2006/11/07 16:24:57  cesrulib
# Minor organizational changes.
#
# Revision 1.29  2006/10/17 12:56:34  cesrulib
# Now sends output to a general log file in the cesr_libs/log directory as well
# as to standard output (e-mail when run via cron).
#
# Revision 1.28  2006/10/13 21:15:53  cesrulib
# Implemented -test flag to perform binary testing of bmadz after a successful
# build.
# A summary of that process is provided after time and disk space summaries.
#
# Revision 1.27  2006/10/06 13:46:58  cesrulib
# Typographical correction.
#
# Revision 1.26  2006/10/04 19:49:22  cesrulib
# Added build statistics output that provides an itemized time summary of
# the builds for each architecture.
# Added disk space check to terminate script if insufficient space exists to
# accomodate the output.
#
# Revision 1.25  2006/09/27 19:37:33  cesrulib
# Aesthetic change
#
# Revision 1.24  2006/09/27 19:28:33  cesrulib
# Various minor bugfixes, cosmetics
#
# Revision 1.23  2006/09/26 20:29:04  cesrulib
# Added code to calculate the elapsed time of a build process.
# The -devel and -current flags now cause standardized tagging and
# rotation behavior.
# Added call to calculate and log disk usage of a build process.
# General cleanup
# Documentation tweaks
#
# Revision 1.22  2006/09/22 18:03:42  cesrulib
# Added ability to tag a release in CVS immediately after a successful build.
#
# Revision 1.21  2006/09/15 21:33:17  cesrulib
# Error-checking and documentation adjustments
#
# Revision 1.20  2006/09/14 18:42:04  cesrulib
# Tweaked error checking for rotation
#
# Revision 1.19  2006/09/13 17:16:57  cesrulib
# Input flag addition and tweaks.
#
# Revision 1.18  2006/09/12 19:51:08  cesrulib
# Added command-line option '-nobs' to suppress voluminous build status
# messages (useful when script's output is directed to something other
# than a tty).
#
# Revision 1.17  2006/09/12 13:24:23  cesrulib
# Added kinit incantation to allow unattended builds.
#
# Revision 1.16  2006/09/11 20:47:01  cesrulib
# Updates for new library build tree (supporting multiple compiler combinations).
#
#
################################################################

################################################################
# Set up some internal functions
################################################################
TIME_1=`date +%s`  # use these later to compute the total 
TIME_2=0            # time spent building a release
TIME_TOTAL=0        #

# Script help function
myprint_help () {
#   Print help info
    echo ""
    echo "Usage is:  do_release [options] [var. defs] [<precision>]"
    echo ""
    echo "Inputs:"
    echo "   <precision>         SGL or DBL (optional) [default is DBL]"
    echo "Options:"
    echo "   -cesr               Flag to checkout and/or build a cesr release"
    echo "   -pkg                Flag to checkout and/or build a packages release"
    echo "   -build_only         If you want to forgo the checkout and creation"
    echo "                       of the release directory tree, use this flag."
    echo "   -dump               Dump this script's configuration information"
#    echo "   -tagr               Tag this cesr release in the CVS repository"
    echo "   -tagp               packages release tagging (not implemented)"
    echo "   -osf                Remote exec OSF1 build"
    echo "   -lnx                Remote exec linux builds"
    echo "   -vms                Prepare VMS build for transfer"
    echo "   -win                Remote exec of Windows build not yet operational"
    echo "   -nobs               Suppress periodic build-status messages."
    echo "   -ntly               Nightly build, rotate library links when done"
    echo "   -devel              Run a DEVEL build, rotate release and apply CVS tag."
    echo "   -curr               Run a CURRENT build, rotate release and apply special CVS tag."
    echo "   -test               Run test jobs on all binary build products. Summarize results."
    echo ""
    echo "   -BRANCH=<br name>   Build a release using modules taken from a specific CESR development branch."
    echo ""
    echo "Variable definitions:"
    echo "   REL=<release_name>  Specify a custom CESR release name"
    echo "   PKG=<packages_name> Specify a custom packages release name"
    echo "   F90=<f90_compiler>  Specify a 3rd-party fortran compiler"
    echo "   TAG=<release_tag>   Specify a custom tag for the release"
    echo "   GMAKE=<gmake_dir>   Specify a custom CESR_GMAKE directory"
    echo "   UTIL=<util_dir>     Specify a custom CESR_UTIL  directory"
    echo "   BIN=<bin_dir>       Specify a custom CESR_BIN   directory"
    echo ""
    echo "   PATH =  $PATH "
}

# Function to convert an elapsed seconds number into Hour Minute and Second
# values, stored in the variables HRS   MINS   SECS
seconds_to_HMS () {
    HRS=`expr ${1} / 3600`
    MINS=`expr \( ${1} % 3600 \) / 60`
    SECS=`expr \( ${1} % 60 \)`
}

# Function to generate unique release names
get_release_name () {
    FULL_RNAME=${BUILD_DIR}/${BASE_TAG}/${RNAME}

#   Determine whether an index tag is needed to 
#   insure a unique release name
    if ( [ -e ${FULL_RNAME} ] ) then
        UNIQ_TAG=0
        TEST_NAME=${FULL_RNAME}

        while ( [ -e ${TEST_NAME} ] ); do
            UNIQ_TAG=`expr ${UNIQ_TAG} + 1`
            TEST_NAME=${FULL_RNAME}_${UNIQ_TAG}
        done

        RNAME=${RNAME}_${UNIQ_TAG}
        FULL_RNAME=${BUILD_DIR}/${BASE_TAG}/${RNAME}
    fi

    RLOG=${RNAME}.log
    FULL_RLOG=${BUILD_DIR}/log/${BASE_TAG}/${RLOG}
}

################################################################
# Main script starts here
################################################################

# Get the operating system, machine type, and default fortran compiler
PLATFORM_TAG="`uname -s`_`uname -m`"
if ( [ -n "${CESR_PLATFORM}" ] ) then
   PLATFORM_TAG="${CESR_PLATFORM}"
fi

# Generate the base directory in which to create/build the release
BASE_TAG=${PLATFORM_TAG}_${CESR_F90}

#Initializations
BUILD_DIR=/home/cesrulib/cesr_libs
PREC="DBL"
REL_TAG="cesr"
PKG_TAG="packages"
DO_REL=0
DO_PKG=0
DO_CHECKOUT="do_checkout"
DO_BUILD="do_build"
DO_DUMP=0
SHOW_STATUS=1
NIGHTLY_BUILD=0
DEVEL_BUILD=0
CURRENT_BUILD=0
TEST_EXEC=0

DO_TAG_RELEASE=0
DO_TAG_PACKAGES=0
CVS_TAGNAME=""
REL=""
PKG=""
BRANCH="TRUNK"

GMAKE_OVERRIDE=0
UTIL_OVERRIDE=0
use_cesr_bin=/home/cesrulib/bin

   # text file containing the REL_NAME of the
   # last successfully built release
PREV_BUILT="${BUILD_DIR}/log/prev_built" 

# Special customization for Windows builds in the CYGWIN environment
if ( [ ${PLATFORM_TAG} = "CYGWIN_NT_i686" ] ) then
 use_cesr_bin=/cygdrive/z/cesrulib/bin
 BUILD_DIR=/cygdrive/c/user_local/cesrulib/cesr_libs
fi

# Build flags and default host machines
# NOTE:  host machine for VMS is to prepare the release for transfer to VMS.  
#        Code builds on VMS must be executed manually (for now)
# NOTE:  host machine for Windows is not presently used.  Builds on Windows 
#        must be executed manually (for now)
OSF=0
LNX=0
VMS=0
WIN=0

OSF_HOST=cesr68.lns.cornell.edu
LNX_HOST=lnx209.lns.cornell.edu
VMS_HOST=cesr68.lns.cornell.edu
WIN_HOST=pc6115.lns.cornell.edu

CURRENT_HOST="`uname -n`"

BASE_AREA_LIST="Linux_i686_intel Linux_i686_lahey OSF1_alpha_hp VMS_alpha_hp CYGWIN_NT_i686_intel"

GMAKE=gmake

if ( [ $# = 0 ] ) then
    myprint_help
    exit 1
fi

# Get inputs
arg_list=""
for i 
do arg_list="${arg_list} ${i}";
   case $i in
     "DBL"|"dbl") PREC="DBL";;
     "SGL"|"sgl") PREC="SGL";;
     "-cesr"    ) DO_REL=1  ;;
     "-pkg"     ) DO_PKG=1  ;;
     "-build_only") DO_CHECKOUT="no_checkout";;
     "-dump"    ) DO_DUMP=1 ;;
#     "-tagr"    ) DO_TAG_RELEASE=1;;
#     "-tagp"    ) DO_TAG_PACKAGES=1;;
     "-osf"     ) OSF=1;;
     "-lnx"     ) LNX=1;;
     "-vms"     ) VMS=1;;
     "-win"     ) WIN=1;;
     "-nobs"    ) SHOW_STATUS=0;;
     "-ntly"    ) NIGHTLY_BUILD=1;;
     "-devel"   ) DEVEL_BUILD=1; DO_TAG_RELEASE=1;;
     "-curr"    ) CURRENT_BUILD=1; DO_TAG_RELEASE=1;;
     "-test"    ) TEST_EXEC=1;;
     TAG=*      ) REL_TAG=`echo $i|cut -d= -f2`;;
     PKG=*      ) PKG=`echo $i|cut -d= -f2`;;
     REL=*      ) REL=`echo $i|cut -d= -f2`;;
     GMAKE=*    )use_cesr_gmake=`echo $i|cut -d= -f2`;
                  GMAKE_OVERRIDE=1;;
     UTIL=*     )use_cesr_util=`echo $i|cut -d= -f2`;
                 UTIL_OVERRIDE=1;;
     BIN=*      )use_cesr_bin=`echo $i|cut -d= -f2`;;
     BRANCH=*   )BRANCH=`echo $i|cut -d= -f2`;;
     *          ) myprint_help;
     exit 1;;
   esac
done


##################################
# Obtain a Kerberos V ticket to enable krsh builds on remote hosts
#################################
# kinit command does not return a meaningful code upon failure or completion
# it merely returns its PID

#kdestroy > /dev/null
kinit -k -t /etc/cesrulib-keytab cesrulib/lnx209.lns.cornell.edu
klist | grep LNS.CORNELL.EDU > /dev/null
if ( [ ${?} -ne 0 ] ) then               # check to see if new credentials are cached
    echo "Could not obtain Kerberos credentials, exiting with error code: ${?}"
    exit ${?}
fi
   
# Platform dependent definitions
if ( [ ${PLATFORM_TAG} = "CYGWIN_NT_i686" ] ) then
   GMAKE=make
fi

# Set up the yyyy_mmdd tag
DATE_TAG=`date +"%Y_%m%d"`

# Set up the precision tag
case $PREC in
   "DBL")PREC_TAG="d";;
   "SGL")PREC_TAG="s";;
esac 
CESR_PREC="_${PREC}"

# Generate the CESR release name
if ( [ $DO_REL -eq 1 -a $DO_CHECKOUT = "do_checkout" ] ) then
    RNAME="${REL_TAG}_${DATE_TAG}_${PREC_TAG}"
    get_release_name
    if ( [ ${BRANCH} != "TRUNK" ] ) then
      REL_NAME="${RNAME}-${BRANCH}"
      FULL_REL_NAME="${FULL_RNAME}-${BRANCH}"
      FULL_REL_LOG="${FULL_RLOG}-${BRANCH}"
    else
      REL_NAME=${RNAME}
      FULL_REL_NAME=${FULL_RNAME}
      FULL_REL_LOG=${FULL_RLOG}
    fi
elif ( [ -n "${REL}" ] ) then
    if ( [ ${BRANCH} != "TRUNK" ] ) then
      REL_NAME=${REL}-${BRANCH}
      FULL_REL_NAME="${FULL_REL_NAME}-${BRANCH}"
      FULL_REL_LOG=${BUILD_DIR}/log/${BASE_TAG}/${REL}-${BRANCH}.log
    else
      REL_NAME=${REL}
      FULL_REL_NAME=${BUILD_DIR}/${BASE_TAG}/${REL_NAME}
      FULL_REL_LOG=${BUILD_DIR}/log/${BASE_TAG}/${REL}.log    
    fi
else
    REL_NAME=""
fi		

# Generate the package release name
if ( [ $DO_PKG -eq 1 ] && [ $DO_CHECKOUT = "do_checkout" ] ) then
    RNAME="${PKG_TAG}_${DATE_TAG}_${PREC_TAG}"
    get_release_name
    PKG_NAME=${RNAME}
    FULL_PKG_NAME=${FULL_RNAME}
    FULL_PKG_LOG=${FULL_RLOG}
elif ( [ -n "${PKG}" ] ) then
    PKG_NAME=${PKG}
    FULL_PKG_NAME=${BUILD_DIR}/${BASE_TAG}/${PKG_NAME}
    FULL_PKG_LOG=${BUILD_DIR}/log/${BASE_TAG}/${PKG}.log
else
    PKG_NAME=${PKG}
fi


if ( [ ${DO_REL} -eq 0 -a ${DO_PKG} -eq 1 ] ) then
    REL_IDENT=${PKG_NAME}
else
    REL_IDENT=${REL_NAME}
fi
echo "=*= do_release - called with the following arguments: " | tee ${BUILD_DIR}/log/${REL_IDENT}.genlog
echo "${arg_list}"  | tee -a ${BUILD_DIR}/log/${REL_NAME}.genlog
echo "" | tee -a ${BUILD_DIR}/log/${REL_NAME}.genlog


#######################################################
# Check the available disk space and abort if it is
# insufficient to contain the expected build size
#######################################################
# 2,500,000 K  =  2.5 Gig
DISK_NEEDED=2500000

DISKSPACE=`df /mnt/libs | tail -n1 | sed 's/ \([ ]*\) /=/g' | cut -d= -f4`
## if there is less than 2.5 Gig available, abort.
if ( [ ${DISKSPACE} -lt ${DISK_NEEDED} ] ) then
    echo "Disk free space = ${DISKSPACE}         Space required = ${DISK_NEEDED}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "Insufficient disk space on /mnt/libs (/dev/vg1/libs).  Quitting!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "Build process terminated at : "`date` | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    exit 1
fi


# Set the CESR bin directory for picking up scripts
BIN_DIR=${use_cesr_bin}
CESRENV=${BIN_DIR}/cesrenv     # Never used?!

# Set before the environment is sourced for the new release
if ( [ -n "${REL_NAME}" ] ) then 
    CESRLIB=${REL_NAME}
else 
    CESRLIB=devel
fi

. ${BIN_DIR}/cesrdefs

# Use user-specified CESR_GMAKE and CESR_UTIL areas, if present.
if ( [ ${GMAKE_OVERRIDE} -eq 1 ] ) then
    CESR_GMAKE=${use_cesr_gmake}
    export CESR_GMAKE
fi

if ( [ ${UTIL_OVERRIDE} -eq 1 ] ) then
    CESR_UTIL=${use_cesr_util}
    export CESR_UTIL
fi

# Dump the configuration information if requested
if ( [ $DO_DUMP -eq 1 ] ) then
    echo "BUILD_DIR         = ${BUILD_DIR}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "PREC              = ${PREC}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "REL_TAG           = ${REL_TAG}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "PKG_TAG           = ${PKG_TAG}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "DO_REL            = ${DO_REL}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "DO_PKG            = ${DO_PKG}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "DO_CHECKOUT       = ${DO_CHECKOUT}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "BRANCH            = ${BRANCH}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "PLATFORM_TAG      = ${PLATFORM_TAG}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "CESR_GMAKE        = ${CESR_GMAKE}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "CESR_UTIL         = ${CESR_UTIL}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "bin Directory     = ${BIN_DIR}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "REL_NAME          = ${REL_NAME}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "FULL_REL_NAME     = ${FULL_REL_NAME}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "FULL_REL_LOG      = ${FULL_REL_LOG}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "PKG_NAME          = ${PKG_NAME}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "FULL_PKG_NAME     = ${FULL_PKG_NAME}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "FULL_PKG_LOG      = ${FULL_PKG_LOG}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "DO_TAG_RELEASE    = ${DO_TAG_RELEASE}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "DO_TAG_PACKAGES   = ${DO_TAG_PACKAGES}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "OSF               = ${OSF}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "LNX               = ${LNX}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "VMS               = ${VMS}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "WIN               = ${WIN}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "OSF_HOST          = ${OSF_HOST}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "LNX_HOST          = ${LNX_HOST}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "VMS_HOST          = ${VMS_HOST}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "WIN_HOST          = ${WIN_HOST}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "CURRENT_HOST      = ${CURRENT_HOST}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "PATH              = ${PATH} " | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "BIN_DIR           = ${BIN_DIR}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "SHOW_STATUS       = ${SHOW_STATUS}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "NIGHTLY_BUILD     = ${NIGHTLY_BUILD}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "DEVEL_BUILD       = ${DEVEL_BUILD}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "CURRENT_BUILD     = ${CURRENT_BUILD}" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
fi

# Print the CESR environment variables
echo "" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
echo "CESR Environment:  " | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
printenv | grep CESR_ | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
printenv | grep PKG_ | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
echo "" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog


#######################################################
# Checkout the PACKAGES RELEASE
#######################################################
co_pkg_status=0
if ( [ $DO_PKG -eq 1 ] && [ ${DO_CHECKOUT} = "do_checkout" ] ) then
    echo "`date`: Checking out packages..." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
#    gmake -f ${BIN_DIR}/M.release PACKAGE_NAME=${PKG_NAME} DO_PKG=${DO_PKG} CESR_PRECISION=${CESR_PREC} CHECKOUT=${DO_CHECKOUT} BASE_AREA_LIST="${BASE_AREA_LIST}" BUILD="" > ${FULL_PKG_LOG} 2>&1
    gmake -f ${BIN_DIR}/M.release PACKAGE_NAME=${PKG_NAME} DO_PKG=${DO_PKG} CESR_PRECISION=${CESR_PREC} CHECKOUT=${DO_CHECKOUT} BASE_AREA_LIST="${BASE_AREA_LIST}" BUILD="" >> ${BUILD_DIR}/log/${REL_IDENT}.genlog 2>&1
    co_pkg_status=$?
fi


#####################################################################
# Checkout the CESR RELEASE 
#####################################################################
echo "Branch name is: ${BRANCH}"
co_rel_status=0
if ( [ $DO_REL -eq 1 ] && [ ${DO_CHECKOUT} = "do_checkout" ] ) then
    echo "`date`: Checking out CESR release..." | tee -a ${BUILD_DIR}/log/${REL_NAME}.genlog
    if ( [ ${BRANCH} != "TRUNK" ] ) then
      branch_arg="BRANCH=${BRANCH}"
    else
      branch_arg=""
    fi
    gmake -f ${BIN_DIR}/M.release PACKAGE_NAME=${PKG_NAME} DO_REL=${DO_REL} CESR_PRECISION=${CESR_PREC} CHECKOUT=${DO_CHECKOUT} BASE_AREA_LIST="${BASE_AREA_LIST}" BUILD="" ${branch_arg} >> ${BUILD_DIR}/log/${REL_IDENT}.genlog 2>&1
    co_rel_status=$?
fi

if ( [ $co_pkg_status -eq 0 ] && [ $co_rel_status -eq 0 ] ) then
    if ( [ ${DO_CHECKOUT} = "do_checkout" ] ) then
        echo "`date`: Checkout phase completed successfully!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    else
        echo "`date`: No checkout required!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    fi
else
    echo "`date`: Checkout failed [PKG_STATUS=$co_pkg_status, REL_STATUS=$co_rel_status]!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "Aborting!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    exit 1
fi


###################################################
# Execute builds on specified platforms
# NOTE:  At present, code builds must be launched
#        manually on OpenVMS and Windows
###################################################

# Specify standard build arguments string for M.release

# Always dump confguration info
BUILD_ARGS="-dump"

# Check whether to build the 3rd-party packages
if ( [ $DO_PKG -eq 1 ] ) then
  BUILD_ARGS="${BUILD_ARGS} -pkg"
fi

# Check whether to build the release
if ( [ $DO_REL -eq 1 ] ) then
  BUILD_ARGS="${BUILD_ARGS} -cesr"
fi

# If binary output testing is requested, pass the message along to
# the build_release calls.
if ( [ $TEST_EXEC -eq 1 ] ) then
  BUILD_ARGS="${BUILD_ARGS} -test"
fi

# Pass along BIN directory path to build_release calls
BUILD_ARGS="${BUILD_ARGS} BIN=${BIN_DIR}"

# If a development branch was specified for this build, pass
# along that paramter to the build initiations
if ( [ $BRANCH != "TRUNK" ] ) then
  BUILD_ARGS="${BUILD_ARGS} BRANCH=${BRANCH}"
fi

# Add release and package specifications
BUILD_ARGS="${BUILD_ARGS} REL=${REL_NAME} PKG=${PKG_NAME} DBL"


# Build Linux releases
echo "" | tee -a ${BUILD_DIR}/log/${REL_NAME}.genlog
echo "_______________________________________________" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
echo "`date`:  Launching builds..." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
if ( [ $LNX -eq 1 ] ) then
    
#   Build Linux_intel release
    LINUX_INTEL_STAT=${BUILD_DIR}/log/Linux_i686_intel/${REL_IDENT}.build_status
    echo "BUILD_STATUS:  -2" > ${LINUX_INTEL_STAT}
    LOCAL_BUILD_ARGS="${BUILD_ARGS} F90=intel"
    LIN_INTEL_T1=`date +%s`
    krsh -x $LNX_HOST ". .bash_profile; ${use_cesr_bin}/build_release ${LOCAL_BUILD_ARGS} >> $LINUX_INTEL_STAT 2>&1 &"&  
    echo "`date`:  Linux_intel build launched with status:  $?" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo ""
            # does this ? grab the return value of 'date'?
    sleep 20          # attempt to eliminate KRB replay messages by spacing out
                      # executions in time.
#   Build Linux_lahey release
    LINUX_LAHEY_STAT=${BUILD_DIR}/log/Linux_i686_lahey/${REL_NAME}.build_status
    echo "BUILD_STATUS:  -2" > ${LINUX_LAHEY_STAT}
    LOCAL_BUILD_ARGS="${BUILD_ARGS} F90=lahey"
    LIN_LAHEY_T1=`date +%s`
    krsh -x $LNX_HOST ". .bash_profile; ${use_cesr_bin}/build_release ${LOCAL_BUILD_ARGS} >> $LINUX_LAHEY_STAT 2>&1 &"&  
    echo "`date`:  Linux_lahey build launched with status:  $?" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo ""
    sleep 20
fi

# Build OSF1 release
if ( [ $OSF -eq 1 ] ) then
    OSF_HP_STAT=${BUILD_DIR}/log/OSF1_alpha_hp/${REL_NAME}.build_status
    echo "BUILD_STATUS:  -2" > ${OSF_HP_STAT}
    LOCAL_BUILD_ARGS="${BUILD_ARGS}"
    OSF_ALPHA_T1=`date +%s`
    krsh -x $OSF_HOST ". .bash_profile; ${use_cesr_bin}/build_release ${LOCAL_BUILD_ARGS} >> $OSF_HP_STAT 2>&1 &"&
    echo "`date`:  OSF_hp build launched with status:  $?" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo ""
    sleep 20
fi

# Prepare OpenVMS release
if ( [ $VMS -eq 1 ] ) then
    VMS_PREP_STAT=${BUILD_DIR}/log/VMS_alpha_hp/${REL_NAME}.build_status
    echo "BUILD_STATUS:  -2" > ${VMS_PREP_STAT}
    LOCAL_BUILD_ARGS="-vms_prep ${BUILD_ARGS}"
    VMS_ALPHA_T1=`date +%s`
    krsh -x $VMS_HOST ". .bash_profile; ${use_cesr_bin}/build_release ${LOCAL_BUILD_ARGS} >> $VMS_PREP_STAT 2>&1"&
    echo "`date`:  VMS preparation job launched with status:  $?" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog   
    echo ""
#    ${use_cesr_bin}/util/cesr_to_vms ${FULL_REL_NAME}
    sleep 10
fi

# Build Windows release - NOT YET AVAILABLE
if ( [ $WIN -eq 1 ] ) then
    CYGWIN_INTEL_STAT=${BUILD_DIR}/log/CYGWIN_NT_i686_intel/${REL_NAME}.build_status
    echo "BUILD_STATUS:  -2" > ${CYGWIN_INTEL_STAT}
    CYGWIN_NT_T1=`date +%s`
    echo "`date`:  Windows release must be started manually on PC6115!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    echo "BUILD_STATUS:  0" >> ${CYGWIN_INTEL_STAT}
    sleep 20
fi

echo "`date`: Launch phase complete..." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
echo "______________________________________________" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog

###################################################
# Loop and check build status on all platforms
####################################################################
# Status value key:    (Double check these values and descriptions)
#   -1 : currently building on designated host
#   -2 : build initiated, awating release checkout etc.?
#    0 : build complete
# +INT : Error code percolated up from some sub-script or command
####################################################################
#max_loops=720  #~12 hours worth of looping
max_loops=480   #~8  hours worth  (Builds usually complete in just over 1 hr.)
sleep_seconds=60

loop=0
loop_done=0
job_status=0

LIN_INTEL_TIME=0
LIN_LAHEY_TIME=0
OSF_ALPHA_TIME=0
VMS_ALPHA_TIME=0
CYGWIN_NT_TIME=0

L_I_donelatch=0
L_L_donelatch=0
O_A_donelatch=0
V_A_donelatch=0
C_I_donelatch=0

while ( [ $loop -le $max_loops ] && [ $loop_done -eq 0 ] ); do

    loop_done=1
    job_status=0
    if ( [ $SHOW_STATUS -eq 1 ] ) then
      echo "`date`: Loop = ${loop}   Last build status - "
    fi
    if ( [ $LNX -eq 1 ] ) then
        linux_intel_build=`grep "BUILD_STATUS:" $LINUX_INTEL_STAT | tail -1l | cut -d: -f2`
        if ( [ $linux_intel_build -eq 0 ] &&  [ $L_I_donelatch -eq 0 ] ) then
	    LIN_INTEL_T2=`date +%s`
	    LIN_INTEL_TIME=`expr ${LIN_INTEL_T2} - ${LIN_INTEL_T1}`
	    L_I_donelatch=1
	fi
	if ( [ $linux_intel_build -lt 0 ] ) then
            loop_done=0
        fi
        if ( [ $linux_intel_build -gt 0 ] ) then
            job_status=10
        fi
        if ( [ $SHOW_STATUS -eq 1 ] ) then
          echo "          Linux_intel :  $linux_intel_build"
        fi
	
        linux_lahey_build=`grep "BUILD_STATUS:" $LINUX_LAHEY_STAT | tail -1l | cut -d: -f2`
        if ( [ $linux_lahey_build -eq 0 ] && [ $L_L_donelatch -eq 0 ] ) then
	    LIN_LAHEY_T2=`date +%s`
	    LIN_LAHEY_TIME=`expr ${LIN_LAHEY_T2} - ${LIN_INTEL_T1}`
	    L_L_donelatch=1
	fi
	if ( [ $linux_lahey_build -lt 0 ] ) then
            loop_done=0
        fi
        if ( [ $linux_lahey_build -gt 0 ] ) then
            job_status=10
        fi
        if ( [ $SHOW_STATUS -eq 1 ] ) then
          echo "          Linux_lahey :  $linux_lahey_build"
        fi
    fi
    if ( [ $OSF -eq 1 ] ) then
        osf_hp_build=`grep "BUILD_STATUS:" $OSF_HP_STAT | tail -1l | cut -d: -f2`
	if ( [ $osf_hp_build -eq 0 ] && [ $O_A_donelatch -eq 0 ] ) then
	    OSF_ALPHA_T2=`date +%s`
	    OSF_ALPHA_TIME=`expr ${OSF_ALPHA_T2} - ${OSF_ALPHA_T1}`
	    O_A_donelatch=1
	fi
        if ( [ $osf_hp_build -lt 0 ] ) then
            loop_done=0
        fi
        if ( [ $osf_hp_build -gt 0 ] ) then
            job_status=10
        fi
        if ( [ $SHOW_STATUS -eq 1 ] ) then
          echo "          OSF_hp      :  $osf_hp_build"
        fi
    fi
    if ( [ $VMS -eq 1 ] ) then
        vms_prep_build=`grep "BUILD_STATUS:" $VMS_PREP_STAT | tail -1l | cut -d: -f2`
	if ( [ $vms_prep_build -eq 0 ] && [ $V_A_donelatch -eq 0 ] ) then
	    VMS_ALPHA_T2=`date +%s`
	    VMS_ALPHA_TIME=`expr ${VMS_ALPHA_T2} - ${VMS_ALPHA_T1}`
	    V_A_donelatch=1
	fi
        if ( [ $vms_prep_build -lt 0 ] ) then
            loop_done=0
        fi
        if ( [ $vms_prep_build -gt 0 ] ) then
            job_status=10
        fi
        if ( [ $SHOW_STATUS -eq 1 ] ) then
          echo "          VMS_prep    :  $vms_prep_build" 
        fi
    fi
    if ( [ $WIN -eq 1 ] ) then
        cygwin_intel_build=`grep "BUILD_STATUS:" $CYGWIN_INTEL_STAT | tail -1l | cut -d: -f2`
	if ( [ $cygwin_intel_build -eq 0 ] && [ $C_I_donelatch -eq 0 ] ) then
	    CYGWIN_NT_T2=`date +%s`
	    CYGWIN_NT_TIME=`expr ${CYGWIN_NT_T2} - ${CYGWIN_NT_T1}`
	    C_I_donelatch=1
	fi
        if ( [ $cygwin_intel_build -lt 0 ] ) then
            loop_done=0
        fi
        if ( [ $cygwin_intel_build -gt 0 ] ) then
            job_status=10
        fi
        if ( [ $SHOW_STATUS -eq 1 ] ) then
          echo "          CYGWIN_intel:  $cygwin_intel_build"
        fi
    fi


#   Control the loop timing at start and end
#   Make the first 10 cycles be fast
    if ( [ $loop -le 10 ] ) then
        tosleep=5
    else
        tosleep=$sleep_seconds
    fi

#   If the job has completed, don't sleep
    if ( [ $loop_done -eq 1 ] ) then
        tosleep=0
    fi

#   Sleep, increment loop counter, and re-check
    sleep ${tosleep}
    loop=`expr ${loop} + 1`

done

#############################################################
# If VMS build was requested, zip up source and generated 
# dependency files after OSF build completes with prep work.
#############################################################
if ( [ $VMS -eq 1 ] ) then
  ${use_cesr_bin}/util/cesr_to_vms ${FULL_REL_NAME}
fi


#------------------------
# Print status summary
#------------------------
if ( [ $loop -lt $max_loops ] ) then
    if ( [ $job_status -eq 0 ] ) then
        echo "`date`:  Release build has completed successfully!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    else
        echo "`date`:  Release build terminated with ERRORS (status = ${job_status})!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    fi
else
    echo "`date`:  Release build has TIMED OUT!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
fi

###################################################################################
# Print itemized time-summary of build processes.
#   Do it before additional loop timeout checks below to highlight which build
#   might have stalled in the event a timeout occurs.
###################################################################################
# Gather time information from each platform build process

echo "" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
echo "          ======= Statistics for this build process =======" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
echo "============================ Time summary: =============================" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog

if ( [ ${LIN_INTEL_TIME} != 0 ] ) then
    seconds_to_HMS ${LIN_INTEL_TIME}
    echo "Linux intel build : ${HRS} hr ${MINS} min ${SECS} sec" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
else
    echo "No time data available for Linux intel build." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
fi
if ( [ ${LIN_LAHEY_TIME} != 0 ] ) then
    seconds_to_HMS ${LIN_LAHEY_TIME}
    echo "Linux lahey build : ${HRS} hr ${MINS} min ${SECS} sec" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
else
    echo "No time data available for Linux lahey bulid." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
fi
if ( [ ${OSF_ALPHA_TIME} != 0 ] ) then
    seconds_to_HMS ${OSF_ALPHA_TIME}
    echo "OSF1 alpha  build : ${HRS} hr ${MINS} min ${SECS} sec" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
else
    echo "No time data available for OSF1 alpha build." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
fi
if ( [ ${VMS_ALPHA_TIME} != 0 ] ) then
    seconds_to_HMS ${VMS_ALPHA_TIME}
    echo "VMS  alpha  build : ${HRS} hr ${MINS} min ${SECS} sec" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
else
    echo "No time data available for VMS alpha build." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
fi
if ( [ ${CYGWIN_NT_TIME} != 0 ] ) then
    seconds_to_HMS ${CYGWIN_NT_TIME}
    echo "Cygwin i686 build : ${HRS} hr ${MINS} min ${SECS} sec" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
else
    echo "No time data available for Cygwin i686 build." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
fi


#####################################################################################
# Compute disk space consumed by this build and append categorized info to 
# standard output.  (Log this somewhere else?  Otherwise, we'll need to keep
# the nightly mail messages or console output from manual builds to preserve
# a size-history of builds.)
#####################################################################################
if ( [ ${DO_PKG} -eq 0 ] ) then
    /home/cesrulib/bin/util/rel_disk_total ${REL_NAME} 2>&1 | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
fi
#####################################################################################
# Print a status summary of all active post-build test jobs (executable testing)
# If any post-build tests fail, keep the release but do not rotate or tag?
# Weight release testing so that errors on key platforms (Linux_intel) cause global
# failure and notification while test failures on less important platforms continue
# with tagging/rotation but still notify of failure?
#####################################################################################
if ( [ ${TEST_EXEC} -eq 1 ] ) then
    echo "======================== Binary testing summary: =======================" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    for platform in ${BASE_AREA_LIST}
      do
      statfile=${BUILD_DIR}/log/${platform}/${REL_NAME}.build_status
      if ( ! [ ${platform} = "VMS_alpha_hp" ] && ! [ ${platform} = "CYGWIN_NT_i686_intel" ] ) then
          echo "${platform}:" | tee -a ${BUILD_DIR}/log/${REL_NAME}.genlog
          ecode=`grep 'BMADZ TEST COMP' ${statfile} | cut -d' ' -f6`
          tsec1=`grep 'BEGIN bmadz' ${statfile} | cut -d'(' -f2 | cut -d')' -f1`
          tsec2=`grep 'END bmadz' ${statfile} | cut -d'(' -f2 | cut -d')' -f1`
          tseconds=`expr ${tsec2} - ${tsec1}`
          seconds_to_HMS ${tseconds}
          if ( [ "${ecode}" -eq 0 ] ) then
              echo -e "  BMADZ:  OK!\t\t\t\tTest lasted: ${HRS} hrs ${MINS} min ${SECS} sec" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
          else
              echo -e "  BMADZ exited with code:  ${ecode}\t\tTest lasted: ${HRS} hrs ${MINS} min ${SECS} sec"  | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
          fi
      else
          echo "No data available for ${platform}." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
      fi
    done
    echo "" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
fi
echo "========================================================================" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog

#####################################################################################
# If all build jobs complete successfully and this is 
# a DEVEL build, tag release, 
# If this is a CURRENT build -- make the tag special.
# Append output of tagging commands to FULL_REL_LOG file
#####################################################################################
if ( [ $loop -lt $max_loops -a $job_status -eq 0 -a $DO_TAG_RELEASE -eq 1 ] ) then
    if ( [ $DEVEL_RELEASE -eq 1 ] ) then
        CVS_TAGNAME="${REL_NAME}"
    fi
    if ( [ $CURRENT_RELEASE -eq 1 ] ) then
        CVS_TAGNAME="${REL_NAME}_current"
    fi
    echo "`date`: TAGGING the files in CVS used to build this release..." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
#    gmake -f ${BIN_DIR}/M.release PACKAGE_NAME=${PKG_NAME} DO_REL="" TAGNAME=${CVS_TAGNAME} CHECKOUT="" BUILD="" >> ${FULL_REL_LOG} 2>&1
    gmake -f ${BIN_DIR}/M.release PACKAGE_NAME=${PKG_NAME} DO_REL="" TAGNAME=${CVS_TAGNAME} CHECKOUT="" BUILD="" 2>&1 | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    if ( [ ${?} -eq 0 ] ) then
        echo "`date`: Release tagged in CVS with tag: "${CVS_TAGNAME} | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
         # python tagscript in viewCVS should take care of mailage when configured properly.
         # It does produce a lot of output (one e-mail message per directory tagged)
    else
        echo "ERROR during tagging!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
    fi
fi

##############################################################
# If this build has not timed out or otherwise failed, and a
# rotaton was requested on the command line,
# call the rotate_release script using appropriate arguments.
##############################################################
rotation_success="false"
if ( [ $job_status -eq 0 ] && [ $loop -lt $max_loops ] ) then
    if ( [ $NIGHTLY_BUILD -eq 1 ] ) then
        /home/cesrulib/bin/util/rotate_release -nightly ${REL_NAME}
        if ( [ $? -eq 0 ] ) then
            rotation_success="true"
        fi
    elif ( [ $DEVEL_BUILD -eq 1 ] ) then
        /home/cesrulib/bin/util/rotate_release -devel ${REL_NAME}
        if ( [ $? -eq 0 ] ) then
            rotation_success="true"
        fi
    elif ( [ $CURRENT_BUILD -eq 1 ] ) then
        /home/cesrulib/bin/util/rotate_release -current ${REL_NAME} 
        if ( [ $? -eq 0 ] ) then
            rotation_success="true"
        fi
    fi
else  
    echo "ERROR: Not rotating release due to build errors or timeout!" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
fi

########################################################
# If this is a nightly, and we've rotated successfully
# by having no other errors, delete the previous night's
# build as long as it hasn't been promoted to a devel
# or current release.  (Checking done within
# DELETE_release script.)
########################################################
if ( [ $NIGHTLY_BUILD -eq 1 ] ) then
    if ( [ $rotation_success = "true" ] ) then
        if ( [ -e ${PREV_BUILT} ] ) then
            echo "Build and rotation successful, so deleting previous night's build." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
            /home/cesrulib/bin/util/DELETE_release -FORCE REL=`cat ${PREV_BUILT}` 2>&1 | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
        else
            echo "Problem reading file ${PREV_BUILT}.  No deletion performed." | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
        fi
    fi    
fi

if ( [ $DO_REL -eq 1 ] ) then
    chmod u+w ${PREV_BUILT}
    echo "${REL_NAME}" > ${PREV_BUILT}
    chmod u-w ${PREV_BUILT}
fi

#####################################################
# Do not leave valid KRB credentials laying about.
#####################################################
kdestroy

#####################################################
# Calculate the elapsed time in Hr:Min:Sec format
#####################################################
TIME_2=`date +%s`
TIME_TOTAL=`expr ${TIME_2} - ${TIME_1}`
seconds_to_HMS ${TIME_TOTAL}
## HRS=`expr ${TIME_TOTAL} / 3600`
## MINS=`expr \( ${TIME_TOTAL} % 3600 \) / 60`
## SECS=`expr \( ${TIME_TOTAL} % 60 \)`
echo "Total elapsed time for this build:    ${HRS} hr ${MINS} min ${SECS} sec" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog
echo "EOF" | tee -a ${BUILD_DIR}/log/${REL_IDENT}.genlog

exit 0
