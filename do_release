#!/bin/sh
#
#-------------------------------------------------------------------------
#
# This is the master script to build new code releases across the  
# supported computer systems at CLASSE.  
# 
# Supporting scripts:  - M.release makefile
#                      - build_release script to execute individual builds
#                      - test_release script to validate the functionality 
#                        of the code builds
#                      - tag_release script to tag releases in the CVS 
#                        repository
#                            
#
# usage : do_release [options] [var defs] <lib_tag> <pkg_tag> [<SGL/DBL>]
#         arguments:
#          <SGL/DBL>      specify double or single precision
#                         (default is DBL)
#
#         flags:
#          -cesr          Build a cesr release
#          -pkg           Build a packages release 
#          -build_only    if you want to forgo the checkout and
#                         creation of necessary dirs, add 
#                         -build_only flag.  In this case, 
#                         <lib_tag> must contain the full name 
#                         of the release
#          -dump          Dump the configuration information for this 
#                         script
#          -tagr          cesr release tagging
#          -tagp          packages release tagging
#          -osf           Run OSF1 build
#          -lnx           Run Linux builds
#          -vms           Prepare release for transfer to VMS_alpha
#          -win           Automatic windows builds not yet operational
#          -nobs          Suppress periodic build-status messages (Default: NO)
#          
#         variables:
#           REL=<release_name>  Specify a specific CESR release
#                               to build against.  Expects only base 
#                               directory name (NO path).
#           PKG=<packages_name> Specify a specific packages release
#                               to build against.  Expects only base 
#                               directory name (NO path).
#           TAG=<release_tag>   Specify a custom tag for the release
#           GMAKE=<gmake_dir>   Specify a custom CESR_GMAKE directory.
#                               Expects FULL path.
#           UTIL=<util_dir>     Specify a custom CESR_UTIL  directory
#                               to build against.  Expects FULL path.
#           BIN=<bin_dir>       Specify a custom CESR_BIN directory
#                               Expects FULL path.
#
# examples: do_release -cesr PKG=packages_2003_0728_d DBL 
#           do_release -cesr -build_only cesr_yyyy_mmdd_d DBL
#
#           do_release -tagr REL=cesr_2003_0728_d DBL 
#                        #  tagging only #
#           do_release -cesr -tagr PKG=packages_2003_0728_d DBL
#                        #building  release then tagging#
################################################################
#
# $Id$
#
# $Log$
# Revision 1.18  2006/09/12 19:51:08  cesrulib
# Added command-line option '-nobs' to suppress voluminous build status
# messages (useful when script's output is directed to something other
# than a tty).
#
# Revision 1.17  2006/09/12 13:24:23  cesrulib
# Added kinit incantation to allow unattended builds.
#
# Revision 1.16  2006/09/11 20:47:01  cesrulib
# Updates for new library build tree (supporting multiple compiler combinations).
#
#
################################################################

################################################################
# Set up some internal functions
################################################################

# Script help function
myprint_help () {
#   Print help info
    echo ""
    echo "Usage is:  do_release [options] [var. defs] [<precision>]"
    echo ""
    echo "Inputs:"
    echo "   <precision>         SGL or DBL (optional) [default is DBL]"
    echo "Options:"
    echo "   -cesr               Flag to checkout and/or build a cesr release"
    echo "   -pkg                Flag to checkout and/or build a packages release"
    echo "   -build_only         If you want to forgo the checkout and creation"
    echo "                       of the release directory tree, use this flag."
    echo "   -dump               Dump this script's configuration information"
    echo "   -tagr               cesr release tagging"
    echo "   -tagp               packages release tagging"
    echo "   -osf                Remote exec OSF1 build"
    echo "   -lnx                Remote exec linux builds"
    echo "   -vms                Prepare VMS build for transfer"
    echo "   -win                Remote exec of Windows build not yet operational"
    echo "   -nobs               Suppress periodic build-status messages."
    echo ""
    echo "Variable definitions:"
    echo "   REL=<release_name>  Specify a custom CESR release name"
    echo "   PKG=<packages_name> Specify a custom packages release name"
    echo "   F90=<f90_compiler>  Specify a 3rd-party fortran compiler"
    echo "   TAG=<release_tag>   Specify a custom tag for the release"
    echo "   GMAKE=<gmake_dir>   Specify a custom CESR_GMAKE directory"
    echo "   UTIL=<util_dir>     Specify a custom CESR_UTIL  directory"
    echo "   BIN=<bin_dir>       Specify a custom CESR_BIN   directory"
    echo ""
    echo "   PATH =  $PATH "
}

# Function to generate unique release names
get_release_name () {
    FULL_RNAME=${BUILD_DIR}/${BASE_TAG}/${RNAME}

#   Determine whether an index tag is needed to 
#   insure a unique release name
    if ( [ -e ${FULL_RNAME} ] ) then
        UNIQ_TAG=0
        TEST_NAME=${FULL_RNAME}

        while ( [ -e ${TEST_NAME} ] ); do
            UNIQ_TAG=`expr ${UNIQ_TAG} + 1`
            TEST_NAME=${FULL_RNAME}_${UNIQ_TAG}
        done

        RNAME=${RNAME}_${UNIQ_TAG}
        FULL_RNAME=${BUILD_DIR}/${BASE_TAG}/${RNAME}
    fi

    RLOG=${RNAME}.log
    FULL_RLOG=${BUILD_DIR}/log/${BASE_TAG}/${RLOG}
}

################################################################
# Main script starts here
################################################################

# Get the operating system, machine type, and default fortran compiler
PLATFORM_TAG="`uname -s`_`uname -m`"
if ( [ -n "${CESR_PLATFORM}" ] ) then
   PLATFORM_TAG="${CESR_PLATFORM}"
fi

# Generate the base directory in which to create/build the release
BASE_TAG=${PLATFORM_TAG}_${CESR_F90}

#Initializations
BUILD_DIR=/home/cesrulib/cesr_libs
PREC="DBL"
REL_TAG="cesr"
PKG_TAG="packages"
DO_REL=0
DO_PKG=0
DO_CHECKOUT="do_checkout"
DO_BUILD="do_build"
DO_DUMP=0
SHOW_STATUS=1
GMAKE_OVERRIDE=0
UTIL_OVERRIDE=0
use_cesr_bin=/home/cesrulib/bin

# Special customization for Windows builds in the CYGWIN environment
if ( [ ${PLATFORM_TAG} = "CYGWIN_NT_i686" ] ) then
 use_cesr_bin=/cygdrive/z/cesrulib/bin
 BUILD_DIR=/cygdrive/c/user_local/cesrulib/cesr_libs
fi


DO_TAG_RELEASE=0
DO_TAG_PACKAGES=0
REL=""
PKG=""

# Build flags and default host machines
# NOTE:  host machine for VMS is to prepare the release for transfer to VMS.  
#        Code builds on VMS must be executed manually (for now)
# NOTE:  host machine for Windows is not presently used.  Builds on Windows 
#        must be executed manually (for now)
OSF=0
LNX=0
VMS=0
WIN=0

OSF_HOST=cesr68.lns.cornell.edu
LNX_HOST=lnx209.lns.cornell.edu
VMS_HOST=cesr68.lns.cornell.edu
WIN_HOST=pc6115.lns.cornell.edu

CURRENT_HOST="`uname -n`"

# Flag for checking whether kinit has been run (needed to remote exec builds)
KINIT_CHECK=0

BASE_AREA_LIST="OSF1_alpha_hp Linux_i686_intel Linux_i686_lahey VMS_alpha_hp CYGWIN_NT_i686_intel"

GMAKE=gmake

# Get inputs
arg_list=""
for i 
do arg_list="${arg_list} ${i}";
   case $i in
     "DBL"|"dbl") PREC="DBL";;
     "SGL"|"sgl") PREC="SGL";;
     "-cesr"    ) DO_REL=1  ;;
     "-pkg"     ) DO_PKG=1  ;;
     "-build_only") DO_CHECKOUT="no_checkout";;
     "-dump"    ) DO_DUMP=1 ;;
     "-tagr"    ) DO_TAG_RELEASE=1;;
     "-tagp"    ) DO_TAG_PACKAGES=1;;
     "-osf"     ) OSF=1; KINIT_CHECK=1;;
     "-lnx"     ) LNX=1; KINIT_CHECK=1;;
     "-vms"     ) VMS=1; KINIT_CHECK=1;;
     "-win"     ) WIN=1; KINIT_CHECK=1;;
     "-nobs"    ) SHOW_STATUS=0 ;;
     TAG=*      ) REL_TAG=`echo $i|cut -d= -f2`;;
     PKG=*      ) PKG=`echo $i|cut -d= -f2`;;
     REL=*      ) REL=`echo $i|cut -d= -f2`;;
     GMAKE=*    )use_cesr_gmake=`echo $i|cut -d= -f2`;
                  GMAKE_OVERRIDE=1;;
     UTIL=*     )use_cesr_util=`echo $i|cut -d= -f2`;
                 UTIL_OVERRIDE=1;;
     BIN=*      )use_cesr_bin=`echo $i|cut -d= -f2`;;
     *          ) myprint_help;
     exit 1;;
   esac
done

echo "do_release - called with the following arguments:  "
echo "${arg_list}" 
echo ""

##################################
# Obtain a Kerberos V ticket to enable krsh builds on remote hosts
#################################

kinit -k -t /etc/cesrulib-keytab cesrulib/lnx209.lns.cornell.edu

#Have you run kinit?
#if ( [ ${KINIT_CHECK} = 1 ] ) then
#    TERMINAL01=`tty`
#    echo "Did you run kinit? (y/n):" >> $TERMINAL01
#    read ANSWER < $TERMINAL01
#    if ( [ $ANSWER != y ] ) then 
#        echo " Run kinit and start again." >> $TERMINAL01
#        exit
#    fi
#fi 
   
# Platform dependent definitions
if ( [ ${PLATFORM_TAG} = "CYGWIN_NT_i686" ] ) then
   GMAKE=make
fi

# Set up the yyyy_mmdd tag
DATE_TAG=`date +"%Y_%m%d"`

# Set up the precision tag
case $PREC in
   "DBL")PREC_TAG="d";;
   "SGL")PREC_TAG="s";;
esac 
CESR_PREC="_${PREC}"

# Generate the CESR release name
if ( [ $DO_REL -eq 1 -a $DO_CHECKOUT = "do_checkout" ] ) then
    RNAME="${REL_TAG}_${DATE_TAG}_${PREC_TAG}"
    get_release_name
    REL_NAME=${RNAME}
    FULL_REL_NAME=${FULL_RNAME}
    FULL_REL_LOG=${FULL_RLOG}
elif ( [ -n "${REL}" ] ) then
    REL_NAME=${REL}
    FULL_REL_NAME=${BUILD_DIR}/${BASE_TAG}/${REL_NAME}
    FULL_REL_LOG=${BUILD_DIR}/log/${BASE_TAG}/${REL}.log
else
    REL_NAME=""
fi		

# Generate the package release name
if ( [ $DO_PKG -eq 1 ] && [ $DO_CHECKOUT = "do_checkout" ] ) then
    RNAME="${PKG_TAG}_${DATE_TAG}_${PREC_TAG}"
    get_release_name
    PKG_NAME=${RNAME}
    FULL_PKG_NAME=${FULL_RNAME}
    FULL_PKG_LOG=${FULL_RLOG}
elif ( [ -n "${PKG}" ] ) then
    PKG_NAME=${PKG}
    FULL_PKG_NAME=${BUILD_DIR}/${BASE_TAG}/${PKG_NAME}
    FULL_PKG_LOG=${BUILD_DIR}/log/${BASE_TAG}/${PKG}.log
else
    PKG_NAME=${PKG}
fi


# Set the CESR bin directory for picking up scripts
BIN_DIR=${use_cesr_bin}
CESRENV=${BIN_DIR}/cesrenv


# Export the environment for the new release
if ( [ -n "${REL_NAME}" ] ) then 
    CESRLIB=${REL_NAME}
else 
    CESRLIB=devel
fi


CESRLIB_BIN=${BIN_DIR}; . ${BIN_DIR}/cesrdefs

# Use user-specified CESR_GMAKE and CESR_UTIL areas, if present.
if ( [ ${GMAKE_OVERRIDE} -eq 1 ] ) then
    CESR_GMAKE=${use_cesr_gmake}
    export CESR_GMAKE
fi

if ( [ ${UTIL_OVERRIDE} -eq 1 ] ) then
    CESR_UTIL=${use_cesr_util}
    export CESR_UTIL
fi

# Dump the configuration information if requested
if ( [ $DO_DUMP -eq 1 ] ) then
    echo "BUILD_DIR         = ${BUILD_DIR}"
    echo "PREC              = ${PREC}"
    echo "REL_TAG           = ${REL_TAG}"
    echo "PKG_TAG           = ${PKG_TAG}"
    echo "DO_REL            = ${DO_REL}"
    echo "DO_PKG            = ${DO_PKG}"
    echo "DO_CHECKOUT       = ${DO_CHECKOUT}"
    echo "PLATFORM_TAG      = ${PLATFORM_TAG}"
    echo ""
    echo "CESR_GMAKE        = ${CESR_GMAKE}"
    echo "CESR_UTIL         = ${CESR_UTIL}"
    echo "bin Directory     = ${BIN_DIR}"
    echo ""
    echo "REL_NAME          = ${REL_NAME}"
    echo "FULL_REL_NAME     = ${FULL_REL_NAME}"
    echo "FULL_REL_LOG      = ${FULL_REL_LOG}"
    echo "PKG_NAME          = ${PKG_NAME}"
    echo "FULL_PKG_NAME     = ${FULL_PKG_NAME}"
    echo "FULL_PKG_LOG      = ${FULL_PKG_LOG}"
    echo "DO_TAG_RELEASE    = ${DO_TAG_RELEASE}"
    echo "DO_TAG_PACKAGES   = ${DO_TAG_PACKAGES}"
    echo ""
    echo "OSF               = ${OSF}"
    echo "LNX               = ${LNX}"
    echo "VMS               = ${VMS}"
    echo "WIN               = ${WIN}"
    echo "OSF_HOST          = ${OSF_HOST}"
    echo "LNX_HOST          = ${LNX_HOST}"
    echo "VMS_HOST          = ${VMS_HOST}"
    echo "WIN_HOST          = ${WIN_HOST}"
    echo ""
    echo "CURRENT_HOST      = ${CURRENT_HOST}"
    echo "PATH              = ${PATH} "
    echo "BIN_DIR           = ${BIN_DIR}"
    echo "KINIT_CHECK       = ${KINIT_CHECK}"
    echo "SHOW_STATUS       = %{SHOW_STATUS}"
fi

# Print the CESR environment variables
echo ""
echo "CESR Environment:  "
printenv | grep CESR_
printenv | grep PKG_
echo ""


#######################################################
# Checkout the PACKAGES RELEASE
#######################################################
co_pkg_status=0
if ( [ $DO_PKG -eq 1 ] && [ ${DO_CHECKOUT} = "do_checkout" ] ) then
    echo "`date`: Checking out packages..."
    gmake -f ${BIN_DIR}/M.release PACKAGE_NAME=${PKG_NAME} DO_PKG=${DO_PKG} CESR_PRECISION=${CESR_PREC} CHECKOUT=${DO_CHECKOUT} BASE_AREA_LIST="${BASE_AREA_LIST}" BUILD="" > ${FULL_PKG_LOG} 2>&1
    co_pkg_status=$?
fi


####################################################
# Checkout the CESR RELEASE
####################################################
co_rel_status=0
if ( [ $DO_REL -eq 1 ] && [ ${DO_CHECKOUT} = "do_checkout" ] ) then
    echo "`date`: Checking out CESR release..."
    gmake -f ${BIN_DIR}/M.release PACKAGE_NAME=${PKG_NAME} DO_REL=${DO_REL} CESR_PRECISION=${CESR_PREC} CHECKOUT=${DO_CHECKOUT} BASE_AREA_LIST="${BASE_AREA_LIST}" BUILD="" > ${FULL_REL_LOG} 2>&1
    co_rel_status=$?
fi

if ( [ $co_pkg_status -eq 0 ] && [ $co_rel_status -eq 0 ] ) then
    if ( [ ${DO_CHECKOUT} = "do_checkout" ] ) then
        echo "`date`: Checkout phase completed successfully!"
    else
        echo "`date`: No checkout required!"
    fi
else
    echo "`date`: Checkout failed [PKG_STATUS=$co_pkg_status, REL_STATUS=$co_rel_status]!"
    echo "Aborting!"
    exit 1
fi


###################################################
# Execute builds on specified platforms
# NOTE:  At present, code builds must be launched
#        manually on OpenVMS and Windows
###################################################

# Specify standard build arguments string for M.release

# Always dump confguration info
BUILD_ARGS="-dump"

# Check whether to build the 3rd-party packages
if ( [ $DO_PKG -eq 1 ] ) then
  BUILD_ARGS="${BUILD_ARGS} -pkg"
fi

# Check whether to build the release
if ( [ $DO_REL -eq 1 ] ) then
  BUILD_ARGS="${BUILD_ARGS} -cesr"
fi

# Add release and package specifications
BUILD_ARGS="${BUILD_ARGS} REL=${REL_NAME} PKG=${PKG_NAME} DBL"


# Build Linux releases
echo ""
echo "`date`:  Launching builds..."
if ( [ $LNX -eq 1 ] ) then
    
#   Build Linux_intel release
    LINUX_INTEL_STAT=${BUILD_DIR}/log/Linux_i686_intel/${REL_NAME}.build_status
    echo "BUILD_STATUS:  -2" > ${LINUX_INTEL_STAT}
    LOCAL_BUILD_ARGS="${BUILD_ARGS} F90=intel"
    krsh -x $LNX_HOST ". .bash_profile; ${use_cesr_bin}/build_release ${LOCAL_BUILD_ARGS} >> $LINUX_INTEL_STAT 2>&1 &"&  
    echo "`date`:  Linux_intel build launched with status:  $?"

#   Build Linux_lahey release
    LINUX_LAHEY_STAT=${BUILD_DIR}/log/Linux_i686_lahey/${REL_NAME}.build_status
    echo "BUILD_STATUS:  -2" > ${LINUX_LAHEY_STAT}
    LOCAL_BUILD_ARGS="${BUILD_ARGS} F90=lahey"
    krsh -x $LNX_HOST ". .bash_profile; ${use_cesr_bin}/build_release ${LOCAL_BUILD_ARGS} >> $LINUX_LAHEY_STAT 2>&1 &"&  
    echo "`date`:  Linux_lahey build launched with status:  $?"
fi

# Build OSF1 release
if ( [ $OSF -eq 1 ] ) then
    OSF_HP_STAT=${BUILD_DIR}/log/OSF1_alpha_hp/${REL_NAME}.build_status
    echo "BUILD_STATUS:  -2" > ${OSF_HP_STAT}
    LOCAL_BUILD_ARGS="${BUILD_ARGS}"
    krsh -x $OSF_HOST ". .bash_profile; ${use_cesr_bin}/build_release ${LOCAL_BUILD_ARGS} >> $OSF_HP_STAT 2>&1 &"&  
    echo "`date`:  OSF_hp build launched with status:  $?"
fi

# Prepare OpenVMS release
if ( [ $VMS -eq 1 ] ) then
    VMS_PREP_STAT=${BUILD_DIR}/log/VMS_alpha_hp/${REL_NAME}.build_status
    echo "BUILD_STATUS:  -2" > ${VMS_PREP_STAT}
    LOCAL_BUILD_ARGS="-vms_prep ${BUILD_ARGS}"
    krsh -x $VMS_HOST ". .bash_profile; ${use_cesr_bin}/build_release ${LOCAL_BUILD_ARGS} >> $VMS_PREP_STAT 2>&1 &"&  
    echo "`date`:  VMS preparation job launched with status:  $?"
fi

# Build Windows release - NOT YET AVAILABLE
if ( [ $WIN -eq 1 ] ) then
    CYGWIN_INTEL_STAT=${BUILD_DIR}/log/CYGWIN_NT_i686_intel/${REL_NAME}.build_status
    echo "BUILD_STATUS:  -2" > ${CYGWIN_INTEL_STAT}
    echo "`date`:  Windows release must be started manually on PC6115!"
    echo "BUILD_STATUS:  0" >> ${CYGWIN_INTEL_STAT}
fi


###################################################
# Loop and check build status on all platforms
###################################################
max_loops=720
sleep_seconds=60

loop=0
loop_done=0
job_status=0

while ( [ $loop -le $max_loops ] && [ $loop_done -eq 0 ] ); do

    loop_done=1
    job_status=0
    if ( [ $SHOW_STATUS -eq 1 ] ) then
      echo "`date`: Loop = ${loop}   Last build status - "
    fi
    if ( [ $LNX -eq 1 ] ) then
        linux_intel_build=`grep "BUILD_STATUS:" $LINUX_INTEL_STAT | tail -1l | cut -d: -f2`
        if ( [ $linux_intel_build -lt 0 ] ) then
            loop_done=0
        fi
        if ( [ $linux_intel_build -gt 0 ] ) then
            job_status=10
        fi
        if ( [ $SHOW_STATUS -eq 1 ] ) then
          echo "          Linux_intel :  $linux_intel_build"
        fi
        linux_lahey_build=`grep "BUILD_STATUS:" $LINUX_LAHEY_STAT | tail -1l | cut -d: -f2`
        if ( [ $linux_lahey_build -lt 0 ] ) then
            loop_done=0
        fi
        if ( [ $linux_lahey_build -gt 0 ] ) then
            job_status=10
        fi
        if ( [ $SHOW_STATUS -eq 1 ] ) then
          echo "          Linux_lahey :  $linux_lahey_build"
        fi
    fi
    if ( [ $OSF -eq 1 ] ) then
        osf_hp_build=`grep "BUILD_STATUS:" $OSF_HP_STAT | tail -1l | cut -d: -f2`
        if ( [ $osf_hp_build -lt 0 ] ) then
            loop_done=0
        fi
        if ( [ $osf_hp_build -gt 0 ] ) then
            job_status=10
        fi
        if ( [ $SHOW_STATUS -eq 1 ] ) then
          echo "          OSF_hp      :  $osf_hp_build"
        fi
    fi
    if ( [ $VMS -eq 1 ] ) then
        vms_prep_build=`grep "BUILD_STATUS:" $VMS_PREP_STAT | tail -1l | cut -d: -f2`
        if ( [ $vms_prep_build -lt 0 ] ) then
            loop_done=0
        fi
        if ( [ $vms_prep_build -gt 0 ] ) then
            job_status=10
        fi
        if ( [ $SHOW_STATUS -eq 1 ] ) then
          echo "          VMS_prep    :  $vms_prep_build" 
        fi
    fi
    if ( [ $WIN -eq 1 ] ) then
        cygwin_intel_build=`grep "BUILD_STATUS:" $CYGWIN_INTEL_STAT | tail -1l | cut -d: -f2`
        if ( [ $cygwin_intel_build -lt 0 ] ) then
            loop_done=0
        fi
        if ( [ $cygwin_intel_build -gt 0 ] ) then
            job_status=10
        fi
        if ( [ $SHOW_STATUS -eq 1 ] ) then
          echo "          CYGWIN_intel:  $cygwin_intel_build"
        fi
    fi


#   Control the loop timing at start and end
#   Make the first 10 cycles be fast
    if ( [ $loop -le 10 ] ) then
        tosleep=5
    else
        tosleep=$sleep_seconds
    fi

#   If the job has completed, don't sleep
    if ( [ $loop_done -eq 1 ] ) then
        tosleep=0
    fi

#   Sleep, increment loop counter, and re-check
    sleep ${tosleep}
    loop=`expr ${loop} + 1`

done

#------------------------------------------------------
# If all build jobs complete successfully, tag release 
# NOTE:  Not yet enabled
#------------------------------------------------------

#------------------------
# Print status summary
#------------------------
if ( [ $loop -lt $max_loops ] ) then
    if ( [ $job_status -eq 0 ] ) then
        echo "`date`:  Release build has completed successfully!"
    else
        echo "`date`:  Release build completed with ERRORS (status = ${job_status})!"
    fi
else
    echo "`date`:  Release build has TIMED OUT!"
fi

exit




















