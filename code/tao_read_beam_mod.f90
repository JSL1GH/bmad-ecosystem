module tao_read_beam_mod

use tao_mod


real(rp), private, save :: bunch_charge
real(rp), private, save :: bunch_charge_set = 0

integer, private, save :: num_bunch, num_particle
integer, private, save :: num_bunch_set = 0, num_particle_set = 0
integer, private, save :: iu

logical, private, save :: ascii_file

contains

!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------

subroutine open_beam_file (file_name)

character(*) file_name
character(100) :: full_file_name
character(80) line

! Open file and determine whether the file is binary or ascii

call tao_open_file ('TAO_INIT_DIR', file_name, iu, full_file_name)
if (iu == 0) stop

ascii_file = .true.
read (iu, '(a80)') line
if (index(line, '!BINARY') /= 0) ascii_file = .false.

if (ascii_file) then
  rewind (iu)
else
  close (iu)
  open (iu, file = full_file_name, form = 'unformatted', status = 'old')
  read (iu) line(1:7)  ! read "!binary" line
endif

end subroutine

!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------

subroutine close_beam_file ()

close (iu)

! reset parameters

num_bunch_set = 0
num_particle_set = 0
bunch_charge_set = 0

end subroutine

!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------

subroutine read_beam_params (ix_ele, n_bunch, n_particle, charge_bunch)

real(rp) charge_bunch
integer n_bunch, n_particle, ix_ele, ios
character(20) :: r_name = 'read_beam_params'

! Read numbers

if (ascii_file) then
  read (iu, *, iostat = ios) ix_ele, n_bunch, n_particle, charge_bunch
else
  read (iu, iostat = ios) ix_ele, n_bunch, n_particle, charge_bunch
endif

if (ios < 0) then
  ix_ele = -1
elseif (ios > 0) then
  ix_ele = -2
  call out_io (s_error$, r_name, 'ERROR READING BEAM PARAMS')
  call err_exit
endif

end subroutine

!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!+
! Subroutine set_beam_params (n_bunch, n_particle, charge_bunch)
!
! Subroutine to set beam parameters.
! This subroutine should be called before read_beam.
!-

subroutine set_beam_params (n_bunch, n_particle, charge_bunch)

real(rp), optional :: charge_bunch
integer, optional :: n_bunch, n_particle

!

if (present(n_bunch))      num_bunch_set = n_bunch
if (present(n_particle))   num_particle_set = n_particle
if (present(charge_bunch)) bunch_charge_set = bunch_charge

end subroutine

!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------

subroutine read_beam (beam)

type (beam_struct), target :: beam
type (bunch_struct), pointer :: bunch

integer i, j, ios
integer n_bunch, n_particle, ix_lost
real(rp) charge_bunch, vec(6)
complex(rp) spin(2)
character(16) :: r_name = 'read_beam'
character(200) line

! parameters come from file unless set_beam_param has been called.

n_bunch = num_bunch
if (num_bunch_set > 0) n_bunch = num_bunch_set

n_particle = num_particle
if (num_particle_set > 0) n_particle = num_particle_set

charge_bunch = bunch_charge
if (bunch_charge_set /= 0) charge_bunch = bunch_charge_set

call reallocate_beam (beam, n_bunch, n_particle)

! An ascii file, if it is generated by another program, may not include ix_lost or the spin.
! so add the default values

do i = 1, n_bunch
  bunch => beam%bunch(i)
  if (ascii_file) then
    read (iu, *) bunch%charge
    read (iu, *) bunch%z_center
    read (iu, *) bunch%t_center
  else
    read (iu) bunch%charge
    read (iu) bunch%z_center
    read (iu) bunch%t_center
  endif
  if (charge_bunch /= 0) bunch%charge = charge_bunch
  do j = 1, n_particle
    if (ascii_file) then
      read (iu, '(a)') line
      line = trim(line) // '  -1   0.0  0.0   0.0  0.0'   ! default ix_lost and spin
      read (line, *) vec, ix_lost, spin
    else
      read (iu) vec, ix_lost, spin
    endif
    if (i > n_bunch .or. j > n_particle) cycle
    bunch%particle(j)%r%vec = vec
    bunch%particle(j)%r%spin = spin
    bunch%particle(j)%ix_lost = ix_lost
    bunch%particle(j)%charge = bunch%charge / n_particle
  enddo
enddo

end subroutine

end module
