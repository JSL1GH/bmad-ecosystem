
//+
// C++ side of the Bmad / C++ structure interface.
//
// This file is generated as part of the Bmad/C++ interface code generation.
// The code generation files can be found in cpp_bmad_interface.
//
// DO NOT EDIT THIS FILE DIRECTLY! 
//-

#ifndef CPP_BMAD_CONVERT

#include <iostream>
#include "cpp_bmad_classes.h"

//---------------------------------------------------------------------------

template <class T> void operator<< (valarray<T>& arr, const T* ptr) {
  unsigned int n = arr.size();
  for (unsigned int i = 0; i < n; i++) arr[i] = ptr[i];
}

template <class T> void operator<< (valarray< valarray<T> >& mat, const T* ptr) {
  unsigned int n1 = mat.size();
  if (n1 == 0) return;
  unsigned int n2 = mat[0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      mat[i][j] = ptr[i*n2+j];
    }
  }
}

template <class T> void operator<< (valarray< valarray< valarray<T> > >& tensor, const T* ptr) {
  unsigned int n1 = tensor.size();
  if (n1 == 0) return;
  unsigned int n2 = tensor[0].size();
  unsigned int n3 = tensor[0][0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      for (unsigned int k = 0; k < n3; k++) {
        tensor[i][j][k] = ptr[i*n2*n3 + j*n3 + k];
      }
    }
  }
}

template <class T> void operator<< (valarray<T>& arr1, const valarray<T>& arr2) {
  unsigned int n1 = arr1.size(), n2 = arr2.size();
  if (n1 != n2) arr1.resize(n2);
  arr1 = arr2;
}

template <class T> void operator<< (valarray< valarray<T> >& mat1, 
                              const valarray< valarray<T> >& mat2) {
  unsigned int n1_1 = mat1.size(), n2_1 = mat2.size();
  unsigned int n1_2 = 0, n2_2 = 0;
  if (n1_1 > 0) n1_2 = mat1[0].size();
  if (n2_1 > 0) n2_2 = mat2[0].size();
  if (n1_1 != n2_1) mat1.resize(n2_1);
  if (n1_2 != n2_2) {for (unsigned int i = 0; i < n1_1; i++) mat1[i].resize(n2_2);}
  mat1 = mat2;
}

template <class T> void matrix_to_vec (const valarray< valarray<T> >& mat, T* vec) {
  unsigned int n1 = mat.size();
  if (n1 == 0) return;
  unsigned int n2 = mat[0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      vec[i*n2+j] = mat[i][j];
    }
  }
}

template <class T> void tensor_to_vec (const valarray< valarray< valarray<T> > >& tensor, T* vec) {
  unsigned int n1 = tensor.size();
  if (n1 == 0) return;
  unsigned int n2 = tensor[0].size();
  unsigned int n3 = tensor[0][0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      for (unsigned int k = 0; k < n3; k++) {
        vec[i*n2*n3 + j*n3 + k] = tensor[i][j][k];
      }
    }
  }
}

//---------------------------------------------------------------------------
// Instantiate instances for conversion from array to C++ structure.

template void operator<< (Bool_ARRAY&,  c_Bool*);
template void operator<< (Bool_MATRIX&, c_Bool*);

template void operator<< (Real_ARRAY&,  c_Real*);
template void operator<< (Real_MATRIX&, c_Real*);
template void operator<< (Real_TENSOR&, c_Real*);

template void operator<< (Complex_ARRAY&,  c_Complex*);
template void operator<< (Complex_MATRIX&, c_Complex*);
template void operator<< (Complex_TENSOR&, c_Complex*);

template void operator<< (Int_ARRAY&,  c_Int*);
template void operator<< (Int_MATRIX&, c_Int*);
template void operator<< (Int_TENSOR&, c_Int*);

//---------------------------------------------------------------------------
// Instantiate instances for transfer

template void operator<< (Real_ARRAY&,  const Real_ARRAY&);
template void operator<< (Real_MATRIX&, const Real_MATRIX&);
template void operator<< (Real_TENSOR&, const Real_TENSOR&);

template void operator<< (Complex_ARRAY&,  const Complex_ARRAY&);
template void operator<< (Complex_MATRIX&, const Complex_MATRIX&);
template void operator<< (Complex_TENSOR&, const Complex_TENSOR&);

template void operator<< (Int_ARRAY&,  const Int_ARRAY&);
template void operator<< (Int_MATRIX&, const Int_MATRIX&);
template void operator<< (Int_TENSOR&, const Int_TENSOR&);

//---------------------------------------------------------------------------

template void matrix_to_vec (const Bool_MATRIX&,     Bool*);
template void matrix_to_vec (const Complex_MATRIX&,  Complex*);
template void matrix_to_vec (const Real_MATRIX&,     Real*);
template void matrix_to_vec (const Int_MATRIX&,      Int*);

template void tensor_to_vec (const Complex_TENSOR&,  Complex*);
template void tensor_to_vec (const Real_TENSOR&,     Real*);
template void tensor_to_vec (const Int_TENSOR&,      Int*);

//---------------------------------------------------------------------------

void void_matrix_to_vec (const valarray< valarray< void** > >& mat, void** vec) {
  unsigned int n1 = mat.size();
  if (n1 == 0) return;
  unsigned int n2 = mat[0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      vec[i*n2+j] = mat[i][j];
    }
  }
}

void void_tensor_to_vec (const valarray< valarray< valarray< void** > > >& tensor, void** vec) {
  unsigned int n1 = tensor.size();
  if (n1 == 0) return;
  unsigned int n2 = tensor[0].size();
  unsigned int n3 = tensor[0][0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      for (unsigned int k = 0; k < n3; k++) {
        vec[i*n2*n3 + j*n3 + k] = tensor[i][j][k];
      }
    }
  }
}


//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_surface_orientation

extern "C" void surface_orientation_to_c (const Bmad_surface_orientation_class*, CPP_surface_orientation&);

// c_side.to_f2_arg
extern "C" void surface_orientation_to_f2 (Bmad_surface_orientation_class*, c_Real&, c_Real&,
    c_Real&, c_Real&);

extern "C" void surface_orientation_to_f (const CPP_surface_orientation& C, Bmad_surface_orientation_class* F) {

  // c_side.to_f2_call
  surface_orientation_to_f2 (F, C.x_pitch, C.y_pitch, C.x_pitch_rms, C.y_pitch_rms);

}

// c_side.to_c2_arg
extern "C" void surface_orientation_to_c2 (CPP_surface_orientation& C, c_Real& z_x_pitch,
    c_Real& z_y_pitch, c_Real& z_x_pitch_rms, c_Real& z_y_pitch_rms) {

  // c_side.to_c2_set[real, 0, NOT]
  C.x_pitch = z_x_pitch;
  // c_side.to_c2_set[real, 0, NOT]
  C.y_pitch = z_y_pitch;
  // c_side.to_c2_set[real, 0, NOT]
  C.x_pitch_rms = z_x_pitch_rms;
  // c_side.to_c2_set[real, 0, NOT]
  C.y_pitch_rms = z_y_pitch_rms;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_interval1_coef

extern "C" void interval1_coef_to_c (const Bmad_interval1_coef_class*, CPP_interval1_coef&);

// c_side.to_f2_arg
extern "C" void interval1_coef_to_f2 (Bmad_interval1_coef_class*, c_Real&, c_Real&, c_Real&);

extern "C" void interval1_coef_to_f (const CPP_interval1_coef& C, Bmad_interval1_coef_class* F) {

  // c_side.to_f2_call
  interval1_coef_to_f2 (F, C.c0, C.c1, C.n_exp);

}

// c_side.to_c2_arg
extern "C" void interval1_coef_to_c2 (CPP_interval1_coef& C, c_Real& z_c0, c_Real& z_c1,
    c_Real& z_n_exp) {

  // c_side.to_c2_set[real, 0, NOT]
  C.c0 = z_c0;
  // c_side.to_c2_set[real, 0, NOT]
  C.c1 = z_c1;
  // c_side.to_c2_set[real, 0, NOT]
  C.n_exp = z_n_exp;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_photon_reflect_table

extern "C" void photon_reflect_table_to_c (const Bmad_photon_reflect_table_class*, CPP_photon_reflect_table&);

// c_side.to_f2_arg
extern "C" void photon_reflect_table_to_f2 (Bmad_photon_reflect_table_class*, c_RealArr, Int,
    c_RealArr, Int, const CPP_interval1_coef**, Int, c_RealArr, Int, Int, c_Real&, c_RealArr,
    Int);

extern "C" void photon_reflect_table_to_f (const CPP_photon_reflect_table& C, Bmad_photon_reflect_table_class* F) {
  // c_side.to_f_setup[real, 1, ALLOC]
  int n1_angle = C.angle.size();
  c_RealArr z_angle = NULL;
  if (n1_angle > 0) {
    z_angle = &C.angle[0];
  }
  // c_side.to_f_setup[real, 1, ALLOC]
  int n1_energy = C.energy.size();
  c_RealArr z_energy = NULL;
  if (n1_energy > 0) {
    z_energy = &C.energy[0];
  }
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_int1 = C.int1.size();
  const CPP_interval1_coef** z_int1 = NULL;
  if (n1_int1 != 0) {
    z_int1 = new const CPP_interval1_coef*[n1_int1];
    for (int i = 0; i < n1_int1; i++) z_int1[i] = &C.int1[i];
  }
  // c_side.to_f_setup[real, 2, ALLOC]
  int n1_p_reflect = C.p_reflect.size(), n2_p_reflect = 0;
  Real* z_p_reflect = NULL;
  if (n1_p_reflect > 0) {
    n2_p_reflect = C.p_reflect[0].size();
    z_p_reflect = new Real [n1_p_reflect*n2_p_reflect];
    matrix_to_vec (C.p_reflect, z_p_reflect);
  }
  // c_side.to_f_setup[real, 1, ALLOC]
  int n1_p_reflect_scratch = C.p_reflect_scratch.size();
  c_RealArr z_p_reflect_scratch = NULL;
  if (n1_p_reflect_scratch > 0) {
    z_p_reflect_scratch = &C.p_reflect_scratch[0];
  }

  // c_side.to_f2_call
  photon_reflect_table_to_f2 (F, z_angle, n1_angle, z_energy, n1_energy, z_int1, n1_int1,
      z_p_reflect, n1_p_reflect, n2_p_reflect, C.max_energy, z_p_reflect_scratch,
      n1_p_reflect_scratch);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_int1;
  // c_side.to_f_cleanup[real, 2, ALLOC]
  delete[] z_p_reflect;
}

// c_side.to_c2_arg
extern "C" void photon_reflect_table_to_c2 (CPP_photon_reflect_table& C, c_RealArr z_angle, Int
    n1_angle, c_RealArr z_energy, Int n1_energy, Bmad_interval1_coef_class** z_int1, Int
    n1_int1, c_RealArr z_p_reflect, Int n1_p_reflect, Int n2_p_reflect, c_Real& z_max_energy,
    c_RealArr z_p_reflect_scratch, Int n1_p_reflect_scratch) {

  // c_side.to_c2_set[real, 1, ALLOC]

  C.angle.resize(n1_angle);
  C.angle << z_angle;

  // c_side.to_c2_set[real, 1, ALLOC]

  C.energy.resize(n1_energy);
  C.energy << z_energy;

  // c_side.to_c2_set[type, 1, ALLOC]
  C.int1.resize(n1_int1);
  for (int i = 0; i < n1_int1; i++) interval1_coef_to_c(z_int1[i], C.int1[i]);

  // c_side.to_c2_set[real, 2, ALLOC]
  C.p_reflect.resize(n1_p_reflect);
  for (int i = 0; i < n1_p_reflect; i++) C.p_reflect[i].resize(n2_p_reflect);
  C.p_reflect << z_p_reflect;

  // c_side.to_c2_set[real, 0, NOT]
  C.max_energy = z_max_energy;
  // c_side.to_c2_set[real, 1, ALLOC]

  C.p_reflect_scratch.resize(n1_p_reflect_scratch);
  C.p_reflect_scratch << z_p_reflect_scratch;

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_photon_reflect_surface

extern "C" void photon_reflect_surface_to_c (const Bmad_photon_reflect_surface_class*, CPP_photon_reflect_surface&);

// c_side.to_f2_arg
extern "C" void photon_reflect_surface_to_f2 (Bmad_photon_reflect_surface_class*, c_Char,
    c_Char, const CPP_photon_reflect_table**, Int, c_Real&, c_Real&, c_Bool&, c_Int&);

extern "C" void photon_reflect_surface_to_f (const CPP_photon_reflect_surface& C, Bmad_photon_reflect_surface_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_table = C.table.size();
  const CPP_photon_reflect_table** z_table = NULL;
  if (n1_table != 0) {
    z_table = new const CPP_photon_reflect_table*[n1_table];
    for (int i = 0; i < n1_table; i++) z_table[i] = &C.table[i];
  }

  // c_side.to_f2_call
  photon_reflect_surface_to_f2 (F, C.descrip.c_str(), C.reflectivity_file.c_str(), z_table,
      n1_table, C.surface_roughness_rms, C.roughness_correlation_len, C.initialized,
      C.ix_surface);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_table;
}

// c_side.to_c2_arg
extern "C" void photon_reflect_surface_to_c2 (CPP_photon_reflect_surface& C, c_Char z_descrip,
    c_Char z_reflectivity_file, Bmad_photon_reflect_table_class** z_table, Int n1_table,
    c_Real& z_surface_roughness_rms, c_Real& z_roughness_correlation_len, c_Bool&
    z_initialized, c_Int& z_ix_surface) {

  // c_side.to_c2_set[character, 0, NOT]
  C.descrip = z_descrip;
  // c_side.to_c2_set[character, 0, NOT]
  C.reflectivity_file = z_reflectivity_file;
  // c_side.to_c2_set[type, 1, ALLOC]
  C.table.resize(n1_table);
  for (int i = 0; i < n1_table; i++) photon_reflect_table_to_c(z_table[i], C.table[i]);

  // c_side.to_c2_set[real, 0, NOT]
  C.surface_roughness_rms = z_surface_roughness_rms;
  // c_side.to_c2_set[real, 0, NOT]
  C.roughness_correlation_len = z_roughness_correlation_len;
  // c_side.to_c2_set[logical, 0, NOT]
  C.initialized = z_initialized;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_surface = z_ix_surface;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_controller_var

extern "C" void controller_var_to_c (const Bmad_controller_var_class*, CPP_controller_var&);

// c_side.to_f2_arg
extern "C" void controller_var_to_f2 (Bmad_controller_var_class*, c_Char, c_Real&, c_Real&);

extern "C" void controller_var_to_f (const CPP_controller_var& C, Bmad_controller_var_class* F) {

  // c_side.to_f2_call
  controller_var_to_f2 (F, C.name.c_str(), C.value, C.old_value);

}

// c_side.to_c2_arg
extern "C" void controller_var_to_c2 (CPP_controller_var& C, c_Char z_name, c_Real& z_value,
    c_Real& z_old_value) {

  // c_side.to_c2_set[character, 0, NOT]
  C.name = z_name;
  // c_side.to_c2_set[real, 0, NOT]
  C.value = z_value;
  // c_side.to_c2_set[real, 0, NOT]
  C.old_value = z_old_value;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_coord

extern "C" void coord_to_c (const Bmad_coord_class*, CPP_coord&);

// c_side.to_f2_arg
extern "C" void coord_to_f2 (Bmad_coord_class*, c_RealArr, c_Real&, c_Real&, c_ComplexArr,
    c_RealArr, c_RealArr, c_Real&, c_Real&, c_Real&, c_Real&, c_Int&, c_Int&, c_Int&, c_Int&,
    c_Int&);

extern "C" void coord_to_f (const CPP_coord& C, Bmad_coord_class* F) {

  // c_side.to_f2_call
  coord_to_f2 (F, &C.vec[0], C.s, C.t, &C.spin[0], &C.field[0], &C.phase[0], C.charge,
      C.path_len, C.p0c, C.beta, C.ix_ele, C.state, C.direction, C.species, C.location);

}

// c_side.to_c2_arg
extern "C" void coord_to_c2 (CPP_coord& C, c_RealArr z_vec, c_Real& z_s, c_Real& z_t,
    c_ComplexArr z_spin, c_RealArr z_field, c_RealArr z_phase, c_Real& z_charge, c_Real&
    z_path_len, c_Real& z_p0c, c_Real& z_beta, c_Int& z_ix_ele, c_Int& z_state, c_Int&
    z_direction, c_Int& z_species, c_Int& z_location) {

  // c_side.to_c2_set[real, 1, NOT]
  C.vec << z_vec;
  // c_side.to_c2_set[real, 0, NOT]
  C.s = z_s;
  // c_side.to_c2_set[real, 0, NOT]
  C.t = z_t;
  // c_side.to_c2_set[complex, 1, NOT]
  C.spin << z_spin;
  // c_side.to_c2_set[real, 1, NOT]
  C.field << z_field;
  // c_side.to_c2_set[real, 1, NOT]
  C.phase << z_phase;
  // c_side.to_c2_set[real, 0, NOT]
  C.charge = z_charge;
  // c_side.to_c2_set[real, 0, NOT]
  C.path_len = z_path_len;
  // c_side.to_c2_set[real, 0, NOT]
  C.p0c = z_p0c;
  // c_side.to_c2_set[real, 0, NOT]
  C.beta = z_beta;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_ele = z_ix_ele;
  // c_side.to_c2_set[integer, 0, NOT]
  C.state = z_state;
  // c_side.to_c2_set[integer, 0, NOT]
  C.direction = z_direction;
  // c_side.to_c2_set[integer, 0, NOT]
  C.species = z_species;
  // c_side.to_c2_set[integer, 0, NOT]
  C.location = z_location;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_coord_array

extern "C" void coord_array_to_c (const Bmad_coord_array_class*, CPP_coord_array&);

// c_side.to_f2_arg
extern "C" void coord_array_to_f2 (Bmad_coord_array_class*, const CPP_coord**, Int);

extern "C" void coord_array_to_f (const CPP_coord_array& C, Bmad_coord_array_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_orbit = C.orbit.size();
  const CPP_coord** z_orbit = NULL;
  if (n1_orbit != 0) {
    z_orbit = new const CPP_coord*[n1_orbit];
    for (int i = 0; i < n1_orbit; i++) z_orbit[i] = &C.orbit[i];
  }

  // c_side.to_f2_call
  coord_array_to_f2 (F, z_orbit, n1_orbit);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_orbit;
}

// c_side.to_c2_arg
extern "C" void coord_array_to_c2 (CPP_coord_array& C, Bmad_coord_class** z_orbit, Int
    n1_orbit) {

  // c_side.to_c2_set[type, 1, ALLOC]
  C.orbit.resize(n1_orbit);
  for (int i = 0; i < n1_orbit; i++) coord_to_c(z_orbit[i], C.orbit[i]);

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_bpm_phase_coupling

extern "C" void bpm_phase_coupling_to_c (const Bmad_bpm_phase_coupling_class*, CPP_bpm_phase_coupling&);

// c_side.to_f2_arg
extern "C" void bpm_phase_coupling_to_f2 (Bmad_bpm_phase_coupling_class*, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&);

extern "C" void bpm_phase_coupling_to_f (const CPP_bpm_phase_coupling& C, Bmad_bpm_phase_coupling_class* F) {

  // c_side.to_f2_call
  bpm_phase_coupling_to_f2 (F, C.k_22a, C.k_12a, C.k_11b, C.k_12b, C.cbar22_a, C.cbar12_a,
      C.cbar11_b, C.cbar12_b, C.phi_a, C.phi_b);

}

// c_side.to_c2_arg
extern "C" void bpm_phase_coupling_to_c2 (CPP_bpm_phase_coupling& C, c_Real& z_k_22a, c_Real&
    z_k_12a, c_Real& z_k_11b, c_Real& z_k_12b, c_Real& z_cbar22_a, c_Real& z_cbar12_a, c_Real&
    z_cbar11_b, c_Real& z_cbar12_b, c_Real& z_phi_a, c_Real& z_phi_b) {

  // c_side.to_c2_set[real, 0, NOT]
  C.k_22a = z_k_22a;
  // c_side.to_c2_set[real, 0, NOT]
  C.k_12a = z_k_12a;
  // c_side.to_c2_set[real, 0, NOT]
  C.k_11b = z_k_11b;
  // c_side.to_c2_set[real, 0, NOT]
  C.k_12b = z_k_12b;
  // c_side.to_c2_set[real, 0, NOT]
  C.cbar22_a = z_cbar22_a;
  // c_side.to_c2_set[real, 0, NOT]
  C.cbar12_a = z_cbar12_a;
  // c_side.to_c2_set[real, 0, NOT]
  C.cbar11_b = z_cbar11_b;
  // c_side.to_c2_set[real, 0, NOT]
  C.cbar12_b = z_cbar12_b;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi_a = z_phi_a;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi_b = z_phi_b;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_expression_atom

extern "C" void expression_atom_to_c (const Bmad_expression_atom_class*, CPP_expression_atom&);

// c_side.to_f2_arg
extern "C" void expression_atom_to_f2 (Bmad_expression_atom_class*, c_Char, c_Int&, c_Real&);

extern "C" void expression_atom_to_f (const CPP_expression_atom& C, Bmad_expression_atom_class* F) {

  // c_side.to_f2_call
  expression_atom_to_f2 (F, C.name.c_str(), C.type, C.value);

}

// c_side.to_c2_arg
extern "C" void expression_atom_to_c2 (CPP_expression_atom& C, c_Char z_name, c_Int& z_type,
    c_Real& z_value) {

  // c_side.to_c2_set[character, 0, NOT]
  C.name = z_name;
  // c_side.to_c2_set[integer, 0, NOT]
  C.type = z_type;
  // c_side.to_c2_set[real, 0, NOT]
  C.value = z_value;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_wake_sr_mode

extern "C" void wake_sr_mode_to_c (const Bmad_wake_sr_mode_class*, CPP_wake_sr_mode&);

// c_side.to_f2_arg
extern "C" void wake_sr_mode_to_f2 (Bmad_wake_sr_mode_class*, c_Real&, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Int&, c_Int&);

extern "C" void wake_sr_mode_to_f (const CPP_wake_sr_mode& C, Bmad_wake_sr_mode_class* F) {

  // c_side.to_f2_call
  wake_sr_mode_to_f2 (F, C.amp, C.damp, C.k, C.phi, C.b_sin, C.b_cos, C.a_sin, C.a_cos,
      C.polarization, C.transverse_dependence);

}

// c_side.to_c2_arg
extern "C" void wake_sr_mode_to_c2 (CPP_wake_sr_mode& C, c_Real& z_amp, c_Real& z_damp, c_Real&
    z_k, c_Real& z_phi, c_Real& z_b_sin, c_Real& z_b_cos, c_Real& z_a_sin, c_Real& z_a_cos,
    c_Int& z_polarization, c_Int& z_transverse_dependence) {

  // c_side.to_c2_set[real, 0, NOT]
  C.amp = z_amp;
  // c_side.to_c2_set[real, 0, NOT]
  C.damp = z_damp;
  // c_side.to_c2_set[real, 0, NOT]
  C.k = z_k;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi = z_phi;
  // c_side.to_c2_set[real, 0, NOT]
  C.b_sin = z_b_sin;
  // c_side.to_c2_set[real, 0, NOT]
  C.b_cos = z_b_cos;
  // c_side.to_c2_set[real, 0, NOT]
  C.a_sin = z_a_sin;
  // c_side.to_c2_set[real, 0, NOT]
  C.a_cos = z_a_cos;
  // c_side.to_c2_set[integer, 0, NOT]
  C.polarization = z_polarization;
  // c_side.to_c2_set[integer, 0, NOT]
  C.transverse_dependence = z_transverse_dependence;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_wake_sr

extern "C" void wake_sr_to_c (const Bmad_wake_sr_class*, CPP_wake_sr&);

// c_side.to_f2_arg
extern "C" void wake_sr_to_f2 (Bmad_wake_sr_class*, const CPP_wake_sr_mode**, Int, c_Real&);

extern "C" void wake_sr_to_f (const CPP_wake_sr& C, Bmad_wake_sr_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_mode = C.mode.size();
  const CPP_wake_sr_mode** z_mode = NULL;
  if (n1_mode != 0) {
    z_mode = new const CPP_wake_sr_mode*[n1_mode];
    for (int i = 0; i < n1_mode; i++) z_mode[i] = &C.mode[i];
  }

  // c_side.to_f2_call
  wake_sr_to_f2 (F, z_mode, n1_mode, C.z_ref);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_mode;
}

// c_side.to_c2_arg
extern "C" void wake_sr_to_c2 (CPP_wake_sr& C, Bmad_wake_sr_mode_class** z_mode, Int n1_mode,
    c_Real& z_z_ref) {

  // c_side.to_c2_set[type, 1, ALLOC]
  C.mode.resize(n1_mode);
  for (int i = 0; i < n1_mode; i++) wake_sr_mode_to_c(z_mode[i], C.mode[i]);

  // c_side.to_c2_set[real, 0, NOT]
  C.z_ref = z_z_ref;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_wake_lr

extern "C" void wake_lr_to_c (const Bmad_wake_lr_class*, CPP_wake_lr&);

// c_side.to_f2_arg
extern "C" void wake_lr_to_f2 (Bmad_wake_lr_class*, c_Real&, c_Real&, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Int&, c_Bool&);

extern "C" void wake_lr_to_f (const CPP_wake_lr& C, Bmad_wake_lr_class* F) {

  // c_side.to_f2_call
  wake_lr_to_f2 (F, C.freq, C.freq_in, C.r_over_q, C.q, C.angle, C.b_sin, C.b_cos, C.a_sin,
      C.a_cos, C.t_ref, C.m, C.polarized);

}

// c_side.to_c2_arg
extern "C" void wake_lr_to_c2 (CPP_wake_lr& C, c_Real& z_freq, c_Real& z_freq_in, c_Real&
    z_r_over_q, c_Real& z_q, c_Real& z_angle, c_Real& z_b_sin, c_Real& z_b_cos, c_Real&
    z_a_sin, c_Real& z_a_cos, c_Real& z_t_ref, c_Int& z_m, c_Bool& z_polarized) {

  // c_side.to_c2_set[real, 0, NOT]
  C.freq = z_freq;
  // c_side.to_c2_set[real, 0, NOT]
  C.freq_in = z_freq_in;
  // c_side.to_c2_set[real, 0, NOT]
  C.r_over_q = z_r_over_q;
  // c_side.to_c2_set[real, 0, NOT]
  C.q = z_q;
  // c_side.to_c2_set[real, 0, NOT]
  C.angle = z_angle;
  // c_side.to_c2_set[real, 0, NOT]
  C.b_sin = z_b_sin;
  // c_side.to_c2_set[real, 0, NOT]
  C.b_cos = z_b_cos;
  // c_side.to_c2_set[real, 0, NOT]
  C.a_sin = z_a_sin;
  // c_side.to_c2_set[real, 0, NOT]
  C.a_cos = z_a_cos;
  // c_side.to_c2_set[real, 0, NOT]
  C.t_ref = z_t_ref;
  // c_side.to_c2_set[integer, 0, NOT]
  C.m = z_m;
  // c_side.to_c2_set[logical, 0, NOT]
  C.polarized = z_polarized;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_lat_ele_loc

extern "C" void lat_ele_loc_to_c (const Bmad_lat_ele_loc_class*, CPP_lat_ele_loc&);

// c_side.to_f2_arg
extern "C" void lat_ele_loc_to_f2 (Bmad_lat_ele_loc_class*, c_Int&, c_Int&);

extern "C" void lat_ele_loc_to_f (const CPP_lat_ele_loc& C, Bmad_lat_ele_loc_class* F) {

  // c_side.to_f2_call
  lat_ele_loc_to_f2 (F, C.ix_ele, C.ix_branch);

}

// c_side.to_c2_arg
extern "C" void lat_ele_loc_to_c2 (CPP_lat_ele_loc& C, c_Int& z_ix_ele, c_Int& z_ix_branch) {

  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_ele = z_ix_ele;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_branch = z_ix_branch;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_wake

extern "C" void wake_to_c (const Bmad_wake_class*, CPP_wake&);

// c_side.to_f2_arg
extern "C" void wake_to_f2 (Bmad_wake_class*, c_Char, c_Char, const CPP_wake_sr&, const
    CPP_wake_sr&, const CPP_wake_lr**, Int, c_Real&);

extern "C" void wake_to_f (const CPP_wake& C, Bmad_wake_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_lr = C.lr.size();
  const CPP_wake_lr** z_lr = NULL;
  if (n1_lr != 0) {
    z_lr = new const CPP_wake_lr*[n1_lr];
    for (int i = 0; i < n1_lr; i++) z_lr[i] = &C.lr[i];
  }

  // c_side.to_f2_call
  wake_to_f2 (F, C.sr_file.c_str(), C.lr_file.c_str(), C.sr_long, C.sr_trans, z_lr, n1_lr,
      C.z_sr_max);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_lr;
}

// c_side.to_c2_arg
extern "C" void wake_to_c2 (CPP_wake& C, c_Char z_sr_file, c_Char z_lr_file, const
    Bmad_wake_sr_class* z_sr_long, const Bmad_wake_sr_class* z_sr_trans, Bmad_wake_lr_class**
    z_lr, Int n1_lr, c_Real& z_z_sr_max) {

  // c_side.to_c2_set[character, 0, NOT]
  C.sr_file = z_sr_file;
  // c_side.to_c2_set[character, 0, NOT]
  C.lr_file = z_lr_file;
  // c_side.to_c2_set[type, 0, NOT]
  wake_sr_to_c(z_sr_long, C.sr_long);
  // c_side.to_c2_set[type, 0, NOT]
  wake_sr_to_c(z_sr_trans, C.sr_trans);
  // c_side.to_c2_set[type, 1, ALLOC]
  C.lr.resize(n1_lr);
  for (int i = 0; i < n1_lr; i++) wake_lr_to_c(z_lr[i], C.lr[i]);

  // c_side.to_c2_set[real, 0, NOT]
  C.z_sr_max = z_z_sr_max;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_taylor_term

extern "C" void taylor_term_to_c (const Bmad_taylor_term_class*, CPP_taylor_term&);

// c_side.to_f2_arg
extern "C" void taylor_term_to_f2 (Bmad_taylor_term_class*, c_Real&, c_IntArr);

extern "C" void taylor_term_to_f (const CPP_taylor_term& C, Bmad_taylor_term_class* F) {

  // c_side.to_f2_call
  taylor_term_to_f2 (F, C.coef, &C.expn[0]);

}

// c_side.to_c2_arg
extern "C" void taylor_term_to_c2 (CPP_taylor_term& C, c_Real& z_coef, c_IntArr z_expn) {

  // c_side.to_c2_set[real, 0, NOT]
  C.coef = z_coef;
  // c_side.to_c2_set[integer, 1, NOT]
  C.expn << z_expn;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_taylor

extern "C" void taylor_to_c (const Bmad_taylor_class*, CPP_taylor&);

// c_side.to_f2_arg
extern "C" void taylor_to_f2 (Bmad_taylor_class*, c_Real&, const CPP_taylor_term**, Int);

extern "C" void taylor_to_f (const CPP_taylor& C, Bmad_taylor_class* F) {
  // c_side.to_f_setup[type, 1, PTR]
  int n1_term = C.term.size();
  const CPP_taylor_term** z_term = NULL;
  if (n1_term != 0) {
    z_term = new const CPP_taylor_term*[n1_term];
    for (int i = 0; i < n1_term; i++) z_term[i] = &C.term[i];
  }

  // c_side.to_f2_call
  taylor_to_f2 (F, C.ref, z_term, n1_term);

  // c_side.to_f_cleanup[type, 1, PTR]
 delete[] z_term;
}

// c_side.to_c2_arg
extern "C" void taylor_to_c2 (CPP_taylor& C, c_Real& z_ref, Bmad_taylor_term_class** z_term,
    Int n1_term) {

  // c_side.to_c2_set[real, 0, NOT]
  C.ref = z_ref;
  // c_side.to_c2_set[type, 1, PTR]
  C.term.resize(n1_term);
  for (int i = 0; i < n1_term; i++) taylor_term_to_c(z_term[i], C.term[i]);

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_wig_term

extern "C" void wig_term_to_c (const Bmad_wig_term_class*, CPP_wig_term&);

// c_side.to_f2_arg
extern "C" void wig_term_to_f2 (Bmad_wig_term_class*, c_Real&, c_Real&, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Int&);

extern "C" void wig_term_to_f (const CPP_wig_term& C, Bmad_wig_term_class* F) {

  // c_side.to_f2_call
  wig_term_to_f2 (F, C.coef, C.kx, C.ky, C.kz, C.x0, C.y0, C.phi_z, C.type);

}

// c_side.to_c2_arg
extern "C" void wig_term_to_c2 (CPP_wig_term& C, c_Real& z_coef, c_Real& z_kx, c_Real& z_ky,
    c_Real& z_kz, c_Real& z_x0, c_Real& z_y0, c_Real& z_phi_z, c_Int& z_type) {

  // c_side.to_c2_set[real, 0, NOT]
  C.coef = z_coef;
  // c_side.to_c2_set[real, 0, NOT]
  C.kx = z_kx;
  // c_side.to_c2_set[real, 0, NOT]
  C.ky = z_ky;
  // c_side.to_c2_set[real, 0, NOT]
  C.kz = z_kz;
  // c_side.to_c2_set[real, 0, NOT]
  C.x0 = z_x0;
  // c_side.to_c2_set[real, 0, NOT]
  C.y0 = z_y0;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi_z = z_phi_z;
  // c_side.to_c2_set[integer, 0, NOT]
  C.type = z_type;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_wig

extern "C" void wig_to_c (const Bmad_wig_class*, CPP_wig&);

// c_side.to_f2_arg
extern "C" void wig_to_f2 (Bmad_wig_class*, c_Int&, const CPP_em_field_cartesian_map_term**,
    Int);

extern "C" void wig_to_f (const CPP_wig& C, Bmad_wig_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_term = C.term.size();
  const CPP_em_field_cartesian_map_term** z_term = NULL;
  if (n1_term != 0) {
    z_term = new const CPP_em_field_cartesian_map_term*[n1_term];
    for (int i = 0; i < n1_term; i++) z_term[i] = &C.term[i];
  }

  // c_side.to_f2_call
  wig_to_f2 (F, C.n_link, z_term, n1_term);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_term;
}

// c_side.to_c2_arg
extern "C" void wig_to_c2 (CPP_wig& C, c_Int& z_n_link,
    Bmad_em_field_cartesian_map_term_class** z_term, Int n1_term) {

  // c_side.to_c2_set[integer, 0, NOT]
  C.n_link = z_n_link;
  // c_side.to_c2_set[type, 1, ALLOC]
  C.term.resize(n1_term);
  for (int i = 0; i < n1_term; i++) em_field_cartesian_map_term_to_c(z_term[i], C.term[i]);

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_em_field_cartesian_map

extern "C" void em_field_cartesian_map_to_c (const Bmad_em_field_cartesian_map_class*, CPP_em_field_cartesian_map&);

// c_side.to_f2_arg
extern "C" void em_field_cartesian_map_to_f2 (Bmad_em_field_cartesian_map_class*, c_Char,
    c_Int&, c_Int&, const CPP_em_field_cartesian_map_term**, Int);

extern "C" void em_field_cartesian_map_to_f (const CPP_em_field_cartesian_map& C, Bmad_em_field_cartesian_map_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_term = C.term.size();
  const CPP_em_field_cartesian_map_term** z_term = NULL;
  if (n1_term != 0) {
    z_term = new const CPP_em_field_cartesian_map_term*[n1_term];
    for (int i = 0; i < n1_term; i++) z_term[i] = &C.term[i];
  }

  // c_side.to_f2_call
  em_field_cartesian_map_to_f2 (F, C.file.c_str(), C.n_link, C.ele_anchor_pt, z_term, n1_term);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_term;
}

// c_side.to_c2_arg
extern "C" void em_field_cartesian_map_to_c2 (CPP_em_field_cartesian_map& C, c_Char z_file,
    c_Int& z_n_link, c_Int& z_ele_anchor_pt, Bmad_em_field_cartesian_map_term_class** z_term,
    Int n1_term) {

  // c_side.to_c2_set[character, 0, NOT]
  C.file = z_file;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_link = z_n_link;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ele_anchor_pt = z_ele_anchor_pt;
  // c_side.to_c2_set[type, 1, ALLOC]
  C.term.resize(n1_term);
  for (int i = 0; i < n1_term; i++) em_field_cartesian_map_term_to_c(z_term[i], C.term[i]);

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_em_field_cartesian_map_term

extern "C" void em_field_cartesian_map_term_to_c (const Bmad_em_field_cartesian_map_term_class*, CPP_em_field_cartesian_map_term&);

// c_side.to_f2_arg
extern "C" void em_field_cartesian_map_term_to_f2 (Bmad_em_field_cartesian_map_term_class*,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Int&);

extern "C" void em_field_cartesian_map_term_to_f (const CPP_em_field_cartesian_map_term& C, Bmad_em_field_cartesian_map_term_class* F) {

  // c_side.to_f2_call
  em_field_cartesian_map_term_to_f2 (F, C.coef, C.kx, C.ky, C.kz, C.x0, C.y0, C.phi_z, C.type);

}

// c_side.to_c2_arg
extern "C" void em_field_cartesian_map_term_to_c2 (CPP_em_field_cartesian_map_term& C, c_Real&
    z_coef, c_Real& z_kx, c_Real& z_ky, c_Real& z_kz, c_Real& z_x0, c_Real& z_y0, c_Real&
    z_phi_z, c_Int& z_type) {

  // c_side.to_c2_set[real, 0, NOT]
  C.coef = z_coef;
  // c_side.to_c2_set[real, 0, NOT]
  C.kx = z_kx;
  // c_side.to_c2_set[real, 0, NOT]
  C.ky = z_ky;
  // c_side.to_c2_set[real, 0, NOT]
  C.kz = z_kz;
  // c_side.to_c2_set[real, 0, NOT]
  C.x0 = z_x0;
  // c_side.to_c2_set[real, 0, NOT]
  C.y0 = z_y0;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi_z = z_phi_z;
  // c_side.to_c2_set[integer, 0, NOT]
  C.type = z_type;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_em_field_cylindrical_map_term

extern "C" void em_field_cylindrical_map_term_to_c (const Bmad_em_field_cylindrical_map_term_class*, CPP_em_field_cylindrical_map_term&);

// c_side.to_f2_arg
extern "C" void em_field_cylindrical_map_term_to_f2 (Bmad_em_field_cylindrical_map_term_class*,
    c_Complex&, c_Complex&);

extern "C" void em_field_cylindrical_map_term_to_f (const CPP_em_field_cylindrical_map_term& C, Bmad_em_field_cylindrical_map_term_class* F) {

  // c_side.to_f2_call
  em_field_cylindrical_map_term_to_f2 (F, C.e_coef, C.b_coef);

}

// c_side.to_c2_arg
extern "C" void em_field_cylindrical_map_term_to_c2 (CPP_em_field_cylindrical_map_term& C,
    c_Complex& z_e_coef, c_Complex& z_b_coef) {

  // c_side.to_c2_set[complex, 0, NOT]
  C.e_coef = z_e_coef;
  // c_side.to_c2_set[complex, 0, NOT]
  C.b_coef = z_b_coef;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_em_field_cylindrical_map

extern "C" void em_field_cylindrical_map_to_c (const Bmad_em_field_cylindrical_map_class*, CPP_em_field_cylindrical_map&);

// c_side.to_f2_arg
extern "C" void em_field_cylindrical_map_to_f2 (Bmad_em_field_cylindrical_map_class*, c_Char,
    c_Int&, c_Int&, c_Real&, const CPP_em_field_cylindrical_map_term**, Int);

extern "C" void em_field_cylindrical_map_to_f (const CPP_em_field_cylindrical_map& C, Bmad_em_field_cylindrical_map_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_term = C.term.size();
  const CPP_em_field_cylindrical_map_term** z_term = NULL;
  if (n1_term != 0) {
    z_term = new const CPP_em_field_cylindrical_map_term*[n1_term];
    for (int i = 0; i < n1_term; i++) z_term[i] = &C.term[i];
  }

  // c_side.to_f2_call
  em_field_cylindrical_map_to_f2 (F, C.file.c_str(), C.n_link, C.ele_anchor_pt, C.dz, z_term,
      n1_term);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_term;
}

// c_side.to_c2_arg
extern "C" void em_field_cylindrical_map_to_c2 (CPP_em_field_cylindrical_map& C, c_Char z_file,
    c_Int& z_n_link, c_Int& z_ele_anchor_pt, c_Real& z_dz,
    Bmad_em_field_cylindrical_map_term_class** z_term, Int n1_term) {

  // c_side.to_c2_set[character, 0, NOT]
  C.file = z_file;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_link = z_n_link;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ele_anchor_pt = z_ele_anchor_pt;
  // c_side.to_c2_set[real, 0, NOT]
  C.dz = z_dz;
  // c_side.to_c2_set[type, 1, ALLOC]
  C.term.resize(n1_term);
  for (int i = 0; i < n1_term; i++) em_field_cylindrical_map_term_to_c(z_term[i], C.term[i]);

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_em_field_taylor

extern "C" void em_field_taylor_to_c (const Bmad_em_field_taylor_class*, CPP_em_field_taylor&);

// c_side.to_f2_arg
extern "C" void em_field_taylor_to_f2 (Bmad_em_field_taylor_class*, c_Char, c_Int&, c_Int&,
    const CPP_taylor**, Int, c_Real&, c_Real&, c_Bool&);

extern "C" void em_field_taylor_to_f (const CPP_em_field_taylor& C, Bmad_em_field_taylor_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_pt = C.pt.size();
  const CPP_taylor** z_pt = NULL;
  if (n1_pt != 0) {
    z_pt = new const CPP_taylor*[n1_pt];
    for (int i = 0; i < n1_pt; i++) z_pt[i] = &C.pt[i];
  }

  // c_side.to_f2_call
  em_field_taylor_to_f2 (F, C.file.c_str(), C.n_link, C.ele_anchor_pt, z_pt, n1_pt, C.dr, C.r0,
      C.curved_coords);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_pt;
}

// c_side.to_c2_arg
extern "C" void em_field_taylor_to_c2 (CPP_em_field_taylor& C, c_Char z_file, c_Int& z_n_link,
    c_Int& z_ele_anchor_pt, Bmad_taylor_class** z_pt, Int n1_pt, c_Real& z_dr, c_Real& z_r0,
    c_Bool& z_curved_coords) {

  // c_side.to_c2_set[character, 0, NOT]
  C.file = z_file;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_link = z_n_link;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ele_anchor_pt = z_ele_anchor_pt;
  // c_side.to_c2_set[type, 1, ALLOC]
  C.pt.resize(n1_pt);
  for (int i = 0; i < n1_pt; i++) taylor_to_c(z_pt[i], C.pt[i]);

  // c_side.to_c2_set[real, 0, NOT]
  C.dr = z_dr;
  // c_side.to_c2_set[real, 0, NOT]
  C.r0 = z_r0;
  // c_side.to_c2_set[logical, 0, NOT]
  C.curved_coords = z_curved_coords;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_em_field_grid_pt

extern "C" void em_field_grid_pt_to_c (const Bmad_em_field_grid_pt_class*, CPP_em_field_grid_pt&);

// c_side.to_f2_arg
extern "C" void em_field_grid_pt_to_f2 (Bmad_em_field_grid_pt_class*, c_ComplexArr,
    c_ComplexArr);

extern "C" void em_field_grid_pt_to_f (const CPP_em_field_grid_pt& C, Bmad_em_field_grid_pt_class* F) {

  // c_side.to_f2_call
  em_field_grid_pt_to_f2 (F, &C.e[0], &C.b[0]);

}

// c_side.to_c2_arg
extern "C" void em_field_grid_pt_to_c2 (CPP_em_field_grid_pt& C, c_ComplexArr z_e, c_ComplexArr
    z_b) {

  // c_side.to_c2_set[complex, 1, NOT]
  C.e << z_e;
  // c_side.to_c2_set[complex, 1, NOT]
  C.b << z_b;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_em_field_grid

extern "C" void em_field_grid_to_c (const Bmad_em_field_grid_class*, CPP_em_field_grid&);

// c_side.to_f2_arg
extern "C" void em_field_grid_to_f2 (Bmad_em_field_grid_class*, c_Char, c_Int&, c_Int&, c_Int&,
    const CPP_em_field_grid_pt**, Int, Int, Int, c_RealArr, c_RealArr, c_Bool&);

extern "C" void em_field_grid_to_f (const CPP_em_field_grid& C, Bmad_em_field_grid_class* F) {
  // c_side.to_f_setup[type, 3, ALLOC]

  int n1_pt = C.pt.size(), n2_pt = 0, n3_pt = 0;
  const CPP_em_field_grid_pt** z_pt = NULL;
  if (n1_pt > 0) {
    n2_pt = C.pt[0].size();
    n3_pt = C.pt[0][0].size();
    z_pt = new const CPP_em_field_grid_pt* [n1_pt*n2_pt*n3_pt];
    for (int i = 0; i < n1_pt; i++) {
      for (int j = 0; j < n2_pt; j++) {
        for (int k = 0; k < n3_pt; k++) {
          z_pt[i*n2_pt*n3_pt + j*n3_pt + k] = &C.pt[i][j][k];
    } } }
  }

  // c_side.to_f2_call
  em_field_grid_to_f2 (F, C.file.c_str(), C.n_link, C.type, C.ele_anchor_pt, z_pt, n1_pt,
      n2_pt, n3_pt, &C.dr[0], &C.r0[0], C.curved_coords);

  // c_side.to_f_cleanup[type, 3, ALLOC]
  delete[] z_pt;
}

// c_side.to_c2_arg
extern "C" void em_field_grid_to_c2 (CPP_em_field_grid& C, c_Char z_file, c_Int& z_n_link,
    c_Int& z_type, c_Int& z_ele_anchor_pt, Bmad_em_field_grid_pt_class** z_pt, Int n1_pt, Int
    n2_pt, Int n3_pt, c_RealArr z_dr, c_RealArr z_r0, c_Bool& z_curved_coords) {

  // c_side.to_c2_set[character, 0, NOT]
  C.file = z_file;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_link = z_n_link;
  // c_side.to_c2_set[integer, 0, NOT]
  C.type = z_type;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ele_anchor_pt = z_ele_anchor_pt;
  // c_side.to_c2_set[type, 3, ALLOC]

  C.pt.resize(n1_pt);
  for (int i = 0; i < n1_pt; i++) {
    C.pt[i].resize(n2_pt);
    for (int j = 0; j < n2_pt; j++) {
      C.pt[i][j].resize(n3_pt);
      for (int k = 0; k < n3_pt; k++) {
        em_field_grid_pt_to_c(z_pt[n3_pt*n2_pt*i+n3_pt*j+k], C.pt[i][j][k]);
    } } }

  // c_side.to_c2_set[real, 1, NOT]
  C.dr << z_dr;
  // c_side.to_c2_set[real, 1, NOT]
  C.r0 << z_r0;
  // c_side.to_c2_set[logical, 0, NOT]
  C.curved_coords = z_curved_coords;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_em_field_mode

extern "C" void em_field_mode_to_c (const Bmad_em_field_mode_class*, CPP_em_field_mode&);

// c_side.to_f2_arg
extern "C" void em_field_mode_to_f2 (Bmad_em_field_mode_class*, c_Int&, c_Int&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Int&, const CPP_em_field_grid&, Int, const
    CPP_em_field_cylindrical_map&, Int, const CPP_em_field_cartesian_map&, Int, const
    CPP_em_field_taylor&, Int);

extern "C" void em_field_mode_to_f (const CPP_em_field_mode& C, Bmad_em_field_mode_class* F) {
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_grid = 0; if (C.grid != NULL) n_grid = 1;
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_cylindrical_map = 0; if (C.cylindrical_map != NULL) n_cylindrical_map = 1;
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_cartesian_map = 0; if (C.cartesian_map != NULL) n_cartesian_map = 1;
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_taylor = 0; if (C.taylor != NULL) n_taylor = 1;

  // c_side.to_f2_call
  em_field_mode_to_f2 (F, C.m, C.harmonic, C.f_damp, C.phi0_ref, C.stored_energy,
      C.phi0_azimuth, C.field_scale, C.master_scale, *C.grid, n_grid, *C.cylindrical_map,
      n_cylindrical_map, *C.cartesian_map, n_cartesian_map, *C.taylor, n_taylor);

}

// c_side.to_c2_arg
extern "C" void em_field_mode_to_c2 (CPP_em_field_mode& C, c_Int& z_m, c_Int& z_harmonic,
    c_Real& z_f_damp, c_Real& z_phi0_ref, c_Real& z_stored_energy, c_Real& z_phi0_azimuth,
    c_Real& z_field_scale, c_Int& z_master_scale, Bmad_em_field_grid_class* z_grid, Int n_grid,
    Bmad_em_field_cylindrical_map_class* z_cylindrical_map, Int n_cylindrical_map,
    Bmad_em_field_cartesian_map_class* z_cartesian_map, Int n_cartesian_map,
    Bmad_em_field_taylor_class* z_taylor, Int n_taylor) {

  // c_side.to_c2_set[integer, 0, NOT]
  C.m = z_m;
  // c_side.to_c2_set[integer, 0, NOT]
  C.harmonic = z_harmonic;
  // c_side.to_c2_set[real, 0, NOT]
  C.f_damp = z_f_damp;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi0_ref = z_phi0_ref;
  // c_side.to_c2_set[real, 0, NOT]
  C.stored_energy = z_stored_energy;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi0_azimuth = z_phi0_azimuth;
  // c_side.to_c2_set[real, 0, NOT]
  C.field_scale = z_field_scale;
  // c_side.to_c2_set[integer, 0, NOT]
  C.master_scale = z_master_scale;
  // c_side.to_c2_set[type, 0, PTR]
  if (n_grid == 0)
    delete C.grid;
  else {
    C.grid = new CPP_em_field_grid;
    em_field_grid_to_c(z_grid, *C.grid);
  }

  // c_side.to_c2_set[type, 0, PTR]
  if (n_cylindrical_map == 0)
    delete C.cylindrical_map;
  else {
    C.cylindrical_map = new CPP_em_field_cylindrical_map;
    em_field_cylindrical_map_to_c(z_cylindrical_map, *C.cylindrical_map);
  }

  // c_side.to_c2_set[type, 0, PTR]
  if (n_cartesian_map == 0)
    delete C.cartesian_map;
  else {
    C.cartesian_map = new CPP_em_field_cartesian_map;
    em_field_cartesian_map_to_c(z_cartesian_map, *C.cartesian_map);
  }

  // c_side.to_c2_set[type, 0, PTR]
  if (n_taylor == 0)
    delete C.taylor;
  else {
    C.taylor = new CPP_em_field_taylor;
    em_field_taylor_to_c(z_taylor, *C.taylor);
  }

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_em_fields

extern "C" void em_fields_to_c (const Bmad_em_fields_class*, CPP_em_fields&);

// c_side.to_f2_arg
extern "C" void em_fields_to_f2 (Bmad_em_fields_class*, const CPP_em_field_mode**, Int,
    c_Int&);

extern "C" void em_fields_to_f (const CPP_em_fields& C, Bmad_em_fields_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_mode = C.mode.size();
  const CPP_em_field_mode** z_mode = NULL;
  if (n1_mode != 0) {
    z_mode = new const CPP_em_field_mode*[n1_mode];
    for (int i = 0; i < n1_mode; i++) z_mode[i] = &C.mode[i];
  }

  // c_side.to_f2_call
  em_fields_to_f2 (F, z_mode, n1_mode, C.mode_to_autoscale);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_mode;
}

// c_side.to_c2_arg
extern "C" void em_fields_to_c2 (CPP_em_fields& C, Bmad_em_field_mode_class** z_mode, Int
    n1_mode, c_Int& z_mode_to_autoscale) {

  // c_side.to_c2_set[type, 1, ALLOC]
  C.mode.resize(n1_mode);
  for (int i = 0; i < n1_mode; i++) em_field_mode_to_c(z_mode[i], C.mode[i]);

  // c_side.to_c2_set[integer, 0, NOT]
  C.mode_to_autoscale = z_mode_to_autoscale;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_floor_position

extern "C" void floor_position_to_c (const Bmad_floor_position_class*, CPP_floor_position&);

// c_side.to_f2_arg
extern "C" void floor_position_to_f2 (Bmad_floor_position_class*, c_RealArr, c_RealArr,
    c_Real&, c_Real&, c_Real&);

extern "C" void floor_position_to_f (const CPP_floor_position& C, Bmad_floor_position_class* F) {
  // c_side.to_f_setup[real, 2, NOT]
  Real z_w[3*3]; matrix_to_vec(C.w, z_w);

  // c_side.to_f2_call
  floor_position_to_f2 (F, &C.r[0], z_w, C.theta, C.phi, C.psi);

}

// c_side.to_c2_arg
extern "C" void floor_position_to_c2 (CPP_floor_position& C, c_RealArr z_r, c_RealArr z_w,
    c_Real& z_theta, c_Real& z_phi, c_Real& z_psi) {

  // c_side.to_c2_set[real, 1, NOT]
  C.r << z_r;
  // c_side.to_c2_set[real, 2, NOT]
  C.w << z_w;
  // c_side.to_c2_set[real, 0, NOT]
  C.theta = z_theta;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi = z_phi;
  // c_side.to_c2_set[real, 0, NOT]
  C.psi = z_psi;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_space_charge

extern "C" void space_charge_to_c (const Bmad_space_charge_class*, CPP_space_charge&);

// c_side.to_f2_arg
extern "C" void space_charge_to_f2 (Bmad_space_charge_class*, const CPP_coord&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&);

extern "C" void space_charge_to_f (const CPP_space_charge& C, Bmad_space_charge_class* F) {

  // c_side.to_f2_call
  space_charge_to_f2 (F, C.closed_orb, C.kick_const, C.sig_x, C.sig_y, C.phi, C.sin_phi,
      C.cos_phi, C.sig_z);

}

// c_side.to_c2_arg
extern "C" void space_charge_to_c2 (CPP_space_charge& C, const Bmad_coord_class* z_closed_orb,
    c_Real& z_kick_const, c_Real& z_sig_x, c_Real& z_sig_y, c_Real& z_phi, c_Real& z_sin_phi,
    c_Real& z_cos_phi, c_Real& z_sig_z) {

  // c_side.to_c2_set[type, 0, NOT]
  coord_to_c(z_closed_orb, C.closed_orb);
  // c_side.to_c2_set[real, 0, NOT]
  C.kick_const = z_kick_const;
  // c_side.to_c2_set[real, 0, NOT]
  C.sig_x = z_sig_x;
  // c_side.to_c2_set[real, 0, NOT]
  C.sig_y = z_sig_y;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi = z_phi;
  // c_side.to_c2_set[real, 0, NOT]
  C.sin_phi = z_sin_phi;
  // c_side.to_c2_set[real, 0, NOT]
  C.cos_phi = z_cos_phi;
  // c_side.to_c2_set[real, 0, NOT]
  C.sig_z = z_sig_z;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_xy_disp

extern "C" void xy_disp_to_c (const Bmad_xy_disp_class*, CPP_xy_disp&);

// c_side.to_f2_arg
extern "C" void xy_disp_to_f2 (Bmad_xy_disp_class*, c_Real&, c_Real&);

extern "C" void xy_disp_to_f (const CPP_xy_disp& C, Bmad_xy_disp_class* F) {

  // c_side.to_f2_call
  xy_disp_to_f2 (F, C.eta, C.etap);

}

// c_side.to_c2_arg
extern "C" void xy_disp_to_c2 (CPP_xy_disp& C, c_Real& z_eta, c_Real& z_etap) {

  // c_side.to_c2_set[real, 0, NOT]
  C.eta = z_eta;
  // c_side.to_c2_set[real, 0, NOT]
  C.etap = z_etap;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_twiss

extern "C" void twiss_to_c (const Bmad_twiss_class*, CPP_twiss&);

// c_side.to_f2_arg
extern "C" void twiss_to_f2 (Bmad_twiss_class*, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&);

extern "C" void twiss_to_f (const CPP_twiss& C, Bmad_twiss_class* F) {

  // c_side.to_f2_call
  twiss_to_f2 (F, C.beta, C.alpha, C.gamma, C.phi, C.eta, C.etap, C.sigma, C.sigma_p, C.emit,
      C.norm_emit);

}

// c_side.to_c2_arg
extern "C" void twiss_to_c2 (CPP_twiss& C, c_Real& z_beta, c_Real& z_alpha, c_Real& z_gamma,
    c_Real& z_phi, c_Real& z_eta, c_Real& z_etap, c_Real& z_sigma, c_Real& z_sigma_p, c_Real&
    z_emit, c_Real& z_norm_emit) {

  // c_side.to_c2_set[real, 0, NOT]
  C.beta = z_beta;
  // c_side.to_c2_set[real, 0, NOT]
  C.alpha = z_alpha;
  // c_side.to_c2_set[real, 0, NOT]
  C.gamma = z_gamma;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi = z_phi;
  // c_side.to_c2_set[real, 0, NOT]
  C.eta = z_eta;
  // c_side.to_c2_set[real, 0, NOT]
  C.etap = z_etap;
  // c_side.to_c2_set[real, 0, NOT]
  C.sigma = z_sigma;
  // c_side.to_c2_set[real, 0, NOT]
  C.sigma_p = z_sigma_p;
  // c_side.to_c2_set[real, 0, NOT]
  C.emit = z_emit;
  // c_side.to_c2_set[real, 0, NOT]
  C.norm_emit = z_norm_emit;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_mode3

extern "C" void mode3_to_c (const Bmad_mode3_class*, CPP_mode3&);

// c_side.to_f2_arg
extern "C" void mode3_to_f2 (Bmad_mode3_class*, c_RealArr, const CPP_twiss&, const CPP_twiss&,
    const CPP_twiss&, const CPP_twiss&, const CPP_twiss&);

extern "C" void mode3_to_f (const CPP_mode3& C, Bmad_mode3_class* F) {
  // c_side.to_f_setup[real, 2, NOT]
  Real z_v[6*6]; matrix_to_vec(C.v, z_v);

  // c_side.to_f2_call
  mode3_to_f2 (F, z_v, C.a, C.b, C.c, C.x, C.y);

}

// c_side.to_c2_arg
extern "C" void mode3_to_c2 (CPP_mode3& C, c_RealArr z_v, const Bmad_twiss_class* z_a, const
    Bmad_twiss_class* z_b, const Bmad_twiss_class* z_c, const Bmad_twiss_class* z_x, const
    Bmad_twiss_class* z_y) {

  // c_side.to_c2_set[real, 2, NOT]
  C.v << z_v;
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_a, C.a);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_b, C.b);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_c, C.c);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_x, C.x);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_y, C.y);
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_bookkeeping_state

extern "C" void bookkeeping_state_to_c (const Bmad_bookkeeping_state_class*, CPP_bookkeeping_state&);

// c_side.to_f2_arg
extern "C" void bookkeeping_state_to_f2 (Bmad_bookkeeping_state_class*, c_Int&, c_Int&, c_Int&,
    c_Int&, c_Int&, c_Int&, c_Int&, c_Int&);

extern "C" void bookkeeping_state_to_f (const CPP_bookkeeping_state& C, Bmad_bookkeeping_state_class* F) {

  // c_side.to_f2_call
  bookkeeping_state_to_f2 (F, C.attributes, C.control, C.floor_position, C.s_position,
      C.ref_energy, C.mat6, C.rad_int, C.ptc);

}

// c_side.to_c2_arg
extern "C" void bookkeeping_state_to_c2 (CPP_bookkeeping_state& C, c_Int& z_attributes, c_Int&
    z_control, c_Int& z_floor_position, c_Int& z_s_position, c_Int& z_ref_energy, c_Int&
    z_mat6, c_Int& z_rad_int, c_Int& z_ptc) {

  // c_side.to_c2_set[integer, 0, NOT]
  C.attributes = z_attributes;
  // c_side.to_c2_set[integer, 0, NOT]
  C.control = z_control;
  // c_side.to_c2_set[integer, 0, NOT]
  C.floor_position = z_floor_position;
  // c_side.to_c2_set[integer, 0, NOT]
  C.s_position = z_s_position;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ref_energy = z_ref_energy;
  // c_side.to_c2_set[integer, 0, NOT]
  C.mat6 = z_mat6;
  // c_side.to_c2_set[integer, 0, NOT]
  C.rad_int = z_rad_int;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ptc = z_ptc;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_rad_int_ele_cache

extern "C" void rad_int_ele_cache_to_c (const Bmad_rad_int_ele_cache_class*, CPP_rad_int_ele_cache&);

// c_side.to_f2_arg
extern "C" void rad_int_ele_cache_to_f2 (Bmad_rad_int_ele_cache_class*, c_RealArr, c_Real&,
    c_Real&, c_RealArr, c_RealArr, c_Bool&);

extern "C" void rad_int_ele_cache_to_f (const CPP_rad_int_ele_cache& C, Bmad_rad_int_ele_cache_class* F) {

  // c_side.to_f2_call
  rad_int_ele_cache_to_f2 (F, &C.orb0[0], C.g2_0, C.g3_0, &C.dg2_dorb[0], &C.dg3_dorb[0],
      C.stale);

}

// c_side.to_c2_arg
extern "C" void rad_int_ele_cache_to_c2 (CPP_rad_int_ele_cache& C, c_RealArr z_orb0, c_Real&
    z_g2_0, c_Real& z_g3_0, c_RealArr z_dg2_dorb, c_RealArr z_dg3_dorb, c_Bool& z_stale) {

  // c_side.to_c2_set[real, 1, NOT]
  C.orb0 << z_orb0;
  // c_side.to_c2_set[real, 0, NOT]
  C.g2_0 = z_g2_0;
  // c_side.to_c2_set[real, 0, NOT]
  C.g3_0 = z_g3_0;
  // c_side.to_c2_set[real, 1, NOT]
  C.dg2_dorb << z_dg2_dorb;
  // c_side.to_c2_set[real, 1, NOT]
  C.dg3_dorb << z_dg3_dorb;
  // c_side.to_c2_set[logical, 0, NOT]
  C.stale = z_stale;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_surface_grid_pt

extern "C" void surface_grid_pt_to_c (const Bmad_surface_grid_pt_class*, CPP_surface_grid_pt&);

// c_side.to_f2_arg
extern "C" void surface_grid_pt_to_f2 (Bmad_surface_grid_pt_class*, const
    CPP_surface_orientation&, c_Int&, c_Complex&, c_Complex&, c_Real&, c_Real&, c_Real&,
    c_RealArr, c_RealArr, c_RealArr, c_RealArr);

extern "C" void surface_grid_pt_to_f (const CPP_surface_grid_pt& C, Bmad_surface_grid_pt_class* F) {

  // c_side.to_f2_call
  surface_grid_pt_to_f2 (F, C.orientation, C.n_photon, C.e_x, C.e_y, C.intensity_x,
      C.intensity_y, C.intensity, &C.orbit[0], &C.orbit_rms[0], &C.init_orbit[0],
      &C.init_orbit_rms[0]);

}

// c_side.to_c2_arg
extern "C" void surface_grid_pt_to_c2 (CPP_surface_grid_pt& C, const
    Bmad_surface_orientation_class* z_orientation, c_Int& z_n_photon, c_Complex& z_e_x,
    c_Complex& z_e_y, c_Real& z_intensity_x, c_Real& z_intensity_y, c_Real& z_intensity,
    c_RealArr z_orbit, c_RealArr z_orbit_rms, c_RealArr z_init_orbit, c_RealArr
    z_init_orbit_rms) {

  // c_side.to_c2_set[type, 0, NOT]
  surface_orientation_to_c(z_orientation, C.orientation);
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_photon = z_n_photon;
  // c_side.to_c2_set[complex, 0, NOT]
  C.e_x = z_e_x;
  // c_side.to_c2_set[complex, 0, NOT]
  C.e_y = z_e_y;
  // c_side.to_c2_set[real, 0, NOT]
  C.intensity_x = z_intensity_x;
  // c_side.to_c2_set[real, 0, NOT]
  C.intensity_y = z_intensity_y;
  // c_side.to_c2_set[real, 0, NOT]
  C.intensity = z_intensity;
  // c_side.to_c2_set[real, 1, NOT]
  C.orbit << z_orbit;
  // c_side.to_c2_set[real, 1, NOT]
  C.orbit_rms << z_orbit_rms;
  // c_side.to_c2_set[real, 1, NOT]
  C.init_orbit << z_init_orbit;
  // c_side.to_c2_set[real, 1, NOT]
  C.init_orbit_rms << z_init_orbit_rms;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_surface_grid

extern "C" void surface_grid_to_c (const Bmad_surface_grid_class*, CPP_surface_grid&);

// c_side.to_f2_arg
extern "C" void surface_grid_to_f2 (Bmad_surface_grid_class*, c_Char, c_Int&, c_RealArr,
    c_RealArr, const CPP_surface_grid_pt**, Int, Int);

extern "C" void surface_grid_to_f (const CPP_surface_grid& C, Bmad_surface_grid_class* F) {
  // c_side.to_f_setup[type, 2, ALLOC]

  int n1_pt = C.pt.size(), n2_pt = 0;
  const CPP_surface_grid_pt** z_pt = NULL;
  if (n1_pt > 0) {
    n2_pt = C.pt[0].size();
    z_pt = new const CPP_surface_grid_pt* [n1_pt*n2_pt];
    for (int i = 0; i < n1_pt; i++) {
      for (int j = 0; j < n2_pt; j++) z_pt[i*n2_pt + j] = &C.pt[i][j];}
  }

  // c_side.to_f2_call
  surface_grid_to_f2 (F, C.file.c_str(), C.type, &C.dr[0], &C.r0[0], z_pt, n1_pt, n2_pt);

  // c_side.to_f_cleanup[type, 2, ALLOC]
  delete[] z_pt;
}

// c_side.to_c2_arg
extern "C" void surface_grid_to_c2 (CPP_surface_grid& C, c_Char z_file, c_Int& z_type,
    c_RealArr z_dr, c_RealArr z_r0, Bmad_surface_grid_pt_class** z_pt, Int n1_pt, Int n2_pt) {

  // c_side.to_c2_set[character, 0, NOT]
  C.file = z_file;
  // c_side.to_c2_set[integer, 0, NOT]
  C.type = z_type;
  // c_side.to_c2_set[real, 1, NOT]
  C.dr << z_dr;
  // c_side.to_c2_set[real, 1, NOT]
  C.r0 << z_r0;
  // c_side.to_c2_set[type, 2, ALLOC]
  C.pt.resize(n1_pt);
  for (int i = 0; i < n1_pt; i++) {
    C.pt[i].resize(n2_pt);
    for (int j = 0; j < n2_pt; j++) surface_grid_pt_to_c(z_pt[n2_pt*i+j], C.pt[i][j]);
  }

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_segmented_surface

extern "C" void segmented_surface_to_c (const Bmad_segmented_surface_class*, CPP_segmented_surface&);

// c_side.to_f2_arg
extern "C" void segmented_surface_to_f2 (Bmad_segmented_surface_class*, c_Int&, c_Int&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&);

extern "C" void segmented_surface_to_f (const CPP_segmented_surface& C, Bmad_segmented_surface_class* F) {

  // c_side.to_f2_call
  segmented_surface_to_f2 (F, C.ix, C.iy, C.x0, C.y0, C.z0, C.slope_x, C.slope_y);

}

// c_side.to_c2_arg
extern "C" void segmented_surface_to_c2 (CPP_segmented_surface& C, c_Int& z_ix, c_Int& z_iy,
    c_Real& z_x0, c_Real& z_y0, c_Real& z_z0, c_Real& z_slope_x, c_Real& z_slope_y) {

  // c_side.to_c2_set[integer, 0, NOT]
  C.ix = z_ix;
  // c_side.to_c2_set[integer, 0, NOT]
  C.iy = z_iy;
  // c_side.to_c2_set[real, 0, NOT]
  C.x0 = z_x0;
  // c_side.to_c2_set[real, 0, NOT]
  C.y0 = z_y0;
  // c_side.to_c2_set[real, 0, NOT]
  C.z0 = z_z0;
  // c_side.to_c2_set[real, 0, NOT]
  C.slope_x = z_slope_x;
  // c_side.to_c2_set[real, 0, NOT]
  C.slope_y = z_slope_y;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_target_point

extern "C" void target_point_to_c (const Bmad_target_point_class*, CPP_target_point&);

// c_side.to_f2_arg
extern "C" void target_point_to_f2 (Bmad_target_point_class*, c_RealArr);

extern "C" void target_point_to_f (const CPP_target_point& C, Bmad_target_point_class* F) {

  // c_side.to_f2_call
  target_point_to_f2 (F, &C.r[0]);

}

// c_side.to_c2_arg
extern "C" void target_point_to_c2 (CPP_target_point& C, c_RealArr z_r) {

  // c_side.to_c2_set[real, 1, NOT]
  C.r << z_r;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_photon_surface

extern "C" void photon_surface_to_c (const Bmad_photon_surface_class*, CPP_photon_surface&);

// c_side.to_f2_arg
extern "C" void photon_surface_to_f2 (Bmad_photon_surface_class*, const CPP_surface_grid&,
    const CPP_segmented_surface&, c_RealArr, c_Bool&);

extern "C" void photon_surface_to_f (const CPP_photon_surface& C, Bmad_photon_surface_class* F) {
  // c_side.to_f_setup[real, 2, NOT]
  Real z_curvature_xy[7*7]; matrix_to_vec(C.curvature_xy, z_curvature_xy);

  // c_side.to_f2_call
  photon_surface_to_f2 (F, C.grid, C.segment, z_curvature_xy, C.has_curvature);

}

// c_side.to_c2_arg
extern "C" void photon_surface_to_c2 (CPP_photon_surface& C, const Bmad_surface_grid_class*
    z_grid, const Bmad_segmented_surface_class* z_segment, c_RealArr z_curvature_xy, c_Bool&
    z_has_curvature) {

  // c_side.to_c2_set[type, 0, NOT]
  surface_grid_to_c(z_grid, C.grid);
  // c_side.to_c2_set[type, 0, NOT]
  segmented_surface_to_c(z_segment, C.segment);
  // c_side.to_c2_set[real, 2, NOT]
  C.curvature_xy << z_curvature_xy;
  // c_side.to_c2_set[logical, 0, NOT]
  C.has_curvature = z_has_curvature;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_photon_target

extern "C" void photon_target_to_c (const Bmad_photon_target_class*, CPP_photon_target&);

// c_side.to_f2_arg
extern "C" void photon_target_to_f2 (Bmad_photon_target_class*, c_Bool&, c_Int&, c_Int&,
    c_Int&, c_Int&, const CPP_lat_ele_loc&, const CPP_target_point**, const CPP_target_point&);

extern "C" void photon_target_to_f (const CPP_photon_target& C, Bmad_photon_target_class* F) {
  // c_side.to_f_setup[type, 1, NOT]
  const CPP_target_point* z_corner[8];
  for (int i = 0; i < 8; i++) {z_corner[i] = &C.corner[i];}

  // c_side.to_f2_call
  photon_target_to_f2 (F, C.deterministic_grid, C.ix_grid, C.iy_grid, C.type, C.n_corner,
      C.ele_loc, z_corner, C.center);

}

// c_side.to_c2_arg
extern "C" void photon_target_to_c2 (CPP_photon_target& C, c_Bool& z_deterministic_grid, c_Int&
    z_ix_grid, c_Int& z_iy_grid, c_Int& z_type, c_Int& z_n_corner, const
    Bmad_lat_ele_loc_class* z_ele_loc, const Bmad_target_point_class** z_corner, const
    Bmad_target_point_class* z_center) {

  // c_side.to_c2_set[logical, 0, NOT]
  C.deterministic_grid = z_deterministic_grid;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_grid = z_ix_grid;
  // c_side.to_c2_set[integer, 0, NOT]
  C.iy_grid = z_iy_grid;
  // c_side.to_c2_set[integer, 0, NOT]
  C.type = z_type;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_corner = z_n_corner;
  // c_side.to_c2_set[type, 0, NOT]
  lat_ele_loc_to_c(z_ele_loc, C.ele_loc);
  // c_side.to_c2_set[type, 1, NOT]
  for (unsigned int i = 0; i < C.corner.size(); i++) target_point_to_c(z_corner[i], C.corner[i]);
  // c_side.to_c2_set[type, 0, NOT]
  target_point_to_c(z_center, C.center);
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_photon_material

extern "C" void photon_material_to_c (const Bmad_photon_material_class*, CPP_photon_material&);

// c_side.to_f2_arg
extern "C" void photon_material_to_f2 (Bmad_photon_material_class*, c_Complex&, c_Complex&,
    c_Complex&, c_Complex&, c_Complex&, c_Complex&, c_RealArr, c_RealArr);

extern "C" void photon_material_to_f (const CPP_photon_material& C, Bmad_photon_material_class* F) {

  // c_side.to_f2_call
  photon_material_to_f2 (F, C.f0_m1, C.f0_m2, C.f_0, C.f_h, C.f_hbar, C.f_hkl, &C.h_norm[0],
      &C.l_ref[0]);

}

// c_side.to_c2_arg
extern "C" void photon_material_to_c2 (CPP_photon_material& C, c_Complex& z_f0_m1, c_Complex&
    z_f0_m2, c_Complex& z_f_0, c_Complex& z_f_h, c_Complex& z_f_hbar, c_Complex& z_f_hkl,
    c_RealArr z_h_norm, c_RealArr z_l_ref) {

  // c_side.to_c2_set[complex, 0, NOT]
  C.f0_m1 = z_f0_m1;
  // c_side.to_c2_set[complex, 0, NOT]
  C.f0_m2 = z_f0_m2;
  // c_side.to_c2_set[complex, 0, NOT]
  C.f_0 = z_f_0;
  // c_side.to_c2_set[complex, 0, NOT]
  C.f_h = z_f_h;
  // c_side.to_c2_set[complex, 0, NOT]
  C.f_hbar = z_f_hbar;
  // c_side.to_c2_set[complex, 0, NOT]
  C.f_hkl = z_f_hkl;
  // c_side.to_c2_set[real, 1, NOT]
  C.h_norm << z_h_norm;
  // c_side.to_c2_set[real, 1, NOT]
  C.l_ref << z_l_ref;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_photon_element

extern "C" void photon_element_to_c (const Bmad_photon_element_class*, CPP_photon_element&);

// c_side.to_f2_arg
extern "C" void photon_element_to_f2 (Bmad_photon_element_class*, const CPP_photon_surface&,
    const CPP_photon_target&, const CPP_photon_material&);

extern "C" void photon_element_to_f (const CPP_photon_element& C, Bmad_photon_element_class* F) {

  // c_side.to_f2_call
  photon_element_to_f2 (F, C.surface, C.target, C.material);

}

// c_side.to_c2_arg
extern "C" void photon_element_to_c2 (CPP_photon_element& C, const Bmad_photon_surface_class*
    z_surface, const Bmad_photon_target_class* z_target, const Bmad_photon_material_class*
    z_material) {

  // c_side.to_c2_set[type, 0, NOT]
  photon_surface_to_c(z_surface, C.surface);
  // c_side.to_c2_set[type, 0, NOT]
  photon_target_to_c(z_target, C.target);
  // c_side.to_c2_set[type, 0, NOT]
  photon_material_to_c(z_material, C.material);
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_wall3d_vertex

extern "C" void wall3d_vertex_to_c (const Bmad_wall3d_vertex_class*, CPP_wall3d_vertex&);

// c_side.to_f2_arg
extern "C" void wall3d_vertex_to_f2 (Bmad_wall3d_vertex_class*, c_Real&, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Int&);

extern "C" void wall3d_vertex_to_f (const CPP_wall3d_vertex& C, Bmad_wall3d_vertex_class* F) {

  // c_side.to_f2_call
  wall3d_vertex_to_f2 (F, C.x, C.y, C.radius_x, C.radius_y, C.tilt, C.angle, C.x0, C.y0,
      C.type);

}

// c_side.to_c2_arg
extern "C" void wall3d_vertex_to_c2 (CPP_wall3d_vertex& C, c_Real& z_x, c_Real& z_y, c_Real&
    z_radius_x, c_Real& z_radius_y, c_Real& z_tilt, c_Real& z_angle, c_Real& z_x0, c_Real&
    z_y0, c_Int& z_type) {

  // c_side.to_c2_set[real, 0, NOT]
  C.x = z_x;
  // c_side.to_c2_set[real, 0, NOT]
  C.y = z_y;
  // c_side.to_c2_set[real, 0, NOT]
  C.radius_x = z_radius_x;
  // c_side.to_c2_set[real, 0, NOT]
  C.radius_y = z_radius_y;
  // c_side.to_c2_set[real, 0, NOT]
  C.tilt = z_tilt;
  // c_side.to_c2_set[real, 0, NOT]
  C.angle = z_angle;
  // c_side.to_c2_set[real, 0, NOT]
  C.x0 = z_x0;
  // c_side.to_c2_set[real, 0, NOT]
  C.y0 = z_y0;
  // c_side.to_c2_set[integer, 0, NOT]
  C.type = z_type;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_wall3d_section

extern "C" void wall3d_section_to_c (const Bmad_wall3d_section_class*, CPP_wall3d_section&);

// c_side.to_f2_arg
extern "C" void wall3d_section_to_f2 (Bmad_wall3d_section_class*, c_Char, c_Char, const
    CPP_wall3d_vertex**, Int, const CPP_photon_reflect_surface&, Int, c_Int&, c_Int&, c_Int&,
    c_Int&, c_Bool&, c_Bool&, c_Real&, c_Real&, c_RealArr, c_Real&, c_Real&, c_RealArr,
    c_RealArr, c_Real&, c_RealArr, c_RealArr);

extern "C" void wall3d_section_to_f (const CPP_wall3d_section& C, Bmad_wall3d_section_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_v = C.v.size();
  const CPP_wall3d_vertex** z_v = NULL;
  if (n1_v != 0) {
    z_v = new const CPP_wall3d_vertex*[n1_v];
    for (int i = 0; i < n1_v; i++) z_v[i] = &C.v[i];
  }
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_surface = 0; if (C.surface != NULL) n_surface = 1;

  // c_side.to_f2_call
  wall3d_section_to_f2 (F, C.name.c_str(), C.material.c_str(), z_v, n1_v, *C.surface,
      n_surface, C.type, C.n_vertex_input, C.ix_ele, C.ix_branch, C.patch_in_region,
      C.absolute_vertices_input, C.thickness, C.s, &C.r0[0], C.dx0_ds, C.dy0_ds, &C.x0_coef[0],
      &C.y0_coef[0], C.dr_ds, &C.p1_coef[0], &C.p2_coef[0]);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_v;
}

// c_side.to_c2_arg
extern "C" void wall3d_section_to_c2 (CPP_wall3d_section& C, c_Char z_name, c_Char z_material,
    Bmad_wall3d_vertex_class** z_v, Int n1_v, Bmad_photon_reflect_surface_class* z_surface, Int
    n_surface, c_Int& z_type, c_Int& z_n_vertex_input, c_Int& z_ix_ele, c_Int& z_ix_branch,
    c_Bool& z_patch_in_region, c_Bool& z_absolute_vertices_input, c_Real& z_thickness, c_Real&
    z_s, c_RealArr z_r0, c_Real& z_dx0_ds, c_Real& z_dy0_ds, c_RealArr z_x0_coef, c_RealArr
    z_y0_coef, c_Real& z_dr_ds, c_RealArr z_p1_coef, c_RealArr z_p2_coef) {

  // c_side.to_c2_set[character, 0, NOT]
  C.name = z_name;
  // c_side.to_c2_set[character, 0, NOT]
  C.material = z_material;
  // c_side.to_c2_set[type, 1, ALLOC]
  C.v.resize(n1_v);
  for (int i = 0; i < n1_v; i++) wall3d_vertex_to_c(z_v[i], C.v[i]);

  // c_side.to_c2_set[type, 0, PTR]
  if (n_surface == 0)
    delete C.surface;
  else {
    C.surface = new CPP_photon_reflect_surface;
    photon_reflect_surface_to_c(z_surface, *C.surface);
  }

  // c_side.to_c2_set[integer, 0, NOT]
  C.type = z_type;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_vertex_input = z_n_vertex_input;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_ele = z_ix_ele;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_branch = z_ix_branch;
  // c_side.to_c2_set[logical, 0, NOT]
  C.patch_in_region = z_patch_in_region;
  // c_side.to_c2_set[logical, 0, NOT]
  C.absolute_vertices_input = z_absolute_vertices_input;
  // c_side.to_c2_set[real, 0, NOT]
  C.thickness = z_thickness;
  // c_side.to_c2_set[real, 0, NOT]
  C.s = z_s;
  // c_side.to_c2_set[real, 1, NOT]
  C.r0 << z_r0;
  // c_side.to_c2_set[real, 0, NOT]
  C.dx0_ds = z_dx0_ds;
  // c_side.to_c2_set[real, 0, NOT]
  C.dy0_ds = z_dy0_ds;
  // c_side.to_c2_set[real, 1, NOT]
  C.x0_coef << z_x0_coef;
  // c_side.to_c2_set[real, 1, NOT]
  C.y0_coef << z_y0_coef;
  // c_side.to_c2_set[real, 0, NOT]
  C.dr_ds = z_dr_ds;
  // c_side.to_c2_set[real, 1, NOT]
  C.p1_coef << z_p1_coef;
  // c_side.to_c2_set[real, 1, NOT]
  C.p2_coef << z_p2_coef;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_wall3d

extern "C" void wall3d_to_c (const Bmad_wall3d_class*, CPP_wall3d&);

// c_side.to_f2_arg
extern "C" void wall3d_to_f2 (Bmad_wall3d_class*, c_Char, c_Int&, c_Int&, c_Int&, c_Real&,
    c_Char, c_Char, c_Bool&, c_Int&, const CPP_wall3d_section**, Int);

extern "C" void wall3d_to_f (const CPP_wall3d& C, Bmad_wall3d_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_section = C.section.size();
  const CPP_wall3d_section** z_section = NULL;
  if (n1_section != 0) {
    z_section = new const CPP_wall3d_section*[n1_section];
    for (int i = 0; i < n1_section; i++) z_section[i] = &C.section[i];
  }

  // c_side.to_f2_call
  wall3d_to_f2 (F, C.name.c_str(), C.type, C.ix_wall3d, C.n_link, C.thickness,
      C.clear_material.c_str(), C.opaque_material.c_str(), C.superimpose, C.ele_anchor_pt,
      z_section, n1_section);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_section;
}

// c_side.to_c2_arg
extern "C" void wall3d_to_c2 (CPP_wall3d& C, c_Char z_name, c_Int& z_type, c_Int& z_ix_wall3d,
    c_Int& z_n_link, c_Real& z_thickness, c_Char z_clear_material, c_Char z_opaque_material,
    c_Bool& z_superimpose, c_Int& z_ele_anchor_pt, Bmad_wall3d_section_class** z_section, Int
    n1_section) {

  // c_side.to_c2_set[character, 0, NOT]
  C.name = z_name;
  // c_side.to_c2_set[integer, 0, NOT]
  C.type = z_type;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_wall3d = z_ix_wall3d;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_link = z_n_link;
  // c_side.to_c2_set[real, 0, NOT]
  C.thickness = z_thickness;
  // c_side.to_c2_set[character, 0, NOT]
  C.clear_material = z_clear_material;
  // c_side.to_c2_set[character, 0, NOT]
  C.opaque_material = z_opaque_material;
  // c_side.to_c2_set[logical, 0, NOT]
  C.superimpose = z_superimpose;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ele_anchor_pt = z_ele_anchor_pt;
  // c_side.to_c2_set[type, 1, ALLOC]
  C.section.resize(n1_section);
  for (int i = 0; i < n1_section; i++) wall3d_section_to_c(z_section[i], C.section[i]);

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_control

extern "C" void control_to_c (const Bmad_control_class*, CPP_control&);

// c_side.to_f2_arg
extern "C" void control_to_f2 (Bmad_control_class*, const CPP_expression_atom**, Int, const
    CPP_lat_ele_loc&, const CPP_lat_ele_loc&, c_Int&);

extern "C" void control_to_f (const CPP_control& C, Bmad_control_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_stack = C.stack.size();
  const CPP_expression_atom** z_stack = NULL;
  if (n1_stack != 0) {
    z_stack = new const CPP_expression_atom*[n1_stack];
    for (int i = 0; i < n1_stack; i++) z_stack[i] = &C.stack[i];
  }

  // c_side.to_f2_call
  control_to_f2 (F, z_stack, n1_stack, C.slave, C.lord, C.ix_attrib);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_stack;
}

// c_side.to_c2_arg
extern "C" void control_to_c2 (CPP_control& C, Bmad_expression_atom_class** z_stack, Int
    n1_stack, const Bmad_lat_ele_loc_class* z_slave, const Bmad_lat_ele_loc_class* z_lord,
    c_Int& z_ix_attrib) {

  // c_side.to_c2_set[type, 1, ALLOC]
  C.stack.resize(n1_stack);
  for (int i = 0; i < n1_stack; i++) expression_atom_to_c(z_stack[i], C.stack[i]);

  // c_side.to_c2_set[type, 0, NOT]
  lat_ele_loc_to_c(z_slave, C.slave);
  // c_side.to_c2_set[type, 0, NOT]
  lat_ele_loc_to_c(z_lord, C.lord);
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_attrib = z_ix_attrib;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_lat_param

extern "C" void lat_param_to_c (const Bmad_lat_param_class*, CPP_lat_param&);

// c_side.to_f2_arg
extern "C" void lat_param_to_f2 (Bmad_lat_param_class*, c_Real&, c_Real&, c_Real&, c_RealArr,
    c_RealArr, c_Int&, c_Int&, c_Int&, c_Int&, c_Bool&, c_Bool&, const CPP_bookkeeping_state&);

extern "C" void lat_param_to_f (const CPP_lat_param& C, Bmad_lat_param_class* F) {
  // c_side.to_f_setup[real, 2, NOT]
  Real z_t1_with_rf[6*6]; matrix_to_vec(C.t1_with_rf, z_t1_with_rf);
  // c_side.to_f_setup[real, 2, NOT]
  Real z_t1_no_rf[6*6]; matrix_to_vec(C.t1_no_rf, z_t1_no_rf);

  // c_side.to_f2_call
  lat_param_to_f2 (F, C.n_part, C.total_length, C.unstable_factor, z_t1_with_rf, z_t1_no_rf,
      C.particle, C.default_tracking_species, C.geometry, C.ixx, C.stable,
      C.backwards_time_tracking, C.bookkeeping_state);

}

// c_side.to_c2_arg
extern "C" void lat_param_to_c2 (CPP_lat_param& C, c_Real& z_n_part, c_Real& z_total_length,
    c_Real& z_unstable_factor, c_RealArr z_t1_with_rf, c_RealArr z_t1_no_rf, c_Int& z_particle,
    c_Int& z_default_tracking_species, c_Int& z_geometry, c_Int& z_ixx, c_Bool& z_stable,
    c_Bool& z_backwards_time_tracking, const Bmad_bookkeeping_state_class* z_bookkeeping_state)
    {

  // c_side.to_c2_set[real, 0, NOT]
  C.n_part = z_n_part;
  // c_side.to_c2_set[real, 0, NOT]
  C.total_length = z_total_length;
  // c_side.to_c2_set[real, 0, NOT]
  C.unstable_factor = z_unstable_factor;
  // c_side.to_c2_set[real, 2, NOT]
  C.t1_with_rf << z_t1_with_rf;
  // c_side.to_c2_set[real, 2, NOT]
  C.t1_no_rf << z_t1_no_rf;
  // c_side.to_c2_set[integer, 0, NOT]
  C.particle = z_particle;
  // c_side.to_c2_set[integer, 0, NOT]
  C.default_tracking_species = z_default_tracking_species;
  // c_side.to_c2_set[integer, 0, NOT]
  C.geometry = z_geometry;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ixx = z_ixx;
  // c_side.to_c2_set[logical, 0, NOT]
  C.stable = z_stable;
  // c_side.to_c2_set[logical, 0, NOT]
  C.backwards_time_tracking = z_backwards_time_tracking;
  // c_side.to_c2_set[type, 0, NOT]
  bookkeeping_state_to_c(z_bookkeeping_state, C.bookkeeping_state);
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_mode_info

extern "C" void mode_info_to_c (const Bmad_mode_info_class*, CPP_mode_info&);

// c_side.to_f2_arg
extern "C" void mode_info_to_f2 (Bmad_mode_info_class*, c_Real&, c_Real&, c_Real&, c_Real&,
    c_Real&);

extern "C" void mode_info_to_f (const CPP_mode_info& C, Bmad_mode_info_class* F) {

  // c_side.to_f2_call
  mode_info_to_f2 (F, C.tune, C.emit, C.chrom, C.sigma, C.sigmap);

}

// c_side.to_c2_arg
extern "C" void mode_info_to_c2 (CPP_mode_info& C, c_Real& z_tune, c_Real& z_emit, c_Real&
    z_chrom, c_Real& z_sigma, c_Real& z_sigmap) {

  // c_side.to_c2_set[real, 0, NOT]
  C.tune = z_tune;
  // c_side.to_c2_set[real, 0, NOT]
  C.emit = z_emit;
  // c_side.to_c2_set[real, 0, NOT]
  C.chrom = z_chrom;
  // c_side.to_c2_set[real, 0, NOT]
  C.sigma = z_sigma;
  // c_side.to_c2_set[real, 0, NOT]
  C.sigmap = z_sigmap;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_pre_tracker

extern "C" void pre_tracker_to_c (const Bmad_pre_tracker_class*, CPP_pre_tracker&);

// c_side.to_f2_arg
extern "C" void pre_tracker_to_f2 (Bmad_pre_tracker_class*, c_Int&, c_Int&, c_Int&, c_Char);

extern "C" void pre_tracker_to_f (const CPP_pre_tracker& C, Bmad_pre_tracker_class* F) {

  // c_side.to_f2_call
  pre_tracker_to_f2 (F, C.who, C.ix_ele_start, C.ix_ele_end, C.input_file.c_str());

}

// c_side.to_c2_arg
extern "C" void pre_tracker_to_c2 (CPP_pre_tracker& C, c_Int& z_who, c_Int& z_ix_ele_start,
    c_Int& z_ix_ele_end, c_Char z_input_file) {

  // c_side.to_c2_set[integer, 0, NOT]
  C.who = z_who;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_ele_start = z_ix_ele_start;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_ele_end = z_ix_ele_end;
  // c_side.to_c2_set[character, 0, NOT]
  C.input_file = z_input_file;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_anormal_mode

extern "C" void anormal_mode_to_c (const Bmad_anormal_mode_class*, CPP_anormal_mode&);

// c_side.to_f2_arg
extern "C" void anormal_mode_to_f2 (Bmad_anormal_mode_class*, c_Real&, c_RealArr, c_Real&,
    c_Real&, c_Real&, c_Real&);

extern "C" void anormal_mode_to_f (const CPP_anormal_mode& C, Bmad_anormal_mode_class* F) {

  // c_side.to_f2_call
  anormal_mode_to_f2 (F, C.emittance, &C.synch_int[0], C.j_damp, C.alpha_damp, C.chrom,
      C.tune);

}

// c_side.to_c2_arg
extern "C" void anormal_mode_to_c2 (CPP_anormal_mode& C, c_Real& z_emittance, c_RealArr
    z_synch_int, c_Real& z_j_damp, c_Real& z_alpha_damp, c_Real& z_chrom, c_Real& z_tune) {

  // c_side.to_c2_set[real, 0, NOT]
  C.emittance = z_emittance;
  // c_side.to_c2_set[real, 1, NOT]
  C.synch_int << z_synch_int;
  // c_side.to_c2_set[real, 0, NOT]
  C.j_damp = z_j_damp;
  // c_side.to_c2_set[real, 0, NOT]
  C.alpha_damp = z_alpha_damp;
  // c_side.to_c2_set[real, 0, NOT]
  C.chrom = z_chrom;
  // c_side.to_c2_set[real, 0, NOT]
  C.tune = z_tune;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_linac_normal_mode

extern "C" void linac_normal_mode_to_c (const Bmad_linac_normal_mode_class*, CPP_linac_normal_mode&);

// c_side.to_f2_arg
extern "C" void linac_normal_mode_to_f2 (Bmad_linac_normal_mode_class*, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&);

extern "C" void linac_normal_mode_to_f (const CPP_linac_normal_mode& C, Bmad_linac_normal_mode_class* F) {

  // c_side.to_f2_call
  linac_normal_mode_to_f2 (F, C.i2_e4, C.i3_e7, C.i5a_e6, C.i5b_e6, C.sig_e1,
      C.a_emittance_end, C.b_emittance_end);

}

// c_side.to_c2_arg
extern "C" void linac_normal_mode_to_c2 (CPP_linac_normal_mode& C, c_Real& z_i2_e4, c_Real&
    z_i3_e7, c_Real& z_i5a_e6, c_Real& z_i5b_e6, c_Real& z_sig_e1, c_Real& z_a_emittance_end,
    c_Real& z_b_emittance_end) {

  // c_side.to_c2_set[real, 0, NOT]
  C.i2_e4 = z_i2_e4;
  // c_side.to_c2_set[real, 0, NOT]
  C.i3_e7 = z_i3_e7;
  // c_side.to_c2_set[real, 0, NOT]
  C.i5a_e6 = z_i5a_e6;
  // c_side.to_c2_set[real, 0, NOT]
  C.i5b_e6 = z_i5b_e6;
  // c_side.to_c2_set[real, 0, NOT]
  C.sig_e1 = z_sig_e1;
  // c_side.to_c2_set[real, 0, NOT]
  C.a_emittance_end = z_a_emittance_end;
  // c_side.to_c2_set[real, 0, NOT]
  C.b_emittance_end = z_b_emittance_end;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_normal_modes

extern "C" void normal_modes_to_c (const Bmad_normal_modes_class*, CPP_normal_modes&);

// c_side.to_f2_arg
extern "C" void normal_modes_to_f2 (Bmad_normal_modes_class*, c_RealArr, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&, const CPP_anormal_mode&, const CPP_anormal_mode&, const
    CPP_anormal_mode&, const CPP_linac_normal_mode&);

extern "C" void normal_modes_to_f (const CPP_normal_modes& C, Bmad_normal_modes_class* F) {

  // c_side.to_f2_call
  normal_modes_to_f2 (F, &C.synch_int[0], C.sige_e, C.sig_z, C.e_loss, C.rf_voltage,
      C.pz_aperture, C.a, C.b, C.z, C.lin);

}

// c_side.to_c2_arg
extern "C" void normal_modes_to_c2 (CPP_normal_modes& C, c_RealArr z_synch_int, c_Real&
    z_sige_e, c_Real& z_sig_z, c_Real& z_e_loss, c_Real& z_rf_voltage, c_Real& z_pz_aperture,
    const Bmad_anormal_mode_class* z_a, const Bmad_anormal_mode_class* z_b, const
    Bmad_anormal_mode_class* z_z, const Bmad_linac_normal_mode_class* z_lin) {

  // c_side.to_c2_set[real, 1, NOT]
  C.synch_int << z_synch_int;
  // c_side.to_c2_set[real, 0, NOT]
  C.sige_e = z_sige_e;
  // c_side.to_c2_set[real, 0, NOT]
  C.sig_z = z_sig_z;
  // c_side.to_c2_set[real, 0, NOT]
  C.e_loss = z_e_loss;
  // c_side.to_c2_set[real, 0, NOT]
  C.rf_voltage = z_rf_voltage;
  // c_side.to_c2_set[real, 0, NOT]
  C.pz_aperture = z_pz_aperture;
  // c_side.to_c2_set[type, 0, NOT]
  anormal_mode_to_c(z_a, C.a);
  // c_side.to_c2_set[type, 0, NOT]
  anormal_mode_to_c(z_b, C.b);
  // c_side.to_c2_set[type, 0, NOT]
  anormal_mode_to_c(z_z, C.z);
  // c_side.to_c2_set[type, 0, NOT]
  linac_normal_mode_to_c(z_lin, C.lin);
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_em_field

extern "C" void em_field_to_c (const Bmad_em_field_class*, CPP_em_field&);

// c_side.to_f2_arg
extern "C" void em_field_to_f2 (Bmad_em_field_class*, c_RealArr, c_RealArr, c_RealArr,
    c_RealArr);

extern "C" void em_field_to_f (const CPP_em_field& C, Bmad_em_field_class* F) {
  // c_side.to_f_setup[real, 2, NOT]
  Real z_de[3*3]; matrix_to_vec(C.de, z_de);
  // c_side.to_f_setup[real, 2, NOT]
  Real z_db[3*3]; matrix_to_vec(C.db, z_db);

  // c_side.to_f2_call
  em_field_to_f2 (F, &C.e[0], &C.b[0], z_de, z_db);

}

// c_side.to_c2_arg
extern "C" void em_field_to_c2 (CPP_em_field& C, c_RealArr z_e, c_RealArr z_b, c_RealArr z_de,
    c_RealArr z_db) {

  // c_side.to_c2_set[real, 1, NOT]
  C.e << z_e;
  // c_side.to_c2_set[real, 1, NOT]
  C.b << z_b;
  // c_side.to_c2_set[real, 2, NOT]
  C.de << z_de;
  // c_side.to_c2_set[real, 2, NOT]
  C.db << z_db;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_track_map

extern "C" void track_map_to_c (const Bmad_track_map_class*, CPP_track_map&);

// c_side.to_f2_arg
extern "C" void track_map_to_f2 (Bmad_track_map_class*, c_RealArr, c_RealArr);

extern "C" void track_map_to_f (const CPP_track_map& C, Bmad_track_map_class* F) {
  // c_side.to_f_setup[real, 2, NOT]
  Real z_mat6[6*6]; matrix_to_vec(C.mat6, z_mat6);

  // c_side.to_f2_call
  track_map_to_f2 (F, &C.vec0[0], z_mat6);

}

// c_side.to_c2_arg
extern "C" void track_map_to_c2 (CPP_track_map& C, c_RealArr z_vec0, c_RealArr z_mat6) {

  // c_side.to_c2_set[real, 1, NOT]
  C.vec0 << z_vec0;
  // c_side.to_c2_set[real, 2, NOT]
  C.mat6 << z_mat6;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_track

extern "C" void track_to_c (const Bmad_track_class*, CPP_track&);

// c_side.to_f2_arg
extern "C" void track_to_f2 (Bmad_track_class*, const CPP_coord**, Int, const CPP_em_field**,
    Int, const CPP_track_map**, Int, c_Real&, c_Int&, c_Int&, c_Int&);

extern "C" void track_to_f (const CPP_track& C, Bmad_track_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_orb = C.orb.size();
  const CPP_coord** z_orb = NULL;
  if (n1_orb != 0) {
    z_orb = new const CPP_coord*[n1_orb];
    for (int i = 0; i < n1_orb; i++) z_orb[i] = &C.orb[i];
  }
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_field = C.field.size();
  const CPP_em_field** z_field = NULL;
  if (n1_field != 0) {
    z_field = new const CPP_em_field*[n1_field];
    for (int i = 0; i < n1_field; i++) z_field[i] = &C.field[i];
  }
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_map = C.map.size();
  const CPP_track_map** z_map = NULL;
  if (n1_map != 0) {
    z_map = new const CPP_track_map*[n1_map];
    for (int i = 0; i < n1_map; i++) z_map[i] = &C.map[i];
  }

  // c_side.to_f2_call
  track_to_f2 (F, z_orb, n1_orb, z_field, n1_field, z_map, n1_map, C.ds_save, C.n_pt, C.n_bad,
      C.n_ok);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_orb;
  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_field;
  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_map;
}

// c_side.to_c2_arg
extern "C" void track_to_c2 (CPP_track& C, Bmad_coord_class** z_orb, Int n1_orb,
    Bmad_em_field_class** z_field, Int n1_field, Bmad_track_map_class** z_map, Int n1_map,
    c_Real& z_ds_save, c_Int& z_n_pt, c_Int& z_n_bad, c_Int& z_n_ok) {

  // c_side.to_c2_set[type, 1, ALLOC]
  C.orb.resize(n1_orb);
  for (int i = 0; i < n1_orb; i++) coord_to_c(z_orb[i], C.orb[i]);

  // c_side.to_c2_set[type, 1, ALLOC]
  C.field.resize(n1_field);
  for (int i = 0; i < n1_field; i++) em_field_to_c(z_field[i], C.field[i]);

  // c_side.to_c2_set[type, 1, ALLOC]
  C.map.resize(n1_map);
  for (int i = 0; i < n1_map; i++) track_map_to_c(z_map[i], C.map[i]);

  // c_side.to_c2_set[real, 0, NOT]
  C.ds_save = z_ds_save;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_pt = z_n_pt;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_bad = z_n_bad;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_ok = z_n_ok;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_synch_rad_common

extern "C" void synch_rad_common_to_c (const Bmad_synch_rad_common_class*, CPP_synch_rad_common&);

// c_side.to_f2_arg
extern "C" void synch_rad_common_to_f2 (Bmad_synch_rad_common_class*, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Bool&);

extern "C" void synch_rad_common_to_f (const CPP_synch_rad_common& C, Bmad_synch_rad_common_class* F) {

  // c_side.to_f2_call
  synch_rad_common_to_f2 (F, C.scale, C.i2, C.i3, C.i5a, C.i5b, C.i_calc_on);

}

// c_side.to_c2_arg
extern "C" void synch_rad_common_to_c2 (CPP_synch_rad_common& C, c_Real& z_scale, c_Real& z_i2,
    c_Real& z_i3, c_Real& z_i5a, c_Real& z_i5b, c_Bool& z_i_calc_on) {

  // c_side.to_c2_set[real, 0, NOT]
  C.scale = z_scale;
  // c_side.to_c2_set[real, 0, NOT]
  C.i2 = z_i2;
  // c_side.to_c2_set[real, 0, NOT]
  C.i3 = z_i3;
  // c_side.to_c2_set[real, 0, NOT]
  C.i5a = z_i5a;
  // c_side.to_c2_set[real, 0, NOT]
  C.i5b = z_i5b;
  // c_side.to_c2_set[logical, 0, NOT]
  C.i_calc_on = z_i_calc_on;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_csr_parameter

extern "C" void csr_parameter_to_c (const Bmad_csr_parameter_class*, CPP_csr_parameter&);

// c_side.to_f2_arg
extern "C" void csr_parameter_to_f2 (Bmad_csr_parameter_class*, c_Real&, c_Real&, c_Real&,
    c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&,
    c_Bool&);

extern "C" void csr_parameter_to_f (const CPP_csr_parameter& C, Bmad_csr_parameter_class* F) {

  // c_side.to_f2_call
  csr_parameter_to_f2 (F, C.ds_track_step, C.beam_chamber_height, C.sigma_cutoff, C.n_bin,
      C.particle_bin_span, C.n_shield_images, C.ix1_ele_csr, C.ix2_ele_csr,
      C.lcsr_component_on, C.lsc_component_on, C.tsc_component_on, C.small_angle_approx,
      C.print_taylor_warning, C.use_csr_old);

}

// c_side.to_c2_arg
extern "C" void csr_parameter_to_c2 (CPP_csr_parameter& C, c_Real& z_ds_track_step, c_Real&
    z_beam_chamber_height, c_Real& z_sigma_cutoff, c_Int& z_n_bin, c_Int& z_particle_bin_span,
    c_Int& z_n_shield_images, c_Int& z_ix1_ele_csr, c_Int& z_ix2_ele_csr, c_Bool&
    z_lcsr_component_on, c_Bool& z_lsc_component_on, c_Bool& z_tsc_component_on, c_Bool&
    z_small_angle_approx, c_Bool& z_print_taylor_warning, c_Bool& z_use_csr_old) {

  // c_side.to_c2_set[real, 0, NOT]
  C.ds_track_step = z_ds_track_step;
  // c_side.to_c2_set[real, 0, NOT]
  C.beam_chamber_height = z_beam_chamber_height;
  // c_side.to_c2_set[real, 0, NOT]
  C.sigma_cutoff = z_sigma_cutoff;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_bin = z_n_bin;
  // c_side.to_c2_set[integer, 0, NOT]
  C.particle_bin_span = z_particle_bin_span;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_shield_images = z_n_shield_images;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix1_ele_csr = z_ix1_ele_csr;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix2_ele_csr = z_ix2_ele_csr;
  // c_side.to_c2_set[logical, 0, NOT]
  C.lcsr_component_on = z_lcsr_component_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.lsc_component_on = z_lsc_component_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.tsc_component_on = z_tsc_component_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.small_angle_approx = z_small_angle_approx;
  // c_side.to_c2_set[logical, 0, NOT]
  C.print_taylor_warning = z_print_taylor_warning;
  // c_side.to_c2_set[logical, 0, NOT]
  C.use_csr_old = z_use_csr_old;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_bmad_common

extern "C" void bmad_common_to_c (const Bmad_bmad_common_class*, CPP_bmad_common&);

// c_side.to_f2_arg
extern "C" void bmad_common_to_f2 (Bmad_bmad_common_class*, c_Real&, c_RealArr, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Int&, c_Int&, c_Int&, c_Int&, c_Bool&, c_Bool&, c_Bool&, c_Bool&,
    c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&,
    c_Bool&);

extern "C" void bmad_common_to_f (const CPP_bmad_common& C, Bmad_bmad_common_class* F) {

  // c_side.to_f2_call
  bmad_common_to_f2 (F, C.max_aperture_limit, &C.d_orb[0], C.default_ds_step,
      C.significant_length, C.rel_tol_tracking, C.abs_tol_tracking,
      C.rel_tol_adaptive_tracking, C.abs_tol_adaptive_tracking, C.init_ds_adaptive_tracking,
      C.min_ds_adaptive_tracking, C.fatal_ds_adaptive_tracking, C.electric_dipole_moment,
      C.ptc_cut_factor, C.sad_eps_scale, C.sad_amp_max, C.sad_n_div_max, C.taylor_order,
      C.default_integ_order, C.ptc_max_fringe_order, C.use_hard_edge_drifts, C.sr_wakes_on,
      C.lr_wakes_on, C.mat6_track_symmetric, C.auto_bookkeeper, C.space_charge_on,
      C.coherent_synch_rad_on, C.spin_tracking_on, C.radiation_damping_on,
      C.radiation_fluctuations_on, C.conserve_taylor_maps, C.absolute_time_tracking_default,
      C.convert_to_kinetic_momentum, C.aperture_limit_on, C.debug);

}

// c_side.to_c2_arg
extern "C" void bmad_common_to_c2 (CPP_bmad_common& C, c_Real& z_max_aperture_limit, c_RealArr
    z_d_orb, c_Real& z_default_ds_step, c_Real& z_significant_length, c_Real&
    z_rel_tol_tracking, c_Real& z_abs_tol_tracking, c_Real& z_rel_tol_adaptive_tracking,
    c_Real& z_abs_tol_adaptive_tracking, c_Real& z_init_ds_adaptive_tracking, c_Real&
    z_min_ds_adaptive_tracking, c_Real& z_fatal_ds_adaptive_tracking, c_Real&
    z_electric_dipole_moment, c_Real& z_ptc_cut_factor, c_Real& z_sad_eps_scale, c_Real&
    z_sad_amp_max, c_Int& z_sad_n_div_max, c_Int& z_taylor_order, c_Int& z_default_integ_order,
    c_Int& z_ptc_max_fringe_order, c_Bool& z_use_hard_edge_drifts, c_Bool& z_sr_wakes_on,
    c_Bool& z_lr_wakes_on, c_Bool& z_mat6_track_symmetric, c_Bool& z_auto_bookkeeper, c_Bool&
    z_space_charge_on, c_Bool& z_coherent_synch_rad_on, c_Bool& z_spin_tracking_on, c_Bool&
    z_radiation_damping_on, c_Bool& z_radiation_fluctuations_on, c_Bool&
    z_conserve_taylor_maps, c_Bool& z_absolute_time_tracking_default, c_Bool&
    z_convert_to_kinetic_momentum, c_Bool& z_aperture_limit_on, c_Bool& z_debug) {

  // c_side.to_c2_set[real, 0, NOT]
  C.max_aperture_limit = z_max_aperture_limit;
  // c_side.to_c2_set[real, 1, NOT]
  C.d_orb << z_d_orb;
  // c_side.to_c2_set[real, 0, NOT]
  C.default_ds_step = z_default_ds_step;
  // c_side.to_c2_set[real, 0, NOT]
  C.significant_length = z_significant_length;
  // c_side.to_c2_set[real, 0, NOT]
  C.rel_tol_tracking = z_rel_tol_tracking;
  // c_side.to_c2_set[real, 0, NOT]
  C.abs_tol_tracking = z_abs_tol_tracking;
  // c_side.to_c2_set[real, 0, NOT]
  C.rel_tol_adaptive_tracking = z_rel_tol_adaptive_tracking;
  // c_side.to_c2_set[real, 0, NOT]
  C.abs_tol_adaptive_tracking = z_abs_tol_adaptive_tracking;
  // c_side.to_c2_set[real, 0, NOT]
  C.init_ds_adaptive_tracking = z_init_ds_adaptive_tracking;
  // c_side.to_c2_set[real, 0, NOT]
  C.min_ds_adaptive_tracking = z_min_ds_adaptive_tracking;
  // c_side.to_c2_set[real, 0, NOT]
  C.fatal_ds_adaptive_tracking = z_fatal_ds_adaptive_tracking;
  // c_side.to_c2_set[real, 0, NOT]
  C.electric_dipole_moment = z_electric_dipole_moment;
  // c_side.to_c2_set[real, 0, NOT]
  C.ptc_cut_factor = z_ptc_cut_factor;
  // c_side.to_c2_set[real, 0, NOT]
  C.sad_eps_scale = z_sad_eps_scale;
  // c_side.to_c2_set[real, 0, NOT]
  C.sad_amp_max = z_sad_amp_max;
  // c_side.to_c2_set[integer, 0, NOT]
  C.sad_n_div_max = z_sad_n_div_max;
  // c_side.to_c2_set[integer, 0, NOT]
  C.taylor_order = z_taylor_order;
  // c_side.to_c2_set[integer, 0, NOT]
  C.default_integ_order = z_default_integ_order;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ptc_max_fringe_order = z_ptc_max_fringe_order;
  // c_side.to_c2_set[logical, 0, NOT]
  C.use_hard_edge_drifts = z_use_hard_edge_drifts;
  // c_side.to_c2_set[logical, 0, NOT]
  C.sr_wakes_on = z_sr_wakes_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.lr_wakes_on = z_lr_wakes_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.mat6_track_symmetric = z_mat6_track_symmetric;
  // c_side.to_c2_set[logical, 0, NOT]
  C.auto_bookkeeper = z_auto_bookkeeper;
  // c_side.to_c2_set[logical, 0, NOT]
  C.space_charge_on = z_space_charge_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.coherent_synch_rad_on = z_coherent_synch_rad_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.spin_tracking_on = z_spin_tracking_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.radiation_damping_on = z_radiation_damping_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.radiation_fluctuations_on = z_radiation_fluctuations_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.conserve_taylor_maps = z_conserve_taylor_maps;
  // c_side.to_c2_set[logical, 0, NOT]
  C.absolute_time_tracking_default = z_absolute_time_tracking_default;
  // c_side.to_c2_set[logical, 0, NOT]
  C.convert_to_kinetic_momentum = z_convert_to_kinetic_momentum;
  // c_side.to_c2_set[logical, 0, NOT]
  C.aperture_limit_on = z_aperture_limit_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.debug = z_debug;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_rad_int1

extern "C" void rad_int1_to_c (const Bmad_rad_int1_class*, CPP_rad_int1&);

// c_side.to_f2_arg
extern "C" void rad_int1_to_f2 (Bmad_rad_int1_class*, c_Real&, c_Real&, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&, c_Real&,
    c_Real&, c_Real&, c_Real&);

extern "C" void rad_int1_to_f (const CPP_rad_int1& C, Bmad_rad_int1_class* F) {

  // c_side.to_f2_call
  rad_int1_to_f2 (F, C.i0, C.i1, C.i2, C.i3, C.i4a, C.i4b, C.i4z, C.i5a, C.i5b, C.i6b,
      C.lin_i2_e4, C.lin_i3_e7, C.lin_i5a_e6, C.lin_i5b_e6, C.lin_norm_emit_a,
      C.lin_norm_emit_b, C.n_steps);

}

// c_side.to_c2_arg
extern "C" void rad_int1_to_c2 (CPP_rad_int1& C, c_Real& z_i0, c_Real& z_i1, c_Real& z_i2,
    c_Real& z_i3, c_Real& z_i4a, c_Real& z_i4b, c_Real& z_i4z, c_Real& z_i5a, c_Real& z_i5b,
    c_Real& z_i6b, c_Real& z_lin_i2_e4, c_Real& z_lin_i3_e7, c_Real& z_lin_i5a_e6, c_Real&
    z_lin_i5b_e6, c_Real& z_lin_norm_emit_a, c_Real& z_lin_norm_emit_b, c_Real& z_n_steps) {

  // c_side.to_c2_set[real, 0, NOT]
  C.i0 = z_i0;
  // c_side.to_c2_set[real, 0, NOT]
  C.i1 = z_i1;
  // c_side.to_c2_set[real, 0, NOT]
  C.i2 = z_i2;
  // c_side.to_c2_set[real, 0, NOT]
  C.i3 = z_i3;
  // c_side.to_c2_set[real, 0, NOT]
  C.i4a = z_i4a;
  // c_side.to_c2_set[real, 0, NOT]
  C.i4b = z_i4b;
  // c_side.to_c2_set[real, 0, NOT]
  C.i4z = z_i4z;
  // c_side.to_c2_set[real, 0, NOT]
  C.i5a = z_i5a;
  // c_side.to_c2_set[real, 0, NOT]
  C.i5b = z_i5b;
  // c_side.to_c2_set[real, 0, NOT]
  C.i6b = z_i6b;
  // c_side.to_c2_set[real, 0, NOT]
  C.lin_i2_e4 = z_lin_i2_e4;
  // c_side.to_c2_set[real, 0, NOT]
  C.lin_i3_e7 = z_lin_i3_e7;
  // c_side.to_c2_set[real, 0, NOT]
  C.lin_i5a_e6 = z_lin_i5a_e6;
  // c_side.to_c2_set[real, 0, NOT]
  C.lin_i5b_e6 = z_lin_i5b_e6;
  // c_side.to_c2_set[real, 0, NOT]
  C.lin_norm_emit_a = z_lin_norm_emit_a;
  // c_side.to_c2_set[real, 0, NOT]
  C.lin_norm_emit_b = z_lin_norm_emit_b;
  // c_side.to_c2_set[real, 0, NOT]
  C.n_steps = z_n_steps;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_rad_int_all_ele

extern "C" void rad_int_all_ele_to_c (const Bmad_rad_int_all_ele_class*, CPP_rad_int_all_ele&);

// c_side.to_f2_arg
extern "C" void rad_int_all_ele_to_f2 (Bmad_rad_int_all_ele_class*, const CPP_rad_int1**, Int);

extern "C" void rad_int_all_ele_to_f (const CPP_rad_int_all_ele& C, Bmad_rad_int_all_ele_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_ele = C.ele.size();
  const CPP_rad_int1** z_ele = NULL;
  if (n1_ele != 0) {
    z_ele = new const CPP_rad_int1*[n1_ele];
    for (int i = 0; i < n1_ele; i++) z_ele[i] = &C.ele[i];
  }

  // c_side.to_f2_call
  rad_int_all_ele_to_f2 (F, z_ele, n1_ele);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_ele;
}

// c_side.to_c2_arg
extern "C" void rad_int_all_ele_to_c2 (CPP_rad_int_all_ele& C, Bmad_rad_int1_class** z_ele, Int
    n1_ele) {

  // c_side.to_c2_set[type, 1, ALLOC]
  C.ele.resize(n1_ele);
  for (int i = 0; i < n1_ele; i++) rad_int1_to_c(z_ele[i], C.ele[i]);

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_ptc_genfield

extern "C" void ptc_genfield_to_c (const Bmad_ptc_genfield_class*, CPP_ptc_genfield&);

// c_side.to_f2_arg
extern "C" void ptc_genfield_to_f2 (Bmad_ptc_genfield_class*, c_RealArr);

extern "C" void ptc_genfield_to_f (const CPP_ptc_genfield& C, Bmad_ptc_genfield_class* F) {

  // c_side.to_f2_call
  ptc_genfield_to_f2 (F, &C.vec0[0]);

}

// c_side.to_c2_arg
extern "C" void ptc_genfield_to_c2 (CPP_ptc_genfield& C, c_RealArr z_vec0) {

  // c_side.to_c2_set[real, 1, NOT]
  C.vec0 << z_vec0;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_ele

extern "C" void ele_to_c (const Bmad_ele_class*, CPP_ele&);

// c_side.to_f2_arg
extern "C" void ele_to_f2 (Bmad_ele_class*, c_Char, c_Char, c_Char, c_Char, c_Char, Int, const
    CPP_twiss&, const CPP_twiss&, const CPP_twiss&, const CPP_xy_disp&, const CPP_xy_disp&,
    const CPP_bookkeeping_state&, const CPP_controller_var**, Int, const CPP_em_fields&, Int,
    const CPP_floor_position&, const CPP_ptc_genfield&, const CPP_mode3&, Int, const
    CPP_photon_element&, Int, const CPP_rad_int_ele_cache&, Int, const CPP_space_charge&, Int,
    const CPP_taylor**, const CPP_taylor**, const CPP_wake&, Int, const CPP_wall3d**, Int,
    const CPP_wig&, Int, const CPP_coord&, const CPP_coord&, const CPP_coord&, const
    CPP_coord&, c_RealArr, c_RealArr, c_RealArr, c_RealArr, c_RealArr, c_Real&, c_Real&,
    c_Real&, c_RealArr, Int, Int, Int, c_RealArr, Int, c_RealArr, Int, c_RealArr, Int,
    c_RealArr, Int, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&,
    c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&,
    c_Int&, c_Int&, c_Int&, c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&,
    c_Bool&, c_Bool&, c_Bool&, c_Bool&, c_Bool&);

extern "C" void ele_to_f (const CPP_ele& C, Bmad_ele_class* F) {
  // c_side.to_f_setup[character, 0, PTR]
  unsigned int n_descrip = 0;
  const char* z_descrip = NULL;  
  if (C.descrip != NULL) {
    z_descrip = C.descrip->c_str();
    n_descrip = 1;
  }
  // c_side.to_f_setup[type, 1, PTR]
  int n1_control_var = C.control_var.size();
  const CPP_controller_var** z_control_var = NULL;
  if (n1_control_var != 0) {
    z_control_var = new const CPP_controller_var*[n1_control_var];
    for (int i = 0; i < n1_control_var; i++) z_control_var[i] = &C.control_var[i];
  }
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_em_field = 0; if (C.em_field != NULL) n_em_field = 1;
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_mode3 = 0; if (C.mode3 != NULL) n_mode3 = 1;
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_photon = 0; if (C.photon != NULL) n_photon = 1;
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_rad_int_cache = 0; if (C.rad_int_cache != NULL) n_rad_int_cache = 1;
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_space_charge = 0; if (C.space_charge != NULL) n_space_charge = 1;
  // c_side.to_f_setup[type, 1, NOT]
  const CPP_taylor* z_taylor[6];
  for (int i = 0; i < 6; i++) {z_taylor[i] = &C.taylor[i];}
  // c_side.to_f_setup[type, 2, NOT]
  const CPP_taylor* z_spin_taylor[3*3];
  for (unsigned int i = 0; i < C.spin_taylor.size(); i++)  for (unsigned int j = 0; j < C.spin_taylor[0].size(); j++) 
    {int m = 3*i + j; z_spin_taylor[m] = &C.spin_taylor[i][j];}
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_wake = 0; if (C.wake != NULL) n_wake = 1;
  // c_side.to_f_setup[type, 1, PTR]
  int n1_wall3d = C.wall3d.size();
  const CPP_wall3d** z_wall3d = NULL;
  if (n1_wall3d != 0) {
    z_wall3d = new const CPP_wall3d*[n1_wall3d];
    for (int i = 0; i < n1_wall3d; i++) z_wall3d[i] = &C.wall3d[i];
  }
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_wig = 0; if (C.wig != NULL) n_wig = 1;
  // c_side.to_f_setup[real, 2, NOT]
  Real z_mat6[6*6]; matrix_to_vec(C.mat6, z_mat6);
  // c_side.to_f_setup[real, 2, NOT]
  Real z_c_mat[2*2]; matrix_to_vec(C.c_mat, z_c_mat);
  // c_side.to_f_setup[real, 3, PTR]

  int n1_r = C.r.size(), n2_r = 0, n3_r = 0;
  Real* z_r = NULL;
  if (n1_r > 0) {
    n2_r = C.r[0].size();
    n3_r = C.r[0][0].size();
    z_r = new Real [C.r.size()*C.r[0].size()*C.r[0][0].size()];
    tensor_to_vec (C.r, z_r);
  }
  // c_side.to_f_setup[real, 1, PTR]
  int n1_a_pole = C.a_pole.size();
  c_RealArr z_a_pole = NULL;
  if (n1_a_pole > 0) {
    z_a_pole = &C.a_pole[0];
  }
  // c_side.to_f_setup[real, 1, PTR]
  int n1_b_pole = C.b_pole.size();
  c_RealArr z_b_pole = NULL;
  if (n1_b_pole > 0) {
    z_b_pole = &C.b_pole[0];
  }
  // c_side.to_f_setup[real, 1, PTR]
  int n1_a_pole_elec = C.a_pole_elec.size();
  c_RealArr z_a_pole_elec = NULL;
  if (n1_a_pole_elec > 0) {
    z_a_pole_elec = &C.a_pole_elec[0];
  }
  // c_side.to_f_setup[real, 1, PTR]
  int n1_b_pole_elec = C.b_pole_elec.size();
  c_RealArr z_b_pole_elec = NULL;
  if (n1_b_pole_elec > 0) {
    z_b_pole_elec = &C.b_pole_elec[0];
  }

  // c_side.to_f2_call
  ele_to_f2 (F, C.name.c_str(), C.type.c_str(), C.alias.c_str(), C.component_name.c_str(),
      z_descrip, n_descrip, C.a, C.b, C.z, C.x, C.y, C.bookkeeping_state, z_control_var,
      n1_control_var, *C.em_field, n_em_field, C.floor, C.ptc_genfield, *C.mode3, n_mode3,
      *C.photon, n_photon, *C.rad_int_cache, n_rad_int_cache, *C.space_charge, n_space_charge,
      z_taylor, z_spin_taylor, *C.wake, n_wake, z_wall3d, n1_wall3d, *C.wig, n_wig,
      C.map_ref_orb_in, C.map_ref_orb_out, C.time_ref_orb_in, C.time_ref_orb_out, &C.value[0],
      &C.old_value[0], &C.vec0[0], z_mat6, z_c_mat, C.gamma_c, C.s, C.ref_time, z_r, n1_r,
      n2_r, n3_r, z_a_pole, n1_a_pole, z_b_pole, n1_b_pole, z_a_pole_elec, n1_a_pole_elec,
      z_b_pole_elec, n1_b_pole_elec, C.key, C.sub_key, C.ix_ele, C.ix_branch, C.slave_status,
      C.n_slave, C.n_slave_field, C.ix1_slave, C.lord_status, C.n_lord, C.n_lord_field,
      C.ic1_lord, C.ix_pointer, C.ixx, C.iyy, C.mat6_calc_method, C.tracking_method,
      C.spin_tracking_method, C.ptc_integration_type, C.field_calc, C.aperture_at,
      C.aperture_type, C.orientation, C.symplectify, C.mode_flip, C.multipoles_on,
      C.scale_multipoles, C.taylor_map_includes_offsets, C.field_master, C.is_on, C.logic,
      C.bmad_logic, C.select, C.csr_calc_on, C.offset_moves_aperture);

  // c_side.to_f_cleanup[type, 1, PTR]
 delete[] z_control_var;
  // c_side.to_f_cleanup[type, 1, PTR]
 delete[] z_wall3d;
  // c_side.to_f_cleanup[real, 3, PTR]
  delete[] z_r;
}

// c_side.to_c2_arg
extern "C" void ele_to_c2 (CPP_ele& C, c_Char z_name, c_Char z_type, c_Char z_alias, c_Char
    z_component_name, c_Char z_descrip, Int n_descrip, const Bmad_twiss_class* z_a, const
    Bmad_twiss_class* z_b, const Bmad_twiss_class* z_z, const Bmad_xy_disp_class* z_x, const
    Bmad_xy_disp_class* z_y, const Bmad_bookkeeping_state_class* z_bookkeeping_state,
    Bmad_controller_var_class** z_control_var, Int n1_control_var, Bmad_em_fields_class*
    z_em_field, Int n_em_field, const Bmad_floor_position_class* z_floor, const
    Bmad_ptc_genfield_class* z_ptc_genfield, Bmad_mode3_class* z_mode3, Int n_mode3,
    Bmad_photon_element_class* z_photon, Int n_photon, Bmad_rad_int_ele_cache_class*
    z_rad_int_cache, Int n_rad_int_cache, Bmad_space_charge_class* z_space_charge, Int
    n_space_charge, const Bmad_taylor_class** z_taylor, const Bmad_taylor_class**
    z_spin_taylor, Bmad_wake_class* z_wake, Int n_wake, Bmad_wall3d_class** z_wall3d, Int
    n1_wall3d, Bmad_wig_class* z_wig, Int n_wig, const Bmad_coord_class* z_map_ref_orb_in,
    const Bmad_coord_class* z_map_ref_orb_out, const Bmad_coord_class* z_time_ref_orb_in, const
    Bmad_coord_class* z_time_ref_orb_out, c_RealArr z_value, c_RealArr z_old_value, c_RealArr
    z_vec0, c_RealArr z_mat6, c_RealArr z_c_mat, c_Real& z_gamma_c, c_Real& z_s, c_Real&
    z_ref_time, c_RealArr z_r, Int n1_r, Int n2_r, Int n3_r, c_RealArr z_a_pole, Int n1_a_pole,
    c_RealArr z_b_pole, Int n1_b_pole, c_RealArr z_a_pole_elec, Int n1_a_pole_elec, c_RealArr
    z_b_pole_elec, Int n1_b_pole_elec, c_Int& z_key, c_Int& z_sub_key, c_Int& z_ix_ele, c_Int&
    z_ix_branch, c_Int& z_slave_status, c_Int& z_n_slave, c_Int& z_n_slave_field, c_Int&
    z_ix1_slave, c_Int& z_lord_status, c_Int& z_n_lord, c_Int& z_n_lord_field, c_Int&
    z_ic1_lord, c_Int& z_ix_pointer, c_Int& z_ixx, c_Int& z_iyy, c_Int& z_mat6_calc_method,
    c_Int& z_tracking_method, c_Int& z_spin_tracking_method, c_Int& z_ptc_integration_type,
    c_Int& z_field_calc, c_Int& z_aperture_at, c_Int& z_aperture_type, c_Int& z_orientation,
    c_Bool& z_symplectify, c_Bool& z_mode_flip, c_Bool& z_multipoles_on, c_Bool&
    z_scale_multipoles, c_Bool& z_taylor_map_includes_offsets, c_Bool& z_field_master, c_Bool&
    z_is_on, c_Bool& z_logic, c_Bool& z_bmad_logic, c_Bool& z_select, c_Bool& z_csr_calc_on,
    c_Bool& z_offset_moves_aperture) {

  // c_side.to_c2_set[character, 0, NOT]
  C.name = z_name;
  // c_side.to_c2_set[character, 0, NOT]
  C.type = z_type;
  // c_side.to_c2_set[character, 0, NOT]
  C.alias = z_alias;
  // c_side.to_c2_set[character, 0, NOT]
  C.component_name = z_component_name;
  // c_side.to_c2_set[character, 0, PTR]
  if (n_descrip == 0) 
    delete C.descrip;
  else {
    C.descrip = new string;
    *(C.descrip) = z_descrip;
  }

  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_a, C.a);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_b, C.b);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_z, C.z);
  // c_side.to_c2_set[type, 0, NOT]
  xy_disp_to_c(z_x, C.x);
  // c_side.to_c2_set[type, 0, NOT]
  xy_disp_to_c(z_y, C.y);
  // c_side.to_c2_set[type, 0, NOT]
  bookkeeping_state_to_c(z_bookkeeping_state, C.bookkeeping_state);
  // c_side.to_c2_set[type, 1, PTR]
  C.control_var.resize(n1_control_var);
  for (int i = 0; i < n1_control_var; i++) controller_var_to_c(z_control_var[i], C.control_var[i]);

  // c_side.to_c2_set[type, 0, PTR]
  if (n_em_field == 0)
    delete C.em_field;
  else {
    C.em_field = new CPP_em_fields;
    em_fields_to_c(z_em_field, *C.em_field);
  }

  // c_side.to_c2_set[type, 0, NOT]
  floor_position_to_c(z_floor, C.floor);
  // c_side.to_c2_set[type, 0, NOT]
  ptc_genfield_to_c(z_ptc_genfield, C.ptc_genfield);
  // c_side.to_c2_set[type, 0, PTR]
  if (n_mode3 == 0)
    delete C.mode3;
  else {
    C.mode3 = new CPP_mode3;
    mode3_to_c(z_mode3, *C.mode3);
  }

  // c_side.to_c2_set[type, 0, PTR]
  if (n_photon == 0)
    delete C.photon;
  else {
    C.photon = new CPP_photon_element;
    photon_element_to_c(z_photon, *C.photon);
  }

  // c_side.to_c2_set[type, 0, PTR]
  if (n_rad_int_cache == 0)
    delete C.rad_int_cache;
  else {
    C.rad_int_cache = new CPP_rad_int_ele_cache;
    rad_int_ele_cache_to_c(z_rad_int_cache, *C.rad_int_cache);
  }

  // c_side.to_c2_set[type, 0, PTR]
  if (n_space_charge == 0)
    delete C.space_charge;
  else {
    C.space_charge = new CPP_space_charge;
    space_charge_to_c(z_space_charge, *C.space_charge);
  }

  // c_side.to_c2_set[type, 1, NOT]
  for (unsigned int i = 0; i < C.taylor.size(); i++) taylor_to_c(z_taylor[i], C.taylor[i]);
  // c_side.to_c2_set[type, 2, NOT]
  for (unsigned int i = 0; i < C.spin_taylor.size(); i++)  for (unsigned int j = 0; j < C.spin_taylor[0].size(); j++) 
    {int m = 3*i + j; taylor_to_c(z_spin_taylor[m], C.spin_taylor[i][j]);}
  // c_side.to_c2_set[type, 0, PTR]
  if (n_wake == 0)
    delete C.wake;
  else {
    C.wake = new CPP_wake;
    wake_to_c(z_wake, *C.wake);
  }

  // c_side.to_c2_set[type, 1, PTR]
  C.wall3d.resize(n1_wall3d);
  for (int i = 0; i < n1_wall3d; i++) wall3d_to_c(z_wall3d[i], C.wall3d[i]);

  // c_side.to_c2_set[type, 0, PTR]
  if (n_wig == 0)
    delete C.wig;
  else {
    C.wig = new CPP_wig;
    wig_to_c(z_wig, *C.wig);
  }

  // c_side.to_c2_set[type, 0, NOT]
  coord_to_c(z_map_ref_orb_in, C.map_ref_orb_in);
  // c_side.to_c2_set[type, 0, NOT]
  coord_to_c(z_map_ref_orb_out, C.map_ref_orb_out);
  // c_side.to_c2_set[type, 0, NOT]
  coord_to_c(z_time_ref_orb_in, C.time_ref_orb_in);
  // c_side.to_c2_set[type, 0, NOT]
  coord_to_c(z_time_ref_orb_out, C.time_ref_orb_out);
  // c_side.to_c2_set[real, 1, NOT]
  C.value[0] = 0;
  for (unsigned int i = 1; i < Bmad::NUM_ELE_ATTRIB+1; i++) C.value[i] = z_value[i-1];

  // c_side.to_c2_set[real, 1, NOT]
  C.old_value[0] = 0;
  for (unsigned int i = 1; i < Bmad::NUM_ELE_ATTRIB+1; i++) C.old_value[i] = z_old_value[i-1];

  // c_side.to_c2_set[real, 1, NOT]
  C.vec0 << z_vec0;
  // c_side.to_c2_set[real, 2, NOT]
  C.mat6 << z_mat6;
  // c_side.to_c2_set[real, 2, NOT]
  C.c_mat << z_c_mat;
  // c_side.to_c2_set[real, 0, NOT]
  C.gamma_c = z_gamma_c;
  // c_side.to_c2_set[real, 0, NOT]
  C.s = z_s;
  // c_side.to_c2_set[real, 0, NOT]
  C.ref_time = z_ref_time;
  // c_side.to_c2_set[real, 3, PTR]
  C.r.resize(n1_r);
  for (unsigned int i = 0; i < C.r.size(); i++) {
    C.r[i].resize(n2_r);
    for (unsigned int j = 0; j < C.r[0].size(); j++)
      C.r[i][j].resize(n3_r);
  }
  C.r << z_r;

  // c_side.to_c2_set[real, 1, PTR]

  C.a_pole.resize(n1_a_pole);
  C.a_pole << z_a_pole;

  // c_side.to_c2_set[real, 1, PTR]

  C.b_pole.resize(n1_b_pole);
  C.b_pole << z_b_pole;

  // c_side.to_c2_set[real, 1, PTR]

  C.a_pole_elec.resize(n1_a_pole_elec);
  C.a_pole_elec << z_a_pole_elec;

  // c_side.to_c2_set[real, 1, PTR]

  C.b_pole_elec.resize(n1_b_pole_elec);
  C.b_pole_elec << z_b_pole_elec;

  // c_side.to_c2_set[integer, 0, NOT]
  C.key = z_key;
  // c_side.to_c2_set[integer, 0, NOT]
  C.sub_key = z_sub_key;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_ele = z_ix_ele;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_branch = z_ix_branch;
  // c_side.to_c2_set[integer, 0, NOT]
  C.slave_status = z_slave_status;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_slave = z_n_slave;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_slave_field = z_n_slave_field;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix1_slave = z_ix1_slave;
  // c_side.to_c2_set[integer, 0, NOT]
  C.lord_status = z_lord_status;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_lord = z_n_lord;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_lord_field = z_n_lord_field;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ic1_lord = z_ic1_lord;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_pointer = z_ix_pointer;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ixx = z_ixx;
  // c_side.to_c2_set[integer, 0, NOT]
  C.iyy = z_iyy;
  // c_side.to_c2_set[integer, 0, NOT]
  C.mat6_calc_method = z_mat6_calc_method;
  // c_side.to_c2_set[integer, 0, NOT]
  C.tracking_method = z_tracking_method;
  // c_side.to_c2_set[integer, 0, NOT]
  C.spin_tracking_method = z_spin_tracking_method;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ptc_integration_type = z_ptc_integration_type;
  // c_side.to_c2_set[integer, 0, NOT]
  C.field_calc = z_field_calc;
  // c_side.to_c2_set[integer, 0, NOT]
  C.aperture_at = z_aperture_at;
  // c_side.to_c2_set[integer, 0, NOT]
  C.aperture_type = z_aperture_type;
  // c_side.to_c2_set[integer, 0, NOT]
  C.orientation = z_orientation;
  // c_side.to_c2_set[logical, 0, NOT]
  C.symplectify = z_symplectify;
  // c_side.to_c2_set[logical, 0, NOT]
  C.mode_flip = z_mode_flip;
  // c_side.to_c2_set[logical, 0, NOT]
  C.multipoles_on = z_multipoles_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.scale_multipoles = z_scale_multipoles;
  // c_side.to_c2_set[logical, 0, NOT]
  C.taylor_map_includes_offsets = z_taylor_map_includes_offsets;
  // c_side.to_c2_set[logical, 0, NOT]
  C.field_master = z_field_master;
  // c_side.to_c2_set[logical, 0, NOT]
  C.is_on = z_is_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.logic = z_logic;
  // c_side.to_c2_set[logical, 0, NOT]
  C.bmad_logic = z_bmad_logic;
  // c_side.to_c2_set[logical, 0, NOT]
  C.select = z_select;
  // c_side.to_c2_set[logical, 0, NOT]
  C.csr_calc_on = z_csr_calc_on;
  // c_side.to_c2_set[logical, 0, NOT]
  C.offset_moves_aperture = z_offset_moves_aperture;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_complex_taylor_term

extern "C" void complex_taylor_term_to_c (const Bmad_complex_taylor_term_class*, CPP_complex_taylor_term&);

// c_side.to_f2_arg
extern "C" void complex_taylor_term_to_f2 (Bmad_complex_taylor_term_class*, c_Complex&,
    c_IntArr);

extern "C" void complex_taylor_term_to_f (const CPP_complex_taylor_term& C, Bmad_complex_taylor_term_class* F) {

  // c_side.to_f2_call
  complex_taylor_term_to_f2 (F, C.coef, &C.expn[0]);

}

// c_side.to_c2_arg
extern "C" void complex_taylor_term_to_c2 (CPP_complex_taylor_term& C, c_Complex& z_coef,
    c_IntArr z_expn) {

  // c_side.to_c2_set[complex, 0, NOT]
  C.coef = z_coef;
  // c_side.to_c2_set[integer, 1, NOT]
  C.expn << z_expn;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_complex_taylor

extern "C" void complex_taylor_to_c (const Bmad_complex_taylor_class*, CPP_complex_taylor&);

// c_side.to_f2_arg
extern "C" void complex_taylor_to_f2 (Bmad_complex_taylor_class*, c_Complex&, const
    CPP_complex_taylor_term**, Int);

extern "C" void complex_taylor_to_f (const CPP_complex_taylor& C, Bmad_complex_taylor_class* F) {
  // c_side.to_f_setup[type, 1, PTR]
  int n1_term = C.term.size();
  const CPP_complex_taylor_term** z_term = NULL;
  if (n1_term != 0) {
    z_term = new const CPP_complex_taylor_term*[n1_term];
    for (int i = 0; i < n1_term; i++) z_term[i] = &C.term[i];
  }

  // c_side.to_f2_call
  complex_taylor_to_f2 (F, C.ref, z_term, n1_term);

  // c_side.to_f_cleanup[type, 1, PTR]
 delete[] z_term;
}

// c_side.to_c2_arg
extern "C" void complex_taylor_to_c2 (CPP_complex_taylor& C, c_Complex& z_ref,
    Bmad_complex_taylor_term_class** z_term, Int n1_term) {

  // c_side.to_c2_set[complex, 0, NOT]
  C.ref = z_ref;
  // c_side.to_c2_set[type, 1, PTR]
  C.term.resize(n1_term);
  for (int i = 0; i < n1_term; i++) complex_taylor_term_to_c(z_term[i], C.term[i]);

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_normal_form

extern "C" void normal_form_to_c (const Bmad_normal_form_class*, CPP_normal_form&);

// c_side.to_f2_arg
extern "C" void normal_form_to_f2 (Bmad_normal_form_class*, const CPP_taylor**, const
    CPP_taylor**, const CPP_taylor**, const CPP_taylor**, const CPP_complex_taylor**, const
    CPP_complex_taylor**, const CPP_ele&, Int);

extern "C" void normal_form_to_f (const CPP_normal_form& C, Bmad_normal_form_class* F) {
  // c_side.to_f_setup[type, 1, NOT]
  const CPP_taylor* z_m[6];
  for (int i = 0; i < 6; i++) {z_m[i] = &C.m[i];}
  // c_side.to_f_setup[type, 1, NOT]
  const CPP_taylor* z_a[6];
  for (int i = 0; i < 6; i++) {z_a[i] = &C.a[i];}
  // c_side.to_f_setup[type, 1, NOT]
  const CPP_taylor* z_a_inv[6];
  for (int i = 0; i < 6; i++) {z_a_inv[i] = &C.a_inv[i];}
  // c_side.to_f_setup[type, 1, NOT]
  const CPP_taylor* z_dhdj[6];
  for (int i = 0; i < 6; i++) {z_dhdj[i] = &C.dhdj[i];}
  // c_side.to_f_setup[type, 1, NOT]
  const CPP_complex_taylor* z_f[6];
  for (int i = 0; i < 6; i++) {z_f[i] = &C.f[i];}
  // c_side.to_f_setup[type, 1, NOT]
  const CPP_complex_taylor* z_l[6];
  for (int i = 0; i < 6; i++) {z_l[i] = &C.l[i];}
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_ele_origin = 0; if (C.ele_origin != NULL) n_ele_origin = 1;

  // c_side.to_f2_call
  normal_form_to_f2 (F, z_m, z_a, z_a_inv, z_dhdj, z_f, z_l, *C.ele_origin, n_ele_origin);

}

// c_side.to_c2_arg
extern "C" void normal_form_to_c2 (CPP_normal_form& C, const Bmad_taylor_class** z_m, const
    Bmad_taylor_class** z_a, const Bmad_taylor_class** z_a_inv, const Bmad_taylor_class**
    z_dhdj, const Bmad_complex_taylor_class** z_f, const Bmad_complex_taylor_class** z_l,
    Bmad_ele_class* z_ele_origin, Int n_ele_origin) {

  // c_side.to_c2_set[type, 1, NOT]
  for (unsigned int i = 0; i < C.m.size(); i++) taylor_to_c(z_m[i], C.m[i]);
  // c_side.to_c2_set[type, 1, NOT]
  for (unsigned int i = 0; i < C.a.size(); i++) taylor_to_c(z_a[i], C.a[i]);
  // c_side.to_c2_set[type, 1, NOT]
  for (unsigned int i = 0; i < C.a_inv.size(); i++) taylor_to_c(z_a_inv[i], C.a_inv[i]);
  // c_side.to_c2_set[type, 1, NOT]
  for (unsigned int i = 0; i < C.dhdj.size(); i++) taylor_to_c(z_dhdj[i], C.dhdj[i]);
  // c_side.to_c2_set[type, 1, NOT]
  for (unsigned int i = 0; i < C.f.size(); i++) complex_taylor_to_c(z_f[i], C.f[i]);
  // c_side.to_c2_set[type, 1, NOT]
  for (unsigned int i = 0; i < C.l.size(); i++) complex_taylor_to_c(z_l[i], C.l[i]);
  // c_side.to_c2_set[type, 0, PTR]
  if (n_ele_origin == 0)
    delete C.ele_origin;
  else {
    C.ele_origin = new CPP_ele;
    ele_to_c(z_ele_origin, *C.ele_origin);
  }

}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_branch

extern "C" void branch_to_c (const Bmad_branch_class*, CPP_branch&);

// c_side.to_f2_arg
extern "C" void branch_to_f2 (Bmad_branch_class*, c_Char, c_Int&, c_Int&, c_Int&, c_IntArr,
    Int, c_IntArr, Int, const CPP_mode_info&, Int, const CPP_mode_info&, Int, const
    CPP_mode_info&, Int, const CPP_ele**, Int, const CPP_lat_param&, Int, const CPP_wall3d**,
    Int, const CPP_normal_form&, const CPP_normal_form&);

extern "C" void branch_to_f (const CPP_branch& C, Bmad_branch_class* F) {
  // c_side.to_f_setup[integer, 0, PTR]
  unsigned int n_n_ele_track = 0; if (C.n_ele_track != NULL) n_n_ele_track = 1;
  // c_side.to_f_setup[integer, 0, PTR]
  unsigned int n_n_ele_max = 0; if (C.n_ele_max != NULL) n_n_ele_max = 1;
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_a = 0; if (C.a != NULL) n_a = 1;
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_b = 0; if (C.b != NULL) n_b = 1;
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_z = 0; if (C.z != NULL) n_z = 1;
  // c_side.to_f_setup[type, 1, PTR]
  int n1_ele = C.ele.size();
  const CPP_ele** z_ele = NULL;
  if (n1_ele != 0) {
    z_ele = new const CPP_ele*[n1_ele];
    for (int i = 0; i < n1_ele; i++) z_ele[i] = &C.ele[i];
  }
  // c_side.to_f_setup[type, 0, PTR]
  unsigned int n_param = 0; if (C.param != NULL) n_param = 1;
  // c_side.to_f_setup[type, 1, PTR]
  int n1_wall3d = C.wall3d.size();
  const CPP_wall3d** z_wall3d = NULL;
  if (n1_wall3d != 0) {
    z_wall3d = new const CPP_wall3d*[n1_wall3d];
    for (int i = 0; i < n1_wall3d; i++) z_wall3d[i] = &C.wall3d[i];
  }

  // c_side.to_f2_call
  branch_to_f2 (F, C.name.c_str(), C.ix_branch, C.ix_from_branch, C.ix_from_ele, C.n_ele_track,
      n_n_ele_track, C.n_ele_max, n_n_ele_max, *C.a, n_a, *C.b, n_b, *C.z, n_z, z_ele, n1_ele,
      *C.param, n_param, z_wall3d, n1_wall3d, C.normal_form_with_rf, C.normal_form_no_rf);

  // c_side.to_f_cleanup[type, 1, PTR]
 delete[] z_ele;
  // c_side.to_f_cleanup[type, 1, PTR]
 delete[] z_wall3d;
}

// c_side.to_c2_arg
extern "C" void branch_to_c2 (CPP_branch& C, c_Char z_name, c_Int& z_ix_branch, c_Int&
    z_ix_from_branch, c_Int& z_ix_from_ele, c_IntArr z_n_ele_track, Int n_n_ele_track, c_IntArr
    z_n_ele_max, Int n_n_ele_max, Bmad_mode_info_class* z_a, Int n_a, Bmad_mode_info_class*
    z_b, Int n_b, Bmad_mode_info_class* z_z, Int n_z, Bmad_ele_class** z_ele, Int n1_ele,
    Bmad_lat_param_class* z_param, Int n_param, Bmad_wall3d_class** z_wall3d, Int n1_wall3d,
    const Bmad_normal_form_class* z_normal_form_with_rf, const Bmad_normal_form_class*
    z_normal_form_no_rf) {

  // c_side.to_c2_set[character, 0, NOT]
  C.name = z_name;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_branch = z_ix_branch;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_from_branch = z_ix_from_branch;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_from_ele = z_ix_from_ele;
  // c_side.to_c2_set[integer, 0, PTR]
  if (n_n_ele_track == 0)
    delete C.n_ele_track;
  else {
    C.n_ele_track = new Int;
    *C.n_ele_track = *z_n_ele_track;
  }

  // c_side.to_c2_set[integer, 0, PTR]
  if (n_n_ele_max == 0)
    delete C.n_ele_max;
  else {
    C.n_ele_max = new Int;
    *C.n_ele_max = *z_n_ele_max;
  }

  // c_side.to_c2_set[type, 0, PTR]
  if (n_a == 0)
    delete C.a;
  else {
    C.a = new CPP_mode_info;
    mode_info_to_c(z_a, *C.a);
  }

  // c_side.to_c2_set[type, 0, PTR]
  if (n_b == 0)
    delete C.b;
  else {
    C.b = new CPP_mode_info;
    mode_info_to_c(z_b, *C.b);
  }

  // c_side.to_c2_set[type, 0, PTR]
  if (n_z == 0)
    delete C.z;
  else {
    C.z = new CPP_mode_info;
    mode_info_to_c(z_z, *C.z);
  }

  // c_side.to_c2_set[type, 1, PTR]
  C.ele.resize(n1_ele);
  for (int i = 0; i < n1_ele; i++) ele_to_c(z_ele[i], C.ele[i]);

  // c_side.to_c2_set[type, 0, PTR]
  if (n_param == 0)
    delete C.param;
  else {
    C.param = new CPP_lat_param;
    lat_param_to_c(z_param, *C.param);
  }

  // c_side.to_c2_set[type, 1, PTR]
  C.wall3d.resize(n1_wall3d);
  for (int i = 0; i < n1_wall3d; i++) wall3d_to_c(z_wall3d[i], C.wall3d[i]);

  // c_side.to_c2_set[type, 0, NOT]
  normal_form_to_c(z_normal_form_with_rf, C.normal_form_with_rf);
  // c_side.to_c2_set[type, 0, NOT]
  normal_form_to_c(z_normal_form_no_rf, C.normal_form_no_rf);
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_lat

extern "C" void lat_to_c (const Bmad_lat_class*, CPP_lat&);

// c_side.to_f2_arg
extern "C" void lat_to_f2 (Bmad_lat_class*, c_Char, c_Char, c_Char, c_Char, c_Char*, Int, const
    CPP_mode_info&, const CPP_mode_info&, const CPP_mode_info&, const CPP_lat_param&, const
    CPP_bookkeeping_state&, const CPP_ele&, const CPP_ele**, Int, const CPP_branch**, Int,
    const CPP_control**, Int, const CPP_photon_reflect_surface**, Int, const CPP_coord&, const
    CPP_pre_tracker&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_Int&, c_IntArr, Int, c_Int&,
    c_Bool&, c_Bool&);

extern "C" void lat_to_f (const CPP_lat& C, Bmad_lat_class* F) {
  // c_side.to_f_setup[character, 1, ALLOC]
  int n1_attribute_alias = C.attribute_alias.size();
  c_Char* z_attribute_alias = NULL;
  if (n1_attribute_alias != 0) {
    z_attribute_alias = new c_Char[n1_attribute_alias];
    for (int i = 0; i < n1_attribute_alias; i++) z_attribute_alias[i] = C.attribute_alias[i].c_str();
  }
  // c_side.to_f_setup[type, 1, PTR]
  int n1_ele = C.ele.size();
  const CPP_ele** z_ele = NULL;
  if (n1_ele != 0) {
    z_ele = new const CPP_ele*[n1_ele];
    for (int i = 0; i < n1_ele; i++) z_ele[i] = &C.ele[i];
  }
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_branch = C.branch.size();
  const CPP_branch** z_branch = NULL;
  if (n1_branch != 0) {
    z_branch = new const CPP_branch*[n1_branch];
    for (int i = 0; i < n1_branch; i++) z_branch[i] = &C.branch[i];
  }
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_control = C.control.size();
  const CPP_control** z_control = NULL;
  if (n1_control != 0) {
    z_control = new const CPP_control*[n1_control];
    for (int i = 0; i < n1_control; i++) z_control[i] = &C.control[i];
  }
  // c_side.to_f_setup[type, 1, PTR]
  int n1_surface = C.surface.size();
  const CPP_photon_reflect_surface** z_surface = NULL;
  if (n1_surface != 0) {
    z_surface = new const CPP_photon_reflect_surface*[n1_surface];
    for (int i = 0; i < n1_surface; i++) z_surface[i] = &C.surface[i];
  }
  // c_side.to_f_setup[integer, 1, ALLOC]
  int n1_ic = C.ic.size();
  c_IntArr z_ic = NULL;
  if (n1_ic > 0) {
    z_ic = &C.ic[0];
  }

  // c_side.to_f2_call
  lat_to_f2 (F, C.use_name.c_str(), C.lattice.c_str(), C.input_file_name.c_str(),
      C.title.c_str(), z_attribute_alias, n1_attribute_alias, C.a, C.b, C.z, C.param,
      C.lord_state, C.ele_init, z_ele, n1_ele, z_branch, n1_branch, z_control, n1_control,
      z_surface, n1_surface, C.beam_start, C.pre_tracker, C.version, C.n_ele_track,
      C.n_ele_max, C.n_control_max, C.n_ic_max, C.input_taylor_order, z_ic, n1_ic,
      C.photon_type, C.absolute_time_tracking, C.ptc_uses_hard_edge_drifts);

  // c_side.to_f_cleanup[character, 1, ALLOC]
 delete[] z_attribute_alias;
  // c_side.to_f_cleanup[type, 1, PTR]
 delete[] z_ele;
  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_branch;
  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_control;
  // c_side.to_f_cleanup[type, 1, PTR]
 delete[] z_surface;
}

// c_side.to_c2_arg
extern "C" void lat_to_c2 (CPP_lat& C, c_Char z_use_name, c_Char z_lattice, c_Char
    z_input_file_name, c_Char z_title, c_Char* z_attribute_alias, Int n1_attribute_alias, const
    Bmad_mode_info_class* z_a, const Bmad_mode_info_class* z_b, const Bmad_mode_info_class*
    z_z, const Bmad_lat_param_class* z_param, const Bmad_bookkeeping_state_class* z_lord_state,
    const Bmad_ele_class* z_ele_init, Bmad_ele_class** z_ele, Int n1_ele, Bmad_branch_class**
    z_branch, Int n1_branch, Bmad_control_class** z_control, Int n1_control,
    Bmad_photon_reflect_surface_class** z_surface, Int n1_surface, const Bmad_coord_class*
    z_beam_start, const Bmad_pre_tracker_class* z_pre_tracker, c_Int& z_version, c_Int&
    z_n_ele_track, c_Int& z_n_ele_max, c_Int& z_n_control_max, c_Int& z_n_ic_max, c_Int&
    z_input_taylor_order, c_IntArr z_ic, Int n1_ic, c_Int& z_photon_type, c_Bool&
    z_absolute_time_tracking, c_Bool& z_ptc_uses_hard_edge_drifts) {

  // c_side.to_c2_set[character, 0, NOT]
  C.use_name = z_use_name;
  // c_side.to_c2_set[character, 0, NOT]
  C.lattice = z_lattice;
  // c_side.to_c2_set[character, 0, NOT]
  C.input_file_name = z_input_file_name;
  // c_side.to_c2_set[character, 0, NOT]
  C.title = z_title;
  // c_side.to_c2_set[character, 1, ALLOC]
  C.attribute_alias.resize(n1_attribute_alias);
  for (int i = 0; i < n1_attribute_alias; i++) C.attribute_alias[i] = z_attribute_alias[i];

  // c_side.to_c2_set[type, 0, NOT]
  mode_info_to_c(z_a, C.a);
  // c_side.to_c2_set[type, 0, NOT]
  mode_info_to_c(z_b, C.b);
  // c_side.to_c2_set[type, 0, NOT]
  mode_info_to_c(z_z, C.z);
  // c_side.to_c2_set[type, 0, NOT]
  lat_param_to_c(z_param, C.param);
  // c_side.to_c2_set[type, 0, NOT]
  bookkeeping_state_to_c(z_lord_state, C.lord_state);
  // c_side.to_c2_set[type, 0, NOT]
  ele_to_c(z_ele_init, C.ele_init);
  // c_side.to_c2_set[type, 1, PTR]
  C.ele.resize(n1_ele);
  for (int i = 0; i < n1_ele; i++) ele_to_c(z_ele[i], C.ele[i]);

  // c_side.to_c2_set[type, 1, ALLOC]
  C.branch.resize(n1_branch);
  for (int i = 0; i < n1_branch; i++) branch_to_c(z_branch[i], C.branch[i]);

  // c_side.to_c2_set[type, 1, ALLOC]
  C.control.resize(n1_control);
  for (int i = 0; i < n1_control; i++) control_to_c(z_control[i], C.control[i]);

  // c_side.to_c2_set[type, 1, PTR]
  C.surface.resize(n1_surface);
  for (int i = 0; i < n1_surface; i++) photon_reflect_surface_to_c(z_surface[i], C.surface[i]);

  // c_side.to_c2_set[type, 0, NOT]
  coord_to_c(z_beam_start, C.beam_start);
  // c_side.to_c2_set[type, 0, NOT]
  pre_tracker_to_c(z_pre_tracker, C.pre_tracker);
  // c_side.to_c2_set[integer, 0, NOT]
  C.version = z_version;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_ele_track = z_n_ele_track;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_ele_max = z_n_ele_max;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_control_max = z_n_control_max;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_ic_max = z_n_ic_max;
  // c_side.to_c2_set[integer, 0, NOT]
  C.input_taylor_order = z_input_taylor_order;
  // c_side.to_c2_set[integer, 1, ALLOC]

  C.ic.resize(n1_ic);
  C.ic << z_ic;

  // c_side.to_c2_set[integer, 0, NOT]
  C.photon_type = z_photon_type;
  // c_side.to_c2_set[logical, 0, NOT]
  C.absolute_time_tracking = z_absolute_time_tracking;
  // c_side.to_c2_set[logical, 0, NOT]
  C.ptc_uses_hard_edge_drifts = z_ptc_uses_hard_edge_drifts;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_bunch

extern "C" void bunch_to_c (const Bmad_bunch_class*, CPP_bunch&);

// c_side.to_f2_arg
extern "C" void bunch_to_f2 (Bmad_bunch_class*, const CPP_coord**, Int, c_IntArr, Int, c_Real&,
    c_Real&, c_Real&, c_Real&, c_Int&, c_Int&);

extern "C" void bunch_to_f (const CPP_bunch& C, Bmad_bunch_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_particle = C.particle.size();
  const CPP_coord** z_particle = NULL;
  if (n1_particle != 0) {
    z_particle = new const CPP_coord*[n1_particle];
    for (int i = 0; i < n1_particle; i++) z_particle[i] = &C.particle[i];
  }
  // c_side.to_f_setup[integer, 1, ALLOC]
  int n1_ix_z = C.ix_z.size();
  c_IntArr z_ix_z = NULL;
  if (n1_ix_z > 0) {
    z_ix_z = &C.ix_z[0];
  }

  // c_side.to_f2_call
  bunch_to_f2 (F, z_particle, n1_particle, z_ix_z, n1_ix_z, C.charge_tot, C.charge_live,
      C.z_center, C.t_center, C.ix_ele, C.ix_bunch);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_particle;
}

// c_side.to_c2_arg
extern "C" void bunch_to_c2 (CPP_bunch& C, Bmad_coord_class** z_particle, Int n1_particle,
    c_IntArr z_ix_z, Int n1_ix_z, c_Real& z_charge_tot, c_Real& z_charge_live, c_Real&
    z_z_center, c_Real& z_t_center, c_Int& z_ix_ele, c_Int& z_ix_bunch) {

  // c_side.to_c2_set[type, 1, ALLOC]
  C.particle.resize(n1_particle);
  for (int i = 0; i < n1_particle; i++) coord_to_c(z_particle[i], C.particle[i]);

  // c_side.to_c2_set[integer, 1, ALLOC]

  C.ix_z.resize(n1_ix_z);
  C.ix_z << z_ix_z;

  // c_side.to_c2_set[real, 0, NOT]
  C.charge_tot = z_charge_tot;
  // c_side.to_c2_set[real, 0, NOT]
  C.charge_live = z_charge_live;
  // c_side.to_c2_set[real, 0, NOT]
  C.z_center = z_z_center;
  // c_side.to_c2_set[real, 0, NOT]
  C.t_center = z_t_center;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_ele = z_ix_ele;
  // c_side.to_c2_set[integer, 0, NOT]
  C.ix_bunch = z_ix_bunch;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_beam_spin

extern "C" void beam_spin_to_c (const Bmad_beam_spin_class*, CPP_beam_spin&);

// c_side.to_f2_arg
extern "C" void beam_spin_to_f2 (Bmad_beam_spin_class*, c_Real&, c_Real&, c_Real&);

extern "C" void beam_spin_to_f (const CPP_beam_spin& C, Bmad_beam_spin_class* F) {

  // c_side.to_f2_call
  beam_spin_to_f2 (F, C.polarization, C.theta, C.phi);

}

// c_side.to_c2_arg
extern "C" void beam_spin_to_c2 (CPP_beam_spin& C, c_Real& z_polarization, c_Real& z_theta,
    c_Real& z_phi) {

  // c_side.to_c2_set[real, 0, NOT]
  C.polarization = z_polarization;
  // c_side.to_c2_set[real, 0, NOT]
  C.theta = z_theta;
  // c_side.to_c2_set[real, 0, NOT]
  C.phi = z_phi;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_bunch_params

extern "C" void bunch_params_to_c (const Bmad_bunch_params_class*, CPP_bunch_params&);

// c_side.to_f2_arg
extern "C" void bunch_params_to_f2 (Bmad_bunch_params_class*, const CPP_twiss&, const
    CPP_twiss&, const CPP_twiss&, const CPP_twiss&, const CPP_twiss&, const CPP_twiss&, const
    CPP_coord&, const CPP_beam_spin&, c_RealArr, c_Real&, c_Real&, c_Int&, c_Int&, c_Int&);

extern "C" void bunch_params_to_f (const CPP_bunch_params& C, Bmad_bunch_params_class* F) {
  // c_side.to_f_setup[real, 2, NOT]
  Real z_sigma[6*6]; matrix_to_vec(C.sigma, z_sigma);

  // c_side.to_f2_call
  bunch_params_to_f2 (F, C.x, C.y, C.z, C.a, C.b, C.c, C.centroid, C.spin, z_sigma, C.s,
      C.charge_live, C.n_particle_tot, C.n_particle_live, C.n_particle_lost_in_ele);

}

// c_side.to_c2_arg
extern "C" void bunch_params_to_c2 (CPP_bunch_params& C, const Bmad_twiss_class* z_x, const
    Bmad_twiss_class* z_y, const Bmad_twiss_class* z_z, const Bmad_twiss_class* z_a, const
    Bmad_twiss_class* z_b, const Bmad_twiss_class* z_c, const Bmad_coord_class* z_centroid,
    const Bmad_beam_spin_class* z_spin, c_RealArr z_sigma, c_Real& z_s, c_Real& z_charge_live,
    c_Int& z_n_particle_tot, c_Int& z_n_particle_live, c_Int& z_n_particle_lost_in_ele) {

  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_x, C.x);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_y, C.y);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_z, C.z);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_a, C.a);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_b, C.b);
  // c_side.to_c2_set[type, 0, NOT]
  twiss_to_c(z_c, C.c);
  // c_side.to_c2_set[type, 0, NOT]
  coord_to_c(z_centroid, C.centroid);
  // c_side.to_c2_set[type, 0, NOT]
  beam_spin_to_c(z_spin, C.spin);
  // c_side.to_c2_set[real, 2, NOT]
  C.sigma << z_sigma;
  // c_side.to_c2_set[real, 0, NOT]
  C.s = z_s;
  // c_side.to_c2_set[real, 0, NOT]
  C.charge_live = z_charge_live;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_particle_tot = z_n_particle_tot;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_particle_live = z_n_particle_live;
  // c_side.to_c2_set[integer, 0, NOT]
  C.n_particle_lost_in_ele = z_n_particle_lost_in_ele;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_beam

extern "C" void beam_to_c (const Bmad_beam_class*, CPP_beam&);

// c_side.to_f2_arg
extern "C" void beam_to_f2 (Bmad_beam_class*, const CPP_bunch**, Int);

extern "C" void beam_to_f (const CPP_beam& C, Bmad_beam_class* F) {
  // c_side.to_f_setup[type, 1, ALLOC]
  int n1_bunch = C.bunch.size();
  const CPP_bunch** z_bunch = NULL;
  if (n1_bunch != 0) {
    z_bunch = new const CPP_bunch*[n1_bunch];
    for (int i = 0; i < n1_bunch; i++) z_bunch[i] = &C.bunch[i];
  }

  // c_side.to_f2_call
  beam_to_f2 (F, z_bunch, n1_bunch);

  // c_side.to_f_cleanup[type, 1, ALLOC]
 delete[] z_bunch;
}

// c_side.to_c2_arg
extern "C" void beam_to_c2 (CPP_beam& C, Bmad_bunch_class** z_bunch, Int n1_bunch) {

  // c_side.to_c2_set[type, 1, ALLOC]
  C.bunch.resize(n1_bunch);
  for (int i = 0; i < n1_bunch; i++) bunch_to_c(z_bunch[i], C.bunch[i]);

}

#define CPP_BMAD_CONVERT
#endif
