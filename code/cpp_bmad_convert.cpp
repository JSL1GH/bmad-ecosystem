
//+
// C++ side of the Bmad / C++ structure interface.
//
// This file is generated as part of the Bmad/C++ interface code generation.
// The code generation files can be found in cpp_bmad_interface.
//
// DO NOT EDIT THIS FILE DIRECTLY! 
//-

#ifndef CPP_BMAD_CONVERT

#include <iostream>
#include "cpp_bmad_classes.h"

//---------------------------------------------------------------------------

template <class T> void operator<< (valarray<T>& arr, const T* ptr) {
  unsigned int n = arr.size();
  for (unsigned int i = 0; i < n; i++) arr[i] = ptr[i];
}

template <class T> void operator<< (valarray< valarray<T> >& mat, const T* ptr) {
  unsigned int n1 = mat.size();
  if (n1 == 0) return;
  unsigned int n2 = mat[0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      mat[i][j] = ptr[i*n2+j];
    }
  }
}

template <class T> void operator<< (valarray< valarray< valarray<T> > >& tensor, const T* ptr) {
  unsigned int n1 = tensor.size();
  if (n1 == 0) return;
  unsigned int n2 = tensor[0].size();
  unsigned int n3 = tensor[0][0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      for (unsigned int k = 0; k < n3; k++) {
        tensor[i][j][k] = ptr[i*n2*n3 + j*n3 + k];
      }
    }
  }
}

template <class T> void operator<< (valarray<T>& arr1, const valarray<T>& arr2) {
  unsigned int n1 = arr1.size(), n2 = arr2.size();
  if (n1 != n2) arr1.resize(n2);
  arr1 = arr2;
}

template <class T> void operator<< (valarray< valarray<T> >& mat1, 
                              const valarray< valarray<T> >& mat2) {
  unsigned int n1_1 = mat1.size(), n2_1 = mat2.size();
  unsigned int n1_2 = 0, n2_2 = 0;
  if (n1_1 > 0) n1_2 = mat1[0].size();
  if (n2_1 > 0) n2_2 = mat2[0].size();
  if (n1_1 != n2_1) mat1.resize(n2_1);
  if (n1_2 != n2_2) {for (unsigned int i = 0; i < n1_1; i++) mat1[i].resize(n2_2);}
  mat1 = mat2;
}

template <class T> void matrix_to_vec (const valarray< valarray<T> >& mat, T* vec) {
  unsigned int n1 = mat.size();
  if (n1 == 0) return;
  unsigned int n2 = mat[0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      vec[i*n2+j] = mat[i][j];
    }
  }
}

template <class T> void tensor_to_vec (const valarray< valarray< valarray<T> > >& tensor, T* vec) {
  unsigned int n1 = tensor.size();
  if (n1 == 0) return;
  unsigned int n2 = tensor[0].size();
  unsigned int n3 = tensor[0][0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      for (unsigned int k = 0; k < n3; k++) {
        vec[i*n2*n3 + j*n3 + k] = tensor[i][j][k];
      }
    }
  }
}

//---------------------------------------------------------------------------
// Instantiate instances for conversion from array to C++ structure.

template void operator<< (Bool_ARRAY&,  c_Bool*);
template void operator<< (Bool_MATRIX&, c_Bool*);

template void operator<< (Real_ARRAY&,  c_Real*);
template void operator<< (Real_MATRIX&, c_Real*);
template void operator<< (Real_TENSOR&, c_Real*);

template void operator<< (Complex_ARRAY&,  c_Complex*);
template void operator<< (Complex_MATRIX&, c_Complex*);
template void operator<< (Complex_TENSOR&, c_Complex*);

template void operator<< (Int_ARRAY&,  c_Int*);
template void operator<< (Int_MATRIX&, c_Int*);
template void operator<< (Int_TENSOR&, c_Int*);

//---------------------------------------------------------------------------
// Instantiate instances for transfer

template void operator<< (Real_ARRAY&,  const Real_ARRAY&);
template void operator<< (Real_MATRIX&, const Real_MATRIX&);
template void operator<< (Real_TENSOR&, const Real_TENSOR&);

template void operator<< (Complex_ARRAY&,  const Complex_ARRAY&);
template void operator<< (Complex_MATRIX&, const Complex_MATRIX&);
template void operator<< (Complex_TENSOR&, const Complex_TENSOR&);

template void operator<< (Int_ARRAY&,  const Int_ARRAY&);
template void operator<< (Int_MATRIX&, const Int_MATRIX&);
template void operator<< (Int_TENSOR&, const Int_TENSOR&);

//---------------------------------------------------------------------------

template void matrix_to_vec (const Bool_MATRIX&,     Bool*);
template void matrix_to_vec (const Complex_MATRIX&,  Complex*);
template void matrix_to_vec (const Real_MATRIX&,     Real*);
template void matrix_to_vec (const Int_MATRIX&,      Int*);

template void tensor_to_vec (const Complex_TENSOR&,  Complex*);
template void tensor_to_vec (const Real_TENSOR&,     Real*);
template void tensor_to_vec (const Int_TENSOR&,      Int*);

//---------------------------------------------------------------------------

void void_matrix_to_vec (const valarray< valarray< void** > >& mat, void** vec) {
  unsigned int n1 = mat.size();
  if (n1 == 0) return;
  unsigned int n2 = mat[0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      vec[i*n2+j] = mat[i][j];
    }
  }
}

void void_tensor_to_vec (const valarray< valarray< valarray< void** > > >& tensor, void** vec) {
  unsigned int n1 = tensor.size();
  if (n1 == 0) return;
  unsigned int n2 = tensor[0].size();
  unsigned int n3 = tensor[0][0].size();
  for (unsigned int i = 0; i < n1; i++) {
    for (unsigned int j = 0; j < n2; j++) {
      for (unsigned int k = 0; k < n3; k++) {
        vec[i*n2*n3 + j*n3 + k] = tensor[i][j][k];
      }
    }
  }
}


//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_my

extern "C" void my_to_c (const Bmad_my_class*, CPP_my&);

// c_side.to_f2_arg
extern "C" void my_to_f2 (Bmad_my_class*, c_Int&);

extern "C" void my_to_f (const CPP_my& C, Bmad_my_class* F) {

  // c_side.to_f2_call
  my_to_f2 (F, C.a);

}

// c_side.to_c2_arg
extern "C" void my_to_c2 (CPP_my& C, c_Int& z_a) {

  // c_side.to_c2_set[integer, 0, NOT]
  C.a = z_a;
}

//--------------------------------------------------------------------
//--------------------------------------------------------------------
// CPP_ttt

extern "C" void ttt_to_c (const Bmad_ttt_class*, CPP_ttt&);

// c_side.to_f2_arg
extern "C" void ttt_to_f2 (Bmad_ttt_class*, c_Bool&, c_BoolArr, Int, c_BoolArr, Int, c_BoolArr,
    c_BoolArr, Int, c_BoolArr, Int, c_BoolArr, c_BoolArr, Int, Int, c_BoolArr, Int, Int,
    c_BoolArr, c_BoolArr, Int, Int, Int, c_BoolArr, Int, Int, Int);

extern "C" void ttt_to_f (const CPP_ttt& C, Bmad_ttt_class* F) {
  // c_side.to_f_setup[logical, 0, PTR]
  unsigned int n_ip0 = 0; if (C.ip0 != NULL) n_ip0 = 1;
  // c_side.to_f_setup[logical, 0, ALLOC]
  unsigned int n_ia0 = 0; if (C.ia0 != NULL) n_ia0 = 1;
  // c_side.to_f_setup[logical, 1, PTR]
  int n1_ip1 = C.ip1.size();
  c_BoolArr z_ip1 = NULL;
  if (n1_ip1 > 0) {
    z_ip1 = &C.ip1[0];
  }
  // c_side.to_f_setup[logical, 1, ALLOC]
  int n1_ia1 = C.ia1.size();
  c_BoolArr z_ia1 = NULL;
  if (n1_ia1 > 0) {
    z_ia1 = &C.ia1[0];
  }
  // c_side.to_f_setup[logical, 2, NOT]
  Bool z_i2[3*2]; matrix_to_vec(C.i2, z_i2);
  // c_side.to_f_setup[logical, 2, PTR]
  int n1_ip2 = C.ip2.size(), n2_ip2 = 0;
  Bool* z_ip2 = NULL;
  if (n1_ip2 > 0) {
    n2_ip2 = C.ip2[0].size();
    z_ip2 = new Bool [n1_ip2*n2_ip2];
    matrix_to_vec (C.ip2, z_ip2);
  }
  // c_side.to_f_setup[logical, 2, ALLOC]
  int n1_ia2 = C.ia2.size(), n2_ia2 = 0;
  Bool* z_ia2 = NULL;
  if (n1_ia2 > 0) {
    n2_ia2 = C.ia2[0].size();
    z_ia2 = new Bool [n1_ia2*n2_ia2];
    matrix_to_vec (C.ia2, z_ia2);
  }
  // c_side.to_f_setup[logical, 3, NOT]
  Bool z_i3[3*2*1]; tensor_to_vec(C.i3, z_i3);
  // c_side.to_f_setup[logical, 3, PTR]

  int n1_ip3 = C.ip3.size(), n2_ip3 = 0, n3_ip3 = 0;
  Bool* z_ip3 = NULL;
  if (n1_ip3 > 0) {
    n2_ip3 = C.ip3[0].size();
    n3_ip3 = C.ip3[0][0].size();
    z_ip3 = new Bool [C.ip3.size()*C.ip3[0].size()*C.ip3[0][0].size()];
    tensor_to_vec (C.ip3, z_ip3);
  }
  // c_side.to_f_setup[logical, 3, ALLOC]

  int n1_ia3 = C.ia3.size(), n2_ia3 = 0, n3_ia3 = 0;
  Bool* z_ia3 = NULL;
  if (n1_ia3 > 0) {
    n2_ia3 = C.ia3[0].size();
    n3_ia3 = C.ia3[0][0].size();
    z_ia3 = new Bool [C.ia3.size()*C.ia3[0].size()*C.ia3[0][0].size()];
    tensor_to_vec (C.ia3, z_ia3);
  }

  // c_side.to_f2_call
  ttt_to_f2 (F, C.i0, C.ip0, n_ip0, C.ia0, n_ia0, &C.i1[0], z_ip1, n1_ip1, z_ia1, n1_ia1, z_i2,
      z_ip2, n1_ip2, n2_ip2, z_ia2, n1_ia2, n2_ia2, z_i3, z_ip3, n1_ip3, n2_ip3, n3_ip3, z_ia3,
      n1_ia3, n2_ia3, n3_ia3);

  // c_side.to_f_cleanup[logical, 2, PTR]
  delete[] z_ip2;
  // c_side.to_f_cleanup[logical, 2, ALLOC]
  delete[] z_ia2;
  // c_side.to_f_cleanup[logical, 3, PTR]
  delete[] z_ip3;
  // c_side.to_f_cleanup[logical, 3, ALLOC]
  delete[] z_ia3;
}

// c_side.to_c2_arg
extern "C" void ttt_to_c2 (CPP_ttt& C, c_Bool& z_i0, c_BoolArr z_ip0, Int n_ip0, c_BoolArr
    z_ia0, Int n_ia0, c_BoolArr z_i1, c_BoolArr z_ip1, Int n1_ip1, c_BoolArr z_ia1, Int n1_ia1,
    c_BoolArr z_i2, c_BoolArr z_ip2, Int n1_ip2, Int n2_ip2, c_BoolArr z_ia2, Int n1_ia2, Int
    n2_ia2, c_BoolArr z_i3, c_BoolArr z_ip3, Int n1_ip3, Int n2_ip3, Int n3_ip3, c_BoolArr
    z_ia3, Int n1_ia3, Int n2_ia3, Int n3_ia3) {

  // c_side.to_c2_set[logical, 0, NOT]
  C.i0 = z_i0;
  // c_side.to_c2_set[logical, 0, PTR]
  if (n_ip0 == 0)
    delete C.ip0;
  else {
    C.ip0 = new Bool;
    *C.ip0 = *z_ip0;
  }

  // c_side.to_c2_set[logical, 0, ALLOC]
  if (n_ia0 == 0)
    delete C.ia0;
  else {
    C.ia0 = new Bool;
    *C.ia0 = *z_ia0;
  }

  // c_side.to_c2_set[logical, 1, NOT]
  C.i1 << z_i1;
  // c_side.to_c2_set[logical, 1, PTR]

  C.ip1.resize(n1_ip1);
  C.ip1 << z_ip1;

  // c_side.to_c2_set[logical, 1, ALLOC]

  C.ia1.resize(n1_ia1);
  C.ia1 << z_ia1;

  // c_side.to_c2_set[logical, 2, NOT]
  C.i2 << z_i2;
  // c_side.to_c2_set[logical, 2, PTR]
  C.ip2.resize(n1_ip2);
  for (int i = 0; i < n1_ip2; i++) C.ip2[i].resize(n2_ip2);
  C.ip2 << z_ip2;

  // c_side.to_c2_set[logical, 2, ALLOC]
  C.ia2.resize(n1_ia2);
  for (int i = 0; i < n1_ia2; i++) C.ia2[i].resize(n2_ia2);
  C.ia2 << z_ia2;

  // c_side.to_c2_set[logical, 3, NOT]
  C.i3 << z_i3;
  // c_side.to_c2_set[logical, 3, PTR]
  C.ip3.resize(n1_ip3);
  for (unsigned int i = 0; i < C.ip3.size(); i++) {
    C.ip3[i].resize(n2_ip3);
    for (unsigned int j = 0; j < C.ip3[0].size(); j++)
      C.ip3[i][j].resize(n3_ip3);
  }
  C.ip3 << z_ip3;

  // c_side.to_c2_set[logical, 3, ALLOC]
  C.ia3.resize(n1_ia3);
  for (unsigned int i = 0; i < C.ia3.size(); i++) {
    C.ia3[i].resize(n2_ia3);
    for (unsigned int j = 0; j < C.ia3[0].size(); j++)
      C.ia3[i][j].resize(n3_ia3);
  }
  C.ia3 << z_ia3;

}

#define CPP_BMAD_CONVERT
#endif
