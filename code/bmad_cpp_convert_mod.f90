
!+
! Fortran side of the Bmad / C++ structure interface.
!
! This file is generated by the Bmad/C++ interface code generation.
! The code generation files can be found in cpp_bmad_interface.
!
! DO NOT EDIT THIS FILE DIRECTLY! 
!-

module bmad_cpp_convert_mod

use bmad_struct
use fortran_cpp_utils
use, intrinsic :: iso_c_binding

!--------------------------------------------------------------------------

interface 
  subroutine coord_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine coord_array_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bpm_phase_coupling_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wig_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wig_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rf_wake_sr_table_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rf_wake_sr_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rf_wake_lr_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rf_wake_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_map_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_map_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_grid_pt_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_grid_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_fields_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine floor_position_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine space_charge_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine xy_disp_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine twiss_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine mode3_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bookkeeping_state_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_int_ele_cache_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wall3d_vertex_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wall3d_section_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wall3d_crotch_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wall3d_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine taylor_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine taylor_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine control_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine lat_param_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine mode_info_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine pre_tracker_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine anormal_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine linac_normal_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine normal_modes_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine track_map_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine track_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine synch_rad_common_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bmad_common_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_int1_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_int_all_ele_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine ele_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine branch_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine lat_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

contains

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad coord_struct to a C++ CPP_coord structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad coord_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_coord struct.
!-

subroutine coord_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine coord_to_c2 (C, z_vec, z_s, z_t, z_spin, z_e_field_x, z_e_field_y, z_phase_x, &
      z_phase_y, z_charge, z_p0c, z_beta, z_ix_ele, z_state, z_location) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_spin(*)
    real(c_double) :: z_vec(*), z_s, z_t, z_e_field_x, z_e_field_y, z_phase_x, z_phase_y
    real(c_double) :: z_charge, z_p0c, z_beta
    integer(c_int) :: z_ix_ele, z_state, z_location
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(coord_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call coord_to_c2 (C, fvec2vec(F%vec, 6), F%s, F%t, fvec2vec(F%spin, 2), F%e_field_x, &
    F%e_field_y, F%phase_x, F%phase_y, F%charge, F%p0c, F%beta, F%ix_ele, F%state, F%location)

end subroutine coord_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_coord structure to a Bmad coord_struct structure.
! This routine is called by coord_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the coord_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad coord_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine coord_to_f2 (Fp, z_vec, z_s, z_t, z_spin, z_e_field_x, z_e_field_y, z_phase_x, &
    z_phase_y, z_charge, z_p0c, z_beta, z_ix_ele, z_state, z_location) bind(c)


implicit none

type(c_ptr), value :: Fp
type(coord_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_spin(*)
real(c_double) :: z_vec(*), z_s, z_t, z_e_field_x, z_e_field_y, z_phase_x, z_phase_y
real(c_double) :: z_charge, z_p0c, z_beta
integer(c_int) :: z_ix_ele, z_state, z_location

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%vec = z_vec(1:6)
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[real, 0, NOT]
F%t = z_t
!! f_side.to_f2_trans[complex, 1, NOT]
F%spin = z_spin(1:2)
!! f_side.to_f2_trans[real, 0, NOT]
F%e_field_x = z_e_field_x
!! f_side.to_f2_trans[real, 0, NOT]
F%e_field_y = z_e_field_y
!! f_side.to_f2_trans[real, 0, NOT]
F%phase_x = z_phase_x
!! f_side.to_f2_trans[real, 0, NOT]
F%phase_y = z_phase_y
!! f_side.to_f2_trans[real, 0, NOT]
F%charge = z_charge
!! f_side.to_f2_trans[real, 0, NOT]
F%p0c = z_p0c
!! f_side.to_f2_trans[real, 0, NOT]
F%beta = z_beta
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%state = z_state
!! f_side.to_f2_trans[integer, 0, NOT]
F%location = z_location

end subroutine coord_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_array_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad coord_array_struct to a C++ CPP_coord_array structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad coord_array_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_coord_array struct.
!-

subroutine coord_array_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine coord_array_to_c2 (C, z_orb, n1_orb) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_orb
    type(c_ptr) :: z_orb(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(coord_array_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_orb(:)
integer(c_int) :: n1_orb

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_orb = 0
if (allocated(F%orb)) then
  n1_orb = size(F%orb); lb1 = lbound(F%orb, 1) - 1
  allocate (z_orb(n1_orb))
  do jd1 = 1, n1_orb
    z_orb(jd1) = c_loc(F%orb(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call coord_array_to_c2 (C, z_orb, n1_orb)

end subroutine coord_array_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_array_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_coord_array structure to a Bmad coord_array_struct structure.
! This routine is called by coord_array_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the coord_array_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad coord_array_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine coord_array_to_f2 (Fp, z_orb, n1_orb) bind(c)


implicit none

type(c_ptr), value :: Fp
type(coord_array_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_orb
type(c_ptr) :: z_orb(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_orb == 0) then
  if (allocated(F%orb)) deallocate(F%orb)
else
  if (allocated(F%orb)) then
    if (n1_orb == 0 .or. any(shape(F%orb) /= [n1_orb])) deallocate(F%orb)
    if (any(lbound(F%orb) /= 1)) deallocate(F%orb)
  endif
  if (.not. allocated(F%orb)) allocate(F%orb(1:n1_orb+1-1))
  do jd1 = 1, n1_orb
    call coord_to_f (z_orb(jd1), c_loc(F%orb(jd1+1-1)))
  enddo
endif


end subroutine coord_array_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bpm_phase_coupling_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bpm_phase_coupling_struct to a C++ CPP_bpm_phase_coupling structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bpm_phase_coupling_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bpm_phase_coupling struct.
!-

subroutine bpm_phase_coupling_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bpm_phase_coupling_to_c2 (C, z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, &
      z_cbar12_a, z_cbar11_b, z_cbar12_b, z_phi_a, z_phi_b) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, z_cbar12_a, z_cbar11_b
    real(c_double) :: z_cbar12_b, z_phi_a, z_phi_b
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bpm_phase_coupling_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bpm_phase_coupling_to_c2 (C, F%k_22a, F%k_12a, F%k_11b, F%k_12b, F%cbar22_a, F%cbar12_a, &
    F%cbar11_b, F%cbar12_b, F%phi_a, F%phi_b)

end subroutine bpm_phase_coupling_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bpm_phase_coupling_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bpm_phase_coupling structure to a Bmad bpm_phase_coupling_struct structure.
! This routine is called by bpm_phase_coupling_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bpm_phase_coupling_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bpm_phase_coupling_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bpm_phase_coupling_to_f2 (Fp, z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, &
    z_cbar12_a, z_cbar11_b, z_cbar12_b, z_phi_a, z_phi_b) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bpm_phase_coupling_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, z_cbar12_a, z_cbar11_b
real(c_double) :: z_cbar12_b, z_phi_a, z_phi_b

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%k_22a = z_k_22a
!! f_side.to_f2_trans[real, 0, NOT]
F%k_12a = z_k_12a
!! f_side.to_f2_trans[real, 0, NOT]
F%k_11b = z_k_11b
!! f_side.to_f2_trans[real, 0, NOT]
F%k_12b = z_k_12b
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar22_a = z_cbar22_a
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar12_a = z_cbar12_a
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar11_b = z_cbar11_b
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar12_b = z_cbar12_b
!! f_side.to_f2_trans[real, 0, NOT]
F%phi_a = z_phi_a
!! f_side.to_f2_trans[real, 0, NOT]
F%phi_b = z_phi_b

end subroutine bpm_phase_coupling_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wig_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wig_term_struct to a C++ CPP_wig_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wig_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wig_term struct.
!-

subroutine wig_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wig_term_to_c2 (C, z_coef, z_kx, z_ky, z_kz, z_phi_z, z_type) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_coef, z_kx, z_ky, z_kz, z_phi_z
    integer(c_int) :: z_type
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wig_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wig_term_to_c2 (C, F%coef, F%kx, F%ky, F%kz, F%phi_z, F%type)

end subroutine wig_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wig_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wig_term structure to a Bmad wig_term_struct structure.
! This routine is called by wig_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wig_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wig_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wig_term_to_f2 (Fp, z_coef, z_kx, z_ky, z_kz, z_phi_z, z_type) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wig_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_coef, z_kx, z_ky, z_kz, z_phi_z
integer(c_int) :: z_type

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[real, 0, NOT]
F%kx = z_kx
!! f_side.to_f2_trans[real, 0, NOT]
F%ky = z_ky
!! f_side.to_f2_trans[real, 0, NOT]
F%kz = z_kz
!! f_side.to_f2_trans[real, 0, NOT]
F%phi_z = z_phi_z
!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type

end subroutine wig_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wig_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wig_struct to a C++ CPP_wig structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wig_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wig struct.
!-

subroutine wig_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wig_to_c2 (C, z_n_link, z_term, n1_term) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_term
    type(c_ptr) :: z_term(*)
    integer(c_int) :: z_n_link
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wig_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_term = 0
if (allocated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call wig_to_c2 (C, F%n_link, z_term, n1_term)

end subroutine wig_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wig_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wig structure to a Bmad wig_struct structure.
! This routine is called by wig_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wig_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wig_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wig_to_f2 (Fp, z_n_link, z_term, n1_term) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wig_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_term
type(c_ptr) :: z_term(*)
integer(c_int) :: z_n_link

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_term == 0) then
  if (allocated(F%term)) deallocate(F%term)
else
  if (allocated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. allocated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call wig_term_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine wig_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rf_wake_sr_table_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rf_wake_sr_table_struct to a C++ CPP_rf_wake_sr_table structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rf_wake_sr_table_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rf_wake_sr_table struct.
!-

subroutine rf_wake_sr_table_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rf_wake_sr_table_to_c2 (C, z_z, z_long, z_trans) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_z, z_long, z_trans
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rf_wake_sr_table_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call rf_wake_sr_table_to_c2 (C, F%z, F%long, F%trans)

end subroutine rf_wake_sr_table_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rf_wake_sr_table_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rf_wake_sr_table structure to a Bmad rf_wake_sr_table_struct structure.
! This routine is called by rf_wake_sr_table_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rf_wake_sr_table_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rf_wake_sr_table_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rf_wake_sr_table_to_f2 (Fp, z_z, z_long, z_trans) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rf_wake_sr_table_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_z, z_long, z_trans

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%z = z_z
!! f_side.to_f2_trans[real, 0, NOT]
F%long = z_long
!! f_side.to_f2_trans[real, 0, NOT]
F%trans = z_trans

end subroutine rf_wake_sr_table_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rf_wake_sr_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rf_wake_sr_mode_struct to a C++ CPP_rf_wake_sr_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rf_wake_sr_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rf_wake_sr_mode struct.
!-

subroutine rf_wake_sr_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rf_wake_sr_mode_to_c2 (C, z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin, &
      z_a_cos) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin
    real(c_double) :: z_a_cos
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rf_wake_sr_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call rf_wake_sr_mode_to_c2 (C, F%amp, F%damp, F%k, F%phi, F%b_sin, F%b_cos, F%a_sin, F%a_cos)

end subroutine rf_wake_sr_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rf_wake_sr_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rf_wake_sr_mode structure to a Bmad rf_wake_sr_mode_struct structure.
! This routine is called by rf_wake_sr_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rf_wake_sr_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rf_wake_sr_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rf_wake_sr_mode_to_f2 (Fp, z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin, &
    z_a_cos) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rf_wake_sr_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin
real(c_double) :: z_a_cos

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%amp = z_amp
!! f_side.to_f2_trans[real, 0, NOT]
F%damp = z_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%k = z_k
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%b_sin = z_b_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%b_cos = z_b_cos
!! f_side.to_f2_trans[real, 0, NOT]
F%a_sin = z_a_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%a_cos = z_a_cos

end subroutine rf_wake_sr_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rf_wake_lr_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rf_wake_lr_struct to a C++ CPP_rf_wake_lr structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rf_wake_lr_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rf_wake_lr struct.
!-

subroutine rf_wake_lr_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rf_wake_lr_to_c2 (C, z_freq, z_freq_in, z_r_over_q, z_q, z_angle, z_b_sin, &
      z_b_cos, z_a_sin, z_a_cos, z_t_ref, z_m, z_polarized) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_polarized
    real(c_double) :: z_freq, z_freq_in, z_r_over_q, z_q, z_angle, z_b_sin, z_b_cos
    real(c_double) :: z_a_sin, z_a_cos, z_t_ref
    integer(c_int) :: z_m
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rf_wake_lr_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call rf_wake_lr_to_c2 (C, F%freq, F%freq_in, F%r_over_q, F%q, F%angle, F%b_sin, F%b_cos, &
    F%a_sin, F%a_cos, F%t_ref, F%m, c_logic(F%polarized))

end subroutine rf_wake_lr_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rf_wake_lr_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rf_wake_lr structure to a Bmad rf_wake_lr_struct structure.
! This routine is called by rf_wake_lr_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rf_wake_lr_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rf_wake_lr_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rf_wake_lr_to_f2 (Fp, z_freq, z_freq_in, z_r_over_q, z_q, z_angle, z_b_sin, z_b_cos, &
    z_a_sin, z_a_cos, z_t_ref, z_m, z_polarized) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rf_wake_lr_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_polarized
real(c_double) :: z_freq, z_freq_in, z_r_over_q, z_q, z_angle, z_b_sin, z_b_cos
real(c_double) :: z_a_sin, z_a_cos, z_t_ref
integer(c_int) :: z_m

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%freq = z_freq
!! f_side.to_f2_trans[real, 0, NOT]
F%freq_in = z_freq_in
!! f_side.to_f2_trans[real, 0, NOT]
F%r_over_q = z_r_over_q
!! f_side.to_f2_trans[real, 0, NOT]
F%q = z_q
!! f_side.to_f2_trans[real, 0, NOT]
F%angle = z_angle
!! f_side.to_f2_trans[real, 0, NOT]
F%b_sin = z_b_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%b_cos = z_b_cos
!! f_side.to_f2_trans[real, 0, NOT]
F%a_sin = z_a_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%a_cos = z_a_cos
!! f_side.to_f2_trans[real, 0, NOT]
F%t_ref = z_t_ref
!! f_side.to_f2_trans[integer, 0, NOT]
F%m = z_m
!! f_side.to_f2_trans[logical, 0, NOT]
F%polarized = f_logic(z_polarized)

end subroutine rf_wake_lr_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rf_wake_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rf_wake_struct to a C++ CPP_rf_wake structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rf_wake_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rf_wake struct.
!-

subroutine rf_wake_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rf_wake_to_c2 (C, z_sr_file, z_lr_file, z_sr_table, n1_sr_table, z_sr_mode_long, &
      n1_sr_mode_long, z_sr_mode_trans, n1_sr_mode_trans, z_lr, n1_lr, z_z_sr_mode_max) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_sr_table, n1_sr_mode_long, n1_sr_mode_trans, n1_lr
    real(c_double) :: z_z_sr_mode_max
    type(c_ptr) :: z_sr_table(*), z_sr_mode_long(*), z_sr_mode_trans(*), z_lr(*)
    character(c_char) :: z_sr_file(*), z_lr_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rf_wake_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_sr_table(:)
integer(c_int) :: n1_sr_table
type(c_ptr), allocatable :: z_sr_mode_long(:)
integer(c_int) :: n1_sr_mode_long
type(c_ptr), allocatable :: z_sr_mode_trans(:)
integer(c_int) :: n1_sr_mode_trans
type(c_ptr), allocatable :: z_lr(:)
integer(c_int) :: n1_lr

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, PTR]
 n1_sr_table = 0
if (associated(F%sr_table)) then
  n1_sr_table = size(F%sr_table); lb1 = lbound(F%sr_table, 1) - 1
  allocate (z_sr_table(n1_sr_table))
  do jd1 = 1, n1_sr_table
    z_sr_table(jd1) = c_loc(F%sr_table(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_sr_mode_long = 0
if (associated(F%sr_mode_long)) then
  n1_sr_mode_long = size(F%sr_mode_long); lb1 = lbound(F%sr_mode_long, 1) - 1
  allocate (z_sr_mode_long(n1_sr_mode_long))
  do jd1 = 1, n1_sr_mode_long
    z_sr_mode_long(jd1) = c_loc(F%sr_mode_long(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_sr_mode_trans = 0
if (associated(F%sr_mode_trans)) then
  n1_sr_mode_trans = size(F%sr_mode_trans); lb1 = lbound(F%sr_mode_trans, 1) - 1
  allocate (z_sr_mode_trans(n1_sr_mode_trans))
  do jd1 = 1, n1_sr_mode_trans
    z_sr_mode_trans(jd1) = c_loc(F%sr_mode_trans(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_lr = 0
if (associated(F%lr)) then
  n1_lr = size(F%lr); lb1 = lbound(F%lr, 1) - 1
  allocate (z_lr(n1_lr))
  do jd1 = 1, n1_lr
    z_lr(jd1) = c_loc(F%lr(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call rf_wake_to_c2 (C, trim(F%sr_file) // c_null_char, trim(F%lr_file) // c_null_char, &
    z_sr_table, n1_sr_table, z_sr_mode_long, n1_sr_mode_long, z_sr_mode_trans, &
    n1_sr_mode_trans, z_lr, n1_lr, F%z_sr_mode_max)

end subroutine rf_wake_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rf_wake_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rf_wake structure to a Bmad rf_wake_struct structure.
! This routine is called by rf_wake_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rf_wake_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rf_wake_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rf_wake_to_f2 (Fp, z_sr_file, z_lr_file, z_sr_table, n1_sr_table, z_sr_mode_long, &
    n1_sr_mode_long, z_sr_mode_trans, n1_sr_mode_trans, z_lr, n1_lr, z_z_sr_mode_max) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rf_wake_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_sr_table, n1_sr_mode_long, n1_sr_mode_trans, n1_lr
real(c_double) :: z_z_sr_mode_max
type(c_ptr) :: z_sr_table(*), z_sr_mode_long(*), z_sr_mode_trans(*), z_lr(*)
character(c_char) :: z_sr_file(*), z_lr_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_sr_file, F%sr_file)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_lr_file, F%lr_file)
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_sr_table == 0) then
  if (associated(F%sr_table)) deallocate(F%sr_table)
else
  if (associated(F%sr_table)) then
    if (n1_sr_table == 0 .or. any(shape(F%sr_table) /= [n1_sr_table])) deallocate(F%sr_table)
    if (any(lbound(F%sr_table) /= 1)) deallocate(F%sr_table)
  endif
  if (.not. associated(F%sr_table)) allocate(F%sr_table(1:n1_sr_table+1-1))
  do jd1 = 1, n1_sr_table
    call rf_wake_sr_table_to_f (z_sr_table(jd1), c_loc(F%sr_table(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_sr_mode_long == 0) then
  if (associated(F%sr_mode_long)) deallocate(F%sr_mode_long)
else
  if (associated(F%sr_mode_long)) then
    if (n1_sr_mode_long == 0 .or. any(shape(F%sr_mode_long) /= [n1_sr_mode_long])) deallocate(F%sr_mode_long)
    if (any(lbound(F%sr_mode_long) /= 1)) deallocate(F%sr_mode_long)
  endif
  if (.not. associated(F%sr_mode_long)) allocate(F%sr_mode_long(1:n1_sr_mode_long+1-1))
  do jd1 = 1, n1_sr_mode_long
    call rf_wake_sr_mode_to_f (z_sr_mode_long(jd1), c_loc(F%sr_mode_long(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_sr_mode_trans == 0) then
  if (associated(F%sr_mode_trans)) deallocate(F%sr_mode_trans)
else
  if (associated(F%sr_mode_trans)) then
    if (n1_sr_mode_trans == 0 .or. any(shape(F%sr_mode_trans) /= [n1_sr_mode_trans])) deallocate(F%sr_mode_trans)
    if (any(lbound(F%sr_mode_trans) /= 1)) deallocate(F%sr_mode_trans)
  endif
  if (.not. associated(F%sr_mode_trans)) allocate(F%sr_mode_trans(1:n1_sr_mode_trans+1-1))
  do jd1 = 1, n1_sr_mode_trans
    call rf_wake_sr_mode_to_f (z_sr_mode_trans(jd1), c_loc(F%sr_mode_trans(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_lr == 0) then
  if (associated(F%lr)) deallocate(F%lr)
else
  if (associated(F%lr)) then
    if (n1_lr == 0 .or. any(shape(F%lr) /= [n1_lr])) deallocate(F%lr)
    if (any(lbound(F%lr) /= 1)) deallocate(F%lr)
  endif
  if (.not. associated(F%lr)) allocate(F%lr(1:n1_lr+1-1))
  do jd1 = 1, n1_lr
    call rf_wake_lr_to_f (z_lr(jd1), c_loc(F%lr(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%z_sr_mode_max = z_z_sr_mode_max

end subroutine rf_wake_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_map_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_map_term_struct to a C++ CPP_em_field_map_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_map_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field_map_term struct.
!-

subroutine em_field_map_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_map_term_to_c2 (C, z_e_coef, z_b_coef) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_e_coef, z_b_coef
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_map_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call em_field_map_term_to_c2 (C, F%e_coef, F%b_coef)

end subroutine em_field_map_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_map_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field_map_term structure to a Bmad em_field_map_term_struct structure.
! This routine is called by em_field_map_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_map_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_map_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_map_term_to_f2 (Fp, z_e_coef, z_b_coef) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_map_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_e_coef, z_b_coef

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 0, NOT]
F%e_coef = z_e_coef
!! f_side.to_f2_trans[complex, 0, NOT]
F%b_coef = z_b_coef

end subroutine em_field_map_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_map_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_map_struct to a C++ CPP_em_field_map structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_map_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field_map struct.
!-

subroutine em_field_map_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_map_to_c2 (C, z_file, z_n_link, z_ele_anchor_pt, z_dz, z_term, n1_term) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_term
    real(c_double) :: z_dz
    type(c_ptr) :: z_term(*)
    integer(c_int) :: z_n_link, z_ele_anchor_pt
    character(c_char) :: z_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_term = 0
if (allocated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call em_field_map_to_c2 (C, trim(F%file) // c_null_char, F%n_link, F%ele_anchor_pt, F%dz, &
    z_term, n1_term)

end subroutine em_field_map_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_map_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field_map structure to a Bmad em_field_map_struct structure.
! This routine is called by em_field_map_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_map_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_map_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_map_to_f2 (Fp, z_file, z_n_link, z_ele_anchor_pt, z_dz, z_term, n1_term) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_term
real(c_double) :: z_dz
type(c_ptr) :: z_term(*)
integer(c_int) :: z_n_link, z_ele_anchor_pt
character(c_char) :: z_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[real, 0, NOT]
F%dz = z_dz
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_term == 0) then
  if (allocated(F%term)) deallocate(F%term)
else
  if (allocated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. allocated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call em_field_map_term_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine em_field_map_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_grid_pt_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_grid_pt_struct to a C++ CPP_em_field_grid_pt structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_grid_pt_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field_grid_pt struct.
!-

subroutine em_field_grid_pt_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_grid_pt_to_c2 (C, z_e, z_b) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_e(*), z_b(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_grid_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call em_field_grid_pt_to_c2 (C, fvec2vec(F%e, 3), fvec2vec(F%b, 3))

end subroutine em_field_grid_pt_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_grid_pt_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field_grid_pt structure to a Bmad em_field_grid_pt_struct structure.
! This routine is called by em_field_grid_pt_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_grid_pt_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_grid_pt_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_grid_pt_to_f2 (Fp, z_e, z_b) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_grid_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_e(*), z_b(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 1, NOT]
F%e = z_e(1:3)
!! f_side.to_f2_trans[complex, 1, NOT]
F%b = z_b(1:3)

end subroutine em_field_grid_pt_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_grid_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_grid_struct to a C++ CPP_em_field_grid structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_grid_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field_grid struct.
!-

subroutine em_field_grid_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_grid_to_c2 (C, z_file, z_type, z_ele_anchor_pt, z_n_link, z_pt, n1_pt, &
      n2_pt, n3_pt, z_dr, z_r0) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_pt, n2_pt, n3_pt
    real(c_double) :: z_dr(*), z_r0(*)
    type(c_ptr) :: z_pt(*)
    integer(c_int) :: z_type, z_ele_anchor_pt, z_n_link
    character(c_char) :: z_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_grid_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_pt(:)
integer(c_int) :: n1_pt
integer(c_int) :: n2_pt
integer(c_int) :: n3_pt

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 3, ALLOC]
if (allocated(F%pt)) then
  n1_pt = size(F%pt, 1); lb1 = lbound(F%pt, 1) - 1
  n2_pt = size(F%pt, 2); lb2 = lbound(F%pt, 2) - 1
  n3_pt = size(F%pt, 3); lb3 = lbound(F%pt, 3) - 1
  allocate (z_pt(n1_pt * n2_pt * n3_pt))
  do jd1 = 1, n1_pt; do jd2 = 1, n2_pt; do jd3 = 1, n3_pt
    z_pt(n3_pt*n2_pt*(jd1-1) + n3_pt*(jd2-1) + jd3) = c_loc(F%pt(jd1+lb1, jd2+lb2, jd3+lb3))
  enddo;  enddo; enddo
else
  n1_pt = 0; n2_pt = 0; n3_pt = 0
endif

!! f_side.to_c2_call
call em_field_grid_to_c2 (C, trim(F%file) // c_null_char, F%type, F%ele_anchor_pt, F%n_link, &
    z_pt, n1_pt, n2_pt, n3_pt, fvec2vec(F%dr, 3), fvec2vec(F%r0, 3))

end subroutine em_field_grid_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_grid_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field_grid structure to a Bmad em_field_grid_struct structure.
! This routine is called by em_field_grid_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_grid_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_grid_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_grid_to_f2 (Fp, z_file, z_type, z_ele_anchor_pt, z_n_link, z_pt, n1_pt, &
    n2_pt, n3_pt, z_dr, z_r0) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_grid_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_pt, n2_pt, n3_pt
real(c_double) :: z_dr(*), z_r0(*)
type(c_ptr) :: z_pt(*)
integer(c_int) :: z_type, z_ele_anchor_pt, z_n_link
character(c_char) :: z_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[type, 3, ALLOC]
if (n1_pt == 0) then
  if (allocated(F%pt)) deallocate(F%pt)
else
  if (allocated(F%pt)) then
    if (n1_pt == 0 .or. any(shape(F%pt) /= [n1_pt, n2_pt, n3_pt])) deallocate(F%pt)
    if (any(lbound(F%pt) /= 1)) deallocate(F%pt)
  endif
  if (.not. allocated(F%pt)) allocate(F%pt(1:n1_pt+1-1, 1:n2_pt+1-1, 1:n3_pt+1-1))
  do jd1 = 1, n1_pt;  do jd2 = 1, n2_pt;  do jd3 = 1, n3_pt
    call em_field_grid_pt_to_f (z_pt(n3_pt*n2_pt*(jd1-1) + n3_pt*(jd2-1) + jd3), c_loc(F%pt(jd1+1-1,jd2+1-1,jd3+1-1)))
  enddo;  enddo;  enddo
endif

!! f_side.to_f2_trans[real, 1, NOT]
F%dr = z_dr(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:3)

end subroutine em_field_grid_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_mode_struct to a C++ CPP_em_field_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field_mode struct.
!-

subroutine em_field_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_mode_to_c2 (C, z_m, z_harmonic, z_f_damp, z_dphi0_ref, z_stored_energy, &
      z_phi0_azimuth, z_field_scale, z_master_scale, z_map, n_map, z_grid, n_grid) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_map, z_grid
    real(c_double) :: z_f_damp, z_dphi0_ref, z_stored_energy, z_phi0_azimuth, z_field_scale
    integer(c_int), value :: n_map, n_grid
    integer(c_int) :: z_m, z_harmonic, z_master_scale
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n_map
integer(c_int) :: n_grid

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 0, PTR]
n_map = 0
if (associated(F%map)) n_map = 1
!! f_side.to_c_trans[type, 0, PTR]
n_grid = 0
if (associated(F%grid)) n_grid = 1

!! f_side.to_c2_call
call em_field_mode_to_c2 (C, F%m, F%harmonic, F%f_damp, F%dphi0_ref, F%stored_energy, &
    F%phi0_azimuth, F%field_scale, F%master_scale, c_loc(F%map), n_map, c_loc(F%grid), n_grid)

end subroutine em_field_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field_mode structure to a Bmad em_field_mode_struct structure.
! This routine is called by em_field_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_mode_to_f2 (Fp, z_m, z_harmonic, z_f_damp, z_dphi0_ref, z_stored_energy, &
    z_phi0_azimuth, z_field_scale, z_master_scale, z_map, n_map, z_grid, n_grid) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_m, z_harmonic, z_master_scale
type(em_field_map_struct), pointer :: f_map
integer(c_int), value :: n_map, n_grid
type(em_field_grid_struct), pointer :: f_grid
real(c_double) :: z_f_damp, z_dphi0_ref, z_stored_energy, z_phi0_azimuth, z_field_scale
type(c_ptr), value :: z_map, z_grid

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%m = z_m
!! f_side.to_f2_trans[integer, 0, NOT]
F%harmonic = z_harmonic
!! f_side.to_f2_trans[real, 0, NOT]
F%f_damp = z_f_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%dphi0_ref = z_dphi0_ref
!! f_side.to_f2_trans[real, 0, NOT]
F%stored_energy = z_stored_energy
!! f_side.to_f2_trans[real, 0, NOT]
F%phi0_azimuth = z_phi0_azimuth
!! f_side.to_f2_trans[real, 0, NOT]
F%field_scale = z_field_scale
!! f_side.to_f2_trans[integer, 0, NOT]
F%master_scale = z_master_scale
!! f_side.to_f2_trans[type, 0, PTR]
if (n_map == 0) then
  if (associated(F%map)) deallocate(F%map)
else
  if (.not. associated(F%map)) allocate(F%map)
  call em_field_map_to_f (z_map, c_loc(F%map))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_grid == 0) then
  if (associated(F%grid)) deallocate(F%grid)
else
  if (.not. associated(F%grid)) allocate(F%grid)
  call em_field_grid_to_f (z_grid, c_loc(F%grid))
endif


end subroutine em_field_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_fields_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_fields_struct to a C++ CPP_em_fields structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_fields_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_fields struct.
!-

subroutine em_fields_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_fields_to_c2 (C, z_mode, n1_mode) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_mode
    type(c_ptr) :: z_mode(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_fields_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_mode(:)
integer(c_int) :: n1_mode

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_mode = 0
if (allocated(F%mode)) then
  n1_mode = size(F%mode); lb1 = lbound(F%mode, 1) - 1
  allocate (z_mode(n1_mode))
  do jd1 = 1, n1_mode
    z_mode(jd1) = c_loc(F%mode(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call em_fields_to_c2 (C, z_mode, n1_mode)

end subroutine em_fields_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_fields_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_fields structure to a Bmad em_fields_struct structure.
! This routine is called by em_fields_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_fields_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_fields_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_fields_to_f2 (Fp, z_mode, n1_mode) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_fields_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_mode
type(c_ptr) :: z_mode(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_mode == 0) then
  if (allocated(F%mode)) deallocate(F%mode)
else
  if (allocated(F%mode)) then
    if (n1_mode == 0 .or. any(shape(F%mode) /= [n1_mode])) deallocate(F%mode)
    if (any(lbound(F%mode) /= 1)) deallocate(F%mode)
  endif
  if (.not. allocated(F%mode)) allocate(F%mode(1:n1_mode+1-1))
  do jd1 = 1, n1_mode
    call em_field_mode_to_f (z_mode(jd1), c_loc(F%mode(jd1+1-1)))
  enddo
endif


end subroutine em_fields_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine floor_position_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad floor_position_struct to a C++ CPP_floor_position structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad floor_position_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_floor_position struct.
!-

subroutine floor_position_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine floor_position_to_c2 (C, z_r, z_theta, z_phi, z_psi) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_r(*), z_theta, z_phi, z_psi
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(floor_position_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call floor_position_to_c2 (C, fvec2vec(F%r, 3), F%theta, F%phi, F%psi)

end subroutine floor_position_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine floor_position_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_floor_position structure to a Bmad floor_position_struct structure.
! This routine is called by floor_position_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the floor_position_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad floor_position_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine floor_position_to_f2 (Fp, z_r, z_theta, z_phi, z_psi) bind(c)


implicit none

type(c_ptr), value :: Fp
type(floor_position_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_r(*), z_theta, z_phi, z_psi

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%r = z_r(1:3)
!! f_side.to_f2_trans[real, 0, NOT]
F%theta = z_theta
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%psi = z_psi

end subroutine floor_position_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine space_charge_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad space_charge_struct to a C++ CPP_space_charge structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad space_charge_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_space_charge struct.
!-

subroutine space_charge_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine space_charge_to_c2 (C, z_closed_orb, z_kick_const, z_sig_x, z_sig_y, z_phi, &
      z_sin_phi, z_cos_phi, z_sig_z) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_closed_orb
    real(c_double) :: z_kick_const, z_sig_x, z_sig_y, z_phi, z_sin_phi, z_cos_phi, z_sig_z
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(space_charge_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call space_charge_to_c2 (C, c_loc(F%closed_orb), F%kick_const, F%sig_x, F%sig_y, F%phi, &
    F%sin_phi, F%cos_phi, F%sig_z)

end subroutine space_charge_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine space_charge_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_space_charge structure to a Bmad space_charge_struct structure.
! This routine is called by space_charge_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the space_charge_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad space_charge_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine space_charge_to_f2 (Fp, z_closed_orb, z_kick_const, z_sig_x, z_sig_y, z_phi, &
    z_sin_phi, z_cos_phi, z_sig_z) bind(c)


implicit none

type(c_ptr), value :: Fp
type(space_charge_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_closed_orb
real(c_double) :: z_kick_const, z_sig_x, z_sig_y, z_phi, z_sin_phi, z_cos_phi, z_sig_z

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_closed_orb, c_loc(F%closed_orb))
!! f_side.to_f2_trans[real, 0, NOT]
F%kick_const = z_kick_const
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_x = z_sig_x
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_y = z_sig_y
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%sin_phi = z_sin_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%cos_phi = z_cos_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_z = z_sig_z

end subroutine space_charge_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine xy_disp_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad xy_disp_struct to a C++ CPP_xy_disp structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad xy_disp_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_xy_disp struct.
!-

subroutine xy_disp_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine xy_disp_to_c2 (C, z_eta, z_etap) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_eta, z_etap
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(xy_disp_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call xy_disp_to_c2 (C, F%eta, F%etap)

end subroutine xy_disp_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine xy_disp_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_xy_disp structure to a Bmad xy_disp_struct structure.
! This routine is called by xy_disp_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the xy_disp_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad xy_disp_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine xy_disp_to_f2 (Fp, z_eta, z_etap) bind(c)


implicit none

type(c_ptr), value :: Fp
type(xy_disp_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_eta, z_etap

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%eta = z_eta
!! f_side.to_f2_trans[real, 0, NOT]
F%etap = z_etap

end subroutine xy_disp_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine twiss_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad twiss_struct to a C++ CPP_twiss structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad twiss_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_twiss struct.
!-

subroutine twiss_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine twiss_to_c2 (C, z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_sigma, &
      z_sigma_p, z_emit, z_norm_emit) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_sigma
    real(c_double) :: z_sigma_p, z_emit, z_norm_emit
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(twiss_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call twiss_to_c2 (C, F%beta, F%alpha, F%gamma, F%phi, F%eta, F%etap, F%sigma, F%sigma_p, &
    F%emit, F%norm_emit)

end subroutine twiss_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine twiss_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_twiss structure to a Bmad twiss_struct structure.
! This routine is called by twiss_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the twiss_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad twiss_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine twiss_to_f2 (Fp, z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_sigma, z_sigma_p, &
    z_emit, z_norm_emit) bind(c)


implicit none

type(c_ptr), value :: Fp
type(twiss_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_sigma
real(c_double) :: z_sigma_p, z_emit, z_norm_emit

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%beta = z_beta
!! f_side.to_f2_trans[real, 0, NOT]
F%alpha = z_alpha
!! f_side.to_f2_trans[real, 0, NOT]
F%gamma = z_gamma
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%eta = z_eta
!! f_side.to_f2_trans[real, 0, NOT]
F%etap = z_etap
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma = z_sigma
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma_p = z_sigma_p
!! f_side.to_f2_trans[real, 0, NOT]
F%emit = z_emit
!! f_side.to_f2_trans[real, 0, NOT]
F%norm_emit = z_norm_emit

end subroutine twiss_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode3_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad mode3_struct to a C++ CPP_mode3 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad mode3_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_mode3 struct.
!-

subroutine mode3_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine mode3_to_c2 (C, z_v, z_a, z_b, z_c, z_x, z_y) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_a, z_b, z_c, z_x, z_y
    real(c_double) :: z_v(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(mode3_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call mode3_to_c2 (C, mat2vec(F%v, 6*6), c_loc(F%a), c_loc(F%b), c_loc(F%c), c_loc(F%x), &
    c_loc(F%y))

end subroutine mode3_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode3_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_mode3 structure to a Bmad mode3_struct structure.
! This routine is called by mode3_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the mode3_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad mode3_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine mode3_to_f2 (Fp, z_v, z_a, z_b, z_c, z_x, z_y) bind(c)


implicit none

type(c_ptr), value :: Fp
type(mode3_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_a, z_b, z_c, z_x, z_y
real(c_double) :: z_v(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_v, F%v)
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_c, c_loc(F%c))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_x, c_loc(F%x))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_y, c_loc(F%y))

end subroutine mode3_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bookkeeping_state_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bookkeeping_state_struct to a C++ CPP_bookkeeping_state structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bookkeeping_state_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bookkeeping_state struct.
!-

subroutine bookkeeping_state_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bookkeeping_state_to_c2 (C, z_attributes, z_control, z_floor_position, &
      z_s_position, z_ref_energy, z_mat6, z_rad_int) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_attributes, z_control, z_floor_position, z_s_position, z_ref_energy, z_mat6, z_rad_int
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bookkeeping_state_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bookkeeping_state_to_c2 (C, F%attributes, F%control, F%floor_position, F%s_position, &
    F%ref_energy, F%mat6, F%rad_int)

end subroutine bookkeeping_state_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bookkeeping_state_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bookkeeping_state structure to a Bmad bookkeeping_state_struct structure.
! This routine is called by bookkeeping_state_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bookkeeping_state_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bookkeeping_state_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bookkeeping_state_to_f2 (Fp, z_attributes, z_control, z_floor_position, &
    z_s_position, z_ref_energy, z_mat6, z_rad_int) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bookkeeping_state_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_attributes, z_control, z_floor_position, z_s_position, z_ref_energy, z_mat6, z_rad_int

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%attributes = z_attributes
!! f_side.to_f2_trans[integer, 0, NOT]
F%control = z_control
!! f_side.to_f2_trans[integer, 0, NOT]
F%floor_position = z_floor_position
!! f_side.to_f2_trans[integer, 0, NOT]
F%s_position = z_s_position
!! f_side.to_f2_trans[integer, 0, NOT]
F%ref_energy = z_ref_energy
!! f_side.to_f2_trans[integer, 0, NOT]
F%mat6 = z_mat6
!! f_side.to_f2_trans[integer, 0, NOT]
F%rad_int = z_rad_int

end subroutine bookkeeping_state_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_ele_cache_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_int_ele_cache_struct to a C++ CPP_rad_int_ele_cache structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_int_ele_cache_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_int_ele_cache struct.
!-

subroutine rad_int_ele_cache_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_int_ele_cache_to_c2 (C, z_orb0, z_g2_0, z_g3_0, z_dg2_dorb, z_dg3_dorb, &
      z_stale) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_stale
    real(c_double) :: z_orb0(*), z_g2_0, z_g3_0, z_dg2_dorb(*), z_dg3_dorb(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_int_ele_cache_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call rad_int_ele_cache_to_c2 (C, fvec2vec(F%orb0, 6), F%g2_0, F%g3_0, fvec2vec(F%dg2_dorb, 6), &
    fvec2vec(F%dg3_dorb, 6), c_logic(F%stale))

end subroutine rad_int_ele_cache_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_ele_cache_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_int_ele_cache structure to a Bmad rad_int_ele_cache_struct structure.
! This routine is called by rad_int_ele_cache_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_int_ele_cache_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_int_ele_cache_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_int_ele_cache_to_f2 (Fp, z_orb0, z_g2_0, z_g3_0, z_dg2_dorb, z_dg3_dorb, &
    z_stale) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_int_ele_cache_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_stale
real(c_double) :: z_orb0(*), z_g2_0, z_g3_0, z_dg2_dorb(*), z_dg3_dorb(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%orb0 = z_orb0(1:6)
!! f_side.to_f2_trans[real, 0, NOT]
F%g2_0 = z_g2_0
!! f_side.to_f2_trans[real, 0, NOT]
F%g3_0 = z_g3_0
!! f_side.to_f2_trans[real, 1, NOT]
F%dg2_dorb = z_dg2_dorb(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%dg3_dorb = z_dg3_dorb(1:6)
!! f_side.to_f2_trans[logical, 0, NOT]
F%stale = f_logic(z_stale)

end subroutine rad_int_ele_cache_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_vertex_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wall3d_vertex_struct to a C++ CPP_wall3d_vertex structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wall3d_vertex_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wall3d_vertex struct.
!-

subroutine wall3d_vertex_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wall3d_vertex_to_c2 (C, z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0, &
      z_y0) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0
    real(c_double) :: z_y0
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wall3d_vertex_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wall3d_vertex_to_c2 (C, F%x, F%y, F%radius_x, F%radius_y, F%tilt, F%angle, F%x0, F%y0)

end subroutine wall3d_vertex_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_vertex_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wall3d_vertex structure to a Bmad wall3d_vertex_struct structure.
! This routine is called by wall3d_vertex_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wall3d_vertex_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wall3d_vertex_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wall3d_vertex_to_f2 (Fp, z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0, &
    z_y0) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wall3d_vertex_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0
real(c_double) :: z_y0

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%x = z_x
!! f_side.to_f2_trans[real, 0, NOT]
F%y = z_y
!! f_side.to_f2_trans[real, 0, NOT]
F%radius_x = z_radius_x
!! f_side.to_f2_trans[real, 0, NOT]
F%radius_y = z_radius_y
!! f_side.to_f2_trans[real, 0, NOT]
F%tilt = z_tilt
!! f_side.to_f2_trans[real, 0, NOT]
F%angle = z_angle
!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0

end subroutine wall3d_vertex_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_section_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wall3d_section_struct to a C++ CPP_wall3d_section structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wall3d_section_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wall3d_section struct.
!-

subroutine wall3d_section_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wall3d_section_to_c2 (C, z_type, z_s, z_n_vertex_input, z_v, n1_v, z_x0, z_y0, &
      z_dx0_ds, z_dy0_ds, z_x0_coef, z_y0_coef, z_dr_ds, z_p1_coef, z_p2_coef) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_v
    real(c_double) :: z_s, z_x0, z_y0, z_dx0_ds, z_dy0_ds, z_x0_coef(*), z_y0_coef(*)
    real(c_double) :: z_dr_ds, z_p1_coef(*), z_p2_coef(*)
    type(c_ptr) :: z_v(*)
    integer(c_int) :: z_type, z_n_vertex_input
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wall3d_section_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_v(:)
integer(c_int) :: n1_v

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_v = 0
if (allocated(F%v)) then
  n1_v = size(F%v); lb1 = lbound(F%v, 1) - 1
  allocate (z_v(n1_v))
  do jd1 = 1, n1_v
    z_v(jd1) = c_loc(F%v(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call wall3d_section_to_c2 (C, F%type, F%s, F%n_vertex_input, z_v, n1_v, F%x0, F%y0, F%dx0_ds, &
    F%dy0_ds, fvec2vec(F%x0_coef, 4), fvec2vec(F%y0_coef, 4), F%dr_ds, fvec2vec(F%p1_coef, 3), &
    fvec2vec(F%p2_coef, 3))

end subroutine wall3d_section_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_section_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wall3d_section structure to a Bmad wall3d_section_struct structure.
! This routine is called by wall3d_section_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wall3d_section_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wall3d_section_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wall3d_section_to_f2 (Fp, z_type, z_s, z_n_vertex_input, z_v, n1_v, z_x0, z_y0, &
    z_dx0_ds, z_dy0_ds, z_x0_coef, z_y0_coef, z_dr_ds, z_p1_coef, z_p2_coef) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wall3d_section_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_v
real(c_double) :: z_s, z_x0, z_y0, z_dx0_ds, z_dy0_ds, z_x0_coef(*), z_y0_coef(*)
real(c_double) :: z_dr_ds, z_p1_coef(*), z_p2_coef(*)
type(c_ptr) :: z_v(*)
integer(c_int) :: z_type, z_n_vertex_input

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_vertex_input = z_n_vertex_input
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_v == 0) then
  if (allocated(F%v)) deallocate(F%v)
else
  if (allocated(F%v)) then
    if (n1_v == 0 .or. any(shape(F%v) /= [n1_v])) deallocate(F%v)
    if (any(lbound(F%v) /= 1)) deallocate(F%v)
  endif
  if (.not. allocated(F%v)) allocate(F%v(1:n1_v+1-1))
  do jd1 = 1, n1_v
    call wall3d_vertex_to_f (z_v(jd1), c_loc(F%v(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0
!! f_side.to_f2_trans[real, 0, NOT]
F%dx0_ds = z_dx0_ds
!! f_side.to_f2_trans[real, 0, NOT]
F%dy0_ds = z_dy0_ds
!! f_side.to_f2_trans[real, 1, NOT]
F%x0_coef = z_x0_coef(1:4)
!! f_side.to_f2_trans[real, 1, NOT]
F%y0_coef = z_y0_coef(1:4)
!! f_side.to_f2_trans[real, 0, NOT]
F%dr_ds = z_dr_ds
!! f_side.to_f2_trans[real, 1, NOT]
F%p1_coef = z_p1_coef(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%p2_coef = z_p2_coef(1:3)

end subroutine wall3d_section_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_crotch_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wall3d_crotch_struct to a C++ CPP_wall3d_crotch structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wall3d_crotch_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wall3d_crotch struct.
!-

subroutine wall3d_crotch_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wall3d_crotch_to_c2 (C, z_location, z_ix_section, z_ix_v1_cut, z_ix_v2_cut, &
      z_section) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_section
    integer(c_int) :: z_location, z_ix_section, z_ix_v1_cut, z_ix_v2_cut
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wall3d_crotch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wall3d_crotch_to_c2 (C, F%location, F%ix_section, F%ix_v1_cut, F%ix_v2_cut, &
    c_loc(F%section))

end subroutine wall3d_crotch_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_crotch_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wall3d_crotch structure to a Bmad wall3d_crotch_struct structure.
! This routine is called by wall3d_crotch_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wall3d_crotch_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wall3d_crotch_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wall3d_crotch_to_f2 (Fp, z_location, z_ix_section, z_ix_v1_cut, z_ix_v2_cut, &
    z_section) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wall3d_crotch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_section
integer(c_int) :: z_location, z_ix_section, z_ix_v1_cut, z_ix_v2_cut

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%location = z_location
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_section = z_ix_section
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_v1_cut = z_ix_v1_cut
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_v2_cut = z_ix_v2_cut
!! f_side.to_f2_trans[type, 0, NOT]
call wall3d_section_to_f(z_section, c_loc(F%section))

end subroutine wall3d_crotch_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wall3d_struct to a C++ CPP_wall3d structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wall3d_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wall3d struct.
!-

subroutine wall3d_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wall3d_to_c2 (C, z_n_link, z_priority, z_ele_anchor_pt, z_crotch, z_section, &
      n1_section) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_section
    type(c_ptr), value :: z_crotch
    type(c_ptr) :: z_section(*)
    integer(c_int) :: z_n_link, z_priority, z_ele_anchor_pt
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wall3d_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_section(:)
integer(c_int) :: n1_section

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_section = 0
if (allocated(F%section)) then
  n1_section = size(F%section); lb1 = lbound(F%section, 1) - 1
  allocate (z_section(n1_section))
  do jd1 = 1, n1_section
    z_section(jd1) = c_loc(F%section(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call wall3d_to_c2 (C, F%n_link, F%priority, F%ele_anchor_pt, c_loc(F%crotch), z_section, &
    n1_section)

end subroutine wall3d_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wall3d structure to a Bmad wall3d_struct structure.
! This routine is called by wall3d_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wall3d_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wall3d_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wall3d_to_f2 (Fp, z_n_link, z_priority, z_ele_anchor_pt, z_crotch, z_section, &
    n1_section) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wall3d_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_section
type(c_ptr), value :: z_crotch
type(c_ptr) :: z_section(*)
integer(c_int) :: z_n_link, z_priority, z_ele_anchor_pt

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[integer, 0, NOT]
F%priority = z_priority
!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[type, 0, NOT]
call wall3d_crotch_to_f(z_crotch, c_loc(F%crotch))
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_section == 0) then
  if (allocated(F%section)) deallocate(F%section)
else
  if (allocated(F%section)) then
    if (n1_section == 0 .or. any(shape(F%section) /= [n1_section])) deallocate(F%section)
    if (any(lbound(F%section) /= 1)) deallocate(F%section)
  endif
  if (.not. allocated(F%section)) allocate(F%section(1:n1_section+1-1))
  do jd1 = 1, n1_section
    call wall3d_section_to_f (z_section(jd1), c_loc(F%section(jd1+1-1)))
  enddo
endif


end subroutine wall3d_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad taylor_term_struct to a C++ CPP_taylor_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad taylor_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_taylor_term struct.
!-

subroutine taylor_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine taylor_term_to_c2 (C, z_coef, z_expn) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_coef
    integer(c_int) :: z_expn(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call taylor_term_to_c2 (C, F%coef, fvec2vec(F%expn, 6))

end subroutine taylor_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_taylor_term structure to a Bmad taylor_term_struct structure.
! This routine is called by taylor_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the taylor_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad taylor_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine taylor_term_to_f2 (Fp, z_coef, z_expn) bind(c)


implicit none

type(c_ptr), value :: Fp
type(taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_coef
integer(c_int) :: z_expn(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[integer, 1, NOT]
F%expn = z_expn(1:6)

end subroutine taylor_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad taylor_struct to a C++ CPP_taylor structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad taylor_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_taylor struct.
!-

subroutine taylor_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine taylor_to_c2 (C, z_ref, z_term, n1_term) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_term
    real(c_double) :: z_ref
    type(c_ptr) :: z_term(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, PTR]
 n1_term = 0
if (associated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call taylor_to_c2 (C, F%ref, z_term, n1_term)

end subroutine taylor_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_taylor structure to a Bmad taylor_struct structure.
! This routine is called by taylor_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the taylor_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad taylor_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine taylor_to_f2 (Fp, z_ref, z_term, n1_term) bind(c)


implicit none

type(c_ptr), value :: Fp
type(taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_term
real(c_double) :: z_ref
type(c_ptr) :: z_term(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%ref = z_ref
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_term == 0) then
  if (associated(F%term)) deallocate(F%term)
else
  if (associated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. associated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call taylor_term_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine taylor_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine control_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad control_struct to a C++ CPP_control structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad control_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_control struct.
!-

subroutine control_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine control_to_c2 (C, z_coef, z_ix_lord, z_ix_slave, z_ix_branch, z_ix_attrib) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_coef
    integer(c_int) :: z_ix_lord, z_ix_slave, z_ix_branch, z_ix_attrib
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(control_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call control_to_c2 (C, F%coef, F%ix_lord, F%ix_slave, F%ix_branch, F%ix_attrib)

end subroutine control_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine control_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_control structure to a Bmad control_struct structure.
! This routine is called by control_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the control_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad control_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine control_to_f2 (Fp, z_coef, z_ix_lord, z_ix_slave, z_ix_branch, z_ix_attrib) bind(c)


implicit none

type(c_ptr), value :: Fp
type(control_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_coef
integer(c_int) :: z_ix_lord, z_ix_slave, z_ix_branch, z_ix_attrib

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_lord = z_ix_lord
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_slave = z_ix_slave
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_attrib = z_ix_attrib

end subroutine control_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_param_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad lat_param_struct to a C++ CPP_lat_param structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad lat_param_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_lat_param struct.
!-

subroutine lat_param_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine lat_param_to_c2 (C, z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf, &
      z_t1_no_rf, z_rel_tracking_charge, z_particle, z_geometry, z_ixx, z_stable, &
      z_aperture_limit_on, z_bookkeeping_state) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_stable, z_aperture_limit_on
    type(c_ptr), value :: z_bookkeeping_state
    real(c_double) :: z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf(*), z_t1_no_rf(*), z_rel_tracking_charge
    integer(c_int) :: z_particle, z_geometry, z_ixx
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(lat_param_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call lat_param_to_c2 (C, F%n_part, F%total_length, F%unstable_factor, mat2vec(F%t1_with_rf, &
    6*6), mat2vec(F%t1_no_rf, 6*6), F%rel_tracking_charge, F%particle, F%geometry, F%ixx, &
    c_logic(F%stable), c_logic(F%aperture_limit_on), c_loc(F%bookkeeping_state))

end subroutine lat_param_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_param_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_lat_param structure to a Bmad lat_param_struct structure.
! This routine is called by lat_param_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the lat_param_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad lat_param_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine lat_param_to_f2 (Fp, z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf, &
    z_t1_no_rf, z_rel_tracking_charge, z_particle, z_geometry, z_ixx, z_stable, &
    z_aperture_limit_on, z_bookkeeping_state) bind(c)


implicit none

type(c_ptr), value :: Fp
type(lat_param_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_stable, z_aperture_limit_on
type(c_ptr), value :: z_bookkeeping_state
real(c_double) :: z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf(*), z_t1_no_rf(*), z_rel_tracking_charge
integer(c_int) :: z_particle, z_geometry, z_ixx

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%n_part = z_n_part
!! f_side.to_f2_trans[real, 0, NOT]
F%total_length = z_total_length
!! f_side.to_f2_trans[real, 0, NOT]
F%unstable_factor = z_unstable_factor
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_t1_with_rf, F%t1_with_rf)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_t1_no_rf, F%t1_no_rf)
!! f_side.to_f2_trans[real, 0, NOT]
F%rel_tracking_charge = z_rel_tracking_charge
!! f_side.to_f2_trans[integer, 0, NOT]
F%particle = z_particle
!! f_side.to_f2_trans[integer, 0, NOT]
F%geometry = z_geometry
!! f_side.to_f2_trans[integer, 0, NOT]
F%ixx = z_ixx
!! f_side.to_f2_trans[logical, 0, NOT]
F%stable = f_logic(z_stable)
!! f_side.to_f2_trans[logical, 0, NOT]
F%aperture_limit_on = f_logic(z_aperture_limit_on)
!! f_side.to_f2_trans[type, 0, NOT]
call bookkeeping_state_to_f(z_bookkeeping_state, c_loc(F%bookkeeping_state))

end subroutine lat_param_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode_info_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad mode_info_struct to a C++ CPP_mode_info structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad mode_info_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_mode_info struct.
!-

subroutine mode_info_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine mode_info_to_c2 (C, z_tune, z_emit, z_chrom, z_sigma, z_sigmap) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_tune, z_emit, z_chrom, z_sigma, z_sigmap
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(mode_info_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call mode_info_to_c2 (C, F%tune, F%emit, F%chrom, F%sigma, F%sigmap)

end subroutine mode_info_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode_info_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_mode_info structure to a Bmad mode_info_struct structure.
! This routine is called by mode_info_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the mode_info_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad mode_info_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine mode_info_to_f2 (Fp, z_tune, z_emit, z_chrom, z_sigma, z_sigmap) bind(c)


implicit none

type(c_ptr), value :: Fp
type(mode_info_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_tune, z_emit, z_chrom, z_sigma, z_sigmap

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%tune = z_tune
!! f_side.to_f2_trans[real, 0, NOT]
F%emit = z_emit
!! f_side.to_f2_trans[real, 0, NOT]
F%chrom = z_chrom
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma = z_sigma
!! f_side.to_f2_trans[real, 0, NOT]
F%sigmap = z_sigmap

end subroutine mode_info_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine pre_tracker_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad pre_tracker_struct to a C++ CPP_pre_tracker structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad pre_tracker_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_pre_tracker struct.
!-

subroutine pre_tracker_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine pre_tracker_to_c2 (C, z_who, z_ix_ele_start, z_ix_ele_end, z_input_file) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_who, z_ix_ele_start, z_ix_ele_end
    character(c_char) :: z_input_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(pre_tracker_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call pre_tracker_to_c2 (C, F%who, F%ix_ele_start, F%ix_ele_end, trim(F%input_file) // &
    c_null_char)

end subroutine pre_tracker_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine pre_tracker_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_pre_tracker structure to a Bmad pre_tracker_struct structure.
! This routine is called by pre_tracker_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the pre_tracker_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad pre_tracker_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine pre_tracker_to_f2 (Fp, z_who, z_ix_ele_start, z_ix_ele_end, z_input_file) bind(c)


implicit none

type(c_ptr), value :: Fp
type(pre_tracker_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_who, z_ix_ele_start, z_ix_ele_end
character(c_char) :: z_input_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%who = z_who
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele_start = z_ix_ele_start
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele_end = z_ix_ele_end
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_input_file, F%input_file)

end subroutine pre_tracker_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine anormal_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad anormal_mode_struct to a C++ CPP_anormal_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad anormal_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_anormal_mode struct.
!-

subroutine anormal_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine anormal_mode_to_c2 (C, z_emittance, z_synch_int, z_j_damp, z_alpha_damp, z_chrom, &
      z_tune) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_emittance, z_synch_int(*), z_j_damp, z_alpha_damp, z_chrom, z_tune
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(anormal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call anormal_mode_to_c2 (C, F%emittance, fvec2vec(F%synch_int, 3), F%j_damp, F%alpha_damp, &
    F%chrom, F%tune)

end subroutine anormal_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine anormal_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_anormal_mode structure to a Bmad anormal_mode_struct structure.
! This routine is called by anormal_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the anormal_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad anormal_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine anormal_mode_to_f2 (Fp, z_emittance, z_synch_int, z_j_damp, z_alpha_damp, z_chrom, &
    z_tune) bind(c)


implicit none

type(c_ptr), value :: Fp
type(anormal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_emittance, z_synch_int(*), z_j_damp, z_alpha_damp, z_chrom, z_tune

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%emittance = z_emittance
!! f_side.to_f2_trans[real, 1, NOT]
F%synch_int = z_synch_int(1:3)
!! f_side.to_f2_trans[real, 0, NOT]
F%j_damp = z_j_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%alpha_damp = z_alpha_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%chrom = z_chrom
!! f_side.to_f2_trans[real, 0, NOT]
F%tune = z_tune

end subroutine anormal_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine linac_normal_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad linac_normal_mode_struct to a C++ CPP_linac_normal_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad linac_normal_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_linac_normal_mode struct.
!-

subroutine linac_normal_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine linac_normal_mode_to_c2 (C, z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, &
      z_a_emittance_end, z_b_emittance_end) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, z_a_emittance_end, z_b_emittance_end
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(linac_normal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call linac_normal_mode_to_c2 (C, F%i2_e4, F%i3_e7, F%i5a_e6, F%i5b_e6, F%sig_e1, &
    F%a_emittance_end, F%b_emittance_end)

end subroutine linac_normal_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine linac_normal_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_linac_normal_mode structure to a Bmad linac_normal_mode_struct structure.
! This routine is called by linac_normal_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the linac_normal_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad linac_normal_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine linac_normal_mode_to_f2 (Fp, z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, &
    z_a_emittance_end, z_b_emittance_end) bind(c)


implicit none

type(c_ptr), value :: Fp
type(linac_normal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, z_a_emittance_end, z_b_emittance_end

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%i2_e4 = z_i2_e4
!! f_side.to_f2_trans[real, 0, NOT]
F%i3_e7 = z_i3_e7
!! f_side.to_f2_trans[real, 0, NOT]
F%i5a_e6 = z_i5a_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%i5b_e6 = z_i5b_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_e1 = z_sig_e1
!! f_side.to_f2_trans[real, 0, NOT]
F%a_emittance_end = z_a_emittance_end
!! f_side.to_f2_trans[real, 0, NOT]
F%b_emittance_end = z_b_emittance_end

end subroutine linac_normal_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine normal_modes_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad normal_modes_struct to a C++ CPP_normal_modes structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad normal_modes_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_normal_modes struct.
!-

subroutine normal_modes_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine normal_modes_to_c2 (C, z_synch_int, z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, &
      z_pz_aperture, z_a, z_b, z_z, z_lin) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_a, z_b, z_z, z_lin
    real(c_double) :: z_synch_int(*), z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, z_pz_aperture
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(normal_modes_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call normal_modes_to_c2 (C, fvec2vec(F%synch_int, 4), F%sige_e, F%sig_z, F%e_loss, &
    F%rf_voltage, F%pz_aperture, c_loc(F%a), c_loc(F%b), c_loc(F%z), c_loc(F%lin))

end subroutine normal_modes_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine normal_modes_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_normal_modes structure to a Bmad normal_modes_struct structure.
! This routine is called by normal_modes_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the normal_modes_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad normal_modes_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine normal_modes_to_f2 (Fp, z_synch_int, z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, &
    z_pz_aperture, z_a, z_b, z_z, z_lin) bind(c)


implicit none

type(c_ptr), value :: Fp
type(normal_modes_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_a, z_b, z_z, z_lin
real(c_double) :: z_synch_int(*), z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, z_pz_aperture

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%synch_int = z_synch_int(1:4)
!! f_side.to_f2_trans[real, 0, NOT]
F%sige_e = z_sige_e
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_z = z_sig_z
!! f_side.to_f2_trans[real, 0, NOT]
F%e_loss = z_e_loss
!! f_side.to_f2_trans[real, 0, NOT]
F%rf_voltage = z_rf_voltage
!! f_side.to_f2_trans[real, 0, NOT]
F%pz_aperture = z_pz_aperture
!! f_side.to_f2_trans[type, 0, NOT]
call anormal_mode_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call anormal_mode_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call anormal_mode_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 0, NOT]
call linac_normal_mode_to_f(z_lin, c_loc(F%lin))

end subroutine normal_modes_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_struct to a C++ CPP_em_field structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field struct.
!-

subroutine em_field_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_to_c2 (C, z_e, z_b, z_de, z_db) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_e(*), z_b(*), z_de(*), z_db(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call em_field_to_c2 (C, fvec2vec(F%e, 3), fvec2vec(F%b, 3), mat2vec(F%de, 3*3), mat2vec(F%db, &
    3*3))

end subroutine em_field_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field structure to a Bmad em_field_struct structure.
! This routine is called by em_field_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_to_f2 (Fp, z_e, z_b, z_de, z_db) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_e(*), z_b(*), z_de(*), z_db(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%e = z_e(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%b = z_b(1:3)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_de, F%de)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_db, F%db)

end subroutine em_field_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_map_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad track_map_struct to a C++ CPP_track_map structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad track_map_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_track_map struct.
!-

subroutine track_map_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine track_map_to_c2 (C, z_vec0, z_mat6) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_vec0(*), z_mat6(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(track_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call track_map_to_c2 (C, fvec2vec(F%vec0, 6), mat2vec(F%mat6, 6*6))

end subroutine track_map_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_map_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_track_map structure to a Bmad track_map_struct structure.
! This routine is called by track_map_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the track_map_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad track_map_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine track_map_to_f2 (Fp, z_vec0, z_mat6) bind(c)


implicit none

type(c_ptr), value :: Fp
type(track_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_vec0(*), z_mat6(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%vec0 = z_vec0(1:6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_mat6, F%mat6)

end subroutine track_map_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad track_struct to a C++ CPP_track structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad track_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_track struct.
!-

subroutine track_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine track_to_c2 (C, z_orb, n1_orb, z_field, n1_field, z_map, n1_map, z_ds_save, &
      z_n_pt, z_n_bad, z_n_ok) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_orb, n1_field, n1_map
    real(c_double) :: z_ds_save
    integer(c_int) :: z_n_pt, z_n_bad, z_n_ok
    type(c_ptr) :: z_orb(*), z_field(*), z_map(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(track_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_orb(:)
integer(c_int) :: n1_orb
type(c_ptr), allocatable :: z_field(:)
integer(c_int) :: n1_field
type(c_ptr), allocatable :: z_map(:)
integer(c_int) :: n1_map

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_orb = 0
if (allocated(F%orb)) then
  n1_orb = size(F%orb); lb1 = lbound(F%orb, 1) - 1
  allocate (z_orb(n1_orb))
  do jd1 = 1, n1_orb
    z_orb(jd1) = c_loc(F%orb(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_field = 0
if (allocated(F%field)) then
  n1_field = size(F%field); lb1 = lbound(F%field, 1) - 1
  allocate (z_field(n1_field))
  do jd1 = 1, n1_field
    z_field(jd1) = c_loc(F%field(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_map = 0
if (allocated(F%map)) then
  n1_map = size(F%map); lb1 = lbound(F%map, 1) - 1
  allocate (z_map(n1_map))
  do jd1 = 1, n1_map
    z_map(jd1) = c_loc(F%map(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call track_to_c2 (C, z_orb, n1_orb, z_field, n1_field, z_map, n1_map, F%ds_save, F%n_pt, &
    F%n_bad, F%n_ok)

end subroutine track_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_track structure to a Bmad track_struct structure.
! This routine is called by track_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the track_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad track_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine track_to_f2 (Fp, z_orb, n1_orb, z_field, n1_field, z_map, n1_map, z_ds_save, z_n_pt, &
    z_n_bad, z_n_ok) bind(c)


implicit none

type(c_ptr), value :: Fp
type(track_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_orb, n1_field, n1_map
real(c_double) :: z_ds_save
integer(c_int) :: z_n_pt, z_n_bad, z_n_ok
type(c_ptr) :: z_orb(*), z_field(*), z_map(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_orb == 0) then
  if (allocated(F%orb)) deallocate(F%orb)
else
  if (allocated(F%orb)) then
    if (n1_orb == 0 .or. any(shape(F%orb) /= [n1_orb])) deallocate(F%orb)
    if (any(lbound(F%orb) /= 1)) deallocate(F%orb)
  endif
  if (.not. allocated(F%orb)) allocate(F%orb(1:n1_orb+1-1))
  do jd1 = 1, n1_orb
    call coord_to_f (z_orb(jd1), c_loc(F%orb(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_field == 0) then
  if (allocated(F%field)) deallocate(F%field)
else
  if (allocated(F%field)) then
    if (n1_field == 0 .or. any(shape(F%field) /= [n1_field])) deallocate(F%field)
    if (any(lbound(F%field) /= 1)) deallocate(F%field)
  endif
  if (.not. allocated(F%field)) allocate(F%field(1:n1_field+1-1))
  do jd1 = 1, n1_field
    call em_field_to_f (z_field(jd1), c_loc(F%field(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_map == 0) then
  if (allocated(F%map)) deallocate(F%map)
else
  if (allocated(F%map)) then
    if (n1_map == 0 .or. any(shape(F%map) /= [n1_map])) deallocate(F%map)
    if (any(lbound(F%map) /= 1)) deallocate(F%map)
  endif
  if (.not. allocated(F%map)) allocate(F%map(1:n1_map+1-1))
  do jd1 = 1, n1_map
    call track_map_to_f (z_map(jd1), c_loc(F%map(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%ds_save = z_ds_save
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_pt = z_n_pt
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_bad = z_n_bad
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ok = z_n_ok

end subroutine track_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine synch_rad_common_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad synch_rad_common_struct to a C++ CPP_synch_rad_common structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad synch_rad_common_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_synch_rad_common struct.
!-

subroutine synch_rad_common_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine synch_rad_common_to_c2 (C, z_scale, z_i2, z_i3, z_i5a, z_i5b, z_i_calc_on) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_i_calc_on
    real(c_double) :: z_scale, z_i2, z_i3, z_i5a, z_i5b
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(synch_rad_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call synch_rad_common_to_c2 (C, F%scale, F%i2, F%i3, F%i5a, F%i5b, c_logic(F%i_calc_on))

end subroutine synch_rad_common_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine synch_rad_common_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_synch_rad_common structure to a Bmad synch_rad_common_struct structure.
! This routine is called by synch_rad_common_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the synch_rad_common_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad synch_rad_common_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine synch_rad_common_to_f2 (Fp, z_scale, z_i2, z_i3, z_i5a, z_i5b, z_i_calc_on) bind(c)


implicit none

type(c_ptr), value :: Fp
type(synch_rad_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_i_calc_on
real(c_double) :: z_scale, z_i2, z_i3, z_i5a, z_i5b

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%scale = z_scale
!! f_side.to_f2_trans[real, 0, NOT]
F%i2 = z_i2
!! f_side.to_f2_trans[real, 0, NOT]
F%i3 = z_i3
!! f_side.to_f2_trans[real, 0, NOT]
F%i5a = z_i5a
!! f_side.to_f2_trans[real, 0, NOT]
F%i5b = z_i5b
!! f_side.to_f2_trans[logical, 0, NOT]
F%i_calc_on = f_logic(z_i_calc_on)

end subroutine synch_rad_common_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bmad_common_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bmad_common_struct to a C++ CPP_bmad_common structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bmad_common_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bmad_common struct.
!-

subroutine bmad_common_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bmad_common_to_c2 (C, z_max_aperture_limit, z_d_orb, z_default_ds_step, &
      z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, &
      z_rel_tol_adaptive_tracking, z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, &
      z_min_ds_adaptive_tracking, z_taylor_order, z_default_integ_order, &
      z_ptc_max_fringe_order, z_use_hard_edge_drifts, z_sr_wakes_on, z_lr_wakes_on, &
      z_mat6_track_symmetric, z_auto_bookkeeper, z_space_charge_on, z_coherent_synch_rad_on, &
      z_spin_tracking_on, z_radiation_damping_on, z_radiation_fluctuations_on, &
      z_conserve_taylor_maps, z_absolute_time_tracking_default, z_rf_auto_scale_phase_default, &
      z_rf_auto_scale_amp_default, z_use_ptc_layout_default) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_use_hard_edge_drifts, z_sr_wakes_on, z_lr_wakes_on, z_mat6_track_symmetric, z_auto_bookkeeper, z_space_charge_on, z_coherent_synch_rad_on
    logical(c_bool) :: z_spin_tracking_on, z_radiation_damping_on, z_radiation_fluctuations_on, z_conserve_taylor_maps, z_absolute_time_tracking_default, z_rf_auto_scale_phase_default, z_rf_auto_scale_amp_default
    logical(c_bool) :: z_use_ptc_layout_default
    real(c_double) :: z_max_aperture_limit, z_d_orb(*), z_default_ds_step, z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, z_rel_tol_adaptive_tracking
    real(c_double) :: z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, z_min_ds_adaptive_tracking
    integer(c_int) :: z_taylor_order, z_default_integ_order, z_ptc_max_fringe_order
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bmad_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bmad_common_to_c2 (C, F%max_aperture_limit, fvec2vec(F%d_orb, 6), F%default_ds_step, &
    F%significant_length, F%rel_tol_tracking, F%abs_tol_tracking, F%rel_tol_adaptive_tracking, &
    F%abs_tol_adaptive_tracking, F%init_ds_adaptive_tracking, F%min_ds_adaptive_tracking, &
    F%taylor_order, F%default_integ_order, F%ptc_max_fringe_order, &
    c_logic(F%use_hard_edge_drifts), c_logic(F%sr_wakes_on), c_logic(F%lr_wakes_on), &
    c_logic(F%mat6_track_symmetric), c_logic(F%auto_bookkeeper), c_logic(F%space_charge_on), &
    c_logic(F%coherent_synch_rad_on), c_logic(F%spin_tracking_on), &
    c_logic(F%radiation_damping_on), c_logic(F%radiation_fluctuations_on), &
    c_logic(F%conserve_taylor_maps), c_logic(F%absolute_time_tracking_default), &
    c_logic(F%rf_auto_scale_phase_default), c_logic(F%rf_auto_scale_amp_default), &
    c_logic(F%use_ptc_layout_default))

end subroutine bmad_common_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bmad_common_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bmad_common structure to a Bmad bmad_common_struct structure.
! This routine is called by bmad_common_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bmad_common_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bmad_common_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bmad_common_to_f2 (Fp, z_max_aperture_limit, z_d_orb, z_default_ds_step, &
    z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, z_rel_tol_adaptive_tracking, &
    z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, z_min_ds_adaptive_tracking, &
    z_taylor_order, z_default_integ_order, z_ptc_max_fringe_order, z_use_hard_edge_drifts, &
    z_sr_wakes_on, z_lr_wakes_on, z_mat6_track_symmetric, z_auto_bookkeeper, z_space_charge_on, &
    z_coherent_synch_rad_on, z_spin_tracking_on, z_radiation_damping_on, &
    z_radiation_fluctuations_on, z_conserve_taylor_maps, z_absolute_time_tracking_default, &
    z_rf_auto_scale_phase_default, z_rf_auto_scale_amp_default, z_use_ptc_layout_default) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(bmad_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_use_hard_edge_drifts, z_sr_wakes_on, z_lr_wakes_on, z_mat6_track_symmetric, z_auto_bookkeeper, z_space_charge_on, z_coherent_synch_rad_on
logical(c_bool) :: z_spin_tracking_on, z_radiation_damping_on, z_radiation_fluctuations_on, z_conserve_taylor_maps, z_absolute_time_tracking_default, z_rf_auto_scale_phase_default, z_rf_auto_scale_amp_default
logical(c_bool) :: z_use_ptc_layout_default
real(c_double) :: z_max_aperture_limit, z_d_orb(*), z_default_ds_step, z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, z_rel_tol_adaptive_tracking
real(c_double) :: z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, z_min_ds_adaptive_tracking
integer(c_int) :: z_taylor_order, z_default_integ_order, z_ptc_max_fringe_order

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%max_aperture_limit = z_max_aperture_limit
!! f_side.to_f2_trans[real, 1, NOT]
F%d_orb = z_d_orb(1:6)
!! f_side.to_f2_trans[real, 0, NOT]
F%default_ds_step = z_default_ds_step
!! f_side.to_f2_trans[real, 0, NOT]
F%significant_length = z_significant_length
!! f_side.to_f2_trans[real, 0, NOT]
F%rel_tol_tracking = z_rel_tol_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%abs_tol_tracking = z_abs_tol_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%rel_tol_adaptive_tracking = z_rel_tol_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%abs_tol_adaptive_tracking = z_abs_tol_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%init_ds_adaptive_tracking = z_init_ds_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%min_ds_adaptive_tracking = z_min_ds_adaptive_tracking
!! f_side.to_f2_trans[integer, 0, NOT]
F%taylor_order = z_taylor_order
!! f_side.to_f2_trans[integer, 0, NOT]
F%default_integ_order = z_default_integ_order
!! f_side.to_f2_trans[integer, 0, NOT]
F%ptc_max_fringe_order = z_ptc_max_fringe_order
!! f_side.to_f2_trans[logical, 0, NOT]
F%use_hard_edge_drifts = f_logic(z_use_hard_edge_drifts)
!! f_side.to_f2_trans[logical, 0, NOT]
F%sr_wakes_on = f_logic(z_sr_wakes_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%lr_wakes_on = f_logic(z_lr_wakes_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%mat6_track_symmetric = f_logic(z_mat6_track_symmetric)
!! f_side.to_f2_trans[logical, 0, NOT]
F%auto_bookkeeper = f_logic(z_auto_bookkeeper)
!! f_side.to_f2_trans[logical, 0, NOT]
F%space_charge_on = f_logic(z_space_charge_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%coherent_synch_rad_on = f_logic(z_coherent_synch_rad_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%spin_tracking_on = f_logic(z_spin_tracking_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%radiation_damping_on = f_logic(z_radiation_damping_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%radiation_fluctuations_on = f_logic(z_radiation_fluctuations_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%conserve_taylor_maps = f_logic(z_conserve_taylor_maps)
!! f_side.to_f2_trans[logical, 0, NOT]
F%absolute_time_tracking_default = f_logic(z_absolute_time_tracking_default)
!! f_side.to_f2_trans[logical, 0, NOT]
F%rf_auto_scale_phase_default = f_logic(z_rf_auto_scale_phase_default)
!! f_side.to_f2_trans[logical, 0, NOT]
F%rf_auto_scale_amp_default = f_logic(z_rf_auto_scale_amp_default)
!! f_side.to_f2_trans[logical, 0, NOT]
F%use_ptc_layout_default = f_logic(z_use_ptc_layout_default)

end subroutine bmad_common_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int1_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_int1_struct to a C++ CPP_rad_int1 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_int1_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_int1 struct.
!-

subroutine rad_int1_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_int1_to_c2 (C, z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z, z_i5a, z_i5b, &
      z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6, z_lin_norm_emit_a, &
      z_lin_norm_emit_b, z_n_steps) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z
    real(c_double) :: z_i5a, z_i5b, z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6
    real(c_double) :: z_lin_norm_emit_a, z_lin_norm_emit_b, z_n_steps
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_int1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call rad_int1_to_c2 (C, F%i0, F%i1, F%i2, F%i3, F%i4a, F%i4b, F%i4z, F%i5a, F%i5b, F%i6b, &
    F%lin_i2_e4, F%lin_i3_e7, F%lin_i5a_e6, F%lin_i5b_e6, F%lin_norm_emit_a, F%lin_norm_emit_b, &
    F%n_steps)

end subroutine rad_int1_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int1_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_int1 structure to a Bmad rad_int1_struct structure.
! This routine is called by rad_int1_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_int1_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_int1_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_int1_to_f2 (Fp, z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z, z_i5a, z_i5b, &
    z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6, z_lin_norm_emit_a, &
    z_lin_norm_emit_b, z_n_steps) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_int1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z
real(c_double) :: z_i5a, z_i5b, z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6
real(c_double) :: z_lin_norm_emit_a, z_lin_norm_emit_b, z_n_steps

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%i0 = z_i0
!! f_side.to_f2_trans[real, 0, NOT]
F%i1 = z_i1
!! f_side.to_f2_trans[real, 0, NOT]
F%i2 = z_i2
!! f_side.to_f2_trans[real, 0, NOT]
F%i3 = z_i3
!! f_side.to_f2_trans[real, 0, NOT]
F%i4a = z_i4a
!! f_side.to_f2_trans[real, 0, NOT]
F%i4b = z_i4b
!! f_side.to_f2_trans[real, 0, NOT]
F%i4z = z_i4z
!! f_side.to_f2_trans[real, 0, NOT]
F%i5a = z_i5a
!! f_side.to_f2_trans[real, 0, NOT]
F%i5b = z_i5b
!! f_side.to_f2_trans[real, 0, NOT]
F%i6b = z_i6b
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i2_e4 = z_lin_i2_e4
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i3_e7 = z_lin_i3_e7
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i5a_e6 = z_lin_i5a_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i5b_e6 = z_lin_i5b_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_norm_emit_a = z_lin_norm_emit_a
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_norm_emit_b = z_lin_norm_emit_b
!! f_side.to_f2_trans[real, 0, NOT]
F%n_steps = z_n_steps

end subroutine rad_int1_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_all_ele_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_int_all_ele_struct to a C++ CPP_rad_int_all_ele structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_int_all_ele_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_int_all_ele struct.
!-

subroutine rad_int_all_ele_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_int_all_ele_to_c2 (C, z_ele, n1_ele) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_ele
    type(c_ptr) :: z_ele(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_int_all_ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_ele(:)
integer(c_int) :: n1_ele

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_ele = 0
if (allocated(F%ele)) then
  n1_ele = size(F%ele); lb1 = lbound(F%ele, 1) - 1
  allocate (z_ele(n1_ele))
  do jd1 = 1, n1_ele
    z_ele(jd1) = c_loc(F%ele(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call rad_int_all_ele_to_c2 (C, z_ele, n1_ele)

end subroutine rad_int_all_ele_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_all_ele_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_int_all_ele structure to a Bmad rad_int_all_ele_struct structure.
! This routine is called by rad_int_all_ele_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_int_all_ele_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_int_all_ele_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_int_all_ele_to_f2 (Fp, z_ele, n1_ele) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_int_all_ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_ele
type(c_ptr) :: z_ele(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_ele == 0) then
  if (allocated(F%ele)) deallocate(F%ele)
else
  if (allocated(F%ele)) then
    if (n1_ele == 0 .or. any(shape(F%ele) /= [n1_ele])) deallocate(F%ele)
    if (any(lbound(F%ele) /= 1)) deallocate(F%ele)
  endif
  if (.not. allocated(F%ele)) allocate(F%ele(1:n1_ele+1-1))
  do jd1 = 1, n1_ele
    call rad_int1_to_f (z_ele(jd1), c_loc(F%ele(jd1+1-1)))
  enddo
endif


end subroutine rad_int_all_ele_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ele_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad ele_struct to a C++ CPP_ele structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad ele_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_ele struct.
!-

subroutine ele_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine ele_to_c2 (C, z_name, z_type, z_alias, z_component_name, z_descrip, n_descrip, &
      z_a, z_b, z_z, z_x, z_y, z_bookkeeping_state, z_em_field, n_em_field, z_floor, z_mode3, &
      n_mode3, z_rad_int_cache, n_rad_int_cache, z_rf_wake, n_rf_wake, z_space_charge, &
      n_space_charge, z_taylor, z_wall3d, n_wall3d, z_wig, n_wig, z_value, z_old_value, z_gen0, &
      z_vec0, z_mat6, z_c_mat, z_gamma_c, z_s, z_ref_time, z_r, n1_r, n2_r, n3_r, z_a_pole, &
      n1_a_pole, z_b_pole, n1_b_pole, z_map_ref_orb_in, z_map_ref_orb_out, z_time_ref_orb_in, &
      z_time_ref_orb_out, z_key, z_sub_key, z_ix_ele, z_ix_branch, z_ix_value, z_slave_status, &
      z_n_slave, z_ix1_slave, z_ix2_slave, z_lord_status, z_n_lord, z_ic1_lord, z_ic2_lord, &
      z_ix_pointer, z_ixx, z_iyy, z_mat6_calc_method, z_tracking_method, &
      z_spin_tracking_method, z_ptc_integration_type, z_field_calc, z_aperture_at, &
      z_aperture_type, z_orientation, z_symplectify, z_mode_flip, z_multipoles_on, &
      z_scale_multipoles, z_map_with_offsets, z_field_master, z_is_on, z_old_is_on, z_logic, &
      z_bmad_logic, z_on_a_girder, z_csr_calc_on, z_offset_moves_aperture) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_key, z_sub_key, z_ix_ele, z_ix_branch, z_ix_value, z_slave_status, z_n_slave
    integer(c_int) :: z_ix1_slave, z_ix2_slave, z_lord_status, z_n_lord, z_ic1_lord, z_ic2_lord, z_ix_pointer
    integer(c_int) :: z_ixx, z_iyy, z_mat6_calc_method, z_tracking_method, z_spin_tracking_method, z_ptc_integration_type, z_field_calc
    integer(c_int) :: z_aperture_at, z_aperture_type, z_orientation
    integer(c_int), value :: n_descrip, n_em_field, n_mode3, n_rad_int_cache, n_rf_wake, n_space_charge, n_wall3d
    integer(c_int), value :: n_wig, n1_r, n2_r, n3_r, n1_a_pole, n1_b_pole
    logical(c_bool) :: z_symplectify, z_mode_flip, z_multipoles_on, z_scale_multipoles, z_map_with_offsets, z_field_master, z_is_on
    logical(c_bool) :: z_old_is_on, z_logic, z_bmad_logic, z_on_a_girder, z_csr_calc_on, z_offset_moves_aperture
    character(c_char) :: z_name(*), z_type(*), z_alias(*), z_component_name(*), z_descrip(*)
    real(c_double) :: z_value(*), z_old_value(*), z_gen0(*), z_vec0(*), z_mat6(*), z_c_mat(*), z_gamma_c
    real(c_double) :: z_s, z_ref_time, z_r(*), z_a_pole(*), z_b_pole(*), z_map_ref_orb_in(*), z_map_ref_orb_out(*)
    real(c_double) :: z_time_ref_orb_in(*), z_time_ref_orb_out(*)
    type(c_ptr), value :: z_a, z_b, z_z, z_x, z_y, z_bookkeeping_state, z_em_field
    type(c_ptr), value :: z_floor, z_mode3, z_rad_int_cache, z_rf_wake, z_space_charge, z_wall3d, z_wig
    type(c_ptr) :: z_taylor(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
character(200+1), target :: f_descrip
integer(c_int) :: n_descrip
integer(c_int) :: n_em_field
integer(c_int) :: n_mode3
integer(c_int) :: n_rad_int_cache
integer(c_int) :: n_rf_wake
integer(c_int) :: n_space_charge
type(c_ptr) :: z_taylor(6)
integer(c_int) :: n_wall3d
integer(c_int) :: n_wig
integer(c_int) :: n1_r
integer(c_int) :: n2_r
integer(c_int) :: n3_r
integer(c_int) :: n1_a_pole
integer(c_int) :: n1_b_pole

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[character, 0, PTR]
n_descrip = 0
if (associated(F%descrip)) then
  n_descrip = 1
  f_descrip = trim(F%descrip) // c_null_char 
endif
!! f_side.to_c_trans[type, 0, PTR]
n_em_field = 0
if (associated(F%em_field)) n_em_field = 1
!! f_side.to_c_trans[type, 0, PTR]
n_mode3 = 0
if (associated(F%mode3)) n_mode3 = 1
!! f_side.to_c_trans[type, 0, PTR]
n_rad_int_cache = 0
if (associated(F%rad_int_cache)) n_rad_int_cache = 1
!! f_side.to_c_trans[type, 0, PTR]
n_rf_wake = 0
if (associated(F%rf_wake)) n_rf_wake = 1
!! f_side.to_c_trans[type, 0, PTR]
n_space_charge = 0
if (associated(F%space_charge)) n_space_charge = 1
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%taylor,1); lb1 = lbound(F%taylor,1) - 1
  z_taylor(jd1) = c_loc(F%taylor(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 0, PTR]
n_wall3d = 0
if (associated(F%wall3d)) n_wall3d = 1
!! f_side.to_c_trans[type, 0, PTR]
n_wig = 0
if (associated(F%wig)) n_wig = 1
!! f_side.to_c_trans[real, 3, PTR]
if (associated(F%r)) then
  n1_r = size(F%r, 1)
  n2_r = size(F%r, 2)
  n3_r = size(F%r, 3)
else
  n1_r = 0; n2_r = 0; n3_r = 0
endif
!! f_side.to_c_trans[real, 1, PTR]
n1_a_pole = 0
if (associated(F%a_pole)) then
  n1_a_pole = size(F%a_pole, 1)
endif
!! f_side.to_c_trans[real, 1, PTR]
n1_b_pole = 0
if (associated(F%b_pole)) then
  n1_b_pole = size(F%b_pole, 1)
endif

!! f_side.to_c2_call
call ele_to_c2 (C, trim(F%name) // c_null_char, trim(F%type) // c_null_char, trim(F%alias) // &
    c_null_char, trim(F%component_name) // c_null_char, f_descrip, n_descrip, c_loc(F%a), &
    c_loc(F%b), c_loc(F%z), c_loc(F%x), c_loc(F%y), c_loc(F%bookkeeping_state), &
    c_loc(F%em_field), n_em_field, c_loc(F%floor), c_loc(F%mode3), n_mode3, &
    c_loc(F%rad_int_cache), n_rad_int_cache, c_loc(F%rf_wake), n_rf_wake, &
    c_loc(F%space_charge), n_space_charge, z_taylor, c_loc(F%wall3d), n_wall3d, c_loc(F%wig), &
    n_wig, fvec2vec(F%value, num_ele_attrib$), fvec2vec(F%old_value, num_ele_attrib$), &
    fvec2vec(F%gen0, 6), fvec2vec(F%vec0, 6), mat2vec(F%mat6, 6*6), mat2vec(F%c_mat, 2*2), &
    F%gamma_c, F%s, F%ref_time, tensor2vec(F%r, n1_r*n2_r*n3_r), n1_r, n2_r, n3_r, &
    fvec2vec(F%a_pole, n1_a_pole), n1_a_pole, fvec2vec(F%b_pole, n1_b_pole), n1_b_pole, &
    fvec2vec(F%map_ref_orb_in, 6), fvec2vec(F%map_ref_orb_out, 6), fvec2vec(F%time_ref_orb_in, &
    6), fvec2vec(F%time_ref_orb_out, 6), F%key, F%sub_key, F%ix_ele, F%ix_branch, F%ix_value, &
    F%slave_status, F%n_slave, F%ix1_slave, F%ix2_slave, F%lord_status, F%n_lord, F%ic1_lord, &
    F%ic2_lord, F%ix_pointer, F%ixx, F%iyy, F%mat6_calc_method, F%tracking_method, &
    F%spin_tracking_method, F%ptc_integration_type, F%field_calc, F%aperture_at, &
    F%aperture_type, F%orientation, c_logic(F%symplectify), c_logic(F%mode_flip), &
    c_logic(F%multipoles_on), c_logic(F%scale_multipoles), c_logic(F%map_with_offsets), &
    c_logic(F%field_master), c_logic(F%is_on), c_logic(F%old_is_on), c_logic(F%logic), &
    c_logic(F%bmad_logic), c_logic(F%on_a_girder), c_logic(F%csr_calc_on), &
    c_logic(F%offset_moves_aperture))

end subroutine ele_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ele_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_ele structure to a Bmad ele_struct structure.
! This routine is called by ele_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the ele_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad ele_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine ele_to_f2 (Fp, z_name, z_type, z_alias, z_component_name, z_descrip, n_descrip, z_a, &
    z_b, z_z, z_x, z_y, z_bookkeeping_state, z_em_field, n_em_field, z_floor, z_mode3, n_mode3, &
    z_rad_int_cache, n_rad_int_cache, z_rf_wake, n_rf_wake, z_space_charge, n_space_charge, &
    z_taylor, z_wall3d, n_wall3d, z_wig, n_wig, z_value, z_old_value, z_gen0, z_vec0, z_mat6, &
    z_c_mat, z_gamma_c, z_s, z_ref_time, z_r, n1_r, n2_r, n3_r, z_a_pole, n1_a_pole, z_b_pole, &
    n1_b_pole, z_map_ref_orb_in, z_map_ref_orb_out, z_time_ref_orb_in, z_time_ref_orb_out, &
    z_key, z_sub_key, z_ix_ele, z_ix_branch, z_ix_value, z_slave_status, z_n_slave, &
    z_ix1_slave, z_ix2_slave, z_lord_status, z_n_lord, z_ic1_lord, z_ic2_lord, z_ix_pointer, &
    z_ixx, z_iyy, z_mat6_calc_method, z_tracking_method, z_spin_tracking_method, &
    z_ptc_integration_type, z_field_calc, z_aperture_at, z_aperture_type, z_orientation, &
    z_symplectify, z_mode_flip, z_multipoles_on, z_scale_multipoles, z_map_with_offsets, &
    z_field_master, z_is_on, z_old_is_on, z_logic, z_bmad_logic, z_on_a_girder, z_csr_calc_on, &
    z_offset_moves_aperture) bind(c)


implicit none

type(c_ptr), value :: Fp
type(ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_symplectify, z_mode_flip, z_multipoles_on, z_scale_multipoles, z_map_with_offsets, z_field_master, z_is_on
logical(c_bool) :: z_old_is_on, z_logic, z_bmad_logic, z_on_a_girder, z_csr_calc_on, z_offset_moves_aperture
type(rf_wake_struct), pointer :: f_rf_wake
integer(c_int) :: z_key, z_sub_key, z_ix_ele, z_ix_branch, z_ix_value, z_slave_status, z_n_slave
integer(c_int) :: z_ix1_slave, z_ix2_slave, z_lord_status, z_n_lord, z_ic1_lord, z_ic2_lord, z_ix_pointer
integer(c_int) :: z_ixx, z_iyy, z_mat6_calc_method, z_tracking_method, z_spin_tracking_method, z_ptc_integration_type, z_field_calc
integer(c_int) :: z_aperture_at, z_aperture_type, z_orientation
type(mode3_struct), pointer :: f_mode3
type(rad_int_ele_cache_struct), pointer :: f_rad_int_cache
integer(c_int), value :: n_descrip, n_em_field, n_mode3, n_rad_int_cache, n_rf_wake, n_space_charge, n_wall3d
integer(c_int), value :: n_wig, n1_r, n2_r, n3_r, n1_a_pole, n1_b_pole
type(wig_struct), pointer :: f_wig
type(c_ptr), value :: z_a, z_b, z_z, z_x, z_y, z_bookkeeping_state, z_em_field
type(c_ptr), value :: z_floor, z_mode3, z_rad_int_cache, z_rf_wake, z_space_charge, z_wall3d, z_wig
type(c_ptr), value :: z_r, z_a_pole, z_b_pole
real(c_double), pointer :: f_r(:), f_a_pole(:), f_b_pole(:)
character(c_char) :: z_name(*), z_type(*), z_alias(*), z_component_name(*), z_descrip(*)
integer(c_int), pointer :: f_descrip
type(space_charge_struct), pointer :: f_space_charge
real(c_double) :: z_value(*), z_old_value(*), z_gen0(*), z_vec0(*), z_mat6(*), z_c_mat(*), z_gamma_c
real(c_double) :: z_s, z_ref_time, z_map_ref_orb_in(*), z_map_ref_orb_out(*), z_time_ref_orb_in(*), z_time_ref_orb_out(*)
type(em_fields_struct), pointer :: f_em_field
type(c_ptr) :: z_taylor(*)
type(wall3d_struct), pointer :: f_wall3d

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_type, F%type)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_alias, F%alias)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_component_name, F%component_name)
!! f_side.to_f2_trans[character, 0, PTR]
if (n_descrip == 0) then
  if (associated(F%descrip)) deallocate(F%descrip)
else
  if (.not. associated(F%descrip)) allocate(F%descrip)
  call to_f_str(z_descrip, F%descrip)
endif

!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 0, NOT]
call xy_disp_to_f(z_x, c_loc(F%x))
!! f_side.to_f2_trans[type, 0, NOT]
call xy_disp_to_f(z_y, c_loc(F%y))
!! f_side.to_f2_trans[type, 0, NOT]
call bookkeeping_state_to_f(z_bookkeeping_state, c_loc(F%bookkeeping_state))
!! f_side.to_f2_trans[type, 0, PTR]
if (n_em_field == 0) then
  if (associated(F%em_field)) deallocate(F%em_field)
else
  if (.not. associated(F%em_field)) allocate(F%em_field)
  call em_fields_to_f (z_em_field, c_loc(F%em_field))
endif

!! f_side.to_f2_trans[type, 0, NOT]
call floor_position_to_f(z_floor, c_loc(F%floor))
!! f_side.to_f2_trans[type, 0, PTR]
if (n_mode3 == 0) then
  if (associated(F%mode3)) deallocate(F%mode3)
else
  if (.not. associated(F%mode3)) allocate(F%mode3)
  call mode3_to_f (z_mode3, c_loc(F%mode3))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_rad_int_cache == 0) then
  if (associated(F%rad_int_cache)) deallocate(F%rad_int_cache)
else
  if (.not. associated(F%rad_int_cache)) allocate(F%rad_int_cache)
  call rad_int_ele_cache_to_f (z_rad_int_cache, c_loc(F%rad_int_cache))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_rf_wake == 0) then
  if (associated(F%rf_wake)) deallocate(F%rf_wake)
else
  if (.not. associated(F%rf_wake)) allocate(F%rf_wake)
  call rf_wake_to_f (z_rf_wake, c_loc(F%rf_wake))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_space_charge == 0) then
  if (associated(F%space_charge)) deallocate(F%space_charge)
else
  if (.not. associated(F%space_charge)) allocate(F%space_charge)
  call space_charge_to_f (z_space_charge, c_loc(F%space_charge))
endif

!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%taylor,1); lb1 = lbound(F%taylor,1) - 1
  call taylor_to_f(z_taylor(jd1), c_loc(F%taylor(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 0, PTR]
if (n_wall3d == 0) then
  if (associated(F%wall3d)) deallocate(F%wall3d)
else
  if (.not. associated(F%wall3d)) allocate(F%wall3d)
  call wall3d_to_f (z_wall3d, c_loc(F%wall3d))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_wig == 0) then
  if (associated(F%wig)) deallocate(F%wig)
else
  if (.not. associated(F%wig)) allocate(F%wig)
  call wig_to_f (z_wig, c_loc(F%wig))
endif

!! f_side.to_f2_trans[real, 1, NOT]
F%value = z_value(2:num_ele_attrib$+1)
!! f_side.to_f2_trans[real, 1, NOT]
F%old_value = z_old_value(2:num_ele_attrib$+1)
!! f_side.to_f2_trans[real, 1, NOT]
F%gen0 = z_gen0(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%vec0 = z_vec0(1:6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_mat6, F%mat6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_c_mat, F%c_mat)
!! f_side.to_f2_trans[real, 0, NOT]
F%gamma_c = z_gamma_c
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[real, 0, NOT]
F%ref_time = z_ref_time
!! f_side.to_f2_trans[real, 3, PTR]
if (associated(F%r)) then
  if (n1_r == 0 .or. any(shape(F%r) /= [n1_r, n2_r, n3_r])) deallocate(F%r)
  if (any(lbound(F%r) /= 1)) deallocate(F%r)
endif
if (n1_r /= 0) then
  call c_f_pointer (z_r, f_r, [n1_r*n2_r*n3_r])
  if (.not. associated(F%r)) allocate(F%r(n1_r, n2_r, n3_r))
  call vec2tensor(f_r, F%r)
else
  if (associated(F%r)) deallocate(F%r)
endif

!! f_side.to_f2_trans[real, 1, PTR]
if (associated(F%a_pole)) then
  if (n1_a_pole == 0 .or. any(shape(F%a_pole) /= [n1_a_pole])) deallocate(F%a_pole)
  if (any(lbound(F%a_pole) /= 1)) deallocate(F%a_pole)
endif
if (n1_a_pole /= 0) then
  call c_f_pointer (z_a_pole, f_a_pole, [n1_a_pole])
  if (.not. associated(F%a_pole)) allocate(F%a_pole(n1_a_pole))
  F%a_pole = f_a_pole(1:n1_a_pole)
else
  if (associated(F%a_pole)) deallocate(F%a_pole)
endif

!! f_side.to_f2_trans[real, 1, PTR]
if (associated(F%b_pole)) then
  if (n1_b_pole == 0 .or. any(shape(F%b_pole) /= [n1_b_pole])) deallocate(F%b_pole)
  if (any(lbound(F%b_pole) /= 1)) deallocate(F%b_pole)
endif
if (n1_b_pole /= 0) then
  call c_f_pointer (z_b_pole, f_b_pole, [n1_b_pole])
  if (.not. associated(F%b_pole)) allocate(F%b_pole(n1_b_pole))
  F%b_pole = f_b_pole(1:n1_b_pole)
else
  if (associated(F%b_pole)) deallocate(F%b_pole)
endif

!! f_side.to_f2_trans[real, 1, NOT]
F%map_ref_orb_in = z_map_ref_orb_in(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%map_ref_orb_out = z_map_ref_orb_out(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%time_ref_orb_in = z_time_ref_orb_in(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%time_ref_orb_out = z_time_ref_orb_out(1:6)
!! f_side.to_f2_trans[integer, 0, NOT]
F%key = z_key
!! f_side.to_f2_trans[integer, 0, NOT]
F%sub_key = z_sub_key
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_value = z_ix_value
!! f_side.to_f2_trans[integer, 0, NOT]
F%slave_status = z_slave_status
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_slave = z_n_slave
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix1_slave = z_ix1_slave
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix2_slave = z_ix2_slave
!! f_side.to_f2_trans[integer, 0, NOT]
F%lord_status = z_lord_status
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_lord = z_n_lord
!! f_side.to_f2_trans[integer, 0, NOT]
F%ic1_lord = z_ic1_lord
!! f_side.to_f2_trans[integer, 0, NOT]
F%ic2_lord = z_ic2_lord
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_pointer = z_ix_pointer
!! f_side.to_f2_trans[integer, 0, NOT]
F%ixx = z_ixx
!! f_side.to_f2_trans[integer, 0, NOT]
F%iyy = z_iyy
!! f_side.to_f2_trans[integer, 0, NOT]
F%mat6_calc_method = z_mat6_calc_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%tracking_method = z_tracking_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%spin_tracking_method = z_spin_tracking_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%ptc_integration_type = z_ptc_integration_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%field_calc = z_field_calc
!! f_side.to_f2_trans[integer, 0, NOT]
F%aperture_at = z_aperture_at
!! f_side.to_f2_trans[integer, 0, NOT]
F%aperture_type = z_aperture_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%orientation = z_orientation
!! f_side.to_f2_trans[logical, 0, NOT]
F%symplectify = f_logic(z_symplectify)
!! f_side.to_f2_trans[logical, 0, NOT]
F%mode_flip = f_logic(z_mode_flip)
!! f_side.to_f2_trans[logical, 0, NOT]
F%multipoles_on = f_logic(z_multipoles_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%scale_multipoles = f_logic(z_scale_multipoles)
!! f_side.to_f2_trans[logical, 0, NOT]
F%map_with_offsets = f_logic(z_map_with_offsets)
!! f_side.to_f2_trans[logical, 0, NOT]
F%field_master = f_logic(z_field_master)
!! f_side.to_f2_trans[logical, 0, NOT]
F%is_on = f_logic(z_is_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%old_is_on = f_logic(z_old_is_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%logic = f_logic(z_logic)
!! f_side.to_f2_trans[logical, 0, NOT]
F%bmad_logic = f_logic(z_bmad_logic)
!! f_side.to_f2_trans[logical, 0, NOT]
F%on_a_girder = f_logic(z_on_a_girder)
!! f_side.to_f2_trans[logical, 0, NOT]
F%csr_calc_on = f_logic(z_csr_calc_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%offset_moves_aperture = f_logic(z_offset_moves_aperture)

end subroutine ele_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine branch_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad branch_struct to a C++ CPP_branch structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad branch_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_branch struct.
!-

subroutine branch_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine branch_to_c2 (C, z_name, z_ix_branch, z_ix_root_branch, z_ix_from_branch, &
      z_ix_from_ele, z_n_ele_track, n_n_ele_track, z_n_ele_max, n_n_ele_max, z_a, n_a, z_b, &
      n_b, z_z, n_z, z_ele, n1_ele, z_param, n_param, z_wall3d, n_wall3d) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_ele(*)
    integer(c_int), value :: n_n_ele_track, n_n_ele_max, n_a, n_b, n_z, n1_ele, n_param
    integer(c_int), value :: n_wall3d
    type(c_ptr), value :: z_a, z_b, z_z, z_param, z_wall3d
    integer(c_int) :: z_ix_branch, z_ix_root_branch, z_ix_from_branch, z_ix_from_ele, z_n_ele_track, z_n_ele_max
    character(c_char) :: z_name(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(branch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n_n_ele_track
integer(c_int) :: n_n_ele_max
integer(c_int) :: n_a
integer(c_int) :: n_b
integer(c_int) :: n_z
type(c_ptr), allocatable :: z_ele(:)
integer(c_int) :: n1_ele
integer(c_int) :: n_param
integer(c_int) :: n_wall3d

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[integer, 0, PTR]
n_n_ele_track = 0
if (associated(F%n_ele_track)) n_n_ele_track = 1
!! f_side.to_c_trans[integer, 0, PTR]
n_n_ele_max = 0
if (associated(F%n_ele_max)) n_n_ele_max = 1
!! f_side.to_c_trans[type, 0, PTR]
n_a = 0
if (associated(F%a)) n_a = 1
!! f_side.to_c_trans[type, 0, PTR]
n_b = 0
if (associated(F%b)) n_b = 1
!! f_side.to_c_trans[type, 0, PTR]
n_z = 0
if (associated(F%z)) n_z = 1
!! f_side.to_c_trans[type, 1, PTR]
 n1_ele = 0
if (associated(F%ele)) then
  n1_ele = size(F%ele); lb1 = lbound(F%ele, 1) - 1
  allocate (z_ele(n1_ele))
  do jd1 = 1, n1_ele
    z_ele(jd1) = c_loc(F%ele(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 0, PTR]
n_param = 0
if (associated(F%param)) n_param = 1
!! f_side.to_c_trans[type, 0, PTR]
n_wall3d = 0
if (associated(F%wall3d)) n_wall3d = 1

!! f_side.to_c2_call
call branch_to_c2 (C, trim(F%name) // c_null_char, F%ix_branch, F%ix_root_branch, &
    F%ix_from_branch, F%ix_from_ele, F%n_ele_track, n_n_ele_track, F%n_ele_max, n_n_ele_max, &
    c_loc(F%a), n_a, c_loc(F%b), n_b, c_loc(F%z), n_z, z_ele, n1_ele, c_loc(F%param), n_param, &
    c_loc(F%wall3d), n_wall3d)

end subroutine branch_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine branch_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_branch structure to a Bmad branch_struct structure.
! This routine is called by branch_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the branch_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad branch_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine branch_to_f2 (Fp, z_name, z_ix_branch, z_ix_root_branch, z_ix_from_branch, &
    z_ix_from_ele, z_n_ele_track, n_n_ele_track, z_n_ele_max, n_n_ele_max, z_a, n_a, z_b, n_b, &
    z_z, n_z, z_ele, n1_ele, z_param, n_param, z_wall3d, n_wall3d) bind(c)


implicit none

type(c_ptr), value :: Fp
type(branch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_ix_branch, z_ix_root_branch, z_ix_from_branch, z_ix_from_ele
type(c_ptr), value :: z_n_ele_track, z_n_ele_max, z_a, z_b, z_z, z_param, z_wall3d
type(lat_param_struct), pointer :: f_param
character(c_char) :: z_name(*)
integer(c_int), pointer :: f_n_ele_track, f_n_ele_max
type(mode_info_struct), pointer :: f_a, f_b, f_z
integer(c_int), value :: n_n_ele_track, n_n_ele_max, n_a, n_b, n_z, n1_ele, n_param
integer(c_int), value :: n_wall3d
type(c_ptr) :: z_ele(*)
type(wall3d_struct), pointer :: f_wall3d

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_root_branch = z_ix_root_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_from_branch = z_ix_from_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_from_ele = z_ix_from_ele
!! f_side.to_f2_trans[integer, 0, PTR]
if (n_n_ele_track == 0) then                                                                                  
  if (associated(F%n_ele_track)) deallocate(F%n_ele_track)                                                           
else                                                                                                   
  call c_f_pointer (z_n_ele_track, f_n_ele_track)                                                                    
  if (.not. associated(F%n_ele_track)) allocate(F%n_ele_track)                                                       
  F%n_ele_track = f_n_ele_track
endif                                                                                                  

!! f_side.to_f2_trans[integer, 0, PTR]
if (n_n_ele_max == 0) then                                                                                  
  if (associated(F%n_ele_max)) deallocate(F%n_ele_max)                                                           
else                                                                                                   
  call c_f_pointer (z_n_ele_max, f_n_ele_max)                                                                    
  if (.not. associated(F%n_ele_max)) allocate(F%n_ele_max)                                                       
  F%n_ele_max = f_n_ele_max
endif                                                                                                  

!! f_side.to_f2_trans[type, 0, PTR]
if (n_a == 0) then
  if (associated(F%a)) deallocate(F%a)
else
  if (.not. associated(F%a)) allocate(F%a)
  call mode_info_to_f (z_a, c_loc(F%a))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_b == 0) then
  if (associated(F%b)) deallocate(F%b)
else
  if (.not. associated(F%b)) allocate(F%b)
  call mode_info_to_f (z_b, c_loc(F%b))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_z == 0) then
  if (associated(F%z)) deallocate(F%z)
else
  if (.not. associated(F%z)) allocate(F%z)
  call mode_info_to_f (z_z, c_loc(F%z))
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_ele == 0) then
  if (associated(F%ele)) deallocate(F%ele)
else
  if (associated(F%ele)) then
    if (n1_ele == 0 .or. any(shape(F%ele) /= [n1_ele])) deallocate(F%ele)
    if (any(lbound(F%ele) /= 0)) deallocate(F%ele)
  endif
  if (.not. associated(F%ele)) allocate(F%ele(0:n1_ele+0-1))
  do jd1 = 1, n1_ele
    call ele_to_f (z_ele(jd1), c_loc(F%ele(jd1+0-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_param == 0) then
  if (associated(F%param)) deallocate(F%param)
else
  if (.not. associated(F%param)) allocate(F%param)
  call lat_param_to_f (z_param, c_loc(F%param))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_wall3d == 0) then
  if (associated(F%wall3d)) deallocate(F%wall3d)
else
  if (.not. associated(F%wall3d)) allocate(F%wall3d)
  call wall3d_to_f (z_wall3d, c_loc(F%wall3d))
endif


end subroutine branch_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad lat_struct to a C++ CPP_lat structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad lat_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_lat struct.
!-

subroutine lat_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine lat_to_c2 (C, z_use_name, z_lattice, z_input_file_name, z_title, &
      z_attribute_alias, n1_attribute_alias, z_a, z_b, z_z, z_param, z_lord_state, z_ele_init, &
      z_ele, n1_ele, z_branch, n1_branch, z_control, n1_control, z_beam_start, z_pre_tracker, &
      z_version, z_n_ele_track, z_n_ele_max, z_n_control_max, z_n_ic_max, z_input_taylor_order, &
      z_ic, n1_ic, z_absolute_time_tracking, z_rf_auto_scale_phase, z_rf_auto_scale_amp, &
      z_use_ptc_layout) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_version, z_n_ele_track, z_n_ele_max, z_n_control_max, z_n_ic_max, z_input_taylor_order, z_ic(*)
    integer(c_int), value :: n1_attribute_alias, n1_ele, n1_branch, n1_control, n1_ic
    logical(c_bool) :: z_absolute_time_tracking, z_rf_auto_scale_phase, z_rf_auto_scale_amp, z_use_ptc_layout
    character(c_char) :: z_use_name(*), z_lattice(*), z_input_file_name(*), z_title(*)
    type(c_ptr), value :: z_a, z_b, z_z, z_param, z_lord_state, z_ele_init, z_beam_start
    type(c_ptr), value :: z_pre_tracker
    type(c_ptr) :: z_attribute_alias(*), z_ele(*), z_branch(*), z_control(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(lat_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_attribute_alias(:)
character(60+1), allocatable :: a_attribute_alias(:)
integer(c_int) :: n1_attribute_alias
type(c_ptr), allocatable :: z_ele(:)
integer(c_int) :: n1_ele
type(c_ptr), allocatable :: z_branch(:)
integer(c_int) :: n1_branch
type(c_ptr), allocatable :: z_control(:)
integer(c_int) :: n1_control
integer(c_int) :: n1_ic

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[character, 1, ALLOC]
n1_attribute_alias = 0
if (allocated(F%attribute_alias)) then
  n1_attribute_alias = size(F%attribute_alias); lb1 = lbound(F%attribute_alias, 1) - 1
  allocate (a_attribute_alias(n1_attribute_alias))
  allocate (z_attribute_alias(n1_attribute_alias))
  do jd1 = 1, n1_attribute_alias
    a_attribute_alias(jd1) = trim(F%attribute_alias(jd1+lb1)) // c_null_char
    z_attribute_alias(jd1) = c_loc(a_attribute_alias(jd1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_ele = 0
if (associated(F%ele)) then
  n1_ele = size(F%ele); lb1 = lbound(F%ele, 1) - 1
  allocate (z_ele(n1_ele))
  do jd1 = 1, n1_ele
    z_ele(jd1) = c_loc(F%ele(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_branch = 0
if (allocated(F%branch)) then
  n1_branch = size(F%branch); lb1 = lbound(F%branch, 1) - 1
  allocate (z_branch(n1_branch))
  do jd1 = 1, n1_branch
    z_branch(jd1) = c_loc(F%branch(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_control = 0
if (allocated(F%control)) then
  n1_control = size(F%control); lb1 = lbound(F%control, 1) - 1
  allocate (z_control(n1_control))
  do jd1 = 1, n1_control
    z_control(jd1) = c_loc(F%control(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[integer, 1, ALLOC]
n1_ic = 0
if (allocated(F%ic)) then
  n1_ic = size(F%ic, 1)
endif

!! f_side.to_c2_call
call lat_to_c2 (C, trim(F%use_name) // c_null_char, trim(F%lattice) // c_null_char, &
    trim(F%input_file_name) // c_null_char, trim(F%title) // c_null_char, z_attribute_alias, &
    n1_attribute_alias, c_loc(F%a), c_loc(F%b), c_loc(F%z), c_loc(F%param), &
    c_loc(F%lord_state), c_loc(F%ele_init), z_ele, n1_ele, z_branch, n1_branch, z_control, &
    n1_control, c_loc(F%beam_start), c_loc(F%pre_tracker), F%version, F%n_ele_track, &
    F%n_ele_max, F%n_control_max, F%n_ic_max, F%input_taylor_order, fvec2vec(F%ic, n1_ic), &
    n1_ic, c_logic(F%absolute_time_tracking), c_logic(F%rf_auto_scale_phase), &
    c_logic(F%rf_auto_scale_amp), c_logic(F%use_ptc_layout))

end subroutine lat_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_lat structure to a Bmad lat_struct structure.
! This routine is called by lat_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the lat_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad lat_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine lat_to_f2 (Fp, z_use_name, z_lattice, z_input_file_name, z_title, z_attribute_alias, &
    n1_attribute_alias, z_a, z_b, z_z, z_param, z_lord_state, z_ele_init, z_ele, n1_ele, &
    z_branch, n1_branch, z_control, n1_control, z_beam_start, z_pre_tracker, z_version, &
    z_n_ele_track, z_n_ele_max, z_n_control_max, z_n_ic_max, z_input_taylor_order, z_ic, n1_ic, &
    z_absolute_time_tracking, z_rf_auto_scale_phase, z_rf_auto_scale_amp, z_use_ptc_layout) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(lat_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_version, z_n_ele_track, z_n_ele_max, z_n_control_max, z_n_ic_max, z_input_taylor_order
integer(c_int), value :: n1_attribute_alias, n1_ele, n1_branch, n1_control, n1_ic
character(c_char) :: z_use_name(*), z_lattice(*), z_input_file_name(*), z_title(*)
logical(c_bool) :: z_absolute_time_tracking, z_rf_auto_scale_phase, z_rf_auto_scale_amp, z_use_ptc_layout
character(c_char), pointer :: f_attribute_alias
integer(c_int), pointer :: f_ic(:)
type(c_ptr), value :: z_a, z_b, z_z, z_param, z_lord_state, z_ele_init, z_beam_start
type(c_ptr), value :: z_pre_tracker, z_ic
type(c_ptr) :: z_attribute_alias(*), z_ele(*), z_branch(*), z_control(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_use_name, F%use_name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_lattice, F%lattice)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_input_file_name, F%input_file_name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_title, F%title)
!! f_side.to_f2_trans[character, 1, ALLOC]
if (n1_attribute_alias == 0) then
  if (allocated(F%attribute_alias)) deallocate(F%attribute_alias)
else
  if (allocated(F%attribute_alias)) then
    if (n1_attribute_alias == 0 .or. any(shape(F%attribute_alias) /= [n1_attribute_alias])) deallocate(F%attribute_alias)
    if (any(lbound(F%attribute_alias) /= 1)) deallocate(F%attribute_alias)
  endif
  if (.not. allocated(F%attribute_alias)) allocate(F%attribute_alias(1:n1_attribute_alias+1-1))
  do jd1 = 1, n1_attribute_alias
    call c_f_pointer (z_attribute_alias(jd1), f_attribute_alias)
    call to_f_str(f_attribute_alias, F%attribute_alias(jd1+1-1))
  enddo
endif

!! f_side.to_f2_trans[type, 0, NOT]
call mode_info_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call mode_info_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call mode_info_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 0, NOT]
call lat_param_to_f(z_param, c_loc(F%param))
!! f_side.to_f2_trans[type, 0, NOT]
call bookkeeping_state_to_f(z_lord_state, c_loc(F%lord_state))
!! f_side.to_f2_trans[type, 0, NOT]
call ele_to_f(z_ele_init, c_loc(F%ele_init))
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_ele == 0) then
  if (associated(F%ele)) deallocate(F%ele)
else
  if (associated(F%ele)) then
    if (n1_ele == 0 .or. any(shape(F%ele) /= [n1_ele])) deallocate(F%ele)
    if (any(lbound(F%ele) /= 1)) deallocate(F%ele)
  endif
  if (.not. associated(F%ele)) allocate(F%ele(1:n1_ele+1-1))
  do jd1 = 1, n1_ele
    call ele_to_f (z_ele(jd1), c_loc(F%ele(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_branch == 0) then
  if (allocated(F%branch)) deallocate(F%branch)
else
  if (allocated(F%branch)) then
    if (n1_branch == 0 .or. any(shape(F%branch) /= [n1_branch])) deallocate(F%branch)
    if (any(lbound(F%branch) /= 1)) deallocate(F%branch)
  endif
  if (.not. allocated(F%branch)) allocate(F%branch(1:n1_branch+1-1))
  do jd1 = 1, n1_branch
    call branch_to_f (z_branch(jd1), c_loc(F%branch(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_control == 0) then
  if (allocated(F%control)) deallocate(F%control)
else
  if (allocated(F%control)) then
    if (n1_control == 0 .or. any(shape(F%control) /= [n1_control])) deallocate(F%control)
    if (any(lbound(F%control) /= 1)) deallocate(F%control)
  endif
  if (.not. allocated(F%control)) allocate(F%control(1:n1_control+1-1))
  do jd1 = 1, n1_control
    call control_to_f (z_control(jd1), c_loc(F%control(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_beam_start, c_loc(F%beam_start))
!! f_side.to_f2_trans[type, 0, NOT]
call pre_tracker_to_f(z_pre_tracker, c_loc(F%pre_tracker))
!! f_side.to_f2_trans[integer, 0, NOT]
F%version = z_version
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ele_track = z_n_ele_track
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ele_max = z_n_ele_max
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_control_max = z_n_control_max
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ic_max = z_n_ic_max
!! f_side.to_f2_trans[integer, 0, NOT]
F%input_taylor_order = z_input_taylor_order
!! f_side.to_f2_trans[integer, 1, ALLOC]
if (allocated(F%ic)) then
  if (n1_ic == 0 .or. any(shape(F%ic) /= [n1_ic])) deallocate(F%ic)
  if (any(lbound(F%ic) /= 1)) deallocate(F%ic)
endif
if (n1_ic /= 0) then
  call c_f_pointer (z_ic, f_ic, [n1_ic])
  if (.not. allocated(F%ic)) allocate(F%ic(n1_ic))
  F%ic = f_ic(1:n1_ic)
else
  if (allocated(F%ic)) deallocate(F%ic)
endif

!! f_side.to_f2_trans[logical, 0, NOT]
F%absolute_time_tracking = f_logic(z_absolute_time_tracking)
!! f_side.to_f2_trans[logical, 0, NOT]
F%rf_auto_scale_phase = f_logic(z_rf_auto_scale_phase)
!! f_side.to_f2_trans[logical, 0, NOT]
F%rf_auto_scale_amp = f_logic(z_rf_auto_scale_amp)
!! f_side.to_f2_trans[logical, 0, NOT]
F%use_ptc_layout = f_logic(z_use_ptc_layout)

end subroutine lat_to_f2
end module
