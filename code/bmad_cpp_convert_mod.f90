
!+
! Fortran side of the Bmad / C++ structure interface.
!
! This file is generated by the Bmad/C++ interface code generation.
! The code generation files can be found in cpp_bmad_interface.
!
! DO NOT EDIT THIS FILE DIRECTLY! 
!-

module bmad_cpp_convert_mod

use beam_def_struct
use fortran_cpp_utils
use, intrinsic :: iso_c_binding

!--------------------------------------------------------------------------

interface 
  subroutine interval1_coef_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_reflect_table_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_reflect_surface_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine coord_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine coord_array_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bpm_phase_coupling_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wig_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wig_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wake_sr_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wake_sr_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wake_lr_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wake_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_map_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_map_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_grid_pt_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_grid_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_fields_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine floor_position_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine space_charge_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine xy_disp_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine twiss_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine mode3_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bookkeeping_state_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_int_ele_cache_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine surface_grid_pt_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine surface_grid_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine segmented_surface_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine target_point_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_surface_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_target_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_material_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_element_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wall3d_vertex_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wall3d_section_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wall3d_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine taylor_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine taylor_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine control_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine lat_param_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine mode_info_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine pre_tracker_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine anormal_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine linac_normal_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine normal_modes_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine track_map_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine track_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine synch_rad_common_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine csr_parameter_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bmad_common_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_int1_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_int_all_ele_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine ele_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine complex_taylor_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine complex_taylor_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine normal_form_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine branch_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine lat_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bunch_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine beam_spin_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bunch_params_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine beam_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

contains

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine interval1_coef_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad interval1_coef_struct to a C++ CPP_interval1_coef structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad interval1_coef_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_interval1_coef struct.
!-

subroutine interval1_coef_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine interval1_coef_to_c2 (C, z_c0, z_c1, z_n_exp) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_c0, z_c1, z_n_exp
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(interval1_coef_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call interval1_coef_to_c2 (C, F%c0, F%c1, F%n_exp)

end subroutine interval1_coef_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine interval1_coef_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_interval1_coef structure to a Bmad interval1_coef_struct structure.
! This routine is called by interval1_coef_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the interval1_coef_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad interval1_coef_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine interval1_coef_to_f2 (Fp, z_c0, z_c1, z_n_exp) bind(c)


implicit none

type(c_ptr), value :: Fp
type(interval1_coef_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_c0, z_c1, z_n_exp

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%c0 = z_c0
!! f_side.to_f2_trans[real, 0, NOT]
F%c1 = z_c1
!! f_side.to_f2_trans[real, 0, NOT]
F%n_exp = z_n_exp

end subroutine interval1_coef_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_reflect_table_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_reflect_table_struct to a C++ CPP_photon_reflect_table structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_reflect_table_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_reflect_table struct.
!-

subroutine photon_reflect_table_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_reflect_table_to_c2 (C, z_angle, n1_angle, z_energy, n1_energy, z_int1, &
      n1_int1, z_p_reflect, n1_p_reflect, n2_p_reflect, z_max_energy, z_p_reflect_scratch, &
      n1_p_reflect_scratch) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_angle, n1_energy, n1_int1, n1_p_reflect, n2_p_reflect, n1_p_reflect_scratch
    real(c_double) :: z_angle(*), z_energy(*), z_p_reflect(*), z_max_energy, z_p_reflect_scratch(*)
    type(c_ptr) :: z_int1(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_reflect_table_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n1_angle
integer(c_int) :: n1_energy
type(c_ptr), allocatable :: z_int1(:)
integer(c_int) :: n1_int1
integer(c_int) :: n1_p_reflect
integer(c_int) :: n2_p_reflect
integer(c_int) :: n1_p_reflect_scratch

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[real, 1, ALLOC]
n1_angle = 0
if (allocated(F%angle)) then
  n1_angle = size(F%angle, 1)
endif
!! f_side.to_c_trans[real, 1, ALLOC]
n1_energy = 0
if (allocated(F%energy)) then
  n1_energy = size(F%energy, 1)
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_int1 = 0
if (allocated(F%int1)) then
  n1_int1 = size(F%int1); lb1 = lbound(F%int1, 1) - 1
  allocate (z_int1(n1_int1))
  do jd1 = 1, n1_int1
    z_int1(jd1) = c_loc(F%int1(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[real, 2, ALLOC]
if (allocated(F%p_reflect)) then
  n1_p_reflect = size(F%p_reflect, 1)
  n2_p_reflect = size(F%p_reflect, 2)
else
  n1_p_reflect = 0; n2_p_reflect = 0
endif
!! f_side.to_c_trans[real, 1, ALLOC]
n1_p_reflect_scratch = 0
if (allocated(F%p_reflect_scratch)) then
  n1_p_reflect_scratch = size(F%p_reflect_scratch, 1)
endif

!! f_side.to_c2_call
call photon_reflect_table_to_c2 (C, fvec2vec(F%angle, n1_angle), n1_angle, fvec2vec(F%energy, &
    n1_energy), n1_energy, z_int1, n1_int1, mat2vec(F%p_reflect, n1_p_reflect*n2_p_reflect), &
    n1_p_reflect, n2_p_reflect, F%max_energy, fvec2vec(F%p_reflect_scratch, &
    n1_p_reflect_scratch), n1_p_reflect_scratch)

end subroutine photon_reflect_table_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_reflect_table_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_reflect_table structure to a Bmad photon_reflect_table_struct structure.
! This routine is called by photon_reflect_table_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_reflect_table_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_reflect_table_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_reflect_table_to_f2 (Fp, z_angle, n1_angle, z_energy, n1_energy, z_int1, &
    n1_int1, z_p_reflect, n1_p_reflect, n2_p_reflect, z_max_energy, z_p_reflect_scratch, &
    n1_p_reflect_scratch) bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_reflect_table_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr) :: z_int1(*)
type(c_ptr), value :: z_angle, z_energy, z_p_reflect, z_p_reflect_scratch
real(c_double) :: z_max_energy
integer(c_int), value :: n1_angle, n1_energy, n1_int1, n1_p_reflect, n2_p_reflect, n1_p_reflect_scratch
real(c_double), pointer :: f_angle(:), f_energy(:), f_p_reflect(:), f_p_reflect_scratch(:)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%angle)) then
  if (n1_angle == 0 .or. any(shape(F%angle) /= [n1_angle])) deallocate(F%angle)
  if (any(lbound(F%angle) /= 1)) deallocate(F%angle)
endif
if (n1_angle /= 0) then
  call c_f_pointer (z_angle, f_angle, [n1_angle])
  if (.not. allocated(F%angle)) allocate(F%angle(n1_angle))
  F%angle = f_angle(1:n1_angle)
else
  if (allocated(F%angle)) deallocate(F%angle)
endif

!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%energy)) then
  if (n1_energy == 0 .or. any(shape(F%energy) /= [n1_energy])) deallocate(F%energy)
  if (any(lbound(F%energy) /= 1)) deallocate(F%energy)
endif
if (n1_energy /= 0) then
  call c_f_pointer (z_energy, f_energy, [n1_energy])
  if (.not. allocated(F%energy)) allocate(F%energy(n1_energy))
  F%energy = f_energy(1:n1_energy)
else
  if (allocated(F%energy)) deallocate(F%energy)
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_int1 == 0) then
  if (allocated(F%int1)) deallocate(F%int1)
else
  if (allocated(F%int1)) then
    if (n1_int1 == 0 .or. any(shape(F%int1) /= [n1_int1])) deallocate(F%int1)
    if (any(lbound(F%int1) /= 1)) deallocate(F%int1)
  endif
  if (.not. allocated(F%int1)) allocate(F%int1(1:n1_int1+1-1))
  do jd1 = 1, n1_int1
    call interval1_coef_to_f (z_int1(jd1), c_loc(F%int1(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 2, ALLOC]
if (allocated(F%p_reflect)) then
  if (n1_p_reflect == 0 .or. any(shape(F%p_reflect) /= [n1_p_reflect, n2_p_reflect])) deallocate(F%p_reflect)
  if (any(lbound(F%p_reflect) /= 1)) deallocate(F%p_reflect)
endif
if (n1_p_reflect /= 0) then
  call c_f_pointer (z_p_reflect, f_p_reflect, [n1_p_reflect*n2_p_reflect])
  if (.not. allocated(F%p_reflect)) allocate(F%p_reflect(n1_p_reflect, n2_p_reflect))
  call vec2mat(f_p_reflect, F%p_reflect)
else
  if (allocated(F%p_reflect)) deallocate(F%p_reflect)
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%max_energy = z_max_energy
!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%p_reflect_scratch)) then
  if (n1_p_reflect_scratch == 0 .or. any(shape(F%p_reflect_scratch) /= [n1_p_reflect_scratch])) deallocate(F%p_reflect_scratch)
  if (any(lbound(F%p_reflect_scratch) /= 1)) deallocate(F%p_reflect_scratch)
endif
if (n1_p_reflect_scratch /= 0) then
  call c_f_pointer (z_p_reflect_scratch, f_p_reflect_scratch, [n1_p_reflect_scratch])
  if (.not. allocated(F%p_reflect_scratch)) allocate(F%p_reflect_scratch(n1_p_reflect_scratch))
  F%p_reflect_scratch = f_p_reflect_scratch(1:n1_p_reflect_scratch)
else
  if (allocated(F%p_reflect_scratch)) deallocate(F%p_reflect_scratch)
endif


end subroutine photon_reflect_table_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_reflect_surface_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_reflect_surface_struct to a C++ CPP_photon_reflect_surface structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_reflect_surface_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_reflect_surface struct.
!-

subroutine photon_reflect_surface_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_reflect_surface_to_c2 (C, z_descrip, z_reflectivity_file, z_table, &
      n1_table, z_surface_roughness_rms, z_roughness_correlation_len, z_initialized, &
      z_ix_surface) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_ix_surface
    integer(c_int), value :: n1_table
    logical(c_bool) :: z_initialized
    character(c_char) :: z_descrip(*), z_reflectivity_file(*)
    real(c_double) :: z_surface_roughness_rms, z_roughness_correlation_len
    type(c_ptr) :: z_table(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_reflect_surface_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_table(:)
integer(c_int) :: n1_table

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_table = 0
if (allocated(F%table)) then
  n1_table = size(F%table); lb1 = lbound(F%table, 1) - 1
  allocate (z_table(n1_table))
  do jd1 = 1, n1_table
    z_table(jd1) = c_loc(F%table(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call photon_reflect_surface_to_c2 (C, trim(F%descrip) // c_null_char, trim(F%reflectivity_file) &
    // c_null_char, z_table, n1_table, F%surface_roughness_rms, F%roughness_correlation_len, &
    c_logic(F%initialized), F%ix_surface)

end subroutine photon_reflect_surface_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_reflect_surface_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_reflect_surface structure to a Bmad photon_reflect_surface_struct structure.
! This routine is called by photon_reflect_surface_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_reflect_surface_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_reflect_surface_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_reflect_surface_to_f2 (Fp, z_descrip, z_reflectivity_file, z_table, n1_table, &
    z_surface_roughness_rms, z_roughness_correlation_len, z_initialized, z_ix_surface) bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_reflect_surface_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_ix_surface
integer(c_int), value :: n1_table
logical(c_bool) :: z_initialized
character(c_char) :: z_descrip(*), z_reflectivity_file(*)
real(c_double) :: z_surface_roughness_rms, z_roughness_correlation_len
type(c_ptr) :: z_table(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_descrip, F%descrip)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_reflectivity_file, F%reflectivity_file)
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_table == 0) then
  if (allocated(F%table)) deallocate(F%table)
else
  if (allocated(F%table)) then
    if (n1_table == 0 .or. any(shape(F%table) /= [n1_table])) deallocate(F%table)
    if (any(lbound(F%table) /= 1)) deallocate(F%table)
  endif
  if (.not. allocated(F%table)) allocate(F%table(1:n1_table+1-1))
  do jd1 = 1, n1_table
    call photon_reflect_table_to_f (z_table(jd1), c_loc(F%table(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%surface_roughness_rms = z_surface_roughness_rms
!! f_side.to_f2_trans[real, 0, NOT]
F%roughness_correlation_len = z_roughness_correlation_len
!! f_side.to_f2_trans[logical, 0, NOT]
F%initialized = f_logic(z_initialized)
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_surface = z_ix_surface

end subroutine photon_reflect_surface_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad coord_struct to a C++ CPP_coord structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad coord_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_coord struct.
!-

subroutine coord_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine coord_to_c2 (C, z_vec, z_s, z_t, z_spin, z_field, z_phase, z_charge, z_path_len, &
      z_p0c, z_beta, z_ix_ele, z_state, z_direction, z_species, z_location) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_spin(*)
    real(c_double) :: z_vec(*), z_s, z_t, z_field(*), z_phase(*), z_charge, z_path_len
    real(c_double) :: z_p0c, z_beta
    integer(c_int) :: z_ix_ele, z_state, z_direction, z_species, z_location
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(coord_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call coord_to_c2 (C, fvec2vec(F%vec, 6), F%s, F%t, fvec2vec(F%spin, 2), fvec2vec(F%field, 2), &
    fvec2vec(F%phase, 2), F%charge, F%path_len, F%p0c, F%beta, F%ix_ele, F%state, F%direction, &
    F%species, F%location)

end subroutine coord_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_coord structure to a Bmad coord_struct structure.
! This routine is called by coord_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the coord_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad coord_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine coord_to_f2 (Fp, z_vec, z_s, z_t, z_spin, z_field, z_phase, z_charge, z_path_len, &
    z_p0c, z_beta, z_ix_ele, z_state, z_direction, z_species, z_location) bind(c)


implicit none

type(c_ptr), value :: Fp
type(coord_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_spin(*)
real(c_double) :: z_vec(*), z_s, z_t, z_field(*), z_phase(*), z_charge, z_path_len
real(c_double) :: z_p0c, z_beta
integer(c_int) :: z_ix_ele, z_state, z_direction, z_species, z_location

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%vec = z_vec(1:6)
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[real, 0, NOT]
F%t = z_t
!! f_side.to_f2_trans[complex, 1, NOT]
F%spin = z_spin(1:2)
!! f_side.to_f2_trans[real, 1, NOT]
F%field = z_field(1:2)
!! f_side.to_f2_trans[real, 1, NOT]
F%phase = z_phase(1:2)
!! f_side.to_f2_trans[real, 0, NOT]
F%charge = z_charge
!! f_side.to_f2_trans[real, 0, NOT]
F%path_len = z_path_len
!! f_side.to_f2_trans[real, 0, NOT]
F%p0c = z_p0c
!! f_side.to_f2_trans[real, 0, NOT]
F%beta = z_beta
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%state = z_state
!! f_side.to_f2_trans[integer, 0, NOT]
F%direction = z_direction
!! f_side.to_f2_trans[integer, 0, NOT]
F%species = z_species
!! f_side.to_f2_trans[integer, 0, NOT]
F%location = z_location

end subroutine coord_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_array_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad coord_array_struct to a C++ CPP_coord_array structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad coord_array_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_coord_array struct.
!-

subroutine coord_array_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine coord_array_to_c2 (C, z_orb, n1_orb) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_orb
    type(c_ptr) :: z_orb(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(coord_array_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_orb(:)
integer(c_int) :: n1_orb

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_orb = 0
if (allocated(F%orb)) then
  n1_orb = size(F%orb); lb1 = lbound(F%orb, 1) - 1
  allocate (z_orb(n1_orb))
  do jd1 = 1, n1_orb
    z_orb(jd1) = c_loc(F%orb(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call coord_array_to_c2 (C, z_orb, n1_orb)

end subroutine coord_array_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_array_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_coord_array structure to a Bmad coord_array_struct structure.
! This routine is called by coord_array_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the coord_array_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad coord_array_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine coord_array_to_f2 (Fp, z_orb, n1_orb) bind(c)


implicit none

type(c_ptr), value :: Fp
type(coord_array_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_orb
type(c_ptr) :: z_orb(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_orb == 0) then
  if (allocated(F%orb)) deallocate(F%orb)
else
  if (allocated(F%orb)) then
    if (n1_orb == 0 .or. any(shape(F%orb) /= [n1_orb])) deallocate(F%orb)
    if (any(lbound(F%orb) /= 1)) deallocate(F%orb)
  endif
  if (.not. allocated(F%orb)) allocate(F%orb(1:n1_orb+1-1))
  do jd1 = 1, n1_orb
    call coord_to_f (z_orb(jd1), c_loc(F%orb(jd1+1-1)))
  enddo
endif


end subroutine coord_array_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bpm_phase_coupling_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bpm_phase_coupling_struct to a C++ CPP_bpm_phase_coupling structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bpm_phase_coupling_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bpm_phase_coupling struct.
!-

subroutine bpm_phase_coupling_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bpm_phase_coupling_to_c2 (C, z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, &
      z_cbar12_a, z_cbar11_b, z_cbar12_b, z_phi_a, z_phi_b) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, z_cbar12_a, z_cbar11_b
    real(c_double) :: z_cbar12_b, z_phi_a, z_phi_b
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bpm_phase_coupling_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bpm_phase_coupling_to_c2 (C, F%k_22a, F%k_12a, F%k_11b, F%k_12b, F%cbar22_a, F%cbar12_a, &
    F%cbar11_b, F%cbar12_b, F%phi_a, F%phi_b)

end subroutine bpm_phase_coupling_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bpm_phase_coupling_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bpm_phase_coupling structure to a Bmad bpm_phase_coupling_struct structure.
! This routine is called by bpm_phase_coupling_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bpm_phase_coupling_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bpm_phase_coupling_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bpm_phase_coupling_to_f2 (Fp, z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, &
    z_cbar12_a, z_cbar11_b, z_cbar12_b, z_phi_a, z_phi_b) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bpm_phase_coupling_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, z_cbar12_a, z_cbar11_b
real(c_double) :: z_cbar12_b, z_phi_a, z_phi_b

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%k_22a = z_k_22a
!! f_side.to_f2_trans[real, 0, NOT]
F%k_12a = z_k_12a
!! f_side.to_f2_trans[real, 0, NOT]
F%k_11b = z_k_11b
!! f_side.to_f2_trans[real, 0, NOT]
F%k_12b = z_k_12b
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar22_a = z_cbar22_a
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar12_a = z_cbar12_a
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar11_b = z_cbar11_b
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar12_b = z_cbar12_b
!! f_side.to_f2_trans[real, 0, NOT]
F%phi_a = z_phi_a
!! f_side.to_f2_trans[real, 0, NOT]
F%phi_b = z_phi_b

end subroutine bpm_phase_coupling_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wig_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wig_term_struct to a C++ CPP_wig_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wig_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wig_term struct.
!-

subroutine wig_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wig_term_to_c2 (C, z_coef, z_kx, z_ky, z_kz, z_phi_z, z_type) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_coef, z_kx, z_ky, z_kz, z_phi_z
    integer(c_int) :: z_type
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wig_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wig_term_to_c2 (C, F%coef, F%kx, F%ky, F%kz, F%phi_z, F%type)

end subroutine wig_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wig_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wig_term structure to a Bmad wig_term_struct structure.
! This routine is called by wig_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wig_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wig_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wig_term_to_f2 (Fp, z_coef, z_kx, z_ky, z_kz, z_phi_z, z_type) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wig_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_coef, z_kx, z_ky, z_kz, z_phi_z
integer(c_int) :: z_type

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[real, 0, NOT]
F%kx = z_kx
!! f_side.to_f2_trans[real, 0, NOT]
F%ky = z_ky
!! f_side.to_f2_trans[real, 0, NOT]
F%kz = z_kz
!! f_side.to_f2_trans[real, 0, NOT]
F%phi_z = z_phi_z
!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type

end subroutine wig_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wig_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wig_struct to a C++ CPP_wig structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wig_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wig struct.
!-

subroutine wig_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wig_to_c2 (C, z_n_link, z_term, n1_term) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_term
    type(c_ptr) :: z_term(*)
    integer(c_int) :: z_n_link
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wig_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_term = 0
if (allocated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call wig_to_c2 (C, F%n_link, z_term, n1_term)

end subroutine wig_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wig_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wig structure to a Bmad wig_struct structure.
! This routine is called by wig_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wig_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wig_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wig_to_f2 (Fp, z_n_link, z_term, n1_term) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wig_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_term
type(c_ptr) :: z_term(*)
integer(c_int) :: z_n_link

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_term == 0) then
  if (allocated(F%term)) deallocate(F%term)
else
  if (allocated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. allocated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call wig_term_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine wig_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_sr_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wake_sr_mode_struct to a C++ CPP_wake_sr_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wake_sr_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wake_sr_mode struct.
!-

subroutine wake_sr_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wake_sr_mode_to_c2 (C, z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin, &
      z_a_cos, z_polarization, z_transverse_dependence) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin
    real(c_double) :: z_a_cos
    integer(c_int) :: z_polarization, z_transverse_dependence
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wake_sr_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wake_sr_mode_to_c2 (C, F%amp, F%damp, F%k, F%phi, F%b_sin, F%b_cos, F%a_sin, F%a_cos, &
    F%polarization, F%transverse_dependence)

end subroutine wake_sr_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_sr_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wake_sr_mode structure to a Bmad wake_sr_mode_struct structure.
! This routine is called by wake_sr_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wake_sr_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wake_sr_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wake_sr_mode_to_f2 (Fp, z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin, &
    z_a_cos, z_polarization, z_transverse_dependence) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wake_sr_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin
real(c_double) :: z_a_cos
integer(c_int) :: z_polarization, z_transverse_dependence

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%amp = z_amp
!! f_side.to_f2_trans[real, 0, NOT]
F%damp = z_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%k = z_k
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%b_sin = z_b_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%b_cos = z_b_cos
!! f_side.to_f2_trans[real, 0, NOT]
F%a_sin = z_a_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%a_cos = z_a_cos
!! f_side.to_f2_trans[integer, 0, NOT]
F%polarization = z_polarization
!! f_side.to_f2_trans[integer, 0, NOT]
F%transverse_dependence = z_transverse_dependence

end subroutine wake_sr_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_sr_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wake_sr_struct to a C++ CPP_wake_sr structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wake_sr_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wake_sr struct.
!-

subroutine wake_sr_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wake_sr_to_c2 (C, z_mode, n1_mode, z_z_ref) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_mode
    real(c_double) :: z_z_ref
    type(c_ptr) :: z_mode(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wake_sr_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_mode(:)
integer(c_int) :: n1_mode

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_mode = 0
if (allocated(F%mode)) then
  n1_mode = size(F%mode); lb1 = lbound(F%mode, 1) - 1
  allocate (z_mode(n1_mode))
  do jd1 = 1, n1_mode
    z_mode(jd1) = c_loc(F%mode(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call wake_sr_to_c2 (C, z_mode, n1_mode, F%z_ref)

end subroutine wake_sr_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_sr_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wake_sr structure to a Bmad wake_sr_struct structure.
! This routine is called by wake_sr_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wake_sr_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wake_sr_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wake_sr_to_f2 (Fp, z_mode, n1_mode, z_z_ref) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wake_sr_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_mode
real(c_double) :: z_z_ref
type(c_ptr) :: z_mode(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_mode == 0) then
  if (allocated(F%mode)) deallocate(F%mode)
else
  if (allocated(F%mode)) then
    if (n1_mode == 0 .or. any(shape(F%mode) /= [n1_mode])) deallocate(F%mode)
    if (any(lbound(F%mode) /= 1)) deallocate(F%mode)
  endif
  if (.not. allocated(F%mode)) allocate(F%mode(1:n1_mode+1-1))
  do jd1 = 1, n1_mode
    call wake_sr_mode_to_f (z_mode(jd1), c_loc(F%mode(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%z_ref = z_z_ref

end subroutine wake_sr_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_lr_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wake_lr_struct to a C++ CPP_wake_lr structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wake_lr_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wake_lr struct.
!-

subroutine wake_lr_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wake_lr_to_c2 (C, z_freq, z_freq_in, z_r_over_q, z_q, z_angle, z_b_sin, z_b_cos, &
      z_a_sin, z_a_cos, z_t_ref, z_m, z_polarized) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_polarized
    real(c_double) :: z_freq, z_freq_in, z_r_over_q, z_q, z_angle, z_b_sin, z_b_cos
    real(c_double) :: z_a_sin, z_a_cos, z_t_ref
    integer(c_int) :: z_m
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wake_lr_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wake_lr_to_c2 (C, F%freq, F%freq_in, F%r_over_q, F%q, F%angle, F%b_sin, F%b_cos, F%a_sin, &
    F%a_cos, F%t_ref, F%m, c_logic(F%polarized))

end subroutine wake_lr_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_lr_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wake_lr structure to a Bmad wake_lr_struct structure.
! This routine is called by wake_lr_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wake_lr_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wake_lr_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wake_lr_to_f2 (Fp, z_freq, z_freq_in, z_r_over_q, z_q, z_angle, z_b_sin, z_b_cos, &
    z_a_sin, z_a_cos, z_t_ref, z_m, z_polarized) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wake_lr_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_polarized
real(c_double) :: z_freq, z_freq_in, z_r_over_q, z_q, z_angle, z_b_sin, z_b_cos
real(c_double) :: z_a_sin, z_a_cos, z_t_ref
integer(c_int) :: z_m

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%freq = z_freq
!! f_side.to_f2_trans[real, 0, NOT]
F%freq_in = z_freq_in
!! f_side.to_f2_trans[real, 0, NOT]
F%r_over_q = z_r_over_q
!! f_side.to_f2_trans[real, 0, NOT]
F%q = z_q
!! f_side.to_f2_trans[real, 0, NOT]
F%angle = z_angle
!! f_side.to_f2_trans[real, 0, NOT]
F%b_sin = z_b_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%b_cos = z_b_cos
!! f_side.to_f2_trans[real, 0, NOT]
F%a_sin = z_a_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%a_cos = z_a_cos
!! f_side.to_f2_trans[real, 0, NOT]
F%t_ref = z_t_ref
!! f_side.to_f2_trans[integer, 0, NOT]
F%m = z_m
!! f_side.to_f2_trans[logical, 0, NOT]
F%polarized = f_logic(z_polarized)

end subroutine wake_lr_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wake_struct to a C++ CPP_wake structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wake_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wake struct.
!-

subroutine wake_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wake_to_c2 (C, z_sr_file, z_lr_file, z_sr_long, z_sr_trans, z_lr, n1_lr, &
      z_z_sr_max) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_sr_long, z_sr_trans
    real(c_double) :: z_z_sr_max
    integer(c_int), value :: n1_lr
    type(c_ptr) :: z_lr(*)
    character(c_char) :: z_sr_file(*), z_lr_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wake_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_lr(:)
integer(c_int) :: n1_lr

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_lr = 0
if (allocated(F%lr)) then
  n1_lr = size(F%lr); lb1 = lbound(F%lr, 1) - 1
  allocate (z_lr(n1_lr))
  do jd1 = 1, n1_lr
    z_lr(jd1) = c_loc(F%lr(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call wake_to_c2 (C, trim(F%sr_file) // c_null_char, trim(F%lr_file) // c_null_char, &
    c_loc(F%sr_long), c_loc(F%sr_trans), z_lr, n1_lr, F%z_sr_max)

end subroutine wake_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wake structure to a Bmad wake_struct structure.
! This routine is called by wake_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wake_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wake_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wake_to_f2 (Fp, z_sr_file, z_lr_file, z_sr_long, z_sr_trans, z_lr, n1_lr, &
    z_z_sr_max) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wake_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_sr_long, z_sr_trans
real(c_double) :: z_z_sr_max
integer(c_int), value :: n1_lr
type(c_ptr) :: z_lr(*)
character(c_char) :: z_sr_file(*), z_lr_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_sr_file, F%sr_file)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_lr_file, F%lr_file)
!! f_side.to_f2_trans[type, 0, NOT]
call wake_sr_to_f(z_sr_long, c_loc(F%sr_long))
!! f_side.to_f2_trans[type, 0, NOT]
call wake_sr_to_f(z_sr_trans, c_loc(F%sr_trans))
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_lr == 0) then
  if (allocated(F%lr)) deallocate(F%lr)
else
  if (allocated(F%lr)) then
    if (n1_lr == 0 .or. any(shape(F%lr) /= [n1_lr])) deallocate(F%lr)
    if (any(lbound(F%lr) /= 1)) deallocate(F%lr)
  endif
  if (.not. allocated(F%lr)) allocate(F%lr(1:n1_lr+1-1))
  do jd1 = 1, n1_lr
    call wake_lr_to_f (z_lr(jd1), c_loc(F%lr(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%z_sr_max = z_z_sr_max

end subroutine wake_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_map_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_map_term_struct to a C++ CPP_em_field_map_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_map_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field_map_term struct.
!-

subroutine em_field_map_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_map_term_to_c2 (C, z_e_coef, z_b_coef) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_e_coef, z_b_coef
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_map_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call em_field_map_term_to_c2 (C, F%e_coef, F%b_coef)

end subroutine em_field_map_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_map_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field_map_term structure to a Bmad em_field_map_term_struct structure.
! This routine is called by em_field_map_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_map_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_map_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_map_term_to_f2 (Fp, z_e_coef, z_b_coef) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_map_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_e_coef, z_b_coef

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 0, NOT]
F%e_coef = z_e_coef
!! f_side.to_f2_trans[complex, 0, NOT]
F%b_coef = z_b_coef

end subroutine em_field_map_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_map_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_map_struct to a C++ CPP_em_field_map structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_map_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field_map struct.
!-

subroutine em_field_map_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_map_to_c2 (C, z_file, z_n_link, z_ele_anchor_pt, z_dz, z_term, n1_term) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_term
    real(c_double) :: z_dz
    type(c_ptr) :: z_term(*)
    integer(c_int) :: z_n_link, z_ele_anchor_pt
    character(c_char) :: z_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_term = 0
if (allocated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call em_field_map_to_c2 (C, trim(F%file) // c_null_char, F%n_link, F%ele_anchor_pt, F%dz, &
    z_term, n1_term)

end subroutine em_field_map_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_map_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field_map structure to a Bmad em_field_map_struct structure.
! This routine is called by em_field_map_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_map_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_map_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_map_to_f2 (Fp, z_file, z_n_link, z_ele_anchor_pt, z_dz, z_term, n1_term) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_term
real(c_double) :: z_dz
type(c_ptr) :: z_term(*)
integer(c_int) :: z_n_link, z_ele_anchor_pt
character(c_char) :: z_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[real, 0, NOT]
F%dz = z_dz
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_term == 0) then
  if (allocated(F%term)) deallocate(F%term)
else
  if (allocated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. allocated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call em_field_map_term_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine em_field_map_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_grid_pt_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_grid_pt_struct to a C++ CPP_em_field_grid_pt structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_grid_pt_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field_grid_pt struct.
!-

subroutine em_field_grid_pt_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_grid_pt_to_c2 (C, z_e, z_b) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_e(*), z_b(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_grid_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call em_field_grid_pt_to_c2 (C, fvec2vec(F%e, 3), fvec2vec(F%b, 3))

end subroutine em_field_grid_pt_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_grid_pt_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field_grid_pt structure to a Bmad em_field_grid_pt_struct structure.
! This routine is called by em_field_grid_pt_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_grid_pt_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_grid_pt_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_grid_pt_to_f2 (Fp, z_e, z_b) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_grid_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_e(*), z_b(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 1, NOT]
F%e = z_e(1:3)
!! f_side.to_f2_trans[complex, 1, NOT]
F%b = z_b(1:3)

end subroutine em_field_grid_pt_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_grid_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_grid_struct to a C++ CPP_em_field_grid structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_grid_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field_grid struct.
!-

subroutine em_field_grid_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_grid_to_c2 (C, z_file, z_type, z_ele_anchor_pt, z_n_link, z_pt, n1_pt, &
      n2_pt, n3_pt, z_dr, z_r0) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_pt, n2_pt, n3_pt
    real(c_double) :: z_dr(*), z_r0(*)
    type(c_ptr) :: z_pt(*)
    integer(c_int) :: z_type, z_ele_anchor_pt, z_n_link
    character(c_char) :: z_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_grid_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_pt(:)
integer(c_int) :: n1_pt
integer(c_int) :: n2_pt
integer(c_int) :: n3_pt

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 3, ALLOC]
if (allocated(F%pt)) then
  n1_pt = size(F%pt, 1); lb1 = lbound(F%pt, 1) - 1
  n2_pt = size(F%pt, 2); lb2 = lbound(F%pt, 2) - 1
  n3_pt = size(F%pt, 3); lb3 = lbound(F%pt, 3) - 1
  allocate (z_pt(n1_pt * n2_pt * n3_pt))
  do jd1 = 1, n1_pt; do jd2 = 1, n2_pt; do jd3 = 1, n3_pt
    z_pt(n3_pt*n2_pt*(jd1-1) + n3_pt*(jd2-1) + jd3) = c_loc(F%pt(jd1+lb1, jd2+lb2, jd3+lb3))
  enddo;  enddo; enddo
else
  n1_pt = 0; n2_pt = 0; n3_pt = 0
endif

!! f_side.to_c2_call
call em_field_grid_to_c2 (C, trim(F%file) // c_null_char, F%type, F%ele_anchor_pt, F%n_link, &
    z_pt, n1_pt, n2_pt, n3_pt, fvec2vec(F%dr, 3), fvec2vec(F%r0, 3))

end subroutine em_field_grid_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_grid_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field_grid structure to a Bmad em_field_grid_struct structure.
! This routine is called by em_field_grid_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_grid_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_grid_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_grid_to_f2 (Fp, z_file, z_type, z_ele_anchor_pt, z_n_link, z_pt, n1_pt, &
    n2_pt, n3_pt, z_dr, z_r0) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_grid_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_pt, n2_pt, n3_pt
real(c_double) :: z_dr(*), z_r0(*)
type(c_ptr) :: z_pt(*)
integer(c_int) :: z_type, z_ele_anchor_pt, z_n_link
character(c_char) :: z_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[type, 3, ALLOC]
if (n1_pt == 0) then
  if (allocated(F%pt)) deallocate(F%pt)
else
  if (allocated(F%pt)) then
    if (n1_pt == 0 .or. any(shape(F%pt) /= [n1_pt, n2_pt, n3_pt])) deallocate(F%pt)
    if (any(lbound(F%pt) /= 1)) deallocate(F%pt)
  endif
  if (.not. allocated(F%pt)) allocate(F%pt(1:n1_pt+1-1, 1:n2_pt+1-1, 1:n3_pt+1-1))
  do jd1 = 1, n1_pt;  do jd2 = 1, n2_pt;  do jd3 = 1, n3_pt
    call em_field_grid_pt_to_f (z_pt(n3_pt*n2_pt*(jd1-1) + n3_pt*(jd2-1) + jd3), c_loc(F%pt(jd1+1-1,jd2+1-1,jd3+1-1)))
  enddo;  enddo;  enddo
endif

!! f_side.to_f2_trans[real, 1, NOT]
F%dr = z_dr(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:3)

end subroutine em_field_grid_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_mode_struct to a C++ CPP_em_field_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field_mode struct.
!-

subroutine em_field_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_mode_to_c2 (C, z_m, z_harmonic, z_f_damp, z_phi0_ref, z_stored_energy, &
      z_phi0_azimuth, z_field_scale, z_master_scale, z_map, n_map, z_grid, n_grid) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_map, z_grid
    real(c_double) :: z_f_damp, z_phi0_ref, z_stored_energy, z_phi0_azimuth, z_field_scale
    integer(c_int), value :: n_map, n_grid
    integer(c_int) :: z_m, z_harmonic, z_master_scale
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n_map
integer(c_int) :: n_grid

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 0, PTR]
n_map = 0
if (associated(F%map)) n_map = 1
!! f_side.to_c_trans[type, 0, PTR]
n_grid = 0
if (associated(F%grid)) n_grid = 1

!! f_side.to_c2_call
call em_field_mode_to_c2 (C, F%m, F%harmonic, F%f_damp, F%phi0_ref, F%stored_energy, &
    F%phi0_azimuth, F%field_scale, F%master_scale, c_loc(F%map), n_map, c_loc(F%grid), n_grid)

end subroutine em_field_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field_mode structure to a Bmad em_field_mode_struct structure.
! This routine is called by em_field_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_mode_to_f2 (Fp, z_m, z_harmonic, z_f_damp, z_phi0_ref, z_stored_energy, &
    z_phi0_azimuth, z_field_scale, z_master_scale, z_map, n_map, z_grid, n_grid) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_m, z_harmonic, z_master_scale
type(em_field_map_struct), pointer :: f_map
integer(c_int), value :: n_map, n_grid
type(em_field_grid_struct), pointer :: f_grid
real(c_double) :: z_f_damp, z_phi0_ref, z_stored_energy, z_phi0_azimuth, z_field_scale
type(c_ptr), value :: z_map, z_grid

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%m = z_m
!! f_side.to_f2_trans[integer, 0, NOT]
F%harmonic = z_harmonic
!! f_side.to_f2_trans[real, 0, NOT]
F%f_damp = z_f_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%phi0_ref = z_phi0_ref
!! f_side.to_f2_trans[real, 0, NOT]
F%stored_energy = z_stored_energy
!! f_side.to_f2_trans[real, 0, NOT]
F%phi0_azimuth = z_phi0_azimuth
!! f_side.to_f2_trans[real, 0, NOT]
F%field_scale = z_field_scale
!! f_side.to_f2_trans[integer, 0, NOT]
F%master_scale = z_master_scale
!! f_side.to_f2_trans[type, 0, PTR]
if (n_map == 0) then
  if (associated(F%map)) deallocate(F%map)
else
  if (.not. associated(F%map)) allocate(F%map)
  call em_field_map_to_f (z_map, c_loc(F%map))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_grid == 0) then
  if (associated(F%grid)) deallocate(F%grid)
else
  if (.not. associated(F%grid)) allocate(F%grid)
  call em_field_grid_to_f (z_grid, c_loc(F%grid))
endif


end subroutine em_field_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_fields_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_fields_struct to a C++ CPP_em_fields structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_fields_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_fields struct.
!-

subroutine em_fields_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_fields_to_c2 (C, z_mode, n1_mode, z_mode_to_autoscale) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_mode
    integer(c_int) :: z_mode_to_autoscale
    type(c_ptr) :: z_mode(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_fields_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_mode(:)
integer(c_int) :: n1_mode

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_mode = 0
if (allocated(F%mode)) then
  n1_mode = size(F%mode); lb1 = lbound(F%mode, 1) - 1
  allocate (z_mode(n1_mode))
  do jd1 = 1, n1_mode
    z_mode(jd1) = c_loc(F%mode(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call em_fields_to_c2 (C, z_mode, n1_mode, F%mode_to_autoscale)

end subroutine em_fields_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_fields_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_fields structure to a Bmad em_fields_struct structure.
! This routine is called by em_fields_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_fields_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_fields_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_fields_to_f2 (Fp, z_mode, n1_mode, z_mode_to_autoscale) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_fields_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_mode
integer(c_int) :: z_mode_to_autoscale
type(c_ptr) :: z_mode(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_mode == 0) then
  if (allocated(F%mode)) deallocate(F%mode)
else
  if (allocated(F%mode)) then
    if (n1_mode == 0 .or. any(shape(F%mode) /= [n1_mode])) deallocate(F%mode)
    if (any(lbound(F%mode) /= 1)) deallocate(F%mode)
  endif
  if (.not. allocated(F%mode)) allocate(F%mode(1:n1_mode+1-1))
  do jd1 = 1, n1_mode
    call em_field_mode_to_f (z_mode(jd1), c_loc(F%mode(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[integer, 0, NOT]
F%mode_to_autoscale = z_mode_to_autoscale

end subroutine em_fields_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine floor_position_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad floor_position_struct to a C++ CPP_floor_position structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad floor_position_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_floor_position struct.
!-

subroutine floor_position_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine floor_position_to_c2 (C, z_r, z_theta, z_phi, z_psi) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_r(*), z_theta, z_phi, z_psi
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(floor_position_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call floor_position_to_c2 (C, fvec2vec(F%r, 3), F%theta, F%phi, F%psi)

end subroutine floor_position_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine floor_position_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_floor_position structure to a Bmad floor_position_struct structure.
! This routine is called by floor_position_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the floor_position_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad floor_position_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine floor_position_to_f2 (Fp, z_r, z_theta, z_phi, z_psi) bind(c)


implicit none

type(c_ptr), value :: Fp
type(floor_position_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_r(*), z_theta, z_phi, z_psi

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%r = z_r(1:3)
!! f_side.to_f2_trans[real, 0, NOT]
F%theta = z_theta
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%psi = z_psi

end subroutine floor_position_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine space_charge_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad space_charge_struct to a C++ CPP_space_charge structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad space_charge_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_space_charge struct.
!-

subroutine space_charge_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine space_charge_to_c2 (C, z_closed_orb, z_kick_const, z_sig_x, z_sig_y, z_phi, &
      z_sin_phi, z_cos_phi, z_sig_z) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_closed_orb
    real(c_double) :: z_kick_const, z_sig_x, z_sig_y, z_phi, z_sin_phi, z_cos_phi, z_sig_z
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(space_charge_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call space_charge_to_c2 (C, c_loc(F%closed_orb), F%kick_const, F%sig_x, F%sig_y, F%phi, &
    F%sin_phi, F%cos_phi, F%sig_z)

end subroutine space_charge_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine space_charge_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_space_charge structure to a Bmad space_charge_struct structure.
! This routine is called by space_charge_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the space_charge_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad space_charge_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine space_charge_to_f2 (Fp, z_closed_orb, z_kick_const, z_sig_x, z_sig_y, z_phi, &
    z_sin_phi, z_cos_phi, z_sig_z) bind(c)


implicit none

type(c_ptr), value :: Fp
type(space_charge_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_closed_orb
real(c_double) :: z_kick_const, z_sig_x, z_sig_y, z_phi, z_sin_phi, z_cos_phi, z_sig_z

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_closed_orb, c_loc(F%closed_orb))
!! f_side.to_f2_trans[real, 0, NOT]
F%kick_const = z_kick_const
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_x = z_sig_x
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_y = z_sig_y
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%sin_phi = z_sin_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%cos_phi = z_cos_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_z = z_sig_z

end subroutine space_charge_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine xy_disp_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad xy_disp_struct to a C++ CPP_xy_disp structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad xy_disp_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_xy_disp struct.
!-

subroutine xy_disp_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine xy_disp_to_c2 (C, z_eta, z_etap) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_eta, z_etap
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(xy_disp_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call xy_disp_to_c2 (C, F%eta, F%etap)

end subroutine xy_disp_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine xy_disp_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_xy_disp structure to a Bmad xy_disp_struct structure.
! This routine is called by xy_disp_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the xy_disp_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad xy_disp_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine xy_disp_to_f2 (Fp, z_eta, z_etap) bind(c)


implicit none

type(c_ptr), value :: Fp
type(xy_disp_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_eta, z_etap

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%eta = z_eta
!! f_side.to_f2_trans[real, 0, NOT]
F%etap = z_etap

end subroutine xy_disp_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine twiss_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad twiss_struct to a C++ CPP_twiss structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad twiss_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_twiss struct.
!-

subroutine twiss_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine twiss_to_c2 (C, z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_sigma, &
      z_sigma_p, z_emit, z_norm_emit) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_sigma
    real(c_double) :: z_sigma_p, z_emit, z_norm_emit
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(twiss_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call twiss_to_c2 (C, F%beta, F%alpha, F%gamma, F%phi, F%eta, F%etap, F%sigma, F%sigma_p, &
    F%emit, F%norm_emit)

end subroutine twiss_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine twiss_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_twiss structure to a Bmad twiss_struct structure.
! This routine is called by twiss_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the twiss_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad twiss_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine twiss_to_f2 (Fp, z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_sigma, z_sigma_p, &
    z_emit, z_norm_emit) bind(c)


implicit none

type(c_ptr), value :: Fp
type(twiss_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_sigma
real(c_double) :: z_sigma_p, z_emit, z_norm_emit

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%beta = z_beta
!! f_side.to_f2_trans[real, 0, NOT]
F%alpha = z_alpha
!! f_side.to_f2_trans[real, 0, NOT]
F%gamma = z_gamma
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%eta = z_eta
!! f_side.to_f2_trans[real, 0, NOT]
F%etap = z_etap
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma = z_sigma
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma_p = z_sigma_p
!! f_side.to_f2_trans[real, 0, NOT]
F%emit = z_emit
!! f_side.to_f2_trans[real, 0, NOT]
F%norm_emit = z_norm_emit

end subroutine twiss_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode3_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad mode3_struct to a C++ CPP_mode3 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad mode3_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_mode3 struct.
!-

subroutine mode3_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine mode3_to_c2 (C, z_v, z_a, z_b, z_c, z_x, z_y) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_a, z_b, z_c, z_x, z_y
    real(c_double) :: z_v(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(mode3_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call mode3_to_c2 (C, mat2vec(F%v, 6*6), c_loc(F%a), c_loc(F%b), c_loc(F%c), c_loc(F%x), &
    c_loc(F%y))

end subroutine mode3_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode3_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_mode3 structure to a Bmad mode3_struct structure.
! This routine is called by mode3_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the mode3_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad mode3_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine mode3_to_f2 (Fp, z_v, z_a, z_b, z_c, z_x, z_y) bind(c)


implicit none

type(c_ptr), value :: Fp
type(mode3_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_a, z_b, z_c, z_x, z_y
real(c_double) :: z_v(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_v, F%v)
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_c, c_loc(F%c))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_x, c_loc(F%x))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_y, c_loc(F%y))

end subroutine mode3_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bookkeeping_state_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bookkeeping_state_struct to a C++ CPP_bookkeeping_state structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bookkeeping_state_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bookkeeping_state struct.
!-

subroutine bookkeeping_state_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bookkeeping_state_to_c2 (C, z_attributes, z_control, z_floor_position, &
      z_s_position, z_ref_energy, z_mat6, z_rad_int, z_ptc) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_attributes, z_control, z_floor_position, z_s_position, z_ref_energy, z_mat6, z_rad_int
    integer(c_int) :: z_ptc
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bookkeeping_state_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bookkeeping_state_to_c2 (C, F%attributes, F%control, F%floor_position, F%s_position, &
    F%ref_energy, F%mat6, F%rad_int, F%ptc)

end subroutine bookkeeping_state_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bookkeeping_state_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bookkeeping_state structure to a Bmad bookkeeping_state_struct structure.
! This routine is called by bookkeeping_state_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bookkeeping_state_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bookkeeping_state_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bookkeeping_state_to_f2 (Fp, z_attributes, z_control, z_floor_position, &
    z_s_position, z_ref_energy, z_mat6, z_rad_int, z_ptc) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bookkeeping_state_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_attributes, z_control, z_floor_position, z_s_position, z_ref_energy, z_mat6, z_rad_int
integer(c_int) :: z_ptc

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%attributes = z_attributes
!! f_side.to_f2_trans[integer, 0, NOT]
F%control = z_control
!! f_side.to_f2_trans[integer, 0, NOT]
F%floor_position = z_floor_position
!! f_side.to_f2_trans[integer, 0, NOT]
F%s_position = z_s_position
!! f_side.to_f2_trans[integer, 0, NOT]
F%ref_energy = z_ref_energy
!! f_side.to_f2_trans[integer, 0, NOT]
F%mat6 = z_mat6
!! f_side.to_f2_trans[integer, 0, NOT]
F%rad_int = z_rad_int
!! f_side.to_f2_trans[integer, 0, NOT]
F%ptc = z_ptc

end subroutine bookkeeping_state_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_ele_cache_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_int_ele_cache_struct to a C++ CPP_rad_int_ele_cache structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_int_ele_cache_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_int_ele_cache struct.
!-

subroutine rad_int_ele_cache_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_int_ele_cache_to_c2 (C, z_orb0, z_g2_0, z_g3_0, z_dg2_dorb, z_dg3_dorb, &
      z_stale) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_stale
    real(c_double) :: z_orb0(*), z_g2_0, z_g3_0, z_dg2_dorb(*), z_dg3_dorb(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_int_ele_cache_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call rad_int_ele_cache_to_c2 (C, fvec2vec(F%orb0, 6), F%g2_0, F%g3_0, fvec2vec(F%dg2_dorb, 6), &
    fvec2vec(F%dg3_dorb, 6), c_logic(F%stale))

end subroutine rad_int_ele_cache_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_ele_cache_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_int_ele_cache structure to a Bmad rad_int_ele_cache_struct structure.
! This routine is called by rad_int_ele_cache_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_int_ele_cache_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_int_ele_cache_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_int_ele_cache_to_f2 (Fp, z_orb0, z_g2_0, z_g3_0, z_dg2_dorb, z_dg3_dorb, &
    z_stale) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_int_ele_cache_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_stale
real(c_double) :: z_orb0(*), z_g2_0, z_g3_0, z_dg2_dorb(*), z_dg3_dorb(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%orb0 = z_orb0(1:6)
!! f_side.to_f2_trans[real, 0, NOT]
F%g2_0 = z_g2_0
!! f_side.to_f2_trans[real, 0, NOT]
F%g3_0 = z_g3_0
!! f_side.to_f2_trans[real, 1, NOT]
F%dg2_dorb = z_dg2_dorb(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%dg3_dorb = z_dg3_dorb(1:6)
!! f_side.to_f2_trans[logical, 0, NOT]
F%stale = f_logic(z_stale)

end subroutine rad_int_ele_cache_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_grid_pt_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad surface_grid_pt_struct to a C++ CPP_surface_grid_pt structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad surface_grid_pt_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_surface_grid_pt struct.
!-

subroutine surface_grid_pt_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine surface_grid_pt_to_c2 (C, z_x_pitch, z_y_pitch, z_x_pitch_rms, z_y_pitch_rms, &
      z_e_x, z_e_y, z_intensity_x, z_intensity_y, z_intensity, z_n_photon, z_energy_ave, &
      z_energy_rms) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_x_pitch, z_y_pitch, z_x_pitch_rms, z_y_pitch_rms, z_e_x(*), z_e_y(*), z_intensity_x
    real(c_double) :: z_intensity_y, z_intensity, z_energy_ave, z_energy_rms
    integer(c_int) :: z_n_photon
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(surface_grid_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call surface_grid_pt_to_c2 (C, F%x_pitch, F%y_pitch, F%x_pitch_rms, F%y_pitch_rms, &
    fvec2vec(F%e_x, 2), fvec2vec(F%e_y, 2), F%intensity_x, F%intensity_y, F%intensity, &
    F%n_photon, F%energy_ave, F%energy_rms)

end subroutine surface_grid_pt_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_grid_pt_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_surface_grid_pt structure to a Bmad surface_grid_pt_struct structure.
! This routine is called by surface_grid_pt_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the surface_grid_pt_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad surface_grid_pt_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine surface_grid_pt_to_f2 (Fp, z_x_pitch, z_y_pitch, z_x_pitch_rms, z_y_pitch_rms, &
    z_e_x, z_e_y, z_intensity_x, z_intensity_y, z_intensity, z_n_photon, z_energy_ave, &
    z_energy_rms) bind(c)


implicit none

type(c_ptr), value :: Fp
type(surface_grid_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_x_pitch, z_y_pitch, z_x_pitch_rms, z_y_pitch_rms, z_e_x(*), z_e_y(*), z_intensity_x
real(c_double) :: z_intensity_y, z_intensity, z_energy_ave, z_energy_rms
integer(c_int) :: z_n_photon

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%x_pitch = z_x_pitch
!! f_side.to_f2_trans[real, 0, NOT]
F%y_pitch = z_y_pitch
!! f_side.to_f2_trans[real, 0, NOT]
F%x_pitch_rms = z_x_pitch_rms
!! f_side.to_f2_trans[real, 0, NOT]
F%y_pitch_rms = z_y_pitch_rms
!! f_side.to_f2_trans[real, 1, NOT]
F%e_x = z_e_x(1:2)
!! f_side.to_f2_trans[real, 1, NOT]
F%e_y = z_e_y(1:2)
!! f_side.to_f2_trans[real, 0, NOT]
F%intensity_x = z_intensity_x
!! f_side.to_f2_trans[real, 0, NOT]
F%intensity_y = z_intensity_y
!! f_side.to_f2_trans[real, 0, NOT]
F%intensity = z_intensity
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_photon = z_n_photon
!! f_side.to_f2_trans[real, 0, NOT]
F%energy_ave = z_energy_ave
!! f_side.to_f2_trans[real, 0, NOT]
F%energy_rms = z_energy_rms

end subroutine surface_grid_pt_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_grid_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad surface_grid_struct to a C++ CPP_surface_grid structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad surface_grid_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_surface_grid struct.
!-

subroutine surface_grid_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine surface_grid_to_c2 (C, z_file, z_type, z_dr, z_r0, z_pt, n1_pt, n2_pt) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_pt, n2_pt
    real(c_double) :: z_dr(*), z_r0(*)
    type(c_ptr) :: z_pt(*)
    integer(c_int) :: z_type
    character(c_char) :: z_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(surface_grid_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_pt(:)
integer(c_int) :: n1_pt
integer(c_int) :: n2_pt

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 2, ALLOC]
if (allocated(F%pt)) then
  n1_pt = size(F%pt, 1); lb1 = lbound(F%pt, 1) - 1
  n2_pt = size(F%pt, 2); lb2 = lbound(F%pt, 2) - 1
  allocate (z_pt(n1_pt * n2_pt))
  do jd1 = 1, n1_pt; do jd2 = 1, n2_pt
    z_pt(n2_pt*(jd1-1) + jd2) = c_loc(F%pt(jd1+lb1, jd2+lb2))
  enddo;  enddo
else
  n1_pt = 0; n2_pt = 0
endif

!! f_side.to_c2_call
call surface_grid_to_c2 (C, trim(F%file) // c_null_char, F%type, fvec2vec(F%dr, 2), &
    fvec2vec(F%r0, 2), z_pt, n1_pt, n2_pt)

end subroutine surface_grid_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_grid_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_surface_grid structure to a Bmad surface_grid_struct structure.
! This routine is called by surface_grid_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the surface_grid_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad surface_grid_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine surface_grid_to_f2 (Fp, z_file, z_type, z_dr, z_r0, z_pt, n1_pt, n2_pt) bind(c)


implicit none

type(c_ptr), value :: Fp
type(surface_grid_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_pt, n2_pt
real(c_double) :: z_dr(*), z_r0(*)
type(c_ptr) :: z_pt(*)
integer(c_int) :: z_type
character(c_char) :: z_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type
!! f_side.to_f2_trans[real, 1, NOT]
F%dr = z_dr(1:2)
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:2)
!! f_side.to_f2_trans[type, 2, ALLOC]
if (n1_pt == 0) then
  if (allocated(F%pt)) deallocate(F%pt)
else
  if (allocated(F%pt)) then
    if (n1_pt == 0 .or. any(shape(F%pt) /= [n1_pt, n2_pt])) deallocate(F%pt)
    if (any(lbound(F%pt) /= 1)) deallocate(F%pt)
  endif
  if (.not. allocated(F%pt)) allocate(F%pt(1:n1_pt+1-1, 1:n2_pt+1-1))
  do jd1 = 1, n1_pt
  do jd2 = 1, n2_pt
    call surface_grid_pt_to_f (z_pt(n2_pt*(jd1-1) + jd2), c_loc(F%pt(jd1+1-1,jd2+1-1)))
  enddo
  enddo
endif


end subroutine surface_grid_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine segmented_surface_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad segmented_surface_struct to a C++ CPP_segmented_surface structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad segmented_surface_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_segmented_surface struct.
!-

subroutine segmented_surface_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine segmented_surface_to_c2 (C, z_ix, z_iy, z_x0, z_y0, z_z0, z_slope_x, z_slope_y) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_x0, z_y0, z_z0, z_slope_x, z_slope_y
    integer(c_int) :: z_ix, z_iy
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(segmented_surface_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call segmented_surface_to_c2 (C, F%ix, F%iy, F%x0, F%y0, F%z0, F%slope_x, F%slope_y)

end subroutine segmented_surface_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine segmented_surface_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_segmented_surface structure to a Bmad segmented_surface_struct structure.
! This routine is called by segmented_surface_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the segmented_surface_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad segmented_surface_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine segmented_surface_to_f2 (Fp, z_ix, z_iy, z_x0, z_y0, z_z0, z_slope_x, z_slope_y) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(segmented_surface_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_x0, z_y0, z_z0, z_slope_x, z_slope_y
integer(c_int) :: z_ix, z_iy

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%ix = z_ix
!! f_side.to_f2_trans[integer, 0, NOT]
F%iy = z_iy
!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0
!! f_side.to_f2_trans[real, 0, NOT]
F%z0 = z_z0
!! f_side.to_f2_trans[real, 0, NOT]
F%slope_x = z_slope_x
!! f_side.to_f2_trans[real, 0, NOT]
F%slope_y = z_slope_y

end subroutine segmented_surface_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine target_point_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad target_point_struct to a C++ CPP_target_point structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad target_point_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_target_point struct.
!-

subroutine target_point_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine target_point_to_c2 (C, z_r) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_r(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(target_point_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call target_point_to_c2 (C, fvec2vec(F%r, 3))

end subroutine target_point_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine target_point_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_target_point structure to a Bmad target_point_struct structure.
! This routine is called by target_point_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the target_point_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad target_point_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine target_point_to_f2 (Fp, z_r) bind(c)


implicit none

type(c_ptr), value :: Fp
type(target_point_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_r(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%r = z_r(1:3)

end subroutine target_point_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_surface_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_surface_struct to a C++ CPP_photon_surface structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_surface_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_surface struct.
!-

subroutine photon_surface_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_surface_to_c2 (C, z_grid, z_segment, z_curvature_xy, z_has_curvature) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_has_curvature
    type(c_ptr), value :: z_grid, z_segment
    real(c_double) :: z_curvature_xy(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_surface_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call photon_surface_to_c2 (C, c_loc(F%grid), c_loc(F%segment), mat2vec(F%curvature_xy, 7*7), &
    c_logic(F%has_curvature))

end subroutine photon_surface_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_surface_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_surface structure to a Bmad photon_surface_struct structure.
! This routine is called by photon_surface_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_surface_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_surface_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_surface_to_f2 (Fp, z_grid, z_segment, z_curvature_xy, z_has_curvature) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_surface_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_has_curvature
type(c_ptr), value :: z_grid, z_segment
real(c_double) :: z_curvature_xy(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 0, NOT]
call surface_grid_to_f(z_grid, c_loc(F%grid))
!! f_side.to_f2_trans[type, 0, NOT]
call segmented_surface_to_f(z_segment, c_loc(F%segment))
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_curvature_xy, F%curvature_xy)
!! f_side.to_f2_trans[logical, 0, NOT]
F%has_curvature = f_logic(z_has_curvature)

end subroutine photon_surface_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_target_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_target_struct to a C++ CPP_photon_target structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_target_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_target struct.
!-

subroutine photon_target_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_target_to_c2 (C, z_enabled, z_n_corner, z_corner, z_center) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_enabled
    type(c_ptr), value :: z_center
    type(c_ptr) :: z_corner(*)
    integer(c_int) :: z_n_corner
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_target_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr) :: z_corner(8)

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%corner,1); lb1 = lbound(F%corner,1) - 1
  z_corner(jd1) = c_loc(F%corner(jd1+lb1))
enddo

!! f_side.to_c2_call
call photon_target_to_c2 (C, c_logic(F%enabled), F%n_corner, z_corner, c_loc(F%center))

end subroutine photon_target_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_target_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_target structure to a Bmad photon_target_struct structure.
! This routine is called by photon_target_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_target_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_target_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_target_to_f2 (Fp, z_enabled, z_n_corner, z_corner, z_center) bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_target_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_enabled
type(c_ptr), value :: z_center
type(c_ptr) :: z_corner(*)
integer(c_int) :: z_n_corner

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[logical, 0, NOT]
F%enabled = f_logic(z_enabled)
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_corner = z_n_corner
!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%corner,1); lb1 = lbound(F%corner,1) - 1
  call target_point_to_f(z_corner(jd1), c_loc(F%corner(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 0, NOT]
call target_point_to_f(z_center, c_loc(F%center))

end subroutine photon_target_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_material_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_material_struct to a C++ CPP_photon_material structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_material_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_material struct.
!-

subroutine photon_material_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_material_to_c2 (C, z_f0_m1, z_f0_m2, z_f_0, z_f_h, z_f_hbar, z_f_hkl, &
      z_h_norm, z_l_ref) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_f0_m1, z_f0_m2, z_f_0, z_f_h, z_f_hbar, z_f_hkl
    real(c_double) :: z_h_norm(*), z_l_ref(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_material_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call photon_material_to_c2 (C, F%f0_m1, F%f0_m2, F%f_0, F%f_h, F%f_hbar, F%f_hkl, &
    fvec2vec(F%h_norm, 3), fvec2vec(F%l_ref, 3))

end subroutine photon_material_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_material_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_material structure to a Bmad photon_material_struct structure.
! This routine is called by photon_material_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_material_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_material_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_material_to_f2 (Fp, z_f0_m1, z_f0_m2, z_f_0, z_f_h, z_f_hbar, z_f_hkl, &
    z_h_norm, z_l_ref) bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_material_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_f0_m1, z_f0_m2, z_f_0, z_f_h, z_f_hbar, z_f_hkl
real(c_double) :: z_h_norm(*), z_l_ref(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 0, NOT]
F%f0_m1 = z_f0_m1
!! f_side.to_f2_trans[complex, 0, NOT]
F%f0_m2 = z_f0_m2
!! f_side.to_f2_trans[complex, 0, NOT]
F%f_0 = z_f_0
!! f_side.to_f2_trans[complex, 0, NOT]
F%f_h = z_f_h
!! f_side.to_f2_trans[complex, 0, NOT]
F%f_hbar = z_f_hbar
!! f_side.to_f2_trans[complex, 0, NOT]
F%f_hkl = z_f_hkl
!! f_side.to_f2_trans[real, 1, NOT]
F%h_norm = z_h_norm(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%l_ref = z_l_ref(1:3)

end subroutine photon_material_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_element_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_element_struct to a C++ CPP_photon_element structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_element_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_element struct.
!-

subroutine photon_element_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_element_to_c2 (C, z_surface, z_target, z_material) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_surface, z_target, z_material
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_element_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call photon_element_to_c2 (C, c_loc(F%surface), c_loc(F%target), c_loc(F%material))

end subroutine photon_element_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_element_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_element structure to a Bmad photon_element_struct structure.
! This routine is called by photon_element_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_element_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_element_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_element_to_f2 (Fp, z_surface, z_target, z_material) bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_element_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_surface, z_target, z_material

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 0, NOT]
call photon_surface_to_f(z_surface, c_loc(F%surface))
!! f_side.to_f2_trans[type, 0, NOT]
call photon_target_to_f(z_target, c_loc(F%target))
!! f_side.to_f2_trans[type, 0, NOT]
call photon_material_to_f(z_material, c_loc(F%material))

end subroutine photon_element_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_vertex_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wall3d_vertex_struct to a C++ CPP_wall3d_vertex structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wall3d_vertex_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wall3d_vertex struct.
!-

subroutine wall3d_vertex_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wall3d_vertex_to_c2 (C, z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0, &
      z_y0, z_type) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0
    real(c_double) :: z_y0
    integer(c_int) :: z_type
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wall3d_vertex_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wall3d_vertex_to_c2 (C, F%x, F%y, F%radius_x, F%radius_y, F%tilt, F%angle, F%x0, F%y0, &
    F%type)

end subroutine wall3d_vertex_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_vertex_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wall3d_vertex structure to a Bmad wall3d_vertex_struct structure.
! This routine is called by wall3d_vertex_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wall3d_vertex_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wall3d_vertex_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wall3d_vertex_to_f2 (Fp, z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0, &
    z_y0, z_type) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wall3d_vertex_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0
real(c_double) :: z_y0
integer(c_int) :: z_type

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%x = z_x
!! f_side.to_f2_trans[real, 0, NOT]
F%y = z_y
!! f_side.to_f2_trans[real, 0, NOT]
F%radius_x = z_radius_x
!! f_side.to_f2_trans[real, 0, NOT]
F%radius_y = z_radius_y
!! f_side.to_f2_trans[real, 0, NOT]
F%tilt = z_tilt
!! f_side.to_f2_trans[real, 0, NOT]
F%angle = z_angle
!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0
!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type

end subroutine wall3d_vertex_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_section_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wall3d_section_struct to a C++ CPP_wall3d_section structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wall3d_section_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wall3d_section struct.
!-

subroutine wall3d_section_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wall3d_section_to_c2 (C, z_name, z_material, z_v, n1_v, z_surface, n_surface, &
      z_type, z_n_vertex_input, z_ix_ele, z_ix_branch, z_patch_in_region, z_thickness, z_s, &
      z_x0, z_y0, z_x_safe, z_y_safe, z_dx0_ds, z_dy0_ds, z_x0_coef, z_y0_coef, z_dr_ds, &
      z_p1_coef, z_p2_coef) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_type, z_n_vertex_input, z_ix_ele, z_ix_branch, z_patch_in_region
    integer(c_int), value :: n1_v, n_surface
    character(c_char) :: z_name(*), z_material(*)
    real(c_double) :: z_thickness, z_s, z_x0, z_y0, z_x_safe, z_y_safe, z_dx0_ds
    real(c_double) :: z_dy0_ds, z_x0_coef(*), z_y0_coef(*), z_dr_ds, z_p1_coef(*), z_p2_coef(*)
    type(c_ptr), value :: z_surface
    type(c_ptr) :: z_v(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wall3d_section_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_v(:)
integer(c_int) :: n1_v
integer(c_int) :: n_surface

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_v = 0
if (allocated(F%v)) then
  n1_v = size(F%v); lb1 = lbound(F%v, 1) - 1
  allocate (z_v(n1_v))
  do jd1 = 1, n1_v
    z_v(jd1) = c_loc(F%v(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 0, PTR]
n_surface = 0
if (associated(F%surface)) n_surface = 1

!! f_side.to_c2_call
call wall3d_section_to_c2 (C, trim(F%name) // c_null_char, trim(F%material) // c_null_char, &
    z_v, n1_v, c_loc(F%surface), n_surface, F%type, F%n_vertex_input, F%ix_ele, F%ix_branch, &
    F%patch_in_region, F%thickness, F%s, F%x0, F%y0, F%x_safe, F%y_safe, F%dx0_ds, F%dy0_ds, &
    fvec2vec(F%x0_coef, 4), fvec2vec(F%y0_coef, 4), F%dr_ds, fvec2vec(F%p1_coef, 3), &
    fvec2vec(F%p2_coef, 3))

end subroutine wall3d_section_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_section_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wall3d_section structure to a Bmad wall3d_section_struct structure.
! This routine is called by wall3d_section_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wall3d_section_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wall3d_section_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wall3d_section_to_f2 (Fp, z_name, z_material, z_v, n1_v, z_surface, n_surface, &
    z_type, z_n_vertex_input, z_ix_ele, z_ix_branch, z_patch_in_region, z_thickness, z_s, z_x0, &
    z_y0, z_x_safe, z_y_safe, z_dx0_ds, z_dy0_ds, z_x0_coef, z_y0_coef, z_dr_ds, z_p1_coef, &
    z_p2_coef) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wall3d_section_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(photon_reflect_surface_struct), pointer :: f_surface
integer(c_int) :: z_type, z_n_vertex_input, z_ix_ele, z_ix_branch, z_patch_in_region
integer(c_int), value :: n1_v, n_surface
character(c_char) :: z_name(*), z_material(*)
real(c_double) :: z_thickness, z_s, z_x0, z_y0, z_x_safe, z_y_safe, z_dx0_ds
real(c_double) :: z_dy0_ds, z_x0_coef(*), z_y0_coef(*), z_dr_ds, z_p1_coef(*), z_p2_coef(*)
type(c_ptr), value :: z_surface
type(c_ptr) :: z_v(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_material, F%material)
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_v == 0) then
  if (allocated(F%v)) deallocate(F%v)
else
  if (allocated(F%v)) then
    if (n1_v == 0 .or. any(shape(F%v) /= [n1_v])) deallocate(F%v)
    if (any(lbound(F%v) /= 1)) deallocate(F%v)
  endif
  if (.not. allocated(F%v)) allocate(F%v(1:n1_v+1-1))
  do jd1 = 1, n1_v
    call wall3d_vertex_to_f (z_v(jd1), c_loc(F%v(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_surface == 0) then
  if (associated(F%surface)) deallocate(F%surface)
else
  if (.not. associated(F%surface)) allocate(F%surface)
  call photon_reflect_surface_to_f (z_surface, c_loc(F%surface))
endif

!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_vertex_input = z_n_vertex_input
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%patch_in_region = z_patch_in_region
!! f_side.to_f2_trans[real, 0, NOT]
F%thickness = z_thickness
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0
!! f_side.to_f2_trans[real, 0, NOT]
F%x_safe = z_x_safe
!! f_side.to_f2_trans[real, 0, NOT]
F%y_safe = z_y_safe
!! f_side.to_f2_trans[real, 0, NOT]
F%dx0_ds = z_dx0_ds
!! f_side.to_f2_trans[real, 0, NOT]
F%dy0_ds = z_dy0_ds
!! f_side.to_f2_trans[real, 1, NOT]
F%x0_coef = z_x0_coef(1:4)
!! f_side.to_f2_trans[real, 1, NOT]
F%y0_coef = z_y0_coef(1:4)
!! f_side.to_f2_trans[real, 0, NOT]
F%dr_ds = z_dr_ds
!! f_side.to_f2_trans[real, 1, NOT]
F%p1_coef = z_p1_coef(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%p2_coef = z_p2_coef(1:3)

end subroutine wall3d_section_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wall3d_struct to a C++ CPP_wall3d structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wall3d_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wall3d struct.
!-

subroutine wall3d_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wall3d_to_c2 (C, z_n_link, z_thickness, z_clear_material, z_opaque_material, &
      z_superimpose, z_ele_anchor_pt, z_section, n1_section) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_n_link, z_ele_anchor_pt
    integer(c_int), value :: n1_section
    logical(c_bool) :: z_superimpose
    character(c_char) :: z_clear_material(*), z_opaque_material(*)
    real(c_double) :: z_thickness
    type(c_ptr) :: z_section(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wall3d_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_section(:)
integer(c_int) :: n1_section

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_section = 0
if (allocated(F%section)) then
  n1_section = size(F%section); lb1 = lbound(F%section, 1) - 1
  allocate (z_section(n1_section))
  do jd1 = 1, n1_section
    z_section(jd1) = c_loc(F%section(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call wall3d_to_c2 (C, F%n_link, F%thickness, trim(F%clear_material) // c_null_char, &
    trim(F%opaque_material) // c_null_char, c_logic(F%superimpose), F%ele_anchor_pt, z_section, &
    n1_section)

end subroutine wall3d_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wall3d structure to a Bmad wall3d_struct structure.
! This routine is called by wall3d_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wall3d_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wall3d_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wall3d_to_f2 (Fp, z_n_link, z_thickness, z_clear_material, z_opaque_material, &
    z_superimpose, z_ele_anchor_pt, z_section, n1_section) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wall3d_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_n_link, z_ele_anchor_pt
integer(c_int), value :: n1_section
logical(c_bool) :: z_superimpose
character(c_char) :: z_clear_material(*), z_opaque_material(*)
real(c_double) :: z_thickness
type(c_ptr) :: z_section(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[real, 0, NOT]
F%thickness = z_thickness
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_clear_material, F%clear_material)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_opaque_material, F%opaque_material)
!! f_side.to_f2_trans[logical, 0, NOT]
F%superimpose = f_logic(z_superimpose)
!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_section == 0) then
  if (allocated(F%section)) deallocate(F%section)
else
  if (allocated(F%section)) then
    if (n1_section == 0 .or. any(shape(F%section) /= [n1_section])) deallocate(F%section)
    if (any(lbound(F%section) /= 1)) deallocate(F%section)
  endif
  if (.not. allocated(F%section)) allocate(F%section(1:n1_section+1-1))
  do jd1 = 1, n1_section
    call wall3d_section_to_f (z_section(jd1), c_loc(F%section(jd1+1-1)))
  enddo
endif


end subroutine wall3d_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad taylor_term_struct to a C++ CPP_taylor_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad taylor_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_taylor_term struct.
!-

subroutine taylor_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine taylor_term_to_c2 (C, z_coef, z_expn) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_coef
    integer(c_int) :: z_expn(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call taylor_term_to_c2 (C, F%coef, fvec2vec(F%expn, 6))

end subroutine taylor_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_taylor_term structure to a Bmad taylor_term_struct structure.
! This routine is called by taylor_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the taylor_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad taylor_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine taylor_term_to_f2 (Fp, z_coef, z_expn) bind(c)


implicit none

type(c_ptr), value :: Fp
type(taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_coef
integer(c_int) :: z_expn(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[integer, 1, NOT]
F%expn = z_expn(1:6)

end subroutine taylor_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad taylor_struct to a C++ CPP_taylor structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad taylor_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_taylor struct.
!-

subroutine taylor_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine taylor_to_c2 (C, z_ref, z_term, n1_term) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_term
    real(c_double) :: z_ref
    type(c_ptr) :: z_term(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, PTR]
 n1_term = 0
if (associated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call taylor_to_c2 (C, F%ref, z_term, n1_term)

end subroutine taylor_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_taylor structure to a Bmad taylor_struct structure.
! This routine is called by taylor_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the taylor_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad taylor_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine taylor_to_f2 (Fp, z_ref, z_term, n1_term) bind(c)


implicit none

type(c_ptr), value :: Fp
type(taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_term
real(c_double) :: z_ref
type(c_ptr) :: z_term(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%ref = z_ref
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_term == 0) then
  if (associated(F%term)) deallocate(F%term)
else
  if (associated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. associated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call taylor_term_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine taylor_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine control_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad control_struct to a C++ CPP_control structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad control_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_control struct.
!-

subroutine control_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine control_to_c2 (C, z_coef, z_ix_lord, z_ix_slave, z_ix_branch, z_ix_attrib) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_coef
    integer(c_int) :: z_ix_lord, z_ix_slave, z_ix_branch, z_ix_attrib
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(control_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call control_to_c2 (C, F%coef, F%ix_lord, F%ix_slave, F%ix_branch, F%ix_attrib)

end subroutine control_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine control_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_control structure to a Bmad control_struct structure.
! This routine is called by control_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the control_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad control_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine control_to_f2 (Fp, z_coef, z_ix_lord, z_ix_slave, z_ix_branch, z_ix_attrib) bind(c)


implicit none

type(c_ptr), value :: Fp
type(control_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_coef
integer(c_int) :: z_ix_lord, z_ix_slave, z_ix_branch, z_ix_attrib

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_lord = z_ix_lord
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_slave = z_ix_slave
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_attrib = z_ix_attrib

end subroutine control_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_param_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad lat_param_struct to a C++ CPP_lat_param structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad lat_param_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_lat_param struct.
!-

subroutine lat_param_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine lat_param_to_c2 (C, z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf, &
      z_t1_no_rf, z_particle, z_default_tracking_species, z_geometry, z_ixx, z_stable, &
      z_aperture_limit_on, z_backwards_time_tracking, z_bookkeeping_state) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_stable, z_aperture_limit_on, z_backwards_time_tracking
    type(c_ptr), value :: z_bookkeeping_state
    real(c_double) :: z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf(*), z_t1_no_rf(*)
    integer(c_int) :: z_particle, z_default_tracking_species, z_geometry, z_ixx
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(lat_param_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call lat_param_to_c2 (C, F%n_part, F%total_length, F%unstable_factor, mat2vec(F%t1_with_rf, &
    6*6), mat2vec(F%t1_no_rf, 6*6), F%particle, F%default_tracking_species, F%geometry, F%ixx, &
    c_logic(F%stable), c_logic(F%aperture_limit_on), c_logic(F%backwards_time_tracking), &
    c_loc(F%bookkeeping_state))

end subroutine lat_param_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_param_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_lat_param structure to a Bmad lat_param_struct structure.
! This routine is called by lat_param_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the lat_param_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad lat_param_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine lat_param_to_f2 (Fp, z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf, &
    z_t1_no_rf, z_particle, z_default_tracking_species, z_geometry, z_ixx, z_stable, &
    z_aperture_limit_on, z_backwards_time_tracking, z_bookkeeping_state) bind(c)


implicit none

type(c_ptr), value :: Fp
type(lat_param_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_stable, z_aperture_limit_on, z_backwards_time_tracking
type(c_ptr), value :: z_bookkeeping_state
real(c_double) :: z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf(*), z_t1_no_rf(*)
integer(c_int) :: z_particle, z_default_tracking_species, z_geometry, z_ixx

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%n_part = z_n_part
!! f_side.to_f2_trans[real, 0, NOT]
F%total_length = z_total_length
!! f_side.to_f2_trans[real, 0, NOT]
F%unstable_factor = z_unstable_factor
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_t1_with_rf, F%t1_with_rf)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_t1_no_rf, F%t1_no_rf)
!! f_side.to_f2_trans[integer, 0, NOT]
F%particle = z_particle
!! f_side.to_f2_trans[integer, 0, NOT]
F%default_tracking_species = z_default_tracking_species
!! f_side.to_f2_trans[integer, 0, NOT]
F%geometry = z_geometry
!! f_side.to_f2_trans[integer, 0, NOT]
F%ixx = z_ixx
!! f_side.to_f2_trans[logical, 0, NOT]
F%stable = f_logic(z_stable)
!! f_side.to_f2_trans[logical, 0, NOT]
F%aperture_limit_on = f_logic(z_aperture_limit_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%backwards_time_tracking = f_logic(z_backwards_time_tracking)
!! f_side.to_f2_trans[type, 0, NOT]
call bookkeeping_state_to_f(z_bookkeeping_state, c_loc(F%bookkeeping_state))

end subroutine lat_param_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode_info_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad mode_info_struct to a C++ CPP_mode_info structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad mode_info_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_mode_info struct.
!-

subroutine mode_info_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine mode_info_to_c2 (C, z_tune, z_emit, z_chrom, z_sigma, z_sigmap) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_tune, z_emit, z_chrom, z_sigma, z_sigmap
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(mode_info_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call mode_info_to_c2 (C, F%tune, F%emit, F%chrom, F%sigma, F%sigmap)

end subroutine mode_info_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode_info_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_mode_info structure to a Bmad mode_info_struct structure.
! This routine is called by mode_info_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the mode_info_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad mode_info_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine mode_info_to_f2 (Fp, z_tune, z_emit, z_chrom, z_sigma, z_sigmap) bind(c)


implicit none

type(c_ptr), value :: Fp
type(mode_info_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_tune, z_emit, z_chrom, z_sigma, z_sigmap

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%tune = z_tune
!! f_side.to_f2_trans[real, 0, NOT]
F%emit = z_emit
!! f_side.to_f2_trans[real, 0, NOT]
F%chrom = z_chrom
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma = z_sigma
!! f_side.to_f2_trans[real, 0, NOT]
F%sigmap = z_sigmap

end subroutine mode_info_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine pre_tracker_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad pre_tracker_struct to a C++ CPP_pre_tracker structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad pre_tracker_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_pre_tracker struct.
!-

subroutine pre_tracker_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine pre_tracker_to_c2 (C, z_who, z_ix_ele_start, z_ix_ele_end, z_input_file) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_who, z_ix_ele_start, z_ix_ele_end
    character(c_char) :: z_input_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(pre_tracker_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call pre_tracker_to_c2 (C, F%who, F%ix_ele_start, F%ix_ele_end, trim(F%input_file) // &
    c_null_char)

end subroutine pre_tracker_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine pre_tracker_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_pre_tracker structure to a Bmad pre_tracker_struct structure.
! This routine is called by pre_tracker_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the pre_tracker_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad pre_tracker_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine pre_tracker_to_f2 (Fp, z_who, z_ix_ele_start, z_ix_ele_end, z_input_file) bind(c)


implicit none

type(c_ptr), value :: Fp
type(pre_tracker_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_who, z_ix_ele_start, z_ix_ele_end
character(c_char) :: z_input_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%who = z_who
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele_start = z_ix_ele_start
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele_end = z_ix_ele_end
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_input_file, F%input_file)

end subroutine pre_tracker_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine anormal_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad anormal_mode_struct to a C++ CPP_anormal_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad anormal_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_anormal_mode struct.
!-

subroutine anormal_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine anormal_mode_to_c2 (C, z_emittance, z_synch_int, z_j_damp, z_alpha_damp, z_chrom, &
      z_tune) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_emittance, z_synch_int(*), z_j_damp, z_alpha_damp, z_chrom, z_tune
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(anormal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call anormal_mode_to_c2 (C, F%emittance, fvec2vec(F%synch_int, 3), F%j_damp, F%alpha_damp, &
    F%chrom, F%tune)

end subroutine anormal_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine anormal_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_anormal_mode structure to a Bmad anormal_mode_struct structure.
! This routine is called by anormal_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the anormal_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad anormal_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine anormal_mode_to_f2 (Fp, z_emittance, z_synch_int, z_j_damp, z_alpha_damp, z_chrom, &
    z_tune) bind(c)


implicit none

type(c_ptr), value :: Fp
type(anormal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_emittance, z_synch_int(*), z_j_damp, z_alpha_damp, z_chrom, z_tune

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%emittance = z_emittance
!! f_side.to_f2_trans[real, 1, NOT]
F%synch_int = z_synch_int(1:3)
!! f_side.to_f2_trans[real, 0, NOT]
F%j_damp = z_j_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%alpha_damp = z_alpha_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%chrom = z_chrom
!! f_side.to_f2_trans[real, 0, NOT]
F%tune = z_tune

end subroutine anormal_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine linac_normal_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad linac_normal_mode_struct to a C++ CPP_linac_normal_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad linac_normal_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_linac_normal_mode struct.
!-

subroutine linac_normal_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine linac_normal_mode_to_c2 (C, z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, &
      z_a_emittance_end, z_b_emittance_end) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, z_a_emittance_end, z_b_emittance_end
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(linac_normal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call linac_normal_mode_to_c2 (C, F%i2_e4, F%i3_e7, F%i5a_e6, F%i5b_e6, F%sig_e1, &
    F%a_emittance_end, F%b_emittance_end)

end subroutine linac_normal_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine linac_normal_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_linac_normal_mode structure to a Bmad linac_normal_mode_struct structure.
! This routine is called by linac_normal_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the linac_normal_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad linac_normal_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine linac_normal_mode_to_f2 (Fp, z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, &
    z_a_emittance_end, z_b_emittance_end) bind(c)


implicit none

type(c_ptr), value :: Fp
type(linac_normal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, z_a_emittance_end, z_b_emittance_end

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%i2_e4 = z_i2_e4
!! f_side.to_f2_trans[real, 0, NOT]
F%i3_e7 = z_i3_e7
!! f_side.to_f2_trans[real, 0, NOT]
F%i5a_e6 = z_i5a_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%i5b_e6 = z_i5b_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_e1 = z_sig_e1
!! f_side.to_f2_trans[real, 0, NOT]
F%a_emittance_end = z_a_emittance_end
!! f_side.to_f2_trans[real, 0, NOT]
F%b_emittance_end = z_b_emittance_end

end subroutine linac_normal_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine normal_modes_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad normal_modes_struct to a C++ CPP_normal_modes structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad normal_modes_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_normal_modes struct.
!-

subroutine normal_modes_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine normal_modes_to_c2 (C, z_synch_int, z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, &
      z_pz_aperture, z_a, z_b, z_z, z_lin) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_a, z_b, z_z, z_lin
    real(c_double) :: z_synch_int(*), z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, z_pz_aperture
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(normal_modes_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call normal_modes_to_c2 (C, fvec2vec(F%synch_int, 4), F%sige_e, F%sig_z, F%e_loss, &
    F%rf_voltage, F%pz_aperture, c_loc(F%a), c_loc(F%b), c_loc(F%z), c_loc(F%lin))

end subroutine normal_modes_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine normal_modes_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_normal_modes structure to a Bmad normal_modes_struct structure.
! This routine is called by normal_modes_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the normal_modes_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad normal_modes_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine normal_modes_to_f2 (Fp, z_synch_int, z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, &
    z_pz_aperture, z_a, z_b, z_z, z_lin) bind(c)


implicit none

type(c_ptr), value :: Fp
type(normal_modes_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_a, z_b, z_z, z_lin
real(c_double) :: z_synch_int(*), z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, z_pz_aperture

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%synch_int = z_synch_int(1:4)
!! f_side.to_f2_trans[real, 0, NOT]
F%sige_e = z_sige_e
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_z = z_sig_z
!! f_side.to_f2_trans[real, 0, NOT]
F%e_loss = z_e_loss
!! f_side.to_f2_trans[real, 0, NOT]
F%rf_voltage = z_rf_voltage
!! f_side.to_f2_trans[real, 0, NOT]
F%pz_aperture = z_pz_aperture
!! f_side.to_f2_trans[type, 0, NOT]
call anormal_mode_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call anormal_mode_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call anormal_mode_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 0, NOT]
call linac_normal_mode_to_f(z_lin, c_loc(F%lin))

end subroutine normal_modes_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_struct to a C++ CPP_em_field structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field struct.
!-

subroutine em_field_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_to_c2 (C, z_e, z_b, z_de, z_db) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_e(*), z_b(*), z_de(*), z_db(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call em_field_to_c2 (C, fvec2vec(F%e, 3), fvec2vec(F%b, 3), mat2vec(F%de, 3*3), mat2vec(F%db, &
    3*3))

end subroutine em_field_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field structure to a Bmad em_field_struct structure.
! This routine is called by em_field_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_to_f2 (Fp, z_e, z_b, z_de, z_db) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_e(*), z_b(*), z_de(*), z_db(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%e = z_e(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%b = z_b(1:3)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_de, F%de)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_db, F%db)

end subroutine em_field_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_map_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad track_map_struct to a C++ CPP_track_map structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad track_map_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_track_map struct.
!-

subroutine track_map_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine track_map_to_c2 (C, z_vec0, z_mat6) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_vec0(*), z_mat6(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(track_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call track_map_to_c2 (C, fvec2vec(F%vec0, 6), mat2vec(F%mat6, 6*6))

end subroutine track_map_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_map_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_track_map structure to a Bmad track_map_struct structure.
! This routine is called by track_map_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the track_map_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad track_map_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine track_map_to_f2 (Fp, z_vec0, z_mat6) bind(c)


implicit none

type(c_ptr), value :: Fp
type(track_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_vec0(*), z_mat6(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%vec0 = z_vec0(1:6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_mat6, F%mat6)

end subroutine track_map_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad track_struct to a C++ CPP_track structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad track_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_track struct.
!-

subroutine track_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine track_to_c2 (C, z_orb, n1_orb, z_field, n1_field, z_map, n1_map, z_ds_save, &
      z_n_pt, z_n_bad, z_n_ok) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_orb, n1_field, n1_map
    real(c_double) :: z_ds_save
    integer(c_int) :: z_n_pt, z_n_bad, z_n_ok
    type(c_ptr) :: z_orb(*), z_field(*), z_map(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(track_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_orb(:)
integer(c_int) :: n1_orb
type(c_ptr), allocatable :: z_field(:)
integer(c_int) :: n1_field
type(c_ptr), allocatable :: z_map(:)
integer(c_int) :: n1_map

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_orb = 0
if (allocated(F%orb)) then
  n1_orb = size(F%orb); lb1 = lbound(F%orb, 1) - 1
  allocate (z_orb(n1_orb))
  do jd1 = 1, n1_orb
    z_orb(jd1) = c_loc(F%orb(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_field = 0
if (allocated(F%field)) then
  n1_field = size(F%field); lb1 = lbound(F%field, 1) - 1
  allocate (z_field(n1_field))
  do jd1 = 1, n1_field
    z_field(jd1) = c_loc(F%field(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_map = 0
if (allocated(F%map)) then
  n1_map = size(F%map); lb1 = lbound(F%map, 1) - 1
  allocate (z_map(n1_map))
  do jd1 = 1, n1_map
    z_map(jd1) = c_loc(F%map(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call track_to_c2 (C, z_orb, n1_orb, z_field, n1_field, z_map, n1_map, F%ds_save, F%n_pt, &
    F%n_bad, F%n_ok)

end subroutine track_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_track structure to a Bmad track_struct structure.
! This routine is called by track_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the track_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad track_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine track_to_f2 (Fp, z_orb, n1_orb, z_field, n1_field, z_map, n1_map, z_ds_save, z_n_pt, &
    z_n_bad, z_n_ok) bind(c)


implicit none

type(c_ptr), value :: Fp
type(track_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_orb, n1_field, n1_map
real(c_double) :: z_ds_save
integer(c_int) :: z_n_pt, z_n_bad, z_n_ok
type(c_ptr) :: z_orb(*), z_field(*), z_map(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_orb == 0) then
  if (allocated(F%orb)) deallocate(F%orb)
else
  if (allocated(F%orb)) then
    if (n1_orb == 0 .or. any(shape(F%orb) /= [n1_orb])) deallocate(F%orb)
    if (any(lbound(F%orb) /= 1)) deallocate(F%orb)
  endif
  if (.not. allocated(F%orb)) allocate(F%orb(1:n1_orb+1-1))
  do jd1 = 1, n1_orb
    call coord_to_f (z_orb(jd1), c_loc(F%orb(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_field == 0) then
  if (allocated(F%field)) deallocate(F%field)
else
  if (allocated(F%field)) then
    if (n1_field == 0 .or. any(shape(F%field) /= [n1_field])) deallocate(F%field)
    if (any(lbound(F%field) /= 1)) deallocate(F%field)
  endif
  if (.not. allocated(F%field)) allocate(F%field(1:n1_field+1-1))
  do jd1 = 1, n1_field
    call em_field_to_f (z_field(jd1), c_loc(F%field(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_map == 0) then
  if (allocated(F%map)) deallocate(F%map)
else
  if (allocated(F%map)) then
    if (n1_map == 0 .or. any(shape(F%map) /= [n1_map])) deallocate(F%map)
    if (any(lbound(F%map) /= 1)) deallocate(F%map)
  endif
  if (.not. allocated(F%map)) allocate(F%map(1:n1_map+1-1))
  do jd1 = 1, n1_map
    call track_map_to_f (z_map(jd1), c_loc(F%map(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%ds_save = z_ds_save
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_pt = z_n_pt
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_bad = z_n_bad
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ok = z_n_ok

end subroutine track_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine synch_rad_common_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad synch_rad_common_struct to a C++ CPP_synch_rad_common structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad synch_rad_common_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_synch_rad_common struct.
!-

subroutine synch_rad_common_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine synch_rad_common_to_c2 (C, z_scale, z_i2, z_i3, z_i5a, z_i5b, z_i_calc_on) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_i_calc_on
    real(c_double) :: z_scale, z_i2, z_i3, z_i5a, z_i5b
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(synch_rad_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call synch_rad_common_to_c2 (C, F%scale, F%i2, F%i3, F%i5a, F%i5b, c_logic(F%i_calc_on))

end subroutine synch_rad_common_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine synch_rad_common_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_synch_rad_common structure to a Bmad synch_rad_common_struct structure.
! This routine is called by synch_rad_common_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the synch_rad_common_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad synch_rad_common_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine synch_rad_common_to_f2 (Fp, z_scale, z_i2, z_i3, z_i5a, z_i5b, z_i_calc_on) bind(c)


implicit none

type(c_ptr), value :: Fp
type(synch_rad_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_i_calc_on
real(c_double) :: z_scale, z_i2, z_i3, z_i5a, z_i5b

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%scale = z_scale
!! f_side.to_f2_trans[real, 0, NOT]
F%i2 = z_i2
!! f_side.to_f2_trans[real, 0, NOT]
F%i3 = z_i3
!! f_side.to_f2_trans[real, 0, NOT]
F%i5a = z_i5a
!! f_side.to_f2_trans[real, 0, NOT]
F%i5b = z_i5b
!! f_side.to_f2_trans[logical, 0, NOT]
F%i_calc_on = f_logic(z_i_calc_on)

end subroutine synch_rad_common_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine csr_parameter_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad csr_parameter_struct to a C++ CPP_csr_parameter structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad csr_parameter_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_csr_parameter struct.
!-

subroutine csr_parameter_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine csr_parameter_to_c2 (C, z_ds_track_step, z_beam_chamber_height, z_sigma_cutoff, &
      z_n_bin, z_particle_bin_span, z_n_shield_images, z_ix1_ele_csr, z_ix2_ele_csr, &
      z_lcsr_component_on, z_lsc_component_on, z_tsc_component_on, z_small_angle_approx, &
      z_print_taylor_warning) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_lcsr_component_on, z_lsc_component_on, z_tsc_component_on, z_small_angle_approx, z_print_taylor_warning
    real(c_double) :: z_ds_track_step, z_beam_chamber_height, z_sigma_cutoff
    integer(c_int) :: z_n_bin, z_particle_bin_span, z_n_shield_images, z_ix1_ele_csr, z_ix2_ele_csr
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(csr_parameter_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call csr_parameter_to_c2 (C, F%ds_track_step, F%beam_chamber_height, F%sigma_cutoff, F%n_bin, &
    F%particle_bin_span, F%n_shield_images, F%ix1_ele_csr, F%ix2_ele_csr, &
    c_logic(F%lcsr_component_on), c_logic(F%lsc_component_on), c_logic(F%tsc_component_on), &
    c_logic(F%small_angle_approx), c_logic(F%print_taylor_warning))

end subroutine csr_parameter_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine csr_parameter_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_csr_parameter structure to a Bmad csr_parameter_struct structure.
! This routine is called by csr_parameter_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the csr_parameter_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad csr_parameter_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine csr_parameter_to_f2 (Fp, z_ds_track_step, z_beam_chamber_height, z_sigma_cutoff, &
    z_n_bin, z_particle_bin_span, z_n_shield_images, z_ix1_ele_csr, z_ix2_ele_csr, &
    z_lcsr_component_on, z_lsc_component_on, z_tsc_component_on, z_small_angle_approx, &
    z_print_taylor_warning) bind(c)


implicit none

type(c_ptr), value :: Fp
type(csr_parameter_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_lcsr_component_on, z_lsc_component_on, z_tsc_component_on, z_small_angle_approx, z_print_taylor_warning
real(c_double) :: z_ds_track_step, z_beam_chamber_height, z_sigma_cutoff
integer(c_int) :: z_n_bin, z_particle_bin_span, z_n_shield_images, z_ix1_ele_csr, z_ix2_ele_csr

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%ds_track_step = z_ds_track_step
!! f_side.to_f2_trans[real, 0, NOT]
F%beam_chamber_height = z_beam_chamber_height
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma_cutoff = z_sigma_cutoff
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_bin = z_n_bin
!! f_side.to_f2_trans[integer, 0, NOT]
F%particle_bin_span = z_particle_bin_span
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_shield_images = z_n_shield_images
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix1_ele_csr = z_ix1_ele_csr
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix2_ele_csr = z_ix2_ele_csr
!! f_side.to_f2_trans[logical, 0, NOT]
F%lcsr_component_on = f_logic(z_lcsr_component_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%lsc_component_on = f_logic(z_lsc_component_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%tsc_component_on = f_logic(z_tsc_component_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%small_angle_approx = f_logic(z_small_angle_approx)
!! f_side.to_f2_trans[logical, 0, NOT]
F%print_taylor_warning = f_logic(z_print_taylor_warning)

end subroutine csr_parameter_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bmad_common_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bmad_common_struct to a C++ CPP_bmad_common structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bmad_common_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bmad_common struct.
!-

subroutine bmad_common_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bmad_common_to_c2 (C, z_max_aperture_limit, z_d_orb, z_default_ds_step, &
      z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, &
      z_rel_tol_adaptive_tracking, z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, &
      z_min_ds_adaptive_tracking, z_fatal_ds_adaptive_tracking, z_taylor_order, &
      z_default_integ_order, z_ptc_max_fringe_order, z_use_hard_edge_drifts, z_sr_wakes_on, &
      z_lr_wakes_on, z_mat6_track_symmetric, z_auto_bookkeeper, z_space_charge_on, &
      z_coherent_synch_rad_on, z_spin_tracking_on, z_radiation_damping_on, &
      z_radiation_fluctuations_on, z_conserve_taylor_maps, z_absolute_time_tracking_default, &
      z_auto_scale_field_phase_default, z_auto_scale_field_amp_default, z_debug) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_use_hard_edge_drifts, z_sr_wakes_on, z_lr_wakes_on, z_mat6_track_symmetric, z_auto_bookkeeper, z_space_charge_on, z_coherent_synch_rad_on
    logical(c_bool) :: z_spin_tracking_on, z_radiation_damping_on, z_radiation_fluctuations_on, z_conserve_taylor_maps, z_absolute_time_tracking_default, z_auto_scale_field_phase_default, z_auto_scale_field_amp_default
    logical(c_bool) :: z_debug
    real(c_double) :: z_max_aperture_limit, z_d_orb(*), z_default_ds_step, z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, z_rel_tol_adaptive_tracking
    real(c_double) :: z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, z_min_ds_adaptive_tracking, z_fatal_ds_adaptive_tracking
    integer(c_int) :: z_taylor_order, z_default_integ_order, z_ptc_max_fringe_order
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bmad_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bmad_common_to_c2 (C, F%max_aperture_limit, fvec2vec(F%d_orb, 6), F%default_ds_step, &
    F%significant_length, F%rel_tol_tracking, F%abs_tol_tracking, F%rel_tol_adaptive_tracking, &
    F%abs_tol_adaptive_tracking, F%init_ds_adaptive_tracking, F%min_ds_adaptive_tracking, &
    F%fatal_ds_adaptive_tracking, F%taylor_order, F%default_integ_order, &
    F%ptc_max_fringe_order, c_logic(F%use_hard_edge_drifts), c_logic(F%sr_wakes_on), &
    c_logic(F%lr_wakes_on), c_logic(F%mat6_track_symmetric), c_logic(F%auto_bookkeeper), &
    c_logic(F%space_charge_on), c_logic(F%coherent_synch_rad_on), c_logic(F%spin_tracking_on), &
    c_logic(F%radiation_damping_on), c_logic(F%radiation_fluctuations_on), &
    c_logic(F%conserve_taylor_maps), c_logic(F%absolute_time_tracking_default), &
    c_logic(F%auto_scale_field_phase_default), c_logic(F%auto_scale_field_amp_default), &
    c_logic(F%debug))

end subroutine bmad_common_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bmad_common_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bmad_common structure to a Bmad bmad_common_struct structure.
! This routine is called by bmad_common_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bmad_common_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bmad_common_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bmad_common_to_f2 (Fp, z_max_aperture_limit, z_d_orb, z_default_ds_step, &
    z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, z_rel_tol_adaptive_tracking, &
    z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, z_min_ds_adaptive_tracking, &
    z_fatal_ds_adaptive_tracking, z_taylor_order, z_default_integ_order, &
    z_ptc_max_fringe_order, z_use_hard_edge_drifts, z_sr_wakes_on, z_lr_wakes_on, &
    z_mat6_track_symmetric, z_auto_bookkeeper, z_space_charge_on, z_coherent_synch_rad_on, &
    z_spin_tracking_on, z_radiation_damping_on, z_radiation_fluctuations_on, &
    z_conserve_taylor_maps, z_absolute_time_tracking_default, z_auto_scale_field_phase_default, &
    z_auto_scale_field_amp_default, z_debug) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bmad_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_use_hard_edge_drifts, z_sr_wakes_on, z_lr_wakes_on, z_mat6_track_symmetric, z_auto_bookkeeper, z_space_charge_on, z_coherent_synch_rad_on
logical(c_bool) :: z_spin_tracking_on, z_radiation_damping_on, z_radiation_fluctuations_on, z_conserve_taylor_maps, z_absolute_time_tracking_default, z_auto_scale_field_phase_default, z_auto_scale_field_amp_default
logical(c_bool) :: z_debug
real(c_double) :: z_max_aperture_limit, z_d_orb(*), z_default_ds_step, z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, z_rel_tol_adaptive_tracking
real(c_double) :: z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, z_min_ds_adaptive_tracking, z_fatal_ds_adaptive_tracking
integer(c_int) :: z_taylor_order, z_default_integ_order, z_ptc_max_fringe_order

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%max_aperture_limit = z_max_aperture_limit
!! f_side.to_f2_trans[real, 1, NOT]
F%d_orb = z_d_orb(1:6)
!! f_side.to_f2_trans[real, 0, NOT]
F%default_ds_step = z_default_ds_step
!! f_side.to_f2_trans[real, 0, NOT]
F%significant_length = z_significant_length
!! f_side.to_f2_trans[real, 0, NOT]
F%rel_tol_tracking = z_rel_tol_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%abs_tol_tracking = z_abs_tol_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%rel_tol_adaptive_tracking = z_rel_tol_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%abs_tol_adaptive_tracking = z_abs_tol_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%init_ds_adaptive_tracking = z_init_ds_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%min_ds_adaptive_tracking = z_min_ds_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%fatal_ds_adaptive_tracking = z_fatal_ds_adaptive_tracking
!! f_side.to_f2_trans[integer, 0, NOT]
F%taylor_order = z_taylor_order
!! f_side.to_f2_trans[integer, 0, NOT]
F%default_integ_order = z_default_integ_order
!! f_side.to_f2_trans[integer, 0, NOT]
F%ptc_max_fringe_order = z_ptc_max_fringe_order
!! f_side.to_f2_trans[logical, 0, NOT]
F%use_hard_edge_drifts = f_logic(z_use_hard_edge_drifts)
!! f_side.to_f2_trans[logical, 0, NOT]
F%sr_wakes_on = f_logic(z_sr_wakes_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%lr_wakes_on = f_logic(z_lr_wakes_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%mat6_track_symmetric = f_logic(z_mat6_track_symmetric)
!! f_side.to_f2_trans[logical, 0, NOT]
F%auto_bookkeeper = f_logic(z_auto_bookkeeper)
!! f_side.to_f2_trans[logical, 0, NOT]
F%space_charge_on = f_logic(z_space_charge_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%coherent_synch_rad_on = f_logic(z_coherent_synch_rad_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%spin_tracking_on = f_logic(z_spin_tracking_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%radiation_damping_on = f_logic(z_radiation_damping_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%radiation_fluctuations_on = f_logic(z_radiation_fluctuations_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%conserve_taylor_maps = f_logic(z_conserve_taylor_maps)
!! f_side.to_f2_trans[logical, 0, NOT]
F%absolute_time_tracking_default = f_logic(z_absolute_time_tracking_default)
!! f_side.to_f2_trans[logical, 0, NOT]
F%auto_scale_field_phase_default = f_logic(z_auto_scale_field_phase_default)
!! f_side.to_f2_trans[logical, 0, NOT]
F%auto_scale_field_amp_default = f_logic(z_auto_scale_field_amp_default)
!! f_side.to_f2_trans[logical, 0, NOT]
F%debug = f_logic(z_debug)

end subroutine bmad_common_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int1_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_int1_struct to a C++ CPP_rad_int1 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_int1_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_int1 struct.
!-

subroutine rad_int1_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_int1_to_c2 (C, z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z, z_i5a, z_i5b, &
      z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6, z_lin_norm_emit_a, &
      z_lin_norm_emit_b, z_n_steps) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z
    real(c_double) :: z_i5a, z_i5b, z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6
    real(c_double) :: z_lin_norm_emit_a, z_lin_norm_emit_b, z_n_steps
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_int1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call rad_int1_to_c2 (C, F%i0, F%i1, F%i2, F%i3, F%i4a, F%i4b, F%i4z, F%i5a, F%i5b, F%i6b, &
    F%lin_i2_e4, F%lin_i3_e7, F%lin_i5a_e6, F%lin_i5b_e6, F%lin_norm_emit_a, F%lin_norm_emit_b, &
    F%n_steps)

end subroutine rad_int1_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int1_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_int1 structure to a Bmad rad_int1_struct structure.
! This routine is called by rad_int1_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_int1_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_int1_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_int1_to_f2 (Fp, z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z, z_i5a, z_i5b, &
    z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6, z_lin_norm_emit_a, &
    z_lin_norm_emit_b, z_n_steps) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_int1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z
real(c_double) :: z_i5a, z_i5b, z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6
real(c_double) :: z_lin_norm_emit_a, z_lin_norm_emit_b, z_n_steps

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%i0 = z_i0
!! f_side.to_f2_trans[real, 0, NOT]
F%i1 = z_i1
!! f_side.to_f2_trans[real, 0, NOT]
F%i2 = z_i2
!! f_side.to_f2_trans[real, 0, NOT]
F%i3 = z_i3
!! f_side.to_f2_trans[real, 0, NOT]
F%i4a = z_i4a
!! f_side.to_f2_trans[real, 0, NOT]
F%i4b = z_i4b
!! f_side.to_f2_trans[real, 0, NOT]
F%i4z = z_i4z
!! f_side.to_f2_trans[real, 0, NOT]
F%i5a = z_i5a
!! f_side.to_f2_trans[real, 0, NOT]
F%i5b = z_i5b
!! f_side.to_f2_trans[real, 0, NOT]
F%i6b = z_i6b
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i2_e4 = z_lin_i2_e4
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i3_e7 = z_lin_i3_e7
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i5a_e6 = z_lin_i5a_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i5b_e6 = z_lin_i5b_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_norm_emit_a = z_lin_norm_emit_a
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_norm_emit_b = z_lin_norm_emit_b
!! f_side.to_f2_trans[real, 0, NOT]
F%n_steps = z_n_steps

end subroutine rad_int1_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_all_ele_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_int_all_ele_struct to a C++ CPP_rad_int_all_ele structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_int_all_ele_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_int_all_ele struct.
!-

subroutine rad_int_all_ele_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_int_all_ele_to_c2 (C, z_ele, n1_ele) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_ele
    type(c_ptr) :: z_ele(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_int_all_ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_ele(:)
integer(c_int) :: n1_ele

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_ele = 0
if (allocated(F%ele)) then
  n1_ele = size(F%ele); lb1 = lbound(F%ele, 1) - 1
  allocate (z_ele(n1_ele))
  do jd1 = 1, n1_ele
    z_ele(jd1) = c_loc(F%ele(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call rad_int_all_ele_to_c2 (C, z_ele, n1_ele)

end subroutine rad_int_all_ele_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_all_ele_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_int_all_ele structure to a Bmad rad_int_all_ele_struct structure.
! This routine is called by rad_int_all_ele_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_int_all_ele_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_int_all_ele_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_int_all_ele_to_f2 (Fp, z_ele, n1_ele) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_int_all_ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_ele
type(c_ptr) :: z_ele(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_ele == 0) then
  if (allocated(F%ele)) deallocate(F%ele)
else
  if (allocated(F%ele)) then
    if (n1_ele == 0 .or. any(shape(F%ele) /= [n1_ele])) deallocate(F%ele)
    if (any(lbound(F%ele) /= 1)) deallocate(F%ele)
  endif
  if (.not. allocated(F%ele)) allocate(F%ele(1:n1_ele+1-1))
  do jd1 = 1, n1_ele
    call rad_int1_to_f (z_ele(jd1), c_loc(F%ele(jd1+1-1)))
  enddo
endif


end subroutine rad_int_all_ele_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ele_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad ele_struct to a C++ CPP_ele structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad ele_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_ele struct.
!-

subroutine ele_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine ele_to_c2 (C, z_name, z_type, z_alias, z_component_name, z_descrip, n_descrip, &
      z_a, z_b, z_z, z_x, z_y, z_bookkeeping_state, z_em_field, n_em_field, z_floor, z_mode3, &
      n_mode3, z_photon, n_photon, z_rad_int_cache, n_rad_int_cache, z_space_charge, &
      n_space_charge, z_taylor, z_wake, n_wake, z_wall3d, n_wall3d, z_wig, n_wig, &
      z_map_ref_orb_in, z_map_ref_orb_out, z_time_ref_orb_in, z_time_ref_orb_out, z_value, &
      z_old_value, z_gen0, z_vec0, z_mat6, z_c_mat, z_gamma_c, z_s, z_ref_time, z_r, n1_r, &
      n2_r, n3_r, z_a_pole, n1_a_pole, z_b_pole, n1_b_pole, z_key, z_sub_key, z_ix_ele, &
      z_ix_branch, z_ix_value, z_slave_status, z_n_slave, z_ix1_slave, z_ix2_slave, &
      z_lord_status, z_n_lord, z_ic1_lord, z_ic2_lord, z_ix_pointer, z_ixx, z_iyy, &
      z_mat6_calc_method, z_tracking_method, z_spin_tracking_method, z_ptc_integration_type, &
      z_field_calc, z_aperture_at, z_aperture_type, z_orientation, z_symplectify, z_mode_flip, &
      z_multipoles_on, z_scale_multipoles, z_taylor_map_includes_offsets, z_field_master, &
      z_is_on, z_old_is_on, z_logic, z_bmad_logic, z_csr_calc_on, z_offset_moves_aperture) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_key, z_sub_key, z_ix_ele, z_ix_branch, z_ix_value, z_slave_status, z_n_slave
    integer(c_int) :: z_ix1_slave, z_ix2_slave, z_lord_status, z_n_lord, z_ic1_lord, z_ic2_lord, z_ix_pointer
    integer(c_int) :: z_ixx, z_iyy, z_mat6_calc_method, z_tracking_method, z_spin_tracking_method, z_ptc_integration_type, z_field_calc
    integer(c_int) :: z_aperture_at, z_aperture_type, z_orientation
    integer(c_int), value :: n_descrip, n_em_field, n_mode3, n_photon, n_rad_int_cache, n_space_charge, n_wake
    integer(c_int), value :: n_wall3d, n_wig, n1_r, n2_r, n3_r, n1_a_pole, n1_b_pole
    logical(c_bool) :: z_symplectify, z_mode_flip, z_multipoles_on, z_scale_multipoles, z_taylor_map_includes_offsets, z_field_master, z_is_on
    logical(c_bool) :: z_old_is_on, z_logic, z_bmad_logic, z_csr_calc_on, z_offset_moves_aperture
    character(c_char) :: z_name(*), z_type(*), z_alias(*), z_component_name(*), z_descrip(*)
    real(c_double) :: z_value(*), z_old_value(*), z_gen0(*), z_vec0(*), z_mat6(*), z_c_mat(*), z_gamma_c
    real(c_double) :: z_s, z_ref_time, z_r(*), z_a_pole(*), z_b_pole(*)
    type(c_ptr), value :: z_a, z_b, z_z, z_x, z_y, z_bookkeeping_state, z_em_field
    type(c_ptr), value :: z_floor, z_mode3, z_photon, z_rad_int_cache, z_space_charge, z_wake, z_wall3d
    type(c_ptr), value :: z_wig, z_map_ref_orb_in, z_map_ref_orb_out, z_time_ref_orb_in, z_time_ref_orb_out
    type(c_ptr) :: z_taylor(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
character(200+1), target :: f_descrip
integer(c_int) :: n_descrip
integer(c_int) :: n_em_field
integer(c_int) :: n_mode3
integer(c_int) :: n_photon
integer(c_int) :: n_rad_int_cache
integer(c_int) :: n_space_charge
type(c_ptr) :: z_taylor(6)
integer(c_int) :: n_wake
integer(c_int) :: n_wall3d
integer(c_int) :: n_wig
integer(c_int) :: n1_r
integer(c_int) :: n2_r
integer(c_int) :: n3_r
integer(c_int) :: n1_a_pole
integer(c_int) :: n1_b_pole

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[character, 0, PTR]
n_descrip = 0
if (associated(F%descrip)) then
  n_descrip = 1
  f_descrip = trim(F%descrip) // c_null_char 
endif
!! f_side.to_c_trans[type, 0, PTR]
n_em_field = 0
if (associated(F%em_field)) n_em_field = 1
!! f_side.to_c_trans[type, 0, PTR]
n_mode3 = 0
if (associated(F%mode3)) n_mode3 = 1
!! f_side.to_c_trans[type, 0, PTR]
n_photon = 0
if (associated(F%photon)) n_photon = 1
!! f_side.to_c_trans[type, 0, PTR]
n_rad_int_cache = 0
if (associated(F%rad_int_cache)) n_rad_int_cache = 1
!! f_side.to_c_trans[type, 0, PTR]
n_space_charge = 0
if (associated(F%space_charge)) n_space_charge = 1
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%taylor,1); lb1 = lbound(F%taylor,1) - 1
  z_taylor(jd1) = c_loc(F%taylor(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 0, PTR]
n_wake = 0
if (associated(F%wake)) n_wake = 1
!! f_side.to_c_trans[type, 0, PTR]
n_wall3d = 0
if (associated(F%wall3d)) n_wall3d = 1
!! f_side.to_c_trans[type, 0, PTR]
n_wig = 0
if (associated(F%wig)) n_wig = 1
!! f_side.to_c_trans[real, 3, PTR]
if (associated(F%r)) then
  n1_r = size(F%r, 1)
  n2_r = size(F%r, 2)
  n3_r = size(F%r, 3)
else
  n1_r = 0; n2_r = 0; n3_r = 0
endif
!! f_side.to_c_trans[real, 1, PTR]
n1_a_pole = 0
if (associated(F%a_pole)) then
  n1_a_pole = size(F%a_pole, 1)
endif
!! f_side.to_c_trans[real, 1, PTR]
n1_b_pole = 0
if (associated(F%b_pole)) then
  n1_b_pole = size(F%b_pole, 1)
endif

!! f_side.to_c2_call
call ele_to_c2 (C, trim(F%name) // c_null_char, trim(F%type) // c_null_char, trim(F%alias) // &
    c_null_char, trim(F%component_name) // c_null_char, f_descrip, n_descrip, c_loc(F%a), &
    c_loc(F%b), c_loc(F%z), c_loc(F%x), c_loc(F%y), c_loc(F%bookkeeping_state), &
    c_loc(F%em_field), n_em_field, c_loc(F%floor), c_loc(F%mode3), n_mode3, c_loc(F%photon), &
    n_photon, c_loc(F%rad_int_cache), n_rad_int_cache, c_loc(F%space_charge), n_space_charge, &
    z_taylor, c_loc(F%wake), n_wake, c_loc(F%wall3d), n_wall3d, c_loc(F%wig), n_wig, &
    c_loc(F%map_ref_orb_in), c_loc(F%map_ref_orb_out), c_loc(F%time_ref_orb_in), &
    c_loc(F%time_ref_orb_out), fvec2vec(F%value, num_ele_attrib$), fvec2vec(F%old_value, &
    num_ele_attrib$), fvec2vec(F%gen0, 6), fvec2vec(F%vec0, 6), mat2vec(F%mat6, 6*6), &
    mat2vec(F%c_mat, 2*2), F%gamma_c, F%s, F%ref_time, tensor2vec(F%r, n1_r*n2_r*n3_r), n1_r, &
    n2_r, n3_r, fvec2vec(F%a_pole, n1_a_pole), n1_a_pole, fvec2vec(F%b_pole, n1_b_pole), &
    n1_b_pole, F%key, F%sub_key, F%ix_ele, F%ix_branch, F%ix_value, F%slave_status, F%n_slave, &
    F%ix1_slave, F%ix2_slave, F%lord_status, F%n_lord, F%ic1_lord, F%ic2_lord, F%ix_pointer, &
    F%ixx, F%iyy, F%mat6_calc_method, F%tracking_method, F%spin_tracking_method, &
    F%ptc_integration_type, F%field_calc, F%aperture_at, F%aperture_type, F%orientation, &
    c_logic(F%symplectify), c_logic(F%mode_flip), c_logic(F%multipoles_on), &
    c_logic(F%scale_multipoles), c_logic(F%taylor_map_includes_offsets), &
    c_logic(F%field_master), c_logic(F%is_on), c_logic(F%old_is_on), c_logic(F%logic), &
    c_logic(F%bmad_logic), c_logic(F%csr_calc_on), c_logic(F%offset_moves_aperture))

end subroutine ele_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ele_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_ele structure to a Bmad ele_struct structure.
! This routine is called by ele_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the ele_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad ele_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine ele_to_f2 (Fp, z_name, z_type, z_alias, z_component_name, z_descrip, n_descrip, z_a, &
    z_b, z_z, z_x, z_y, z_bookkeeping_state, z_em_field, n_em_field, z_floor, z_mode3, n_mode3, &
    z_photon, n_photon, z_rad_int_cache, n_rad_int_cache, z_space_charge, n_space_charge, &
    z_taylor, z_wake, n_wake, z_wall3d, n_wall3d, z_wig, n_wig, z_map_ref_orb_in, &
    z_map_ref_orb_out, z_time_ref_orb_in, z_time_ref_orb_out, z_value, z_old_value, z_gen0, &
    z_vec0, z_mat6, z_c_mat, z_gamma_c, z_s, z_ref_time, z_r, n1_r, n2_r, n3_r, z_a_pole, &
    n1_a_pole, z_b_pole, n1_b_pole, z_key, z_sub_key, z_ix_ele, z_ix_branch, z_ix_value, &
    z_slave_status, z_n_slave, z_ix1_slave, z_ix2_slave, z_lord_status, z_n_lord, z_ic1_lord, &
    z_ic2_lord, z_ix_pointer, z_ixx, z_iyy, z_mat6_calc_method, z_tracking_method, &
    z_spin_tracking_method, z_ptc_integration_type, z_field_calc, z_aperture_at, &
    z_aperture_type, z_orientation, z_symplectify, z_mode_flip, z_multipoles_on, &
    z_scale_multipoles, z_taylor_map_includes_offsets, z_field_master, z_is_on, z_old_is_on, &
    z_logic, z_bmad_logic, z_csr_calc_on, z_offset_moves_aperture) bind(c)


implicit none

type(c_ptr), value :: Fp
type(ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_symplectify, z_mode_flip, z_multipoles_on, z_scale_multipoles, z_taylor_map_includes_offsets, z_field_master, z_is_on
logical(c_bool) :: z_old_is_on, z_logic, z_bmad_logic, z_csr_calc_on, z_offset_moves_aperture
integer(c_int) :: z_key, z_sub_key, z_ix_ele, z_ix_branch, z_ix_value, z_slave_status, z_n_slave
integer(c_int) :: z_ix1_slave, z_ix2_slave, z_lord_status, z_n_lord, z_ic1_lord, z_ic2_lord, z_ix_pointer
integer(c_int) :: z_ixx, z_iyy, z_mat6_calc_method, z_tracking_method, z_spin_tracking_method, z_ptc_integration_type, z_field_calc
integer(c_int) :: z_aperture_at, z_aperture_type, z_orientation
type(mode3_struct), pointer :: f_mode3
type(rad_int_ele_cache_struct), pointer :: f_rad_int_cache
integer(c_int), value :: n_descrip, n_em_field, n_mode3, n_photon, n_rad_int_cache, n_space_charge, n_wake
integer(c_int), value :: n_wall3d, n_wig, n1_r, n2_r, n3_r, n1_a_pole, n1_b_pole
type(wig_struct), pointer :: f_wig
type(photon_element_struct), pointer :: f_photon
type(c_ptr), value :: z_a, z_b, z_z, z_x, z_y, z_bookkeeping_state, z_em_field
type(c_ptr), value :: z_floor, z_mode3, z_photon, z_rad_int_cache, z_space_charge, z_wake, z_wall3d
type(c_ptr), value :: z_wig, z_map_ref_orb_in, z_map_ref_orb_out, z_time_ref_orb_in, z_time_ref_orb_out, z_r, z_a_pole
type(c_ptr), value :: z_b_pole
real(c_double), pointer :: f_r(:), f_a_pole(:), f_b_pole(:)
type(wake_struct), pointer :: f_wake
character(c_char) :: z_name(*), z_type(*), z_alias(*), z_component_name(*), z_descrip(*)
integer(c_int), pointer :: f_descrip
type(space_charge_struct), pointer :: f_space_charge
real(c_double) :: z_value(*), z_old_value(*), z_gen0(*), z_vec0(*), z_mat6(*), z_c_mat(*), z_gamma_c
real(c_double) :: z_s, z_ref_time
type(em_fields_struct), pointer :: f_em_field
type(c_ptr) :: z_taylor(*)
type(wall3d_struct), pointer :: f_wall3d

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_type, F%type)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_alias, F%alias)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_component_name, F%component_name)
!! f_side.to_f2_trans[character, 0, PTR]
if (n_descrip == 0) then
  if (associated(F%descrip)) deallocate(F%descrip)
else
  if (.not. associated(F%descrip)) allocate(F%descrip)
  call to_f_str(z_descrip, F%descrip)
endif

!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 0, NOT]
call xy_disp_to_f(z_x, c_loc(F%x))
!! f_side.to_f2_trans[type, 0, NOT]
call xy_disp_to_f(z_y, c_loc(F%y))
!! f_side.to_f2_trans[type, 0, NOT]
call bookkeeping_state_to_f(z_bookkeeping_state, c_loc(F%bookkeeping_state))
!! f_side.to_f2_trans[type, 0, PTR]
if (n_em_field == 0) then
  if (associated(F%em_field)) deallocate(F%em_field)
else
  if (.not. associated(F%em_field)) allocate(F%em_field)
  call em_fields_to_f (z_em_field, c_loc(F%em_field))
endif

!! f_side.to_f2_trans[type, 0, NOT]
call floor_position_to_f(z_floor, c_loc(F%floor))
!! f_side.to_f2_trans[type, 0, PTR]
if (n_mode3 == 0) then
  if (associated(F%mode3)) deallocate(F%mode3)
else
  if (.not. associated(F%mode3)) allocate(F%mode3)
  call mode3_to_f (z_mode3, c_loc(F%mode3))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_photon == 0) then
  if (associated(F%photon)) deallocate(F%photon)
else
  if (.not. associated(F%photon)) allocate(F%photon)
  call photon_element_to_f (z_photon, c_loc(F%photon))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_rad_int_cache == 0) then
  if (associated(F%rad_int_cache)) deallocate(F%rad_int_cache)
else
  if (.not. associated(F%rad_int_cache)) allocate(F%rad_int_cache)
  call rad_int_ele_cache_to_f (z_rad_int_cache, c_loc(F%rad_int_cache))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_space_charge == 0) then
  if (associated(F%space_charge)) deallocate(F%space_charge)
else
  if (.not. associated(F%space_charge)) allocate(F%space_charge)
  call space_charge_to_f (z_space_charge, c_loc(F%space_charge))
endif

!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%taylor,1); lb1 = lbound(F%taylor,1) - 1
  call taylor_to_f(z_taylor(jd1), c_loc(F%taylor(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 0, PTR]
if (n_wake == 0) then
  if (associated(F%wake)) deallocate(F%wake)
else
  if (.not. associated(F%wake)) allocate(F%wake)
  call wake_to_f (z_wake, c_loc(F%wake))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_wall3d == 0) then
  if (associated(F%wall3d)) deallocate(F%wall3d)
else
  if (.not. associated(F%wall3d)) allocate(F%wall3d)
  call wall3d_to_f (z_wall3d, c_loc(F%wall3d))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_wig == 0) then
  if (associated(F%wig)) deallocate(F%wig)
else
  if (.not. associated(F%wig)) allocate(F%wig)
  call wig_to_f (z_wig, c_loc(F%wig))
endif

!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_map_ref_orb_in, c_loc(F%map_ref_orb_in))
!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_map_ref_orb_out, c_loc(F%map_ref_orb_out))
!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_time_ref_orb_in, c_loc(F%time_ref_orb_in))
!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_time_ref_orb_out, c_loc(F%time_ref_orb_out))
!! f_side.to_f2_trans[real, 1, NOT]
F%value = z_value(2:num_ele_attrib$+1)
!! f_side.to_f2_trans[real, 1, NOT]
F%old_value = z_old_value(2:num_ele_attrib$+1)
!! f_side.to_f2_trans[real, 1, NOT]
F%gen0 = z_gen0(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%vec0 = z_vec0(1:6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_mat6, F%mat6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_c_mat, F%c_mat)
!! f_side.to_f2_trans[real, 0, NOT]
F%gamma_c = z_gamma_c
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[real, 0, NOT]
F%ref_time = z_ref_time
!! f_side.to_f2_trans[real, 3, PTR]
if (associated(F%r)) then
  if (n1_r == 0 .or. any(shape(F%r) /= [n1_r, n2_r, n3_r])) deallocate(F%r)
  if (any(lbound(F%r) /= 1)) deallocate(F%r)
endif
if (n1_r /= 0) then
  call c_f_pointer (z_r, f_r, [n1_r*n2_r*n3_r])
  if (.not. associated(F%r)) allocate(F%r(n1_r, n2_r, n3_r))
  call vec2tensor(f_r, F%r)
else
  if (associated(F%r)) deallocate(F%r)
endif

!! f_side.to_f2_trans[real, 1, PTR]
if (associated(F%a_pole)) then
  if (n1_a_pole == 0 .or. any(shape(F%a_pole) /= [n1_a_pole])) deallocate(F%a_pole)
  if (any(lbound(F%a_pole) /= 1)) deallocate(F%a_pole)
endif
if (n1_a_pole /= 0) then
  call c_f_pointer (z_a_pole, f_a_pole, [n1_a_pole])
  if (.not. associated(F%a_pole)) allocate(F%a_pole(n1_a_pole))
  F%a_pole = f_a_pole(1:n1_a_pole)
else
  if (associated(F%a_pole)) deallocate(F%a_pole)
endif

!! f_side.to_f2_trans[real, 1, PTR]
if (associated(F%b_pole)) then
  if (n1_b_pole == 0 .or. any(shape(F%b_pole) /= [n1_b_pole])) deallocate(F%b_pole)
  if (any(lbound(F%b_pole) /= 1)) deallocate(F%b_pole)
endif
if (n1_b_pole /= 0) then
  call c_f_pointer (z_b_pole, f_b_pole, [n1_b_pole])
  if (.not. associated(F%b_pole)) allocate(F%b_pole(n1_b_pole))
  F%b_pole = f_b_pole(1:n1_b_pole)
else
  if (associated(F%b_pole)) deallocate(F%b_pole)
endif

!! f_side.to_f2_trans[integer, 0, NOT]
F%key = z_key
!! f_side.to_f2_trans[integer, 0, NOT]
F%sub_key = z_sub_key
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_value = z_ix_value
!! f_side.to_f2_trans[integer, 0, NOT]
F%slave_status = z_slave_status
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_slave = z_n_slave
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix1_slave = z_ix1_slave
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix2_slave = z_ix2_slave
!! f_side.to_f2_trans[integer, 0, NOT]
F%lord_status = z_lord_status
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_lord = z_n_lord
!! f_side.to_f2_trans[integer, 0, NOT]
F%ic1_lord = z_ic1_lord
!! f_side.to_f2_trans[integer, 0, NOT]
F%ic2_lord = z_ic2_lord
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_pointer = z_ix_pointer
!! f_side.to_f2_trans[integer, 0, NOT]
F%ixx = z_ixx
!! f_side.to_f2_trans[integer, 0, NOT]
F%iyy = z_iyy
!! f_side.to_f2_trans[integer, 0, NOT]
F%mat6_calc_method = z_mat6_calc_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%tracking_method = z_tracking_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%spin_tracking_method = z_spin_tracking_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%ptc_integration_type = z_ptc_integration_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%field_calc = z_field_calc
!! f_side.to_f2_trans[integer, 0, NOT]
F%aperture_at = z_aperture_at
!! f_side.to_f2_trans[integer, 0, NOT]
F%aperture_type = z_aperture_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%orientation = z_orientation
!! f_side.to_f2_trans[logical, 0, NOT]
F%symplectify = f_logic(z_symplectify)
!! f_side.to_f2_trans[logical, 0, NOT]
F%mode_flip = f_logic(z_mode_flip)
!! f_side.to_f2_trans[logical, 0, NOT]
F%multipoles_on = f_logic(z_multipoles_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%scale_multipoles = f_logic(z_scale_multipoles)
!! f_side.to_f2_trans[logical, 0, NOT]
F%taylor_map_includes_offsets = f_logic(z_taylor_map_includes_offsets)
!! f_side.to_f2_trans[logical, 0, NOT]
F%field_master = f_logic(z_field_master)
!! f_side.to_f2_trans[logical, 0, NOT]
F%is_on = f_logic(z_is_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%old_is_on = f_logic(z_old_is_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%logic = f_logic(z_logic)
!! f_side.to_f2_trans[logical, 0, NOT]
F%bmad_logic = f_logic(z_bmad_logic)
!! f_side.to_f2_trans[logical, 0, NOT]
F%csr_calc_on = f_logic(z_csr_calc_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%offset_moves_aperture = f_logic(z_offset_moves_aperture)

end subroutine ele_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine complex_taylor_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad complex_taylor_term_struct to a C++ CPP_complex_taylor_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad complex_taylor_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_complex_taylor_term struct.
!-

subroutine complex_taylor_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine complex_taylor_term_to_c2 (C, z_coef, z_expn) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_coef
    integer(c_int) :: z_expn(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(complex_taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call complex_taylor_term_to_c2 (C, F%coef, fvec2vec(F%expn, 6))

end subroutine complex_taylor_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine complex_taylor_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_complex_taylor_term structure to a Bmad complex_taylor_term_struct structure.
! This routine is called by complex_taylor_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the complex_taylor_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad complex_taylor_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine complex_taylor_term_to_f2 (Fp, z_coef, z_expn) bind(c)


implicit none

type(c_ptr), value :: Fp
type(complex_taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_coef
integer(c_int) :: z_expn(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[integer, 1, NOT]
F%expn = z_expn(1:6)

end subroutine complex_taylor_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine complex_taylor_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad complex_taylor_struct to a C++ CPP_complex_taylor structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad complex_taylor_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_complex_taylor struct.
!-

subroutine complex_taylor_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine complex_taylor_to_c2 (C, z_ref, z_term, n1_term) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_ref
    integer(c_int), value :: n1_term
    type(c_ptr) :: z_term(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(complex_taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, PTR]
 n1_term = 0
if (associated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call complex_taylor_to_c2 (C, F%ref, z_term, n1_term)

end subroutine complex_taylor_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine complex_taylor_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_complex_taylor structure to a Bmad complex_taylor_struct structure.
! This routine is called by complex_taylor_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the complex_taylor_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad complex_taylor_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine complex_taylor_to_f2 (Fp, z_ref, z_term, n1_term) bind(c)


implicit none

type(c_ptr), value :: Fp
type(complex_taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_ref
integer(c_int), value :: n1_term
type(c_ptr) :: z_term(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 0, NOT]
F%ref = z_ref
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_term == 0) then
  if (associated(F%term)) deallocate(F%term)
else
  if (associated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. associated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call complex_taylor_term_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine complex_taylor_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine normal_form_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad normal_form_struct to a C++ CPP_normal_form structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad normal_form_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_normal_form struct.
!-

subroutine normal_form_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine normal_form_to_c2 (C, z_m, z_a, z_a_inv, z_dhdj, z_f, z_l, z_ele_origin, &
      n_ele_origin) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_ele_origin
    integer(c_int), value :: n_ele_origin
    type(c_ptr) :: z_m(*), z_a(*), z_a_inv(*), z_dhdj(*), z_f(*), z_l(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(normal_form_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr) :: z_m(6)
type(c_ptr) :: z_a(6)
type(c_ptr) :: z_a_inv(6)
type(c_ptr) :: z_dhdj(6)
type(c_ptr) :: z_f(6)
type(c_ptr) :: z_l(6)
integer(c_int) :: n_ele_origin

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%m,1); lb1 = lbound(F%m,1) - 1
  z_m(jd1) = c_loc(F%m(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%a,1); lb1 = lbound(F%a,1) - 1
  z_a(jd1) = c_loc(F%a(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%a_inv,1); lb1 = lbound(F%a_inv,1) - 1
  z_a_inv(jd1) = c_loc(F%a_inv(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%dhdj,1); lb1 = lbound(F%dhdj,1) - 1
  z_dhdj(jd1) = c_loc(F%dhdj(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%f,1); lb1 = lbound(F%f,1) - 1
  z_f(jd1) = c_loc(F%f(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%l,1); lb1 = lbound(F%l,1) - 1
  z_l(jd1) = c_loc(F%l(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 0, PTR]
n_ele_origin = 0
if (associated(F%ele_origin)) n_ele_origin = 1

!! f_side.to_c2_call
call normal_form_to_c2 (C, z_m, z_a, z_a_inv, z_dhdj, z_f, z_l, c_loc(F%ele_origin), &
    n_ele_origin)

end subroutine normal_form_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine normal_form_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_normal_form structure to a Bmad normal_form_struct structure.
! This routine is called by normal_form_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the normal_form_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad normal_form_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine normal_form_to_f2 (Fp, z_m, z_a, z_a_inv, z_dhdj, z_f, z_l, z_ele_origin, &
    n_ele_origin) bind(c)


implicit none

type(c_ptr), value :: Fp
type(normal_form_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(ele_struct), pointer :: f_ele_origin
type(c_ptr), value :: z_ele_origin
integer(c_int), value :: n_ele_origin
type(c_ptr) :: z_m(*), z_a(*), z_a_inv(*), z_dhdj(*), z_f(*), z_l(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%m,1); lb1 = lbound(F%m,1) - 1
  call taylor_to_f(z_m(jd1), c_loc(F%m(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%a,1); lb1 = lbound(F%a,1) - 1
  call taylor_to_f(z_a(jd1), c_loc(F%a(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%a_inv,1); lb1 = lbound(F%a_inv,1) - 1
  call taylor_to_f(z_a_inv(jd1), c_loc(F%a_inv(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%dhdj,1); lb1 = lbound(F%dhdj,1) - 1
  call taylor_to_f(z_dhdj(jd1), c_loc(F%dhdj(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%f,1); lb1 = lbound(F%f,1) - 1
  call complex_taylor_to_f(z_f(jd1), c_loc(F%f(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%l,1); lb1 = lbound(F%l,1) - 1
  call complex_taylor_to_f(z_l(jd1), c_loc(F%l(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 0, PTR]
if (n_ele_origin == 0) then
  if (associated(F%ele_origin)) deallocate(F%ele_origin)
else
  if (.not. associated(F%ele_origin)) allocate(F%ele_origin)
  call ele_to_f (z_ele_origin, c_loc(F%ele_origin))
endif


end subroutine normal_form_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine branch_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad branch_struct to a C++ CPP_branch structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad branch_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_branch struct.
!-

subroutine branch_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine branch_to_c2 (C, z_name, z_ix_branch, z_ix_from_branch, z_ix_from_ele, &
      z_n_ele_track, n_n_ele_track, z_n_ele_max, n_n_ele_max, z_a, n_a, z_b, n_b, z_z, n_z, &
      z_ele, n1_ele, z_param, n_param, z_wall3d, n_wall3d, z_normal_form_with_rf, &
      z_normal_form_no_rf) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_ele(*)
    integer(c_int), value :: n_n_ele_track, n_n_ele_max, n_a, n_b, n_z, n1_ele, n_param
    integer(c_int), value :: n_wall3d
    type(c_ptr), value :: z_a, z_b, z_z, z_param, z_wall3d, z_normal_form_with_rf, z_normal_form_no_rf
    integer(c_int) :: z_ix_branch, z_ix_from_branch, z_ix_from_ele, z_n_ele_track, z_n_ele_max
    character(c_char) :: z_name(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(branch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n_n_ele_track
integer(c_int) :: n_n_ele_max
integer(c_int) :: n_a
integer(c_int) :: n_b
integer(c_int) :: n_z
type(c_ptr), allocatable :: z_ele(:)
integer(c_int) :: n1_ele
integer(c_int) :: n_param
integer(c_int) :: n_wall3d

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[integer, 0, PTR]
n_n_ele_track = 0
if (associated(F%n_ele_track)) n_n_ele_track = 1
!! f_side.to_c_trans[integer, 0, PTR]
n_n_ele_max = 0
if (associated(F%n_ele_max)) n_n_ele_max = 1
!! f_side.to_c_trans[type, 0, PTR]
n_a = 0
if (associated(F%a)) n_a = 1
!! f_side.to_c_trans[type, 0, PTR]
n_b = 0
if (associated(F%b)) n_b = 1
!! f_side.to_c_trans[type, 0, PTR]
n_z = 0
if (associated(F%z)) n_z = 1
!! f_side.to_c_trans[type, 1, PTR]
 n1_ele = 0
if (associated(F%ele)) then
  n1_ele = size(F%ele); lb1 = lbound(F%ele, 1) - 1
  allocate (z_ele(n1_ele))
  do jd1 = 1, n1_ele
    z_ele(jd1) = c_loc(F%ele(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 0, PTR]
n_param = 0
if (associated(F%param)) n_param = 1
!! f_side.to_c_trans[type, 0, PTR]
n_wall3d = 0
if (associated(F%wall3d)) n_wall3d = 1

!! f_side.to_c2_call
call branch_to_c2 (C, trim(F%name) // c_null_char, F%ix_branch, F%ix_from_branch, &
    F%ix_from_ele, F%n_ele_track, n_n_ele_track, F%n_ele_max, n_n_ele_max, c_loc(F%a), n_a, &
    c_loc(F%b), n_b, c_loc(F%z), n_z, z_ele, n1_ele, c_loc(F%param), n_param, c_loc(F%wall3d), &
    n_wall3d, c_loc(F%normal_form_with_rf), c_loc(F%normal_form_no_rf))

end subroutine branch_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine branch_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_branch structure to a Bmad branch_struct structure.
! This routine is called by branch_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the branch_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad branch_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine branch_to_f2 (Fp, z_name, z_ix_branch, z_ix_from_branch, z_ix_from_ele, &
    z_n_ele_track, n_n_ele_track, z_n_ele_max, n_n_ele_max, z_a, n_a, z_b, n_b, z_z, n_z, &
    z_ele, n1_ele, z_param, n_param, z_wall3d, n_wall3d, z_normal_form_with_rf, &
    z_normal_form_no_rf) bind(c)


implicit none

type(c_ptr), value :: Fp
type(branch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_ix_branch, z_ix_from_branch, z_ix_from_ele
type(c_ptr), value :: z_n_ele_track, z_n_ele_max, z_a, z_b, z_z, z_param, z_wall3d
type(c_ptr), value :: z_normal_form_with_rf, z_normal_form_no_rf
type(lat_param_struct), pointer :: f_param
character(c_char) :: z_name(*)
integer(c_int), pointer :: f_n_ele_track, f_n_ele_max
type(mode_info_struct), pointer :: f_a, f_b, f_z
integer(c_int), value :: n_n_ele_track, n_n_ele_max, n_a, n_b, n_z, n1_ele, n_param
integer(c_int), value :: n_wall3d
type(c_ptr) :: z_ele(*)
type(wall3d_struct), pointer :: f_wall3d

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_from_branch = z_ix_from_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_from_ele = z_ix_from_ele
!! f_side.to_f2_trans[integer, 0, PTR]
if (n_n_ele_track == 0) then                                                                                  
  if (associated(F%n_ele_track)) deallocate(F%n_ele_track)                                                           
else                                                                                                   
  call c_f_pointer (z_n_ele_track, f_n_ele_track)                                                                    
  if (.not. associated(F%n_ele_track)) allocate(F%n_ele_track)                                                       
  F%n_ele_track = f_n_ele_track
endif                                                                                                  

!! f_side.to_f2_trans[integer, 0, PTR]
if (n_n_ele_max == 0) then                                                                                  
  if (associated(F%n_ele_max)) deallocate(F%n_ele_max)                                                           
else                                                                                                   
  call c_f_pointer (z_n_ele_max, f_n_ele_max)                                                                    
  if (.not. associated(F%n_ele_max)) allocate(F%n_ele_max)                                                       
  F%n_ele_max = f_n_ele_max
endif                                                                                                  

!! f_side.to_f2_trans[type, 0, PTR]
if (n_a == 0) then
  if (associated(F%a)) deallocate(F%a)
else
  if (.not. associated(F%a)) allocate(F%a)
  call mode_info_to_f (z_a, c_loc(F%a))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_b == 0) then
  if (associated(F%b)) deallocate(F%b)
else
  if (.not. associated(F%b)) allocate(F%b)
  call mode_info_to_f (z_b, c_loc(F%b))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_z == 0) then
  if (associated(F%z)) deallocate(F%z)
else
  if (.not. associated(F%z)) allocate(F%z)
  call mode_info_to_f (z_z, c_loc(F%z))
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_ele == 0) then
  if (associated(F%ele)) deallocate(F%ele)
else
  if (associated(F%ele)) then
    if (n1_ele == 0 .or. any(shape(F%ele) /= [n1_ele])) deallocate(F%ele)
    if (any(lbound(F%ele) /= 0)) deallocate(F%ele)
  endif
  if (.not. associated(F%ele)) allocate(F%ele(0:n1_ele+0-1))
  do jd1 = 1, n1_ele
    call ele_to_f (z_ele(jd1), c_loc(F%ele(jd1+0-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_param == 0) then
  if (associated(F%param)) deallocate(F%param)
else
  if (.not. associated(F%param)) allocate(F%param)
  call lat_param_to_f (z_param, c_loc(F%param))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_wall3d == 0) then
  if (associated(F%wall3d)) deallocate(F%wall3d)
else
  if (.not. associated(F%wall3d)) allocate(F%wall3d)
  call wall3d_to_f (z_wall3d, c_loc(F%wall3d))
endif

!! f_side.to_f2_trans[type, 0, NOT]
call normal_form_to_f(z_normal_form_with_rf, c_loc(F%normal_form_with_rf))
!! f_side.to_f2_trans[type, 0, NOT]
call normal_form_to_f(z_normal_form_no_rf, c_loc(F%normal_form_no_rf))

end subroutine branch_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad lat_struct to a C++ CPP_lat structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad lat_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_lat struct.
!-

subroutine lat_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine lat_to_c2 (C, z_use_name, z_lattice, z_input_file_name, z_title, &
      z_attribute_alias, n1_attribute_alias, z_a, z_b, z_z, z_param, z_lord_state, z_ele_init, &
      z_ele, n1_ele, z_branch, n1_branch, z_control, n1_control, z_surface, n1_surface, &
      z_beam_start, z_pre_tracker, z_version, z_n_ele_track, z_n_ele_max, z_n_control_max, &
      z_n_ic_max, z_input_taylor_order, z_ic, n1_ic, z_photon_type, z_absolute_time_tracking, &
      z_auto_scale_field_phase, z_auto_scale_field_amp, z_ptc_uses_hard_edge_drifts) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_version, z_n_ele_track, z_n_ele_max, z_n_control_max, z_n_ic_max, z_input_taylor_order, z_ic(*)
    integer(c_int) :: z_photon_type
    integer(c_int), value :: n1_attribute_alias, n1_ele, n1_branch, n1_control, n1_surface, n1_ic
    logical(c_bool) :: z_absolute_time_tracking, z_auto_scale_field_phase, z_auto_scale_field_amp, z_ptc_uses_hard_edge_drifts
    character(c_char) :: z_use_name(*), z_lattice(*), z_input_file_name(*), z_title(*)
    type(c_ptr), value :: z_a, z_b, z_z, z_param, z_lord_state, z_ele_init, z_beam_start
    type(c_ptr), value :: z_pre_tracker
    type(c_ptr) :: z_attribute_alias(*), z_ele(*), z_branch(*), z_control(*), z_surface(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(lat_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_attribute_alias(:)
character(60+1), allocatable, target :: a_attribute_alias(:)
integer(c_int) :: n1_attribute_alias
type(c_ptr), allocatable :: z_ele(:)
integer(c_int) :: n1_ele
type(c_ptr), allocatable :: z_branch(:)
integer(c_int) :: n1_branch
type(c_ptr), allocatable :: z_control(:)
integer(c_int) :: n1_control
type(c_ptr), allocatable :: z_surface(:)
integer(c_int) :: n1_surface
integer(c_int) :: n1_ic

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[character, 1, ALLOC]
n1_attribute_alias = 0
if (allocated(F%attribute_alias)) then
  n1_attribute_alias = size(F%attribute_alias); lb1 = lbound(F%attribute_alias, 1) - 1
  allocate (a_attribute_alias(n1_attribute_alias))
  allocate (z_attribute_alias(n1_attribute_alias))
  do jd1 = 1, n1_attribute_alias
    a_attribute_alias(jd1) = trim(F%attribute_alias(jd1+lb1)) // c_null_char
    z_attribute_alias(jd1) = c_loc(a_attribute_alias(jd1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_ele = 0
if (associated(F%ele)) then
  n1_ele = size(F%ele); lb1 = lbound(F%ele, 1) - 1
  allocate (z_ele(n1_ele))
  do jd1 = 1, n1_ele
    z_ele(jd1) = c_loc(F%ele(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_branch = 0
if (allocated(F%branch)) then
  n1_branch = size(F%branch); lb1 = lbound(F%branch, 1) - 1
  allocate (z_branch(n1_branch))
  do jd1 = 1, n1_branch
    z_branch(jd1) = c_loc(F%branch(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_control = 0
if (allocated(F%control)) then
  n1_control = size(F%control); lb1 = lbound(F%control, 1) - 1
  allocate (z_control(n1_control))
  do jd1 = 1, n1_control
    z_control(jd1) = c_loc(F%control(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_surface = 0
if (associated(F%surface)) then
  n1_surface = size(F%surface); lb1 = lbound(F%surface, 1) - 1
  allocate (z_surface(n1_surface))
  do jd1 = 1, n1_surface
    z_surface(jd1) = c_loc(F%surface(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[integer, 1, ALLOC]
n1_ic = 0
if (allocated(F%ic)) then
  n1_ic = size(F%ic, 1)
endif

!! f_side.to_c2_call
call lat_to_c2 (C, trim(F%use_name) // c_null_char, trim(F%lattice) // c_null_char, &
    trim(F%input_file_name) // c_null_char, trim(F%title) // c_null_char, z_attribute_alias, &
    n1_attribute_alias, c_loc(F%a), c_loc(F%b), c_loc(F%z), c_loc(F%param), &
    c_loc(F%lord_state), c_loc(F%ele_init), z_ele, n1_ele, z_branch, n1_branch, z_control, &
    n1_control, z_surface, n1_surface, c_loc(F%beam_start), c_loc(F%pre_tracker), F%version, &
    F%n_ele_track, F%n_ele_max, F%n_control_max, F%n_ic_max, F%input_taylor_order, &
    fvec2vec(F%ic, n1_ic), n1_ic, F%photon_type, c_logic(F%absolute_time_tracking), &
    c_logic(F%auto_scale_field_phase), c_logic(F%auto_scale_field_amp), &
    c_logic(F%ptc_uses_hard_edge_drifts))

end subroutine lat_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_lat structure to a Bmad lat_struct structure.
! This routine is called by lat_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the lat_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad lat_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine lat_to_f2 (Fp, z_use_name, z_lattice, z_input_file_name, z_title, z_attribute_alias, &
    n1_attribute_alias, z_a, z_b, z_z, z_param, z_lord_state, z_ele_init, z_ele, n1_ele, &
    z_branch, n1_branch, z_control, n1_control, z_surface, n1_surface, z_beam_start, &
    z_pre_tracker, z_version, z_n_ele_track, z_n_ele_max, z_n_control_max, z_n_ic_max, &
    z_input_taylor_order, z_ic, n1_ic, z_photon_type, z_absolute_time_tracking, &
    z_auto_scale_field_phase, z_auto_scale_field_amp, z_ptc_uses_hard_edge_drifts) bind(c)


implicit none

type(c_ptr), value :: Fp
type(lat_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_version, z_n_ele_track, z_n_ele_max, z_n_control_max, z_n_ic_max, z_input_taylor_order, z_photon_type
integer(c_int), value :: n1_attribute_alias, n1_ele, n1_branch, n1_control, n1_surface, n1_ic
character(c_char) :: z_use_name(*), z_lattice(*), z_input_file_name(*), z_title(*)
logical(c_bool) :: z_absolute_time_tracking, z_auto_scale_field_phase, z_auto_scale_field_amp, z_ptc_uses_hard_edge_drifts
character(c_char), pointer :: f_attribute_alias
integer(c_int), pointer :: f_ic(:)
type(c_ptr), value :: z_a, z_b, z_z, z_param, z_lord_state, z_ele_init, z_beam_start
type(c_ptr), value :: z_pre_tracker, z_ic
type(c_ptr) :: z_attribute_alias(*), z_ele(*), z_branch(*), z_control(*), z_surface(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_use_name, F%use_name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_lattice, F%lattice)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_input_file_name, F%input_file_name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_title, F%title)
!! f_side.to_f2_trans[character, 1, ALLOC]
if (n1_attribute_alias == 0) then
  if (allocated(F%attribute_alias)) deallocate(F%attribute_alias)
else
  if (allocated(F%attribute_alias)) then
    if (n1_attribute_alias == 0 .or. any(shape(F%attribute_alias) /= [n1_attribute_alias])) deallocate(F%attribute_alias)
    if (any(lbound(F%attribute_alias) /= 1)) deallocate(F%attribute_alias)
  endif
  if (.not. allocated(F%attribute_alias)) allocate(F%attribute_alias(1:n1_attribute_alias+1-1))
  do jd1 = 1, n1_attribute_alias
    call c_f_pointer (z_attribute_alias(jd1), f_attribute_alias)
    call to_f_str(f_attribute_alias, F%attribute_alias(jd1+1-1))
  enddo
endif

!! f_side.to_f2_trans[type, 0, NOT]
call mode_info_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call mode_info_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call mode_info_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 0, NOT]
call lat_param_to_f(z_param, c_loc(F%param))
!! f_side.to_f2_trans[type, 0, NOT]
call bookkeeping_state_to_f(z_lord_state, c_loc(F%lord_state))
!! f_side.to_f2_trans[type, 0, NOT]
call ele_to_f(z_ele_init, c_loc(F%ele_init))
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_ele == 0) then
  if (associated(F%ele)) deallocate(F%ele)
else
  if (associated(F%ele)) then
    if (n1_ele == 0 .or. any(shape(F%ele) /= [n1_ele])) deallocate(F%ele)
    if (any(lbound(F%ele) /= 1)) deallocate(F%ele)
  endif
  if (.not. associated(F%ele)) allocate(F%ele(1:n1_ele+1-1))
  do jd1 = 1, n1_ele
    call ele_to_f (z_ele(jd1), c_loc(F%ele(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_branch == 0) then
  if (allocated(F%branch)) deallocate(F%branch)
else
  if (allocated(F%branch)) then
    if (n1_branch == 0 .or. any(shape(F%branch) /= [n1_branch])) deallocate(F%branch)
    if (any(lbound(F%branch) /= 1)) deallocate(F%branch)
  endif
  if (.not. allocated(F%branch)) allocate(F%branch(1:n1_branch+1-1))
  do jd1 = 1, n1_branch
    call branch_to_f (z_branch(jd1), c_loc(F%branch(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_control == 0) then
  if (allocated(F%control)) deallocate(F%control)
else
  if (allocated(F%control)) then
    if (n1_control == 0 .or. any(shape(F%control) /= [n1_control])) deallocate(F%control)
    if (any(lbound(F%control) /= 1)) deallocate(F%control)
  endif
  if (.not. allocated(F%control)) allocate(F%control(1:n1_control+1-1))
  do jd1 = 1, n1_control
    call control_to_f (z_control(jd1), c_loc(F%control(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_surface == 0) then
  if (associated(F%surface)) deallocate(F%surface)
else
  if (associated(F%surface)) then
    if (n1_surface == 0 .or. any(shape(F%surface) /= [n1_surface])) deallocate(F%surface)
    if (any(lbound(F%surface) /= 1)) deallocate(F%surface)
  endif
  if (.not. associated(F%surface)) allocate(F%surface(1:n1_surface+1-1))
  do jd1 = 1, n1_surface
    call photon_reflect_surface_to_f (z_surface(jd1), c_loc(F%surface(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_beam_start, c_loc(F%beam_start))
!! f_side.to_f2_trans[type, 0, NOT]
call pre_tracker_to_f(z_pre_tracker, c_loc(F%pre_tracker))
!! f_side.to_f2_trans[integer, 0, NOT]
F%version = z_version
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ele_track = z_n_ele_track
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ele_max = z_n_ele_max
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_control_max = z_n_control_max
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ic_max = z_n_ic_max
!! f_side.to_f2_trans[integer, 0, NOT]
F%input_taylor_order = z_input_taylor_order
!! f_side.to_f2_trans[integer, 1, ALLOC]
if (allocated(F%ic)) then
  if (n1_ic == 0 .or. any(shape(F%ic) /= [n1_ic])) deallocate(F%ic)
  if (any(lbound(F%ic) /= 1)) deallocate(F%ic)
endif
if (n1_ic /= 0) then
  call c_f_pointer (z_ic, f_ic, [n1_ic])
  if (.not. allocated(F%ic)) allocate(F%ic(n1_ic))
  F%ic = f_ic(1:n1_ic)
else
  if (allocated(F%ic)) deallocate(F%ic)
endif

!! f_side.to_f2_trans[integer, 0, NOT]
F%photon_type = z_photon_type
!! f_side.to_f2_trans[logical, 0, NOT]
F%absolute_time_tracking = f_logic(z_absolute_time_tracking)
!! f_side.to_f2_trans[logical, 0, NOT]
F%auto_scale_field_phase = f_logic(z_auto_scale_field_phase)
!! f_side.to_f2_trans[logical, 0, NOT]
F%auto_scale_field_amp = f_logic(z_auto_scale_field_amp)
!! f_side.to_f2_trans[logical, 0, NOT]
F%ptc_uses_hard_edge_drifts = f_logic(z_ptc_uses_hard_edge_drifts)

end subroutine lat_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bunch_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bunch_struct to a C++ CPP_bunch structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bunch_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bunch struct.
!-

subroutine bunch_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bunch_to_c2 (C, z_particle, n1_particle, z_ix_z, n1_ix_z, z_charge_tot, &
      z_charge_live, z_z_center, z_t_center, z_ix_ele, z_ix_bunch) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_particle, n1_ix_z
    real(c_double) :: z_charge_tot, z_charge_live, z_z_center, z_t_center
    integer(c_int) :: z_ix_z(*), z_ix_ele, z_ix_bunch
    type(c_ptr) :: z_particle(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bunch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_particle(:)
integer(c_int) :: n1_particle
integer(c_int) :: n1_ix_z

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_particle = 0
if (allocated(F%particle)) then
  n1_particle = size(F%particle); lb1 = lbound(F%particle, 1) - 1
  allocate (z_particle(n1_particle))
  do jd1 = 1, n1_particle
    z_particle(jd1) = c_loc(F%particle(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[integer, 1, ALLOC]
n1_ix_z = 0
if (allocated(F%ix_z)) then
  n1_ix_z = size(F%ix_z, 1)
endif

!! f_side.to_c2_call
call bunch_to_c2 (C, z_particle, n1_particle, fvec2vec(F%ix_z, n1_ix_z), n1_ix_z, F%charge_tot, &
    F%charge_live, F%z_center, F%t_center, F%ix_ele, F%ix_bunch)

end subroutine bunch_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bunch_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bunch structure to a Bmad bunch_struct structure.
! This routine is called by bunch_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bunch_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bunch_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bunch_to_f2 (Fp, z_particle, n1_particle, z_ix_z, n1_ix_z, z_charge_tot, &
    z_charge_live, z_z_center, z_t_center, z_ix_ele, z_ix_bunch) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bunch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_ix_ele, z_ix_bunch
integer(c_int), value :: n1_particle, n1_ix_z
integer(c_int), pointer :: f_ix_z(:)
real(c_double) :: z_charge_tot, z_charge_live, z_z_center, z_t_center
type(c_ptr), value :: z_ix_z
type(c_ptr) :: z_particle(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_particle == 0) then
  if (allocated(F%particle)) deallocate(F%particle)
else
  if (allocated(F%particle)) then
    if (n1_particle == 0 .or. any(shape(F%particle) /= [n1_particle])) deallocate(F%particle)
    if (any(lbound(F%particle) /= 1)) deallocate(F%particle)
  endif
  if (.not. allocated(F%particle)) allocate(F%particle(1:n1_particle+1-1))
  do jd1 = 1, n1_particle
    call coord_to_f (z_particle(jd1), c_loc(F%particle(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[integer, 1, ALLOC]
if (allocated(F%ix_z)) then
  if (n1_ix_z == 0 .or. any(shape(F%ix_z) /= [n1_ix_z])) deallocate(F%ix_z)
  if (any(lbound(F%ix_z) /= 1)) deallocate(F%ix_z)
endif
if (n1_ix_z /= 0) then
  call c_f_pointer (z_ix_z, f_ix_z, [n1_ix_z])
  if (.not. allocated(F%ix_z)) allocate(F%ix_z(n1_ix_z))
  F%ix_z = f_ix_z(1:n1_ix_z)
else
  if (allocated(F%ix_z)) deallocate(F%ix_z)
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%charge_tot = z_charge_tot
!! f_side.to_f2_trans[real, 0, NOT]
F%charge_live = z_charge_live
!! f_side.to_f2_trans[real, 0, NOT]
F%z_center = z_z_center
!! f_side.to_f2_trans[real, 0, NOT]
F%t_center = z_t_center
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_bunch = z_ix_bunch

end subroutine bunch_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine beam_spin_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad beam_spin_struct to a C++ CPP_beam_spin structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad beam_spin_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_beam_spin struct.
!-

subroutine beam_spin_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine beam_spin_to_c2 (C, z_polarization, z_theta, z_phi) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_polarization, z_theta, z_phi
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(beam_spin_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call beam_spin_to_c2 (C, F%polarization, F%theta, F%phi)

end subroutine beam_spin_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine beam_spin_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_beam_spin structure to a Bmad beam_spin_struct structure.
! This routine is called by beam_spin_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the beam_spin_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad beam_spin_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine beam_spin_to_f2 (Fp, z_polarization, z_theta, z_phi) bind(c)


implicit none

type(c_ptr), value :: Fp
type(beam_spin_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_polarization, z_theta, z_phi

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%polarization = z_polarization
!! f_side.to_f2_trans[real, 0, NOT]
F%theta = z_theta
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi

end subroutine beam_spin_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bunch_params_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bunch_params_struct to a C++ CPP_bunch_params structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bunch_params_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bunch_params struct.
!-

subroutine bunch_params_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bunch_params_to_c2 (C, z_x, z_y, z_z, z_a, z_b, z_c, z_centroid, z_spin, z_sigma, &
      z_s, z_charge_live, z_n_particle_tot, z_n_particle_live, z_n_particle_lost_in_ele) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_x, z_y, z_z, z_a, z_b, z_c, z_centroid
    type(c_ptr), value :: z_spin
    real(c_double) :: z_sigma(*), z_s, z_charge_live
    integer(c_int) :: z_n_particle_tot, z_n_particle_live, z_n_particle_lost_in_ele
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bunch_params_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bunch_params_to_c2 (C, c_loc(F%x), c_loc(F%y), c_loc(F%z), c_loc(F%a), c_loc(F%b), &
    c_loc(F%c), c_loc(F%centroid), c_loc(F%spin), mat2vec(F%sigma, 6*6), F%s, F%charge_live, &
    F%n_particle_tot, F%n_particle_live, F%n_particle_lost_in_ele)

end subroutine bunch_params_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bunch_params_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bunch_params structure to a Bmad bunch_params_struct structure.
! This routine is called by bunch_params_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bunch_params_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bunch_params_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bunch_params_to_f2 (Fp, z_x, z_y, z_z, z_a, z_b, z_c, z_centroid, z_spin, z_sigma, &
    z_s, z_charge_live, z_n_particle_tot, z_n_particle_live, z_n_particle_lost_in_ele) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bunch_params_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_x, z_y, z_z, z_a, z_b, z_c, z_centroid
type(c_ptr), value :: z_spin
real(c_double) :: z_sigma(*), z_s, z_charge_live
integer(c_int) :: z_n_particle_tot, z_n_particle_live, z_n_particle_lost_in_ele

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_x, c_loc(F%x))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_y, c_loc(F%y))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_c, c_loc(F%c))
!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_centroid, c_loc(F%centroid))
!! f_side.to_f2_trans[type, 0, NOT]
call beam_spin_to_f(z_spin, c_loc(F%spin))
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_sigma, F%sigma)
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[real, 0, NOT]
F%charge_live = z_charge_live
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_particle_tot = z_n_particle_tot
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_particle_live = z_n_particle_live
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_particle_lost_in_ele = z_n_particle_lost_in_ele

end subroutine bunch_params_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine beam_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad beam_struct to a C++ CPP_beam structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad beam_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_beam struct.
!-

subroutine beam_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine beam_to_c2 (C, z_bunch, n1_bunch) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int), value :: n1_bunch
    type(c_ptr) :: z_bunch(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(beam_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_bunch(:)
integer(c_int) :: n1_bunch

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_bunch = 0
if (allocated(F%bunch)) then
  n1_bunch = size(F%bunch); lb1 = lbound(F%bunch, 1) - 1
  allocate (z_bunch(n1_bunch))
  do jd1 = 1, n1_bunch
    z_bunch(jd1) = c_loc(F%bunch(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call beam_to_c2 (C, z_bunch, n1_bunch)

end subroutine beam_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine beam_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_beam structure to a Bmad beam_struct structure.
! This routine is called by beam_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the beam_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad beam_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine beam_to_f2 (Fp, z_bunch, n1_bunch) bind(c)


implicit none

type(c_ptr), value :: Fp
type(beam_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int), value :: n1_bunch
type(c_ptr) :: z_bunch(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_bunch == 0) then
  if (allocated(F%bunch)) deallocate(F%bunch)
else
  if (allocated(F%bunch)) then
    if (n1_bunch == 0 .or. any(shape(F%bunch) /= [n1_bunch])) deallocate(F%bunch)
    if (any(lbound(F%bunch) /= 1)) deallocate(F%bunch)
  endif
  if (.not. allocated(F%bunch)) allocate(F%bunch(1:n1_bunch+1-1))
  do jd1 = 1, n1_bunch
    call bunch_to_f (z_bunch(jd1), c_loc(F%bunch(jd1+1-1)))
  enddo
endif


end subroutine beam_to_f2
end module
