\chapter {Element Attributes}
\label{c:attrib}
\index{element attribute}

%-----------------------------------------------------------------
\section{Dependent and Independent Attributes} 
\label{s:depend} 
\index{element attribute!dependent and independent}

\index{parameter statement}
\index{dependent attribute}
For convenience, \bmad computes the values of some attributes based
upon the values of other attributes. Some of these dependent variables are
listed in Table~\ref{t:dependent}. Also shown in
Table~\ref{t:dependent} are the independent variables they are
calculated from.  In the table \vn{n_part} and \vn{l_lattice} (lattice
length) are lattice attributes, not element attributes. The first two
are set by the \vn{parameter} statement (See
\sref{s:param}). \vn{l_lattice} is calculated when the lattice is read
in.

\index{bbi_constant}\index{charge}\index{sig_x}\index{sig_y}
\index{e_tot}\index{n_part}\index{e_field}\index{voltage}
\index{hkick}\index{vkick}\index{gap}\index{l}
\index{e_tot}\index{e_loss}\index{delta_e}\index{gradient}
\index{l}\index{rho}\index{angle}\index{l_chord}
\index{g}\index{l}\index{k1}\index{rho}\index{num_steps}\index{ds_step}
\index{b_max}\index{e_tot}\index{beambeam}\index{elseparator}
\index{lcavity}\index{rbend}\index{sbend}\index{wiggler}
\begin{table}[ht]
\centering {
\begin{tabular}{|l|l|l|} \hline
 {\em Element}                & {\em Independent Variables}    & {\em Dependent Variables}          \HH
 All elements                 & \vn{ds_step}                   & \vn{num_steps}                     \HH
 \vn{BeamBeam}                & \vn{charge}, \vn{sig_x}, \vn{sig_y}, \vn{e_tot}, \vn{n_part}
                                                               & \vn{bbi_constant}                  \HH
 \vn{Elseparator}             & \vn{hkick}, \vn{vkick}, \vn{gap}, \vn{l}, \vn{e_tot}      
                                                               & \vn{e_field}, \vn{voltage}         \HH
 \vn{Lcavity}                 & \vn{gradient}, \vn{l}          & \vn{e_loss}, \vn{voltage}          \HH
 \vn{Rbend}, \vn{Sbend}       & \vn{g}, \vn{l}                     
                                                               & \vn{rho}, \vn{angle}, \vn{l_chord} \HH

 \vn{Wiggler} (map type)      & \vn{term(i)}                   & \vn{b_max}, \vn{k1}, \vn{rho}      \HH
 \vn{Wiggler} (periodic type) & \vn{b_max}, \vn{e_tot}         & \vn{k1}, \vn{rho}                  \HH
\end{tabular}
}
\caption[Table of dependent variables.]{Partial listing of dependent variables and 
  the independent variables they are calculated from.}
\label{t:dependent}
\end{table}

\index{lattice!expansion}\index{harmon}\index{delta_e}\index{gradient}
\index{rho}\index{g}\index{angle}\index{rf_frequency}
No attempt should be made to set or vary within a program dependent
attributes. It should be remarked that this is not an iron clad rule.
If a program properly bypasses \bmad's attribute bookkeeping routine
then anything is possible. In a lattice file, before lattice expansion
(\sref{s:expand}), \bmad allows the setting of a select group of
dependent attributes if the appropriate independent attributes are
not set. The list of settable dependent variables is given in
Table~\ref{t:dep.except}.  After reading in the lattice \bmad will set
the appropriate independent variable based upon the value of the
dependent variable. \vn{harmon} is the exception in that it will never
be set by the bookkeeping routine.
\index{lcavity}\index{rbend}
\index{sbend}\index{rfcavity}
\begin{table}[ht]
\centering {
\begin{tabular}{|l|l|l|} \hline
{\em Element}                  & {\em Dependent Variable Set}  &  {\em Independent Variables Not Set} \HH
  \vn{Lcavity}                 & \vn{voltage}       & \vn{gradient}      \HH
  \vn{Rbend}, \vn{Sbend}       & \vn{rho}           & \vn{g}             \HH
  \vn{Rbend}, \vn{Sbend}       & \vn{angle}         & \vn{g}, or \vn{l}  \HH
  \vn{RFcavity}                & \vn{rf_frequency}  & \vn{harmon}        \HH
  \vn{Wiggler} (periodic type) & \vn{n_pole}        & \vn{l_pole}        \HH
\end{tabular}
}
\caption {Dependent variables that can be set in a primary lattice file.}
\label{t:dep.except}
\end{table}

\index{g}\index{g_err}\index{b_field}\index{bs_field}\index{b_field_err}
\index{b1_gradient}\index{b2_gradient}\index{b3_gradient}\index{ks}
\index{k1}\index{k2}\index{k3}
\index{bl_kick}\index{bl_hkick}\index{bl_vkick}
\index{kick}\index{hkick}\index{vkick}
The normal attribute used to vary the strength of, say, a
\vn{quadrupole} is \vn{k1}.  It is sometimes convenient to be able to
vary the magnetic field strength directly instead. To do this \bmad
has a rule that if the appropriate field attribute appears in the
primary lattice file then it becomes an independent variable and the
normalized strength attribute (the strength attribute normalized by
the reference energy) becomes a dependent variable as tabulated in
Table~\ref{t:dep.field}.
\index{sbend}\index{rbend}\index{solenoid}\index{quadrupole}
\index{sol_quad}\index{sextupole}\index{octupole}
\begin{table}[ht]
\centering {
\begin{tabular}{|l|l|l|} \hline
  {\em Element} & {\em Normalized Strength} & {\em Field Attribute} \HH
  \vn{Sbend}, \vn{Rbend}     & \vn{g}      &  \vn{b_field}        \HH
  \vn{Sbend}, \vn{Rbend}     & \vn{g_err}  &  \vn{b_field_err}    \HH
  \vn{Solenoid, Sol_quad}    & \vn{ks}     &  \vn{bs_field}       \HH
  \vn{Quadrupole, Sol_quad, Sbend, Rbend}            
                             & \vn{k1}     &  \vn{b1_gradient}    \HH
  \vn{Sextupole, Sbend, Rbend}             
                             & \vn{k2}     &  \vn{b2_gradient}    \HH
  \vn{Octupole}              & \vn{k3}     &  \vn{b3_gradient}    \HH
  \vn{HKicker}, \vn{VKicker} & \vn{kick}   &  \vn{bl_kick}        \HH
  Most                       & \vn{hkick}  &  \vn{bl_hkick}       \HH
  Most                       & \vn{vkick}  &  \vn{bl_vkick}       \HH
\end{tabular}
}
\caption {Field and Strength Attributes.}
\label{t:dep.field}
\end{table}
Using both field strength and normalized strength as the independent
variable for a given element is not permitted. For example, for a quadrupole the 
normalized strengths \vn{k1}, \vn{hkick}, and \vn{vkick} can be used as the
independent variable or the field strengths \vn{b1_gradient}, \vn{bl_hkick} and
\vn{bl_vkick}. but the mixing of the two is not valid
\begin{example}
  Q1: quadrupole, k1 = 0.6, bl_hkick = 37.5  ! NO. Not VALID.
\end{example}
\index{field_master}
To define an element with the field strength as the independent
attribute without setting the strength just set the strength to zero
or, alternatively, the \vn{field_master} logical can be set. For
example
\begin{example}
  Q1: quadrupole, b1_gradient = 0   ! Field strengths now the independent variables
  Q1: quadrupole, field_master = T  ! Same as above
\end{example}
The same effect can be obtained by setting the field or \vn{field_master} attributes
after the element has been defined.
\begin{example}
  q1: quadrupole        ! Define q1.
  q1[b1_gradient] = 0   ! Field strengths now the independent variables.
  q1[field_master] = T  ! Same as above.
\end{example}

%-----------------------------------------------------------------
\section{Type, Alias and Descrip Attributes}
\label{s:alias}
\index{type|hyperbf}
\index{alias|hyperbf}
\index{descrip|hyperbf}

There are three string labels associated with any element:
\begin{example}
  type    = <String>
  alias   = <String>
  descrip = <String>
\end{example}
\bmad routines do not use these labels except when printing element
information. \vn{type} and \vn{alias} can be up to 40 characters in
length and \vn{descrip} can be up to 200 characters. The attribute
strings can be enclosed in double quotation marks ("). The attribute
strings may contain blanks. If the attribute string does not contain a
blank then the quotation marks may be omitted. In this case the first
comma (,) or the end of the line marks the end of the string. Example:
\begin{example}
  Q00W: Quad, type = "My Type", alias = Who_knows, &
                                  descrip = "Only the shadow knows"
\end{example}

%-----------------------------------------------------------------
\section[Energy and Wavelength Attributes]{Energy and Wavelength Attributes: E_tot, P0C, and \\ ref_wavelength }
\label{s:energy}
\index{parameter statement}\index{e_tot}
\index{e_tot_start}\index{p0c_start}
\index{patch}\index{lcavity}\index{p0c}\index{e_gun}
\index{n_ref_pass}\index{ref_wave_length}
The attributes that define the reference energy and momentum at an element are:
\begin{example}
  e_tot  = <Real>  ! Total energy in eV.
  p0c    = <Real>  ! Momentum in eV.
\end{example}
The energy and momentum are defined at the exit end of the element.
For ultra--relativistic particles, and for photons, these two values
are the same (\sref{s:phase.space}). Except for multipass elements
(\sref{s:multipass}), \vn{e_tot} and \vn{p0c} are dependent attributes
and, except for multipass elements, any setting of \vn{e_tot} and
\vn{p0c} in the lattice input file is an error. The value of
\vn{e_tot} and \vn{p0c} for an element is calculated by \bmad to be
the same as the previous element except for \vn{e_gun}, \vn{lcavity} and
\vn{patch} elements. To set the \vn{e_tot} or \vn{p0c} at the start of
the lattice use the \vn{beginning} or \vn{parameter} statements.
See~\sref{s:param}. Since the energy changes from the start to the end
of an \vn{lcavity} or. \vn{em_field}, an \vn{lcavity} or \vn{em_field} has
the dependent attributes
\index{em_field}\index{lcavity}
\begin{example}
  e_tot_start   and
  p0c_start
\end{example}
which are just the reference energy and momentum at the start of the element.

\index{init_ele}
The \vn{init_ele} element (\sref{s:init.ele}) also has associated
\vn{e_tot_start} and \vn{p0c_start} attributes as well as \vn{e_tot}
and \vn{p0c}. Generally, for an \vn{init_ele}, \vn{p0c_start} and
\vn{p0c} are the same and \vn{e_tot_start} and \vn{e_tot} are the same
and the values for these attributes are set in the lattice file with
the appropriate \vn{parameter} (\sref{s:param}) or \vn{beginning}
(\sref{s:beginning}) statement. The exception occurs when there is an
\vn{e_gun} element in the lattice (\sref{s:e.gun}). In this case, the
\vn{p0c_start} and \vn{e_tot_start} attributes of the \vn{init_ele}
are set to the values as set in the lattice file and \vn{e_tot} is set
to
\begin{example}
  e_tot = e_tot_start + voltage
\end{example}
and \vn{p0c} is calculated from \vn{e_tot} and the mass of the
particle being tracked. For example, if the lattice file contained:
\begin{example}
  beginning[p0c] = 0
  gun: e_gun, voltage = 0.5e6
  injector: line = (gun, ...)
\end{example}
Then the following energy values will be set for the beginning \vn{init_ele} element:
\begin{example}
  p0c_start   = 0
  e_tot_start = mc2
  e_tot       = mc2 + 0.5e6
  p0c         = Sqrt(e_tot - mc2^2)
\end{example}
where \vn{mc2} is the particle rest mass.  The reason for using this
convoluted convention is to allow the setting, in the lattice file, of
a zero reference momentum at the start of the lattice, while
avoiding the calculational problems that would occur if the \vn{e_gun}
element truly had a starting reference momentum of zero.
Specifically, the problem with zero reference momentum is that the
phase space momentum would be infinity as can be seen from \Eqs{ppp}.

For \vn{multipass} elements, the reference energy is set by specifying
one of \vn{e_tot}, \vn{p0c}, or \vn{n_ref_pass} as described in
\sref{s:multipass}.

For photons, the reference wavelength, \vn{ref_wavelength} is also a
dependent attribute calculated from the reference energy.

\vfill

%-----------------------------------------------------------------
\section{Orientation: Offset, Pitch, Tilt, and Roll Attributes}
\label{s:offset}
\index{x_offset|hyperbf}
\index{y_offset|hyperbf}\index{z_offset|hyperbf}
\index{x_pitch|hyperbf}\index{y_pitch|hyperbf}
\index{roll|hyperbf}\index{tilt|hyperbf}

By default, an element, like a quadrupole, is aligned in space
coincident with the reference orbit running through it
(\sref{s:ref.construct}). A quadrupole can be displaced in space using
the quadrupole's ``\vn{orientational}'' attributes. For a quadrupole,
the orientational attributes only affect the physical element and not
the reference orbit. However, the orientational attributes of some
other elements, like the \vn{fiducial} element, do affect the
reference orbit. To sort all this out, lattice elements can be divided
into six classes:
  \begin{description}
  \item[\vn{Straight line elements}] \Newline
Straight line elements are elements where the reference orbit is a
straight line. Examples include \vn{quadrupoles}, and \vn{sextupoles}
as well as zero length elements like \vn{markers}.
  \item[\vn{Dipole bends}]  \Newline
Dipole bends are:
\begin{example}
  sbend \& rbend             ! \sref{s:bend}
\end{example}
  \item[\vn{Photon reflecting elements}] \Newline
The reflecting elements are
\begin{example}
  crystal                   ! \sref{s:crystal}
  mirror                    ! \sref{s:mirror}
  multilayer_mirror         ! \sref{s:multilayer}
\end{example}
These elements have a kink in the reference orbit at the nominal
element surface.
  \item[\vn{Reference orbit manipulator elements}] \Newline
Elements that are used to manipulate the reference orbit are
\begin{example}
  branch \& photon_branch    ! \sref{s:branch}
  floor_shift               ! \sref{s:floor.ele}
  patch                     ! \sref{s:patch}
\end{example}
  \item[\vn{Fiducial Element}] \Newline
  \item[\vn{Girder Elements}] \Newline
  \item[\vn{Control Elements}] \Newline
Control elements are elements that control attributes of other
elements. The control elements are:
\begin{example}
  group
  overlay
\end{example}
These elements do not have orientational attributes.
  \end{description}

%-----------------------------------------------------------------
\subsection{Straight Line Element Orientation}

The straight line elements have the following orientational attributes:
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  z_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  tilt     = <Real>    
\end{example}
For straight line elements the orientational attributes only shift the
physical element and do not affect the reference orbit.

\begin{figure}[tb]
  \centering
  \includegraphics{pitch.pdf}
  \caption{Geometry of Pitch and Offset attributes}
  \label{f:pitch}
\end{figure}

\vn{x_offset} translates an element in the local $x$--direction
as shown in \fig{f:pitch}. Similarly, \vn{y_offset} and 
\vn{z_offset} translate an element along the local $y$ and 
$z$--directions respectively.

The \vn{x_pitch} attribute rotates an element about the element's
center such that the exit face of the element is displaced in the
$+x$--direction as shown in figure~\ref{f:pitch}.  An
\vn{x_pitch} represents a rotation around the positive $y$-axis.

Similarly, the \vn{y_pitch} attribute rotates an element about the
element's center using the negative $x$--axis as the rotation axis so
that the exit face of the element is displaced in the $+y$--direction.

The \vn{x_pitch} and \vn{y_pitch} rotations are about the center of
the element which is in contrast to the \vn{dtheta} and \vn{dphi}
misalignments of \mad which rotate around the entrance point. The
sense of the rotation between \bmad and MAD is:
\index{MAD!element rotation origin}
\begin{example}
  x_pitch (Bmad) =  dtheta (MAD)
  y_pitch (Bmad) = -dphi (MAD)
\end{example}

\begin{figure}[tb]
  \centering
  \includegraphics{tilt.pdf}
  \caption{Geometry of a Tilt}
  \label{f:tilt}
\end{figure}

The tilt attribute rotates the element in the $(x, y)$ plane as shown
in figure~\ref{f:tilt}. The rotation axis is the positive
$z$-axis. For example
\begin{example}
  q1: quad, l = 0.6, x_offset = 0.03, y_pitch = 0.001, tilt
\end{example}
\index{sol_quad!tilt default}\index{quadrupole!tilt default}
\index{sextupole!tilt default}\index{octupole!tilt default}
Like MAD, \bmad allows the use of the \vn{tilt} attribute without a
value to designate a skew element. The default tilt is $\pi/(2(n+1))$
where $n$ is the order of the element:
\begin{example}
  sol_quad       n = 1
  quadrupole     n = 1
  sextupole      n = 2
  octupole       n = 3
\end{example}

Note that \vn{hkick} and \vn{vkick} attributes are not affected by
\vn{tilt} except for \vn{kicker} and \vn{elseparator} elements.

%-----------------------------------------------------------------
\subsection{Bend Element Orientation}

\begin{figure}[ht]
  \centering
  \includegraphics{roll.pdf}
  \caption[Geometry of a Bend]{
Geometry of a Bend. Like straight line elements, offsets and pitches
are calculated with respect to the coordinates at the center of the
bend. The exception is the \vn{roll} attribute which is a rotation
around the axis passing through the entrance and exit points.  Shown
here is the geometry for a bend with \vn{ref_tilt} = 0. That is, the bend
is in the $x-z$ plane.}
  \label{f:roll}
\end{figure}

The orientation attributes for \vn{sbend} and \vn{rbend} elements is
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  z_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  ref_tilt = <Real>    ! Shifts and reference orbit rotation axis.
  roll     = <Real>    
\end{example}
The geometry for orienting a bend is shown in \fig{f:roll}. Like
straight line elements, the offset and pitch attributes are evaluated
with respect to the center of the element. 

Unlike the straight line elements, bends do not have a \vn{tilt}
attribute. Rather they have a \vn{ref_tilt} and a \vn{roll} attribute.
The \vn{roll} attribute rotates the bend along an axis that runs
through the entrance point and exit point as shown in
figure~\ref{f:roll}. A \vn{roll} attribute, like the offset and pitch
attributes does not affect the reference orbit.
The major effect of a \vn{roll} is to give a vertical
kick to the beam. For a bend with positive bend angle, a positive
\vn{roll} will move the outside portion ($+x$ side) of the bend upward
and the inside portion (-$x$ side) downward. Much like car racetracks
which are typically slanted towards the inside of a turn.

The \vn{ref_tilt} attribute of a bend rotates the bend about the $z$
axis at the upstream end of the bend as shown in \fig{f:roll}. Unlike
\vn{rolls} and \vn{tilts}, \vn{ref_tilt} also shifts the rotation axis
of the reference orbit along with the physical element. A \vn{bend}
with a \vn{ref_tilt} of $\pi/2$ will bend a beam vertically downward
(\sref{s:global}). Note that the \vn{ref_tilt} attribute of \bmad is
the same as the MAD \vn{tilt} attribute.

%-----------------------------------------------------------------
\subsection{Photon Reflecting Element Orientation}

\begin{figure}[ht]
  \centering
  \includegraphics{reflect-orient.pdf}
  \caption[Geometry of a photon reflecting element orientation]{
Geometry of a photon reflecting element orientation.
The reference coordinates used for defining the orientational attribute
is the entrance reference coordinates. 
}
  \label{f:reflect.orient}
\end{figure}

Photon reflecting elements have the following orientational attributes:
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  z_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  ref_tilt = <Real>    ! Shifts both element and reference orbit.
  tilt     = <Real>    
\end{example}
Roughly, these elements can be viewed as zero length bends except,
since there is no center position, the orientational attributes are
defined with respect to the entrance coordinates as shown in
\fig{f:reflect.orient}. Like bend elements, the \vn{ref_tilt} attribute
rotates both the physical element and the reference coordinates.
The \vn{tilt} attribute rotates just the physical element. Thus
the total rotation of the physical element about the entrance $z$
axis is the sum \vn{tilt} + \vn{ref_tilt}.

%-----------------------------------------------------------------
\subsection{Reference Orbit Manipulator Element Orientation}

The \vn{branch}, \vn{photon_branch}, \vn{floor_shift}, and \vn{patch} elements
use the following attributes to orient their exit edge with respect to their
entrance edge:
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  z_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  tilt     = <Real>    
\end{example}
Here "exit" edge for \vn{branch} and \vn{photon_branch} elements is defined
to be the start of the line being branched to. [Within the line containing
the branch, the branch is considered to have zero length so the exit face
in the line containing the branch is coincident with the entrance face.]
The placement of the exit edge for these elements defines the reference orbit.
Thus, unlike the corresponding attributes for other elements, 
the orientational attributes here directly control the reference orbit.

%-----------------------------------------------------------------
\subsection{Fiducial Element Orientation}

The \vn{fiducial} element (\sref{s:girder}) uses the 
following attributes to define its position:
\begin{example}
  origin_ele        = <Name>     ! Reference element.
  origin_ele_ref_pt = <location> ! Reference pt on reference ele.
  dx_origin         = <Real>     ! x-position offset
  dy_origin         = <Real>     ! y-position offset
  dz_origin         = <Real>     ! z-position offset
  dtheta_origin     = <Real>     ! orientation angle offset.
  dphi_origin       = <Real>     ! orientation angle offset.
  dpsi_origin       = <Real>     ! orientation angle offset.
\end{example}
See Section~\sref{s:fiducial} for more details.



%-----------------------------------------------------------------
\subsection{Girder Orientation}

A \vn{girder} (\sref{s:girder}) element uses the same attributes as a \vn{fiducial}
element (\sref{s:fiducial}) to orient the reference girder position. In addition,
the following attributes are used to move the girder physically from the reference position: 
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  z_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  tilt     = <Real>    
\end{example}
Shifting the girder from its reference position shifts all the elements that are
supported by the girder. See Section~\sref{s:girder} for more details.

\index{x_offset_tot|hyperbf}\index{y_offset_tot|hyperbf}\index{z_offset_tot|hyperbf}
\index{x_pitch_tot|hyperbf}\index{y_pitch_tot|hyperbf}
\index{tilt_tot|hyperbf}\index{roll_tot|hyperbf}\index{tilt_err_tot|hyperbf}
If an element is supported by a \vn{girder} element (\sref{s:girder}),
the orientational attributes of the element are with respect to the
orientation of the \vn{girder}. The computed offsets, pitches and tilt with
respect to the local reference coordinates are stored in the dependent attributes
\begin{example}
  x_offset_tot
  y_offset_tot
  z_offset_tot
  x_pitch_tot
  y_pitch_tot
  tilt_tot
  roll_tot
\end{example}
\index{sbend}\index{rbend}
A \vn{*_tot} attribute will only be present if the corresponding non
\vn{*_tot} attribute is present. For example, only \vn{sbend} and
\vn{rbend} elements have a \vn{roll_tot} attribute since only these
elements have a \vn{roll} attribute.

If an element is not supported by a \vn{girder}, the values of the
\vn{*_tot} attributes will be the same value as the values of the
corresponding non \vn{*_tot} attributes.

%-----------------------------------------------------------------
\section{Hkick, Vkick, and Kick Attributes}
\label{s:kick}
\index{hkick|hyperbf}\index{bl_hkick|hyperbf}
\index{vkick|hyperbf}\index{bl_vkick|hyperbf}
\index{kick|hyperbf}\index{bl_kick|hyperbf}


\index{hkicker}
\index{vkicker}
\index{elseparator}
\index{kicker}
The kick attributes that an element may have are:
\begin{example}
  kick,  bl_kick  = <Real>  ! Used only with a Hkicker or Vkicker
  hkick, bl_hkick = <Real>
  vkick, bl_vkick = <Real>
\end{example}
\vn{kick}, \vn{hkick}, and \vn{vkick} attributes are the integrated
kick of an element in radians. \vn{kick} is only used for \vn{hkicker}
and \vn{vkicker} elements. All other elements that can kick use
\vn{hkick} and \vn{vkick}. The \vn{tilt} attribute will only rotate a
kick for \vn{hkicker}, \vn{vkicker}, \vn{elseparator} and \vn{kicker}
elements. This rule was implemented so that, for example, the
\vn{hkick} attribute for a skew quadrupole would represent a
horizontal steering. The \vn{bl_kick}, \vn{bl_hkick}, and
\vn{bl_vkick} attributes are the integrated field kick in
\vn{meters-Tesla}. Normally these are dependent attributes except if
they appear in the lattice file (\sref{s:depend}).

%-----------------------------------------------------------------
\section{Aperture and Limit Attributes}
\label{s:limit}
\index{aperture|hyperbf}
\index{limit|hyperbf}
\index{aperture_at|hyperbf}

\begin{figure}[ht]
  \centering
  \includegraphics{apertures.pdf}
  \caption[Apertures for ecollimator and rcollimator elements.]
  {Apertures for ecollimator and rcollimator elements. 
  Positive $s$ points up out of the page.}
  \label{f:limit}
\end{figure}

\index{ecollimator}
\index{rcollimator}
\index{x_limit|hyperbf}
\index{y_limit|hyperbf}
\index{x1_limit|hyperbf}
\index{y1_limit|hyperbf}
\index{x2_limit|hyperbf}
\index{y2_limit|hyperbf}
\index{x_offset|hyperbf}
\index{offset_moves_aperture|hyperbf}
\index{aperture_type}
The aperture attributes are:
\begin{example}
  x1_limit      = <Real>      ! Horizontal, negative side, aperture limit
  x2_limit      = <Real>      ! Horizontal, positive side, aperture limit
  y1_limit      = <Real>      ! Vertical, negative side, aperture limit
  y2_limit      = <Real>      ! Vertical, positive side, aperture limit
  x_limit       = <Real>      ! Alternative to specifying x1_limit and x2_limit
  y_limit       = <Real>      ! Alternative to specifying y1_limit and y2_limit
  aperture      = <Real>      ! Alternative to specifying x_limit and y_limit
  aperture_at   = <Switch>    ! What end aperture is at.
  aperture_type = <Switch>    ! What type of aperture it is.
  offset_moves_aperture = <Logical> ! Element offsets affect aperture position
\end{example}
\vn{x1_limit}, \vn{x2_limit}, \vn{y1_limit}, and \vn{y2_limit} specify
the half--width of the aperture of an element as shown in
figure~\ref{f:limit}. A zero \vn{x1_limit}, \vn{x2_limit},
\vn{y1_limit}, or \vn{y2_limit} is interpreted as no aperture in the
appropriate plane.

By default, apertures are assumed to be
rectangular except that an \vn{ecollimator} has a elliptical aperture.
This can be changed by setting the \vn{aperture_type} attribute. The possible 
values of this attribute are:
\begin{example}
  rectangular
  elliptical
  custom
\end{example}
The \vn{custom} setting is used in the case where programs have been
compiled with custom, non-Bmad, code to handle the aperture calculation.

To avoid numerical overflow and other errors in tracking, a particle
will be considered to have hit an aperture in an element, even if
there are no apertures set for that element, if its orbit exceeds 1000
meters. Additionally, there are other situations where a particle will
be considered lost. For example, if a particle's trajectory does
not intersect the output face in a bend.

For convenience, \vn{x_limit} can be used to set \vn{x1_limit} and
\vn{x2_limit} to a common value. Similarly, \vn{y_limit} can be used
to set \vn{y1_limit} and \vn{y2_limit}.  The \vn{aperture} attribute
can be use to set all four \vn{x1_limit}, \vn{x2_limit}, \vn{y1_limit}
and \vn{y2_limit} to a common value. Internally, the \bmad code does {\em not}
store \vn{x_limit}, \vn{y_limit}, or \vn{aperture}. This means that
using \vn{x_limit}, \vn{y_limit} or aperture in arithmetic expressions is
an error:
\begin{example}
  q2: quad, aperture = q1[aperture]   ! THIS IS AN ERROR!
  q2: quad, aperture = q1[x1_limit]   ! Correct
\end{example}

Examples:
\begin{example}
  q1[y1_limit] = 0.03
  q1[y2_limit] = 0.03
  q1[y_limit] = 0.03  ! equivalent to the proceeding 2 lines.  
  q1[aperture_at] = both_ends
\end{example}

%-----------------------------------------------------------------
\subsection{Apertures and Element Offsets}

\index{tilt}
\index{x_offset}
\index{y_offset}
\index{x_pitch}
\index{y_pitch}
\index{rcollimator}\index{ecollimator}
\index{multilayer_mirror}\index{mirror}\index{crystal}
Normally, whether a particle hits an aperture or not is evaluated
independent of any element offsets (\sref{s:offset}). This is
equivalent to the situation where a beam pipe containing an aperture
is independent of the placement of the physical element the beam pipe
passes through. That is, the beam pipe does not ``touch'' the physical
element. This can be changed by setting the \vn{offset_moves_aperture}
attribute to \vn{True}. In this case any offsets or pitches will be
considered to have shifted the aperture boundary. The exceptions here
is that the default for the following elements is for
\vn{offset_moves_aperture} to be \vn{True}:
\begin{example}
  rcollimator, 
  ecollimator,
  multilayer_mirror, 
  mirror, and 
  crystal 
\end{example}

Even with \vn{offset_moves_aperture} set to \vn{True}, \vn{tilt}s will
not affect the aperture calculation. This is done, for example, so
that the tilt of a skew quadrupole does not affect the aperture. The
exception here is that tilting an \vn{rcollimator} or \vn{ecollimator}
element will tilt the aperture. Additionally, when the aperture is at
the \vn{surface} (see below), any \vn{tilt} will be used in the
calculation.

Examples:
\begin{example}
  q1: quad, l = 0.6, x1_limit = 0.045, offset_moves_aperture = T
\end{example}

%-----------------------------------------------------------------
\subsection{Aperture Placement}

\index{both_ends|hyperbf}\index{continuous|hyperbf}
\index{entrance_end|hyperbf}\index{exit_end|hyperbf}
\index{surface|hyperbf}\index{aperture_at}
By default the aperture is evaluated at the exit face only of the
element. This can be changed by setting the \vn{aperture_at} attribute.
Possible settings for \vn{aperture_at} are:
\begin{example}
  entrance_end
  exit_end       ! Default for most elements
  both_ends
  continuous
  surface        ! Default for mirror, multilayer_mirror and crystal
\end{example}
Note that the entrance and exit ends of an element are independent of
which direction particles are tracked through an element. Thus if a
particle is tracked backwards it enters an element at the ``exit end''
and exits at the ``entrance end''. The \vn{continuous} setting
indicates that the aperture is continuous along the length of the
element. This only matters when particle tracking involves stepping
through an element a little bit at a time. For example, as in
Runge-Kutta tracking (\sref{s:tkm}). For tracking where a formula is
used to transform the particle coordinates at the entrance of an
element to the coordinates at the exit end, the aperture is only
checked at the end points so, in this situation, a \vn{continuous}
aperture is equivalent to the \vn{both_ends} setting.

\index{mirror}\index{multilayer_mirror}\index{crystal}
The \vn{surface} setting for \vn{aperture_at} can be only be used for
elements
\begin{example}
  mirror, 
  multilayer_mirror, and 
  crystal
\end{example}
For these elements, the \vn{surface} setting is the default. Due to
the complicated geometry of these elements, to keep things
conceptionally simple, the rule is imposed that, for an aperture at the
surface, the \vn{offset_moves_aperture} setting must be left in its
default state of True. Additionally, For \vn{entrance_end} or
\vn{exit_end} apertures, \vn{offset_moves_aperture} must be set to
False.

Examples:
\begin{example}
  q2: quad, aperture_type = elliptical, aperture_at = continuous
  q1: quad, l = 0.6, x1_limit = 0.045, offset_moves_aperture = T
\end{example}

%-----------------------------------------------------------------
\subsection{Apertures and X-Ray Generation}
\label{s:aper.x.ray}

With X-ray simulation apertures can be used by \bmad to limit the
directions in which photons are generated. This can greatly decrease
simulation times. For example, a photon passing through a
\vn{diffraction_plate} element will diffract in an arbitrary
direction. If a {\em downstream} element has an aperture set, \bmad
can restrict the velocity directions so that the photons will fill the
downstream aperture and the amount of time wasted tracking photons
that ultimately would be collimated is minimal.

%-----------------------------------------------------------------
\section{X-Rays Crystal \& Compound Materials}
\label{s:cryst.list}

For basic crystallographic and X-ray matter interaction cross-sections,
\bmad uses the XRAYLIB\cite{b:xraylib} library. Crystal structure
parameters in XRAYLIB are mainly from R.~W.~G.~Wyckoff\cite{b:wyckoff}
with some structure parameters coming from NIST. The list of available
structures is:
\begin{center}
\begin{tabular}{llll}
AlphaAlumina & GaP       & KCl        & Platinum  \\
AlphaQuartz  & GaSb      & KTP        & RbAP      \\
Aluminum     & Ge        & LaB6       & Sapphire  \\
Be           & Gold      & LaB6_NIST  & Si        \\
Beryl        & Graphite  & LiF        & Si_NIST   \\
Copper       & InAs      & LiNbO3     & Si2       \\
CsCl         & InP       & Muscovite  & SiC       \\
CsF          & InSb      & NaCl       & Titanium  \\
Diamond      & Iron      & PET        & TlAP      \\
GaAs         & KAP       &            &           \\
\end{tabular}
\end{center}
These names are case sensitive

From XRAYLIB, bmad knows about the following materials. Material
properties are from NIST. These names are case sensitive (that is, the
names must generally be uppercase). As noted in the table, several of
the materials may be specified using the appropriate chemical
formula. For example, liquid water may be referenced using the name
\vn{H2O}.
\begin{center}
\footnotesize
\begin{longtable}{lll}
\multicolumn{3}{r}{{\normalsize Continued on next page}} \\
\endfoot
\endlastfoot
A_150_TISSUE_EQUIVALENT_PLASTIC     & LITHIUM_TETRABORATE                       \\
ACETONE                             & LUNG_ICRP                                 \\
ACETYLENE                           & M3_WAX                                    \\
ADENINE                             & MAGNESIUM_CARBONATE                       \\
ADIPOSE_TISSUE_ICRP                 & MAGNESIUM_FLUORIDE                        \\
AIR_DRY_NEAR_SEA_LEVEL              & MAGNESIUM_OXIDE                           \\
ALANINE                             & MAGNESIUM_TETRABORATE                     \\
ALUMINUM_OXIDE, Al2O3               & MERCURIC_IODIDE                           \\
AMBER                               & METHANE                                   \\
AMMONIA, NH3                        & METHANOL                                  \\
ANILINE                             & MIX_D_WAX                                 \\
ANTHRACENE                          & MS20_TISSUE_SUBSTITUTE                    \\
B_100_BONE_EQUIVALENT_PLASTIC       & MUSCLE_SKELETAL                           \\
BAKELITE                            & MUSCLE_STRIATED                           \\
BARIUM_FLUORIDE                     & MUSCLE_EQUIVALENT_LIQUID_WITH_SUCROSE     \\
BARIUM_SULFATE                      & MUSCLE_EQUIVALENT_LIQUID_WITHOUT_SUCROSE  \\
BENZENE, C6H6                       & NAPHTHALENE                               \\
BERYLLIUM_OXIDE                     & NITROBENZENE                              \\
BISMUTH_GERMANIUM_OXIDE             & NITROUS_OXIDE                             \\
BLOOD_ICRP                          & NYLON_DU_PONT_ELVAMIDE_8062               \\
BONE_COMPACT_ICRU                   & NYLON_TYPE_6_AND_TYPE_6_6                 \\
BONE_CORTICAL_ICRP                  & NYLON_TYPE_6_10                           \\
BORON_CARBIDE, B4C                  & NYLON_TYPE_11_RILSAN                      \\
BORON_OXIDE, B2O3                   & OCTANE_LIQUID                             \\
BRAIN_ICRP                          & PARAFFIN_WAX                              \\
BUTANE                              & N_PENTANE                                 \\
N_BUTYL_ALCOHOL                     & PHOTOGRAPHIC_EMULSION                     \\
C_552_AIR_EQUIVALENT_PLASTIC        & PLASTIC_SCINTILLATOR_VINYLTOLUENE_BASED   \\
CADMIUM_TELLURIDE                   & PLUTONIUM_DIOXIDE                         \\
CADMIUM_TUNGSTATE                   & POLYACRYLONITRILE                         \\
CALCIUM_CARBONATE                   & POLYCARBONATE_MAKROLON_LEXAN              \\
CALCIUM_FLUORIDE                    & POLYCHLOROSTYRENE                         \\
CALCIUM_OXIDE                       & POLYETHYLENE                              \\
CALCIUM_SULFATE                     & POLYETHYLENE_TEREPHTHALATE_MYLAR          \\
CALCIUM_TUNGSTATE                   & POLYMETHYL_METHACRALATE_LUCITE_PERSPEX    \\
CARBON_DIOXIDE                      & POLYOXYMETHYLENE                          \\
CARBON_TETRACHLORIDE                & POLYPROPYLENE                             \\
CELLULOSE_ACETATE_CELLOPHANE        & POLYSTYRENE                               \\
CELLULOSE_ACETATE_BUTYRATE          & POLYTETRAFLUOROETHYLENE_TEFLON            \\
CELLULOSE_NITRATE                   & POLYTRIFLUOROCHLOROETHYLENE               \\
CERIC_SULFATE_DOSIMETER_SOLUTION    & POLYVINYL_ACETATE                         \\
CESIUM_FLUORIDE                     & POLYVINYL_ALCOHOL                         \\
CESIUM_IODIDE                       & POLYVINYL_BUTYRAL                         \\
CHLOROBENZENE                       & POLYVINYL_CHLORIDE                        \\
CHLOROFORM                          & POLYVINYLIDENE_CHLORIDE_SARAN             \\
CONCRETE_PORTLAND                   & POLYVINYLIDENE_FLUORIDE                   \\
CYCLOHEXANE                         & POLYVINYL_PYRROLIDONE                     \\
12_DDIHLOROBENZENE                  & POTASSIUM_IODIDE                          \\
DICHLORODIETHYL_ETHER               & POTASSIUM_OXIDE                           \\
12_DICHLOROETHANE                   & PROPANE                                   \\
DIETHYL_ETHER                       & PROPANE_LIQUID                            \\
NN_DIMETHYL_FORMAMIDE               & N_PROPYL_ALCOHOL                          \\
DIMETHYL_SULFOXIDE                  & PYRIDINE                                  \\
ETHANE                              & RUBBER_BUTYL                              \\
ETHYL_ALCOHOL                       & RUBBER_NATURAL                            \\
ETHYL_CELLULOSE                     & RUBBER_NEOPRENE                           \\
ETHYLENE                            & SILICON_DIOXIDE                           \\
EYE_LENS_ICRP                       & SILVER_BROMIDE                            \\
FERRIC_OXIDE                        & SILVER_CHLORIDE                           \\
FERROBORIDE                         & SILVER_HALIDES_IN_PHOTOGRAPHIC_EMULSION   \\
FERROUS_OXIDE                       & SILVER_IODIDE                             \\
FERROUS_SULFATE_DOSIMETER_SOLUTION  & SKIN_ICRP                                 \\
FREON_12                            & SODIUM_CARBONATE                          \\
FREON_12B2                          & SODIUM_IODIDE                             \\
FREON_13                            & SODIUM_MONOXIDE                           \\
FREON_13B1                          & SODIUM_NITRATE                            \\
FREON_13I1                          & STILBENE                                  \\
GADOLINIUM_OXYSULFIDE               & SUCROSE                                   \\
GALLIUM_ARSENIDE                    & TERPHENYL                                 \\
GEL_IN_PHOTOGRAPHIC_EMULSION        & TESTES_ICRP                               \\
GLASS_PYREX                         & TETRACHLOROETHYLENE                       \\
GLASS_LEAD                          & THALLIUM_CHLORIDE                         \\
GLASS_PLATE                         & TISSUE_SOFT_ICRP                          \\
GLUCOSE                             & TISSUE_SOFT_ICRU_FOUR_COMPONENT           \\
GLUTAMINE                           & TISSUE_EQUIVALENT_GAS_METHANE_BASED       \\
GLYCEROL                            & TISSUE_EQUIVALENT_GAS_PROPANE_BASED       \\
GUANINE                             & TITANIUM_DIOXIDE                          \\
GYPSUM_PLASTER_OF_PARIS             & TOLUENE                                   \\
N_HEPTANE                           & TRICHLOROETHYLENE                         \\
N_HEXANE                            & TRIETHYL_PHOSPHATE                        \\
KAPTON_POLYIMIDE_FILM               & TUNGSTEN_HEXAFLUORIDE                     \\
LANTHANUM_OXYBROMIDE                & URANIUM_DICARBIDE                         \\
LANTHANUM_OXYSULFIDE                & URANIUM_MONOCARBIDE                       \\
LEAD_OXIDE                          & URANIUM_OXIDE                             \\
LITHIUM_AMIDE                       & UREA                                      \\
LITHIUM_CARBONATE                   & VALINE                                    \\
LITHIUM_FLUORIDE                    & VITON_FLUOROELASTOMER                     \\
LITHIUM_HYDRIDE                     & WATER_LIQUID, H2O                         \\
LITHIUM_IODIDE                      & WATER_VAPOR                               \\
LITHIUM_OXIDE                       & XYLENE                                    \\
\end{longtable}
\end{center}

%-----------------------------------------------------------------

\begin{figure}[tb]
  \centering
  \includegraphics[width=5in]{surface-curvature.pdf}
  \caption[Surface curvature geometry.]
{Surface curvature geometry. The element reference frame used to
describe surface curvature has the $x$ axis pointing towards the
interior of the element, and the $z$ axis along the plane defined by
the entrance and exit reference orbit.}
  \label{f:surface}
\end{figure}

%-----------------------------------------------------------------
\section{Surface Properties for X-Ray elements}
\label{s:s.curve}

The following X-ray elements have a surface which X-rays impinge upon:
\begin{example}
  crystal               \sref{s:crystal}
  detector              \sref{s:detector}
  diffraction_plate     \sref{s:diff.plate}
  mirror, and           \sref{s:mirror}
  multilayer_mirror     \sref{s:multilayer}
  sample                \sref{s:sample}
\end{example}
[There is also the \vn{capillary} element but this element specifies
its surface differently.]

The coordinate system used for characterizing the curvature of a
surface is the element reference frame as shown in
\fig{f:surface}). This coordinate system has the $x$ axis pointing
towards the interior of the element, and the $z$ axis along the plane
defined by the entrance and exit reference orbit. In this coordinate system, 
the surface curvature is parameterized by
a fourth order polynomial in $z$ and $y$
\Begineq
  {-z} = \sum_{2 \le i+j \le 4} c_{ij} \, x^i \, y^j
  \label{xs2ij4}
\Endeq
The coefficients are set in the lattice file by setting the following
element attributes
\index{surface curveture}
\begin{example}
  curvature_xM_yN      = <Real>   
\end{example}
where \vn{M} and \vn{N} are integers in the range 0 through 4 with the restriction
\begin{example}
  2 \(\le\) M + N \(\le\) 4
\end{example}
Example:
\begin{example}
  c2: crystal, curvature_x2_y0 = 37, ...
\end{example}
in this example, \vn{curvature_x2_y0} corresponds to the $c_{20}$ term
in \Eq{xs2ij4}. To get the effect of a nonzero $x^0\, y^0$, $x^1 \,
y^0$, or $x^0 \, y^1$ terms (since corresponding \vn{curvature_xN_yM}
are not permitted), element offsets and pitches can be used
(\sref{s:offset}).

Some useful formulas: Series expansion for a circle of radius $R$:
\Begineq
  {-z} = \frac{x^2}{2 \, R} + \frac{x^4}{8 \, R^3} + \frac{x^6}{16 \, R^5} +
         \frac{y^2}{2 \, R} + \frac{y^4}{8 \, R^3} + \frac{y^6}{16 \, R^5} +
         \frac{x^2 \, y^2}{4 \, R^3} + \frac{3 \, x^4 \, y^2}{16 \, R^5} +
         \frac{3 \, x^2 \, y^4}{16 \, R^5} 
\Endeq
If $p$ is the distance from the source to the crystal, and $q$ is the
distance from the crystal to the detector, the radius of the Rowland
circle $R_s$ in the sagittal plane is given by\cite{b:del.rio}
\Begineq
  \frac{1}{p} + \frac{1}{q} = \frac{\sin\theta_{g,in} + \sin\theta_{g,out}}{R_s}
\Endeq
where $\theta_{g,in}$ and $\theta_{g,out}$ are the entrance and exit
graze angles. In the transverse plane (also called meridional plane),
the radius $R_t$ needed for foucusing is
\Begineq
  \frac{\sin^2\theta_{g,in}}{p} + \frac{\sin^2\theta_{g,out}}{q} = \frac{\sin\theta_{g,in} + \sin\theta_{g,out}}{R_t}
\Endeq

Example:
\begin{example}
  t_bragg = 1.3950647
  rt = 1  ! Crystal transverse radius
  rs = rt*(sin(t_bragg))^2
  c: crystal, crystal_type =  'Si(553)', b_param = -1,
        curvature_x0_y2 =  1 / (2 * rs), curvature_x0_y4 = 1 / (8 * rs^3),
        curvature_x2_y0 = 1 / (2 * rt), curvature_x4_y0 = 1 / (8 * rt^3),
\end{example}

%-----------------------------------------------------------------
\subsection{Surface Grid}
\label{s:surf.grid}
\index{surface grid}

A surface can be broken up into a grid of rectangles. This is useful,
for example, in breaking up a \vn{detector} element into pixel photo
receptors or in simulating a rough serface for \vn{crystal}s and other
elements. The general syntax is:
\begin{example}
  surface = \{
    grid = \{                
      type = <type_name>,               ! Crystals: Off, Segmented, or H_Misalign
      x_bounds = (<ix_min>, <ix_max>),  ! Min/max index bounds in x-direction
      y_bounds = (<iy_min>, <iy_max>),  ! Min/max index bounds in y-direction
      r0 = (<x0>, <y0>),                ! (x,y) coordinates at grid origin
      dr = (<dx>, <dy>),                ! width and height of pixels.
      pt(<i>,<j>) = (<x_pitch>, <y_pitch>, <x_pitch_rms>, <x_pitch_rms>),
          \} \}
\end{example}
Example:
\begin{example}
  ccd: crystal, surface = \{
          grid = \{
            type = h_misalign,
            r0 = (0.0, 0.01), dr = (0.005, 0.005),
            x_bounds = (1, 57), y_bounds = (-30, 10),
            pt(1,-30) = (0.001, -0.002, 0, 0), 
            pt(1,-29) = ..., 
          \} \}
\end{example}

The grid is a two dimensional with bounds given by the \vn{x_bounds}
and \vn{y_bounds} components. These two components must be present. In
the above example the grid is 57 pixels in $x$ and 41 pixels in $y$.

The physical placement of the grid on the element is determined by the
\vn{r0} and \vn{dr} components. \vn{r0} is optional and gives the
$(x,y)$ coordinates of the center of the pixel with index $(0,0)$. The
\vn{dr} component, which must be present, gives the pixal width and
height. Thus the center of the $(i,j)$ pixel is:
\begin{example}
  (x,y) = (r0(1), r0(2)) + (i*dr(1), j*dr(2))
\end{example}

The \vn{type} component of the grid is used for
\vn{crystal} elements only. Possible \vn{type} values are:
\begin{example}
  H_Misalign         ! Misalignment of crystal H vector
  Off               ⁄! Ignore grid
  Segmented          ! Surface is a matrix of flat rectangles
\end{example}
\vn{H_Misalign} misaligns the $H$ vector which is the normal to the
diffracting planes of the the crystal (\sref{s:crystal.tracking}).
When using \vn{H_Misalign}, each \vn{pt(i,j)} component gives the
misalignment of $H$ for the corresponding pixel. For an individual
photon, the misalignt of $H$ will be
\begin{example}
  x_pitch_tot = <x_pitch> + r1 * <x_pitch_rms>
  y_pitch_tot = <y_pitch> + r2 * <y_pitch_rms>
\end{example}
where \vn{x_pitch_tot} and \vn{y_pitch_tot} are the rotational
misalignment (\sref{s:offset}) used in the calculation, the quantities
in brackets \vn{<...>} are components of \vn{pt}, and \vn{r1} and
\vn{r2} are Gaussian distributed random numbers with unit rms. These
random numbers are regenerated for each photon. Note: \vn{pt} is only
used with \vn{H_Misalign}.

When the \vn{type} component is set to \vn{Segmented}, the crystal
surface is modeled as a grid of flat ``rectangles'' (the actual shape
is very close but not quite rectangular). Using a segmented crystal
only makes sense when the crystal is curved. There is one rectangle
for each pixel. Each rectangle has an extent in the $(x,y)$ transverse
dimensions equal to the extent of the corresponding pixel. The $z$
coordinate of the vertices of the rectangular are adjusted so that 
\begin{example}
  1) The rectangle is flat
  2) The rectangle contacts the unsegmented surface two diagonally opposite vertices.
  3) The other two diagonnaly opposite vertices will be as close as possible in the
     least squares sense from the unsegmented surface.
\end{example}

When the \vn{type} component is set to \vn{Off}, the grid will not be used.

%-----------------------------------------------------------------
\section{Walls: Vacuum Chamber, Capillary and Diffraction Plate}
\label{s:wall}
\index{wall}

The \vn{wall} attribute for an element is used to define:
\begin{example}
  vacuum chamber wall
  capillary element (\sref{s:capillary}) inside wall
  diffraction_plate (\sref{s:diff.plate}) geometry
\end{example}

The topics of the following subsections are:
\begin{example}
  \sref{s:wall.syntax}      General wall syntax.
  \sref{s:wall.section}      Cross-section construction. 
  \sref{s:wall.interpolation}      Capillary and vacuum chamber wall interpolation.
  \sref{s:wall.capillary}      Capillary specific.
  \sref{s:wall.vacuum}      Vacuum chamber specific.
  \sref{s:wall.diff.plate}      Diffraction_plate specific.
\end{example}

%-----------------------------------------------------------------
\subsection{Wall Syntax}
\label{s:wall.syntax}

The syntax of the \vn{wall} attribute is:
\begin{example}
  wall = \{
    superimpose = <T/F>,                     ! Chamber wall only
    thickness = <real>                       ! Diffraction_plate only
    opaque_material = <material_type>        ! Diffraction_plate only
    clear_material = <material_type>         ! Diffraction_plate only
    section = \{ 
      type = <section_type>,                 ! Chamber and Diffraction_plate only
      s = <longitudinal_position>,           ! Capillary and Chamber only
      x0 = <value>,
      y0 = <value>,
      dr_ds = <value>,                       ! Capillary and Chamber only
      v(1) = \{<x>, <y>, <radius_x>, <radius_y>, <tilt>\}, 
      v(2) = \{ ... \},
      ...\},
    section = \{
      s = <longitudinal_position>, 
      v(1) = \{... \},
      ... \},
    ... \}
\end{example}
A \vn{wall} begins with ``\vn{wall = \{}'' and ends with a
``\vn{\}}''. In between are a number of individual cross-section
structures. Each individual cross-section begins with ``\vn{section =
\{}'' and ends with a ``\vn{\}}''. The \vn{s} parameter of a
cross-section gives the longitudinal position of the cross-section.
Example:
\begin{example}
  this_cap: capillary, 
    wall = \{   
      section = \{ ! cross-section with top/bottom symmetry
        s = 0, v(1) =  \{0.02, 0.00\}, 
        v(2) = \{0.00, 0.02, 0.02\}, v(3) = \{-0.01, 0.01\} \}, 
      section = \{  ! Cross-section that is a tilted ellipse.
        s = 0.34, 
        v(1) = \{0.003, -0.001, 0.015, 0.008, 0.2*pi\} \} \}
\end{example}
In this example an element called \vn{this_cap} is a \vn{capillary}
whose wall is defined by two cross-sections.

%------------------

\begin{figure}[tb]
  \centering
  \includegraphics[width=6in]{chamber-wall.pdf}
  \caption[Capillary or vacuum chamber wall.]
{A) The inside wall of a capillary or the vacuum chamber wall of a
non-capillary element is defined by a number of cross-sectional
slices.  B) Each cross-section is made up of a number of vertices. The
segments between the vertices can be either a line segment, the arc of
a circle, or a section of an ellipse.}
  \label{f:chamber.wall}
\end{figure}

%-----------------------------------------------------------------
\subsection{Wall Sections}
\label{s:wall.section}

The wall is defined by a number of cross-sectional slices. For
\fig{f:chamber.wall}A shows the geometry for \vn{capillary} or vacuum
chamber walls.  Each cross-section is defined by a number of
vertices. The verticies are defined with respect to the local sector
origin $(x_0, y_0)$. The arc between each vertex may be either a
straight line, an arc of a circle, or a section of an ellipse. For a
capillary it is mandatory that a cross-section be convex. That is,
given any two points within the cross-section, all points on the line
segment connecting them must be within the cross-section.

The \vn{v(<j>)} within a cross-section define the vertices for each
cross-section. The vertices are defined with respect to the section
origin given by \vn{x0} and \vn{y0}. Each \vn{v(<j>)} has five
parameters. It is mandatory to specify the first two parameters
\vn{<x>} and \vn{<y>}. Specifying the rest, \vn{<radius_x>},
\vn{<radius_y>}, and \vn{<tilt>}, is optional. The default values, if
not specified, is zero. The point (\vn{<x>}, \vn{<y>}) defines the
position of the vertex. The parameters \vn{<radius_x>},
\vn{<radius_y>}, and \vn{<tilt>} define the shape of the segment of
the cross-section between the given vertex and the preceding one.
\begin{example}
  <radius_x>  = 0, <radius_y>  = 0   --> Straight line segment.
  <radius_x> != 0, <radius_y>  = 0   --> Circular arc with radius = radius_x
  <radius_x>  = 0, <radius_y> != 0   --> Illegal!
  <radius_x> != 0, <radius_y> != 0   --> Ellipse section.
\end{example}
When an ellipse is specified, \vn{<radius_x>}, and \vn{<radius_y>} are
the half width and half height of the semi-major axes and the
\vn{<tilt>} parameter gives the tilt of the ellipse. \vn{<radius_x>}
and \vn{<radius_y>} must not be negative.

In the example above, for the first cross-section, \vn{v(2)}
specifies a non-zero \vn{<radius_x>} and, by default, \vn{<radius_y>}
is zero. Thus the segment of the cross-section between \vn{v(1)} and
\vn{v(2)} is circular in nature with a radius of 0.02. Since \vn{v(3)}
does not specify \vn{<radius_x>} nor \vn{<radius_y>}, the
cross-section between \vn{v(2)} and \vn{v(3)} is a straight line
segment.

The vertex points must be arranged in a ``counter clockwise manner''. 
For vertices \vn{<v(i)>} and \vn{<v(i+1)>} connected by a line segment
this translates to
\Begineq
  0 < \theta_{i+1} - \theta_{i} \pmod{2\pi} < \pi
\Endeq
where $(r_n, \theta_n)$ are the polar coordinates of the $n^{th}$
vertex. For vertices connected by an arc, ``counter clockwise manner''
means that the line segment with one end at the center of the arc and
the other end traversing the arc from \vn{<v(i)>} to \vn{<v(i+1)>}
rotates in counter clockwise as shown in
\fig{f:chamber.wall}B. 

The red line segment with one end at the center of the arc and the
other end traversing the arc from, in this case, $V(2)$ to $V(3)$,
rotates in counter clockwise manner. In general, there are two
solutions for constructing such an arc. For positive radii, the
solution chosen is the one whose center is closest to the section
origin $(x_0, y_0)$. If the radii are negative, the center point will
be the point farthest from the origin (the dashed line between $V(2)$
and $V(3)$ in the figure).

A restriction on cross-sections is that the section origin $(x_0,
y_0)$ must be in the interior of any cross-section and that for any
cross-section a line drawn from the origin at any given angle $\theta$
will intersect the cross-section at exactly one point as shown in
\fig{f:chamber.wall}B. This is an important point in the construction
of the wall between cross-sections as explained below.

The last vertex specified, call it \vn{<v(n)>}, should not have the
same \vn{<x>}, \vn{<y>} values as the first vertex \vn{<v(1)>}. That
is, there will be a segment of the cross-section connecting
\vn{<v(n)>} to \vn{<v(1)>}. The geometry of this segment is determined
by the parameters of \vn{<v(1)>}.

If there is mirror symmetry about the $x$ or $y$ axis for a
cross-section, the ``mirrored'' vertices, on the ``negative'' side of
the mirror plane, do not have to be specified. Thus if all the vertex
points of a cross-section are in the first quadrant, that is, all
\vn{<x>} and \vn{<y>} are zero or positive, mirror symmetry about both the
$x$ and $y$ axes is assumed. If all the \vn{<y>} values are zero or
positive and some \vn{<x>} values are positive and some are negative,
mirror symmetry about the $x$ axis is assumed. Finally, if all the
\vn{<x>} values are zero or positive but some \vn{<y>} values are
positive and some are negative, symmetry about the $y$ axis is
assumed. For example, for the first in the above example, since
all the \vn{<y>} values are non-negative and there are positive and
negative \vn{<x>} values, symmetry about the $x$ axis is assumed.

The one exception to the above rule that (\vn{<x>}, \vn{<y>}) is the
vertex center is when a single vertex \vn{v(1)} is specified for a
cross-section with a non-zero \vn{<radius_x>}. In this case,
(\vn{<x>}, \vn{<y>}) are taken to be the center of the circle or
ellipse. In the example above, the second cross-section is a
tilted ellipse with center at $(0.003, -0.001)$. If a cross-section
has a single vertex and \vn{<radius_x>} is
not specified, the cross-section is a rectangle. For example
\begin{example}
    section = \{ s = 0.34, v(1) = \{0.03, 0.01\} \}
\end{example}

%-----------------------------------------------------------------
\subsection{Interpolation Between Sections}
\label{s:wall.interpolation}

\begin{figure}[tb]
  \centering
  \includegraphics[width=4in]{concave-capillary.pdf}
  \caption[Convex cross-sections do not guarantee a convex volume.]
{Example where convex cross-sections do not produce a convex volume.
Cross-sections (A) and (C) are ellipses with a 5 to 1 aspect ratio.
Half way in between, linear interpolation produces a convex cross-section
as shown in (B).} 
  \label{f:concave.capillary}
\end{figure}

For \vn{capillary} and vacuum chamber walls, the wall between
cross-sections, is defined by interpolation. Let $r_{c1}(\theta)$ be
the radius of the wall as a function of $\theta$ for a given
cross-section defined at $s = s_1$. Let $r_{c2}(\theta)$ be the radius
function at the next defined cross-section at $s = s_2$. The wall
$r_c(\theta, s)$ at any point $s$ between $s_1$ and $s_2$ is defined
by the equation
\Begineq
  r_c(\theta, s) = p_1(\stilde) \, r_{c1}(\theta) + p_2(\stilde) \, r_{c2}(\theta)
\Endeq
where 
\Begineq
  \stilde \equiv \frac{s - s_1}{s_2 - s_1}
\Endeq
and $p_1$ and $p_2$ are cubic polynomials parameterized by
\begin{align}
  p_1 &= 1 - \stilde + a_1 \, \stilde + a_2 \, \stilde^2 + a_3 \, \stilde^3 \CRNO
  p_2 &= \stilde + b_1 \, \stilde + b_2 \, \stilde^2 + b_3 \, \stilde^3 
\end{align}
If $a_i = b_i = 0$ for all $i = 1, 2, 3$, the interpolation is linear
and this is the default if either of the parameters \vn{dr_ds1} and
\vn{dr_ds2} are not given in the wall definition. These parameters are
the slopes of the wall with respect to $s$ at the end points
\begin{equation}
  \mbox{dr_ds1} \equiv \left. \frac{d\overline{r}}{ds} \right|_{s = s_1} \comma \qquad
  \mbox{dr_ds2} \equiv \left. \frac{d\overline{r}}{ds} \right|_{s = s_2} 
\end{equation}
where $\overline{r}$ is the average $r$ averaged over all
$\theta$. When {\em both} \vn{dr_ds1} and \vn{dr_ds2} are specified, the $a_i$
and $b_i$ are calculated so that the slopes of the wall match 
the values of \vn{dr_ds1} and \vn{dr_ds2} along with the constraints.
\begin{align}
  p_1(0) &= 1 \comma \qquad p_1(1) = 0 \CRNO
  p_2(0) &= 0 \comma \qquad p_2(1) = 1 \\
  M &\equiv a_1^2 + a_2^2 + a_3^2 + b_1^2 + b_2^2 + b_3^2 \mbox{ is a minimum}
  \nonumber
\end{align}
The last constraint ensures a ``smooth'' transition between the two cross-sections.

To refer to a cross-section parameters after an element has been
defined, the following syntax is used:
\begin{example}
  ele_name[wall.section(n).v(j).x]   ! x value of j^th vertex of n^th cross-section
\end{example}

%-----------------------------------------------------------------
\subsection{Capillary Wall}
\label{s:wall.capillary}
\index{capillary!wall}

For a \vn{capillary}, \vn{s} must be zero for the first cross-section and
the length of the capillary is given by the value of \vn{s} of the
last cross-section.

For a \vn{capillary}, in order for \bmad to quickly track photons,
\bmad assumes that the volume between the cross-sections is
convex. The volume will be convex if each cross-section $r_c(\theta,
s)$ at any given $s$ is convex. Note that it is {\em not} sufficient
for $r_c(\theta, s)$ to be convex at the specified cross-sections as
shown in \fig{f:concave.capillary}. Also note that it is perfectly
fine for the total capillary volume to not be convex.

%-----------------------------------------------------------------
\subsection{Vacuum Chamber Wall}
\label{s:wall.vacuum}

The vacuum chamber wall is independent of the element apertures
(\sref{s:limit}). Unless a program is specifically constructed, the
presence of a vacuum chamber wall will not affect particle tracking.

The vacuum chamber wall defined for an element may be shorter or
longer than the element.  The vacuum chamber wall for a particular
lattice branch is the sum of all the chamber walls of the individual
elements. That is, the chamber wall at any given point is determined
by interpolation of the nearest sections upstream and downstream to
the point.  Thus a given lattice element need not contain a \vn{wall}
component for the chamber wall to be well defined at the element. 

The exception to the above rule is when a \vn{section} has its
\vn{type} component set to either:
\begin{example}
  wall_start
  wall_end
\end{example}
If a section has a \vn{type} of \vn{wall_start}, the region between
that section and the previous section will be considered to have no
wall. If the \vn{wall_start} section is the first section of the
containing lattice branch, and if the lattice branch has an open
geometry, then the region of no wall will start at the end of the
branch. Similarly, if a section has a \vn{type} of \vn{wall_end}, the
region between that section and the next section (or the end of the
lattice branch if there is no next seciton and the branch has an open
geometry) will not have a wall.

The chamber walls of any two elements may not overlap. The exception
is when the \vn{superimpose} attribute for a wall of an element is set
to True. In this case, any other wall cross-sections from any other
elements that overlap the superimposed wall are discarded.
Superposition of a wall is useful, for example, in introducing mask
regions into the wall.

If a branch has a closed geometry (\sref{s:param}), wall sections that
extend beyound the ends of the branch are ``wrapped'' around.

If a particle is past the last wall cross-section or before the first
wall cross-section, The following rules are used: If the branch has a
\vn{closed geometry}, the wall will be interpolated between the last
and first cross-sections. If the branch has an \vn{open} geometry, the
wall is taken to have a constant cross-section in these regions. 

The chamber wall is defined with respect to the local coordinate
system (\sref{s:ref}). That is, in a bend a wall that has a constant
cross section is a section of a torus.

\index{patch!and chamber wall}
\vn{Patch} elements complicate the wall geometry since the coordinate
system at the end of the \vn{patch} may be arbitrarily located
relative to the beginning of the patch. To avoid confusion as to what
coordinate system a wall section belongs to, \vn{patch} elements are
not allowed to define a wall. The wall through a patch is determined
by the closest wall sections of neighboring elements. These wall
sections need to be placed at the edge of the \vn{patch}.

%-------------------

\begin{figure}[tb]
  \centering
  \includegraphics[width=6in]{crotch.pdf}
  \caption[vacuum chamber crotch geometry.]
{A) Crotch geometry: Two pipes labeled ``leg1'' and ``leg2'' merge
into a single pipe called the ``trunk'' pipe. Five wall sections are
used to define the crotch geometry (solid lines). Dashed lines
represent sections not involved in defining the crotch. For purposes
of illustration the three trunk sections are displaced longitudinally
but in reality must have the same longitudinal coordinate.  B) Example
layout of the crotch1, crotch2 and crotch wall sections. $O_1$, $O_2$
and $O$ are the $x_0, y_0$ origins of the sections.}
  \label{f:crotch}
\end{figure}

%-------------------

\index{crotch chamber geometry}
Each section has a \vn{type} attribute. This attribute is not used for 
\vn{capillary} elements. For a vacuum chamber wall, the \vn{type} 
attribute is used to dscribe a ``crotch'' geometry where
two pipes merge into one pipe. The possible values for the \vn{type} 
attribute are:
\begin{example}
  normal     ! default
  leg1
  leg2
  trunk1
  trunk2
  trunk
\end{example}
The geometry of a crotch is shown in \fig{f:crotch}A. Two pipes,
called ``leg1'' and ``leg2'', merge into one pipe called the ``trunk''
pipe.  The trunk pipe can be either upstream or downstream of the leg
pipes.  To describe this situation, five sections are needed: One
section in each leg pipe which need to have their \vn{type} attribute
set to \vn{leg1} and \vn{leg2}, and three sections in the trunk with
one having a a \vn{type} attribute of \vn{trunk1}, another having a
\vn{type} attribute of \vn{trunk2} and the third haveing a \vn{type}
attribute of \vn{trunk}. There can be no sections between the leg
sections and the trunk sections.

All three trunk sections must be associated with the same element and
have the same \vn{s} value. In the list of sections of the element
containing the trunk elements, the \vn{trunk1} and \vn{trunk2}
sections must be listed first if the leg pipes are upstream of the
trunk pipe (the situation shown in the figure) and must be listed last
if the leg pipes are downstream. That is, the \vn{trunk1} and
\vn{trunk2} sections are ``between'' the leg sections and the
\vn{trunk} section. It does not matter if \vn{trunk1} is before or
after \vn{trunk2}.

The \vn{trunk1} and \vn{trunk2} sections must not overlap and the
\vn{trunk} section must be constructed so that its area is the union
of the areas of \vn{trunk1} and \vn{trunk2}. An example is illustrated
in \fig{f:crotch}B. Here the \vn{trunk1} and \vn{trunk2} sections are
squares with origins labeled $O_1$ and $O_2$ in the figure. By
necessity, these origins must be different since each must lie within
the boundaries of their respective areas. The \vn{trunk} section is a
rectagle encomposing the two squares and has an origin labeled $O$.

Between \vn{leg1} and \vn{trunk1} sections the wall is interpolated
using these two section. Similarly for the region between \vn{leg2}
and \vn{trunk2} sections. Away from these regions interpolation is
done as outlined above but these regions need a different
interpolation scheme since, \vn{leg1} and \vn{trunk1}, as well as
\vn{leg2} and \vn{trunk2} sections do not have to be parallel to each
other.

%-----------------------------------------------------------------
\subsection{Diffraction Plate Wall}
\label{s:wall.diff.plate}

\begin{figure}[tb]
  \centering
  \includegraphics[width=5in]{diffraction-plate.pdf}
  \caption[Example diffraction_plate element]{
A) The diffraction plate surface is divided into ``clear'' (white) and
``opaque'' (black) areas. In this example there are two clear sections
labeled \#1 and \#2. B) All wall sections must be star shaped with
respect to the section's origin. In this example, The section is {\em
not} star shaped since a line drawn from the origin point $o$ to the
point $p$ on the boundary intersects the boundary twice in between. In
this case the section can be made star shaped by moving the origin to
$o'$.
  }
  \label{f:diff.plate}
\end{figure}

The \vn{wall} of a \vn{diffraction_plate} (\sref{s:diff.plate})
specifies the topology of the plate in terms of what areas of the
plate will transmit or reflect X-rays and what areas will not.  The
areas where there is transmission or reflection are called ``clear''
areas and everything else is called ``opaque''. 

A \vn{wall} is comprised a a ordered list of \vn{sections} as
discussed in \sref{s:wall.section}. Each section of a
\vn{diffraction_plate} element must have its \vn{type} attribute set
to one of:
\begin{example}
  clear
  mask
\end{example}
A section is called ``clear'' or ``mask'' depending upon the setting
of its \vn{type} attribute. Do not confuse ``clear section'' with 
``clear area''.

A clear area is defined by one or more consecutive wall sections. The
first section that defines a clear area must be a clear section.  All
the other sections associated with a clear area must be mask sections.
That is, a clear area starts with a clear section and any preceeding
mask sections up to the next clear section or the end of the section
list. As a consequence of the above rules, the fist section of the
wall must be a clear section and the number of clear areas is equal to
the number of clear sections.

The default behavior is that a photon will be transmitted if it is
within any clear area. A photon is considered to be within a given
clear area if its $(x,y)$ coordinates put in within the corresponding
clear section but not within any mask section of the clear area.



To enable \bmad to quickly calculate whether a photon has landed on a
clear or mask section, All sections, both clear and mask, must be
``star shaped'' with respect to the $(x_0, y_0)$ origin used by the
section. That is, a line drawn from the section origin to any point on
the section boundary must not pass through any boundary points of the
section in between. This is illustrated in \fig{f:diff.plate}B where
the section is not star shaped since a line drawn from the origin $o$
to the point $p$ on the boundary passes through two boundary points in
between. In this case the section can trivially be made star shaped by
moving the origin to point $o'$. If it is not possible to make a
section star shaped by moving the origin, the section must be divided
into multiple sections.

An example diffraction plate geometry is shown in \fig{f:diff.plate}A.
In the figure, there are two openings labeled \#1, and \#2. A
wall that constructs this geometry is:
\begin{example}
  zone1: diffraction_plate, wall = \{
    thickness = <real>
    opaque_material = <material_type>
    clear_material = <material_type>
    section = \{           ! Clear area \# 1
      type = clear, 
      v(1) = \{0.04, 0\}, v(2) = \{0.04, 0.022\},
      v(3) = \{0, 0.03\},
    section = \{
      type = mask,
      v(1) = \{0.032, 0.016\},
    section = \{          ! Clear area \# 2
      type = clear,
      v(1) = \{0, 0, 0.03, 0.013\},
    section = \{
      type = mask,
      v(1) = \{0, 0, 0.005\},
    section = \{
      type = mask,
      x0 = 0.02,
      v(1) = \{0, 0, 0.005\} \}
\end{example}
Clear area \#1 has a clear section and one mask section. These
sections rely on the four fold symmetry of the sections so that only
points in the first quadrant need be specified. Clear area \#2 has one
clear section in the shape of an ellipse with two mask circles.

Sections may overlap and a mask section does not have to be wholly
within the corresponding clear section.

%-----------------------------------------------------------------
\section{Length Attributes}
\label{s:l}

\index{length of elements}
\index{l|hyperbf}
\index{l_chord|hyperbf}
\index{rbend}
\index{sbend}
The length attributes are
\begin{example}
  l       = <Real>  ! 
  l_chord = <Real>  ! Chord length of a bend. Dependent attribute.
\end{example}
The length \vn{l} is the path length of the reference particle. The
one exception is for an \vn{rbend}, the length \vn{l} set in the
lattice file is the chord length (\sref{s:bend}). internally, \bmad
converts all \vn{rbend}s to \vn{sbend}s and stores the chord length
under the \vn{l_chord} attribute.
Example:
\begin{example}
  q: quadrupole, l = 0.6, k1 = 0.3425
\end{example}

\index{wiggler}
Note that for \vn{wiggler}s, the length \vn{l} is not the same as the
path length for a particle with the reference energy starting on the
reference orbit. See~\sref{s:ref}.

\index{patch}
For \vn{patch} elements the \vn{l} length is, by definition, equal to
\vn{z_offset}. For \vn{patch} elements, \vn{l} is a dependent
attribute and will be automatically set to \vn{z_offset} by \bmad.

\index{capillary}
The length of a \vn{capillary} element is a dependent variable and is
given by the value of \vn{s} of the last wall cross-section
(\sref{s:wall.capillary}).

%-----------------------------------------------------------------
\section{Is_on Attribute}
\label{s:is.on}
\index{is_on|hyperbf}

The \vn{is_on} attribute
\begin{example}
  is_on = <Logical>
\end{example}
is used to turn an element off. Turning
an element off essentially converts it into a drift.
Example
\begin{example}
  q1: quad, l = 0.6, k1 = 0.95
  q1[is_on] = False
\end{example}

\index{aperture}
\index{reference orbit}
\index{reference energy}
\vn{is_on} does not affect any apertures that are set. Additionally,
\vn{is_on} does not affect the reference orbit. Therefore, turning 
off an \vn{lcavity} will not affect the reference energy.

%-----------------------------------------------------------------
\section{Multipole Attributes: An, Bn, KnL, Tn}
\label{s:multip}

\index{multipole!an, bn|hyperbf} 
\index{multipole!knl, tn|hyperbf} 
\index{ab_multipole}
\index{multipole}
\index{radius}
A \vn{multipole} (\sref{s:mult}) element specifies its multipole
components using an Amplitude (\vn{KnL}) and a tilt (\vn{Tn})
\begin{example}
  KnL = <Real>
  Tn  = <Real>  ! Default is $pi$/(2n + 2)
\end{example}
\vn{ab_Multipole} (\sref{s:ab.m}) and all other elements that
have multipole attributes specify the multipoles using normal
(\vn{Bn}) and skew (\vn{An}) components 
\begin{example}
  An = <Real>
  Bn = <Real>
\end{example}
Here \vn{n} ranges from 0
(dipole component) through 20. Example:
\begin{example}
  q1: ab_multipole, b0 = 0.12, a20 = 1e7
\end{example}

Multipole formulas for are given in \sref{s:fields}.  Note that for
\vn{multipole} and \vn{ab_multipole} (but not any other element) a
non-zero dipole component will affect the reference orbit (just like a
normal dipole will).

The \vn{Tn} tilt component without a value takes a default of $pi$/(2n
+ 2) which makes the component \vn{skew}.  Example:
\begin{example}
  m: multipole, k1l = 0.45, t1  ! Skew quadrupole
\end{example}

For everything other than a \vn{multipole} and \vn{ab_multipole}, the
multipole strength is scaled by a factor $F \, r_0^{n_\text{ref}} /
r_0^n$ (cf.~\Eq{ababf}) where $F$ is the strength of the element (for
example $F$ is $K1 \cdot L$ for a quadrupole), and $r_0$ is the
``measurement radius'' and is set by the \vn{radius} attribute. The
default value of $r_0$, if the \vn{radius} is not given, is 1.0.  This
behavior may be turned off by setting the \vn{scale_multipoles}
attribute.  Example:
\begin{example}
  q1: quadrupole, b0 = 0.12, a20 = 1e7, scale_multipoles = F
\end{example}

%-----------------------------------------------------------------
\section{Specifying Electromagnetic Fields Via Tables or Maps}
\label{s:em.fields}

\index{lcavity}\index{rfcavity}\index{em_field}\index{field}
3D Electromagnetic fields can be specified using the \vn{field}
attribute. Fields so specified can be used with, for example,
\vn{runge_kutta} tracking (\sref{s:tkm}), etc. The \vn{field}
attribute can be used with both RF and DC fields however RF fields can
only be associated with \vn{lcavity}, \vn{rfcavity}, and \vn{em_field}
elements.

The syntax for specifying the electromagnetic fields is
\index{m}\index{field}\index{mode}\index{freq}\index{dphi0_ref}
\index{f_damp}\index{field_scale}\index{master_scale}\index{phi0_azimuth}
\index{map}\index{grid}
\begin{example}
  field = \{
    mode = \{
      m             = <Integer>, ! Mode number
      harmonic      = <Integer>, ! Harmonic number 
      dphi0_ref     = <Real>,    ! Phase of oscillations.
      f_damp        = <Real>,    ! Oscillation damping factor. Default = 0.
      field_scale   = <Real>,    ! Scale factor for the E & B fields.
      master_scale  = <Name>,    ! Master scaling parameter for E & B fields.
      phi0_azimuth  = <Real>,    ! Azimuthal orientation.
      map           = <EM_field_map>,        ! EM field map data
      grid          = \{<EM_field_grid>\} \},    ! EM field grid data
    mode = \{...\}\}
\end{example}
The electromagnetic field is specified as a series of \vn{modes}. Each
\vn{mode} has a \vn{harmonic} number which, if non-zero, identifies it
as an RF field. The field associated with a mode can be specified
using a \vn{grid} of data points or by a \vn{map} which specify the
coefficients of an analytical form for the field.

The field is scaled by two values specified by \vn{field_scale} and
\vn{master_scale}. That is
\begin{equation}
  [E, B] (actual) = [E, B] (from map or grid) * field_scale * master_scale_value
\end{equation}
That is, the actual field is the value as determined from the \vn{map}
or \vn{grid} data (see below) scaled by the value of \vn{field_scale}
times the ``master_scale_value''. This master_scale_value is the value
of the element parameter given by \vn{master_scale}. For example, for
a quadrupole element, if \vn{master_scale} is set to "K1" then the
fields are scaled by the quadrupole strength parameter. The purpose of
this \vn{master_scale} is to provide a way to scale the 3D fields with
the element strength parameter (K1 for a quadrupole) and also provide
a way to scale separate \vn{mode}s jointly.

The \vn{map} specification has the form
\begin{example}
  map = \{
    dz        = <Real>,    ! Distance between sampled field points.
    e_coef_re = (<Real>, <Real>, ....),  ! Real part of e.
    e_coef_im = (<Real>, <Real>, ....),  ! Imaginary part of e.
    b_coef_re = (<Real>, <Real>, ....),  ! Real part of b.
    b_coef_im = (<Real>, <Real>, ....),  ! Imaginary part of b.
  \}
\end{example}
For rf fields the basic equations used for the mode decomposition of
the rf fields are given in Section~\sref{s:rf.fields.phys}. 
\vn{e_re} and \vn{e_im} give the real an imaginary part of $e$ and
\vn{b_re} and \vn{b_im} give the real and imaginary part of $b$. All
of these vectors must be present and have the same length. The
exception is with an $m = 0$ mode either the $e$ or $b$ arrays can be
omitted and will default to zero. The number of terms $N$ for the $e$
or $b$ vectors must be a power of $2$ and all modes must have the same
number of terms. The $n$\Th element in the $e$ or $b$ arrays, with $n$
running from 0 to $N-1$, is associated with a wavelength $k_n$
\begin{equation}
  k_n = \begin{cases}
    \frac{2 \, \pi \, n}{N \, dz} & n < \frac{N}{2} \\
    \frac{2 \, \pi \, (n-N)}{N \, dz} & \mbox{otherwise}
  \end{cases}
\end{equation}
This convention follows the convention used by Numerical
Recipes\cite{b:nr}.  

The longitudinal length
of the field is
\begin{equation}
  L_{\mbox{field}} = \frac{N - 1}{dz}
\end{equation}
this may be different from the length \vn{l} specified for the
element. If there is a difference, the field is assumed to be centered
on the element and drifts will be used at the entrance and exit ends
of the element to make up the difference.

Alternatively, a grid of field points may be specified. The general format is:
\begin{example}
  grid = \{ 
    type = <String>,
    r0   = (<Real>, <Real>, <Real>),  ! Grid origin 
    dr   = (<Real>, <Real>, <Real>),  ! Grid spacing
    ele_anchor_pt = <Position>        ! BEGINNING, CENTER, or END
    pt(<Integer>, <Integer>, <Integer>) = ( (<Real>, <Real>), \ldots ),  ! Grid field points
    \ldots \}
\end{example}
Currently the only available value for the grid \vn{type} is 
\begin{example} 
  rotationally_symmetric_rz
\end{example} 
The format for this type of grid is 
\begin{example}
  grid = \{ 
    type = rotationally_symmetric_rz,
    r0   = (<r(0,0)>,  <z(0,0)>),     ! Grid origin 
    dr   = (<delta_r>, <delta_z>),    ! Grid spacing
    pt(i_r, i_z) = ((<Re(E_r)>, <Im(E_r)), (<Re(E_phi)>, <Im(E_phi)>), 
                                             (<Re(E_z)>, <Im(E_z)>))
    \ldots \}
\end{example}

The field of a given mode oscillates as given by Eq.~\ref{eseei}  
\Begineq
  e^{-i \, 2 \, \pi ( f \, t + \theta_0)}
\Endeq
The phase of the oscillation, $\theta_0$ comes from two
sources: the phase \vn{dphi0_ref} set for the mode and an overall phase
\vn{phi_ref} given by
\begin{example}
 phi_ref = phi0 + dphi0
\end{example}
\index{lcavity!reference phase}\index{rfcavity!reference phase}
Unfortunately, to be consistent with \mad, the definition of
\vn{phi_ref} for an \vn{lcavity} (\sref{s:lcav}) differs in sign to
that for an \vn{rfcavity} (\sref{s:rfcav}). This being the case,
$\theta_0$ is
\Begineq
  \theta_0 = 
  \begin{cases}
    \mbox{dphi0_ref} + \dsfrac{f}{f_0} \, (\mbox{phi_ref} + \mbox{phi0_err}) & 
    \mbox{lcavity element} \\
    \mbox{dphi0_ref} - \dsfrac{f}{f_0} \, \mbox{phi_ref} & 
    \mbox{rfcavity element}
  \end{cases}
\Endeq
where $f$ is the mode frequency and $f_0$ is the frequency of the fundamental.

The phase \vn{dphi0_ref} of the fundamental mode is auto-scaled by Bmad
so that a particle with $z = 0$ will go through the cavity on crest
for a \vn{lcavity} and on the zero-crossing for an
\vn{rfcavity}. Additionally, the field of the fundamental mode is
adjusted by an overall factor so that for an \vn{lcavity} the maximal
acceleration is equal to \vn{gradient * L} and for an \vn{rfcavity}
the maximal acceleration is equal to \vn{e * voltage}.

%-----------------------------------------------------------------
\section{RF Couplers}
\label{s:rf.coupler}

\index{lcavity}\index{rfcavity}
\index{coupler_at}\index{coupler_strength}
\index{coupler_angle}\index{coupler_phase}
For \vn{lcavity} and \vn{rfcavity} elements, the attributes that
characterize the dipole transverse kick due to a coupler port are:
\begin{example}
  coupler_at       = <Switch> ! What end the coupler is at
  coupler_strength = <Real>   ! Normalized strength
  coupler_angle    = <Real>   ! Polarization angle (rad/2\(\pi\))
  coupler_phase    = <Real>   ! Phase angle with respect to the RF (rad/2\(\pi\))
\end{example}
The possible \vn{coupler_at} settings are:
\begin{example}
  entrance_end
  exit_end  ! default
  both_ends
\end{example}
The kick due to the coupler is
\begin{example}
  dP_x = amp * cos(phase) * cos(angle) 
  dP_y = amp * cos(phase) * sin(angle)
  dE   = amp * (cos(angle) * x + sin(angle) * y) * sin(phase) * twopi * rf_frequency / c_light 
\end{example}
where \vn{dP_x} and \vn{dP_y} are the transverse momentum kicks, \vn{dE} is an energy kick, and
\begin{example}
  amp   = gradient * coupler_strength 
  phase = twopi * (phi_particle + phi_ref + coupler_phase)         ! For lcavity \sref{s:lcav}
        = pi/2 + twopi * (phi_particle - phi_ref + coupler_phase)  ! For rfcavity \sref{s:lcav}
  angle = twopi * coupler_angle
\end{example}
The energy kick is needed to keep things symplectic. 

Example:
\begin{example}
  rf1: lcav, l = 4.5, gradient = 1.2e6, coupler_at = both_ends, rf
                                                  coupler_strength = 0.037
\end{example}

%-----------------------------------------------------------------
\section{RF Wakes}
\label{s:rf.wakes}

Wake fields can be specified for \vn{lcavity} and \vn{rfcavity} elements.
The attributes that characterize the wakes are:
\index{sr_wake_file}\index{lr_wake_file}\index{lr_freq_spread}
\begin{example}
  sr_wake_file     = <String> ! Short range wake field definition file.
  lr_wake_file     = <String> ! Long range wake field definition file.
  lr_freq_spread   = <Real>   ! Frequency spread of the LR wake fields.
\end{example}

The formulas used to compute the wake field are given in
\sref{s:wake.fields}.  The input file name for the short--range
wake fields is specified using the \vn{sr_wake_file} attribute. The
file gives both monopole longitudinal and dipole transverse
wakes. Comment lines may be included by starting a line with an
exclamation mark (!). Blank lines are also ignored.  An example input
file is:
\begin{example}
  !    z           Wz             Wt
  !   [m]       [V/C/m]       [V/C/m^2]
   0.000E+00  1.61125E+15   0.00000E+00     1 
  -1.000E-05  1.44516E+15  -1.30560E+15     2 
  -2.000E-05  1.38148E+15  -2.50665E+15     3 
  .. etc ..
  -1.970E-03  3.49958E+14  -7.95507E+16   198 
  -1.980E-03  3.48606E+14  -7.97253E+16   199  
  -1.990E-03  3.47263E+14  -7.98989E+16   200
     END_SECTION


  ! Pseudo Wake modes:
  !                      Amp       damp          k      phase
  ! Longitudinal:      [V/C/m]     [1/m]      [1/m]     [rad]  
  ! Transverse:      [V/C/m^2]     [1/m]      [1/m]     [rad]  

  &short_range_modes
    longitudinal(1) = 3.23e14     1.23e3     3.62e3     0.123
    longitudinal(2) = 6.95e13     5.02e2     1.90e3    -1.503
    .. etc ..
    transverse(1) =   4.23e14     2.23e3     5.62e3     0.789
    transverse(2) =   8.40e13     5.94e2     1.92e3     1.455
     .. etc ..
    z_max = -1.3e-3
  /
\end{example}
The file is divided into two sections with a line containing the word
\vn{END_SECTION} marking the division between the sections.  Wakes can
be specified via a table of wake versus longitudinal position $z$
and/or using a set of ``pseudo'' modes (\sref{s:wake.fields}). The
first section gives the wake vs $z$ table, and the second section
gives the longitudinal monopole and transverse dipole pseudo modes.
The range of the table is from $0$ to $z_{cut}$ where $z_{cut}$ is the
$z$ value in the last line of the table. If the longitudinal distance
$dz$ between two particles is within the range of the table then the
table will be used to calculate the wake kick for this pair. If $dz$
is larger than $z_{cut}$ the pseudo modes will be used. The pseudo
modes are valid from $z_{cut}$ to \vn{z_max}. 

In the first section with the table of wake vs. $z$, the first column is the
longitudinal distance $z$. $z$ must start at 0 and must increment by the a
constant amount from row to row. $z$ is negative since the wake extends behind
a particle. The second column is the longitudinal wake function in $V/C/m$. The
third column is the transverse wake in $V/C/m^2$. Any additional columns are
ignored.  Wake field formulas are to be found in \sref{s:wake.fields}.  The
wake field file is only used with macroparticle and particle distribution
tracking.  When the short--range wake field file is used with either of these
the \vn{e_loss} attribute is ignored. However, even in this case, a finite
\vn{e_loss} value will affect the reference energy. Since the quantities like
quadrupole k1 strengths and bend strengths are referenced to the reference
energy, The value of \vn{e_loss} will affect the results even with a
short--range wake field file.

The input file name for the long--range wake fields is specified using
the \vn{lr_wake_file} attribute. The file gives the
wake modes by specifying the frequency (in Hz), R/Q (in
$\Omega$/meter$^{2m}$), Q, and m (order number), and optionally the
polarization angle (in radians/2pi) for each cavity mode. The input
uses Fortran90 namelist syntax: The data begins with the string
\vn{\&long_range_modes} and ends with a \vn{/}. Everything outside is
ignored. Each mode is labeled \vn{lr(i)} where \vn{i} is the mode
index. An example input file is:
\begin{example}
              Freq      R/Q      Q    m   Polar   b_sin  b_cos a_sin  a_cos  t_ref 
                      [Ohm/               Angle 
              [Hz]     m^(2m)]           [Rad/2pi]
  &long_range_modes
    lr(1) = 1.650e9    0.76    7.0e4  1    unpol
    lr(2) = 1.699e9   11.21    5.0e4  1    0.15
    lr(3) =    0       0.57    1.1e6  0    unpol
  /
\end{example}
A frequency of zero is used to designate wakes that are part of the
fundamental accelerating mode. \bmad needs to know if a wake is part
of the fundamental mode due to timing issues as discussed in \sref{s:rf.time}.

If the polarization angle is set to ``\vn{unpolarized}'' the mode is
taken to be unpolarized. [Note: Technically the unpolarized mode is
actually two polarized normal modes. The axes of these two normal
modes can be chosen arbitrary as long as they are at right angles to
each other.]

\vn{lr_freq_spread} is used to randomly spread out the long range mode
frequencies among different cavities. The spread is Gaussian in shape
with an RMS of \vn{lr_freq_spread} * $F$ where $F$ is the frequency of a
mode.  After the long--range modes have been defined they can be
referenced or redefined using the notation
\begin{example}
  lr(n)%freq      ! Frequency
  lr(n)%r_over_q  ! R/Q
  lr(n)%q         ! Q
  lr(n)%angle     ! Polarization Angle
\end{example}
Example:
\begin{example}
  lcav[lr(2)%freq] = 1.1 * lcav[lr(2)%freq] ! Raise frequency by 10\%
\end{example}

Example:
\begin{example}
  rf1: lcav, l = 4.5, gradient = 1.2e6, sr_wake_file = "sr1.dat"
\end{example}

%-----------------------------------------------------------------
\section{Fringe Fields}
\label{s:fringe}
\index{fringe fields}

\index{fringe_type}\index{kill_fringe}
The tracking through the fringe fields of such elements as bends,
quadrupoles, etc is determined by the following element attributes
\begin{example}
  fringe_type    !  
  kill_fringe
\end{example}

The \vn{kill_fringe} may be set to one of
\begin{example}
  no_end               ! Default
  both_ends
  entrance_end
  exit_end
\end{example}
The \vn{kill_fringe} switch is used for vetoing fringe effects at
either of the faces of the element. This is useful in vetoing the
fringe effect in the interior of split elements.

The \vn{fringe_type} may be set to one of the following
\begin{example}
  none              ! Default for non-bend elements.
  basic_bend        ! Default for sbend and rbend elements
  full_bend
  full_straight
\end{example}
The \vn{none} setting ignores any fringe fields and is the default for
\vn{quadrupoles}, \vn{sextupoles}, etc. The \vn{basic bend} setting,
which is the default for \vn{rbend} and \vn{sbend} elements, is
essentially the basic vertical focusing effect that is present when
there is a finite \vn{e1} or \vn{e2} face angle. With
\vn{bmad_standard} tracking, \vn{basic_bend} also includes second
order terms.  In some cases, for instance in a chicane,
\vn{basic_bend} is not good enough. With \vn{full_bend} or
\vn{full_straight}, higher order effects are taken into account.  The
difference between \vn{full_bend} and \vn{full_straight} is that with
\vn{full_bend} the fringe field is calculated assuming that there is
translational invariance along the horizontal $x$ axis (as one would have 
in a bend) and for \vn{full_straight} the fringe_field i

Example:
\begin{example}
  b1: rbend, angle = pi/4, g = 0.3, fringe_type = full_bend
\end{example}

\index{ptc_max_fringe_order}
When using PTC tracking (\sref{s:ptc.intro}), the
\vn{parameter[ptc_max_fringe_order]} (\sref{s:param}) determines the maximum
order of the calculated fringe fields.

\index{permfringe}\index{bendfringe}
For programmers who deal with PTC directly: The translation between
\vn{fringe_type} on the \bmad side and \vn{permfringe} and \vn{bendfringe} 
on the PTC side is:
\begin{center}
\begin{tabular}{lll} \hline 
{\em fringe_type} & {\em permfringe} & {\em bendfringe} \\ \hline
  none            & False            & False            \\    
  basic_bend      & False            & True             \\    
  full_bend       & True             & True             \\    
  full_straight   & True             & False            \\    
\end{tabular}
\end{center}

%-----------------------------------------------------------------
\section{Instrumental Measurement Attributes}
\label{s:meas.attrib}

\index{instrument}\index{monitor}\index{marker}
\index{x_gain_err}\index{y_gain_err}\index{crunch}\index{noise}
\index{x_gain_calib}\index{y_gain_calib}\index{crunch_calib}
\index{x_offset}\index{y_offset}\index{tilt}
\index{x_offset_calib}\index{y_offset_calib}\index{tilt_calib}
\index{de_eta_meas}\index{n_sample}\index{osc_amplitude}

\vn{instrument}, \vn{monitor}, and \vn{marker} elements have special
attributes to describe orbit, betatron phase, dispersion and coupling
measurements. These attributes are:
\hfill\break
\hspace*{0.1in}
\begin{tabular}{llll}
  {\em Attribute}     &            &! {\em Symbol} (\sref{s:meas.calc}) & \\
  \vn{tilt}           &= <Real>    &! $\theta_t$            & See \sref{s:offset} \\ 
  \vn{x_offset}       &= <Real>    &! $x_{\mss{err}}$       & See \sref{s:offset} \\ 
  \vn{y_offset}       &= <Real>    &! $y_{\mss{err}}$       & See \sref{s:offset} \\ 
  \vn{x_gain_err}     &= <Real>    &! $dg_{x,\mss{err}}$    & Horizontal gain error \\ 
  \vn{y_gain_err}     &= <Real>    &! $dg_{y,\mss{err}}$    & Vertical gain error \\ 
  \vn{crunch}         &= <Real>    &! $\psi_{\mss{err}}$    & Crunch angle \\ 
  \vn{tilt_calib}     &= <Real>    &! $\theta_{\mss{err}}$  & tilt angle calibration \\ 
  \vn{x_offset_calib} &= <Real>    &! $x_{\mss{cal}}$       & Horizontal offset calibration \\ 
  \vn{y_offset_calib} &= <Real>    &! $y_{\mss{cal}}$       & Vertical offset calibration \\ 
  \vn{x_gain_calib}   &= <Real>    &! $dg_{x,\mss{cal}}$    & Horizontal gain calibration \\ 
  \vn{y_gain_calib}   &= <Real>    &! $dg_{y,\mss{cal}}$    & Vertical gain calibration \\ 
  \vn{crunch_calib}   &= <Real>    &! $\psi_{\mss{cal}}$    & Crunch angle calibration \\ 
  \vn{noise}          &= <Real>    &! $n_f$                 & Noise factor \\ 
  \vn{de_eta_meas}    &= <Real>    &! $dE/E$                & Percent change in energy \\ 
  \vn{n_sample}       &= <Real>    &! $N_s$                 & Number of sampling points \\ 
  \vn{osc_amplitude}  &= <Real>    &! $A_{\mss{osc}}$       & Oscillation amplitude \\ 
\end{tabular}
\hfill\break
A program can use these quantities to calculate ``measured'' values from the
``laboratory'' values. Here, ``laboratory'' means as calculated from some model lattice.
See \sref{s:meas.calc} for the conversion formulas.
