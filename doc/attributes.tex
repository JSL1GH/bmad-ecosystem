\chapter {Element Attributes}
\label{c:attrib}
\index{Element attribute}

%-----------------------------------------------------------------
\section{Dependent and Independent Attributes} 
\label{s:depend} 
\index{Element attribute!dependent and independent}

\index{Parameter statement}
For convenience, \bmad computes the values of some attributes based
upon the values of other attributes. These dependent variables are
listed in Table~\ref{t:dependent}. Also shown in
Table~\ref{t:dependent} are the independent variables they are
calculated from.  In the table \vn{n_part} and \vn{l_lattice} (lattice
length) are lattice attributes, not element attributes. The first two
are set by the \vn{parameter} statement (See
\sref{s:param}). \vn{l_lattice} is calculated when the
lattice is read in.

\index{BBI_const}\index{Charge}\index{Sig_x}\index{Sig_y}
\index{E_tot}\index{N_part}\index{E_field}\index{Voltage}
\index{Hkick}\index{Vkick}\index{Gap}\index{L}
\index{E_tot}\index{E_loss}\index{Delta_e}\index{Gradient}
\index{L}\index{Rho}\index{Angle}\index{L_chord}
\index{G}\index{L}\index{K1}\index{Rho}
\index{B_max}\index{E_tot}\index{BeamBeam}\index{Elseparator}
\index{Lcavity}\index{Rbend}\index{Sbend}\index{Wiggler}
\begin{table}[ht]
\centering {
\begin{tabular}{|l|l|l|} \hline
 {\em Element}                & {\em Dependent Variables}    & {\em Independent Variables}        \HH
 \vn{BeamBeam}                & \vn{bbi_const}               & 
                                     \vn{charge}, \vn{sig_x}, \vn{sig_y}, \vn{E_tot}, \vn{n_part} \HH
 \vn{Elseparator}             & \vn{e_field}, \vn{voltage}   & 
                                          \vn{hkick}, \vn{vkick}, \vn{gap}, \vn{l}, \vn{E_tot}    \HH
 \vn{Lcavity}                 & \vn{e_loss}, \vn{delta_e}    & \vn{gradient}, \vn{l}              \HH
 \vn{Rbend}, \vn{Sbend}       & \vn{rho}, \vn{angle}, \vn{l_chord} 
                                                             & \vn{g}, \vn{l}                     \HH
 \vn{Wiggler} (periodic type) & \vn{k1}, \vn{rho}            & \vn{b_max}, \vn{E_tot}             \HH
 All elements                 & \vn{num_steps}               & \vn{ds_step}                       \HH
\end{tabular}
}
\caption[Table of dependent variables.]{Table of dependent variables and 
  the independent variables 
they are calculated from.}
\label{t:dependent}
\end{table}

\index{Lattice!expansion}\index{Harmon}\index{Delta_e}\index{Gradient}
\index{Rho}\index{G}\index{Angle}\index{Rf_frequency}
No attempt should be made to set or vary within a program dependent
attributes. It should be remarked that this is not an iron clad rule.
If a program properly bypasses \bmad's attribute bookkeeping routine
then anything is possible. In a lattice file, before lattice expansion
(\sref{s:expand}), \bmad allows the setting of a select group of
dependent attributes if the appropriate independent attributes are
not set. The list of settable dependent variables is given in
Table~\ref{t:dep.except}.  After reading in the lattice \bmad will set
the appropriate independent variable based upon the value of the
dependent variable. \vn{harmon} is the exception in that it will never
be set by the bookkeeping routine.
\index{Lcavity}\index{Rbend}
\index{Sbend}\index{RFcavity}
\begin{table}[ht]
\centering {
\begin{tabular}{|l|l|l|} \hline
{\em Element}                  & {\em Dependent Variable Set}  &  {\em Independent Variables Not Set} \HH
  \vn{Lcavity}                 & \vn{delta_e}       & \vn{gradient}      \HH
  \vn{Rbend}, \vn{Sbend}       & \vn{rho}           & \vn{g}             \HH
  \vn{Rbend}, \vn{Sbend}       & \vn{angle}         & \vn{g}, or \vn{l}  \HH
  \vn{Rbend}, \vn{Sbend}       & \vn{k2}            & \vn{b2}            \HH
  \vn{RFcavity}                & \vn{rf_frequency}  & \vn{harmon}        \HH
  \vn{Wiggler} (periodic type) & \vn{n_pole}        & \vn{l_pole}        \HH
\end{tabular}
}
\caption {Dependent variables that can be set in a primary lattice file.}
\label{t:dep.except}
\end{table}

\index{G}\index{G_err}\index{B_field}\index{Bs_field}\index{B_field_err}
\index{B1_gradient}\index{B2_gradient}\index{B3_gradient}\index{Ks}
\index{K1}\index{K2}\index{K3}
\index{BL_kick}\index{BL_hkick}\index{BL_vkick}
\index{Kick}\index{HKick}\index{VKick}
The normal attribute used to vary the strength of, say, a
\vn{quadrupole} is \vn{k1}.  It is sometimes convenient to be able to
vary the magnetic field strength directly instead. To do this \bmad
has a rule that if the appropriate field attribute appears in the
primary lattice file then it becomes an independent variable and the
normalized strength attribute (the strength attribute normalized by
the reference energy) becomes a dependent variable as tabulated in
Table~\ref{t:dep.field}.
\index{Sbend}\index{Rbend}\index{Solenoid}\index{Quadrupole}
\index{Sol_Quad}\index{Sextupole}\index{Octupole}
\begin{table}[ht]
\centering {
\begin{tabular}{|l|l|l|} \hline
  {\em Element} & {\em Normalized Strength Attribute} & {\em Field Attribute} \HH
  \vn{Sbend}, \vn{Rbend}     & \vn{g}      &  \vn{b_field}        \HH
  \vn{Sbend}, \vn{Rbend}     & \vn{g_err}  &  \vn{b_field_err}    \HH
  \vn{Solenoid}              & \vn{ks}     &  \vn{bs_field}       \HH
  \vn{Sol_quad}              & \vn{ks}     &  \vn{bs_field}       \HH
  \vn{Sol_quad}              & \vn{k1}     &  \vn{b1_gradient}    \HH
  \vn{Quadrupole}            & \vn{k1}     &  \vn{b1_gradient}    \HH
  \vn{Sextupole}             & \vn{k2}     &  \vn{b2_gradient}    \HH
  \vn{Octupole}              & \vn{k3}     &  \vn{b3_gradient}    \HH
  \vn{HKicker}, \vn{VKicker} & \vn{kick}   &  \vn{bl_kick}        \HH
  Most                       & \vn{hkick}  &  \vn{bl_hkick}       \HH
  Most                       & \vn{vkick}  &  \vn{bl_vkick}       \HH
\end{tabular}
}
\caption {Field and Strength Attributes.}
\label{t:dep.field}
\end{table}
Using both field strength and normalized strength as the independent
variable for a given element is not permitted. For example, for a quadrupole the 
normalized strengths \vn{k1}, \vn{hkick}, and \vn{vkick} can be used as the
independent variable or the field strengths \vn{b1_gradient}, \vn{bl_hkick} and
\vn{bl_vkick}. but the mixing of the two is not valid
\begin{example}
  Q1: quadrupole, k1 = 0.6, bl_hkick = 37.5  ! NO. Not VALID.
\end{example}
To define an element with the field strength as the independent
attribute without setting the strength just set the strength to zero. For example
\begin{example}
  Q1: quadrupole, b1_gradient = 0   ! Field strengths now the independent variables
\end{example}


%-----------------------------------------------------------------
\section{Type, Alias and Descrip Attributes}
\label{s:string}
\index{Type|textbf}
\index{Alias|textbf}
\index{Descrip|textbf}

There are three string labels associated with any element:
\begin{example}
  type    = <String>
  alias   = <String>
  descrip = <String>
\end{example}
\bmad routines do not use these labels except when printing element
information. \vn{type} and \vn{alias} can be up to 16 characters in
length and \vn{descrip} can be up to 200 characters. The attribute
strings can be enclosed in double quotation marks ("). The attribute
strings may contain blanks. If the attribute string does not contain a
blank then the quotation marks may be omitted. In this case the first
comma (,) or the end of the line marks the end of the string. Example:
\begin{example}
  Q00W: Quad, type = "My Type", alias = Who_knows, &
                                  descrip = "Only the shadow knows"
\end{example}

%-----------------------------------------------------------------
\section{Beam_Energy and P0C Attributes}
\label{s:energy}
\index{Parameter statement}\index{E_tot}
\index{E_tot_start}\index{P0c_start}
\index{Patch}\index{Lcavity}\index{P0c}
The attributes that define the reference energy and momentum at an element are:
\begin{example}
  E_tot = <Real>  ! Total energy in eV.
  p0c         = <Real>  ! Momentum in eV.
\end{example}
The energy and momentum are defined at the exit end of the element.
For ultra--relativistic particles these two values are the same.
See~\sref{s:phase.space.coords}. These attributes are dependent and thus
cannot be set for an element directly in the lattice input
file. The value of \vn{E_tot} and \vn{p0c} for an element is calculated by
\bmad to be the same as the previous element except for \vn{Lcavity}
and \vn{Patch} elements. To set the \vn{E_tot} or \vn{p0c} at the start of
the lattice use the \vn{beginning} or \vn{parameter} statements.
See~\sref{s:param}. Since the energy changes from the start to the end
of an \vn{Lcavity}, An \vn{Lcavity} has the attributes
\begin{example}
  E_tot_start
  p0c_start
\end{example}
which is just the reference energy and momentum at the start of the element.


%-----------------------------------------------------------------
\section{Offset, Pitch, Tilt, and Roll Attributes}
\label{s:offset}
\index{X_offset|textbf}
\index{Y_offset|textbf}
\index{S_offset|textbf}
\index{X_pitch|textbf}
\index{Y_pitch|textbf}
\index{Roll|textbf}
\index{Tilt|textbf}

There are up to 7 attributes that can offset a physical element
from the reference orbit. They are
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  s_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  tilt     = <Real>
  roll     = <Real>
\end{example}
\index{Pitch}
The exception here is the \vn{Patch} element which uses these
attributes to modify the reference orbit itself.

\vn{x_offset} translates an element in the local $x$--direction
as shown in Figure~\ref{f:pitch}. Similarly, \vn{y_offset} and 
\vn{s_offset} translate an element along the local $y$ and 
$z$--directions respectively. For a bend it is assumed that
the bend angle is small and the rotation of the local reference
axes through the bend is ignored.

The \vn{x_pitch} attribute rotates an element about the $y$--axis so
that the exit face of the element is displaced in the $+x$--direction
as shown in figure~\ref{f:pitch}. Similarly the \vn{y_pitch} attribute
rotates an element about the $x$--axis so that the exit face of the
element is displaced in the $+y$--direction. The rotations are about
the center of the element which is in contrast to the \vn{dtheta} and
\vn{dphi} misalignments of \mad which rotate around the entrance
point. In terms of rotation angle
\index{MAD!element rotation origin}
\begin{example}
  x_pitch =  dtheta
  y_pitch = -dphi
\end{example}
In both \bmad and \mad offsets are applied before pitches.
\begin{figure}[ht]
  \centering
  \includegraphics{pitch.eps}
  \caption{Geometry of Pitch and Offset attributes}
  \label{f:pitch}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics{tilt.eps}
  \caption{Geometry of a Tilt}
  \label{f:tilt}
\end{figure}

The tilt attribute rotates the element in the $(x, y)$ plane as
shown in figure~\ref{f:tilt}. For a bend the rotation axis is the
$z$-axis at the entrance face. The reference orbit is also rotated
with the element. A bend with a tilt of $\pi/2$ will bend a beam
upward vertically. The \vn{hkick} and \vn{vkick} attributes are
not affected by \vn{tilt} except for \vn{Kicker} and \vn{ElSeparator}
elements
Like MAD, \bmad allows the use of the \vn{tilt} attribute without
a value to designate a skew element. For example
\begin{example}
  q1: quad, l = 0.6, x_offset = 0.03, y_pitch = 0.001, tilt
\end{example}
Default tilts can be used for \vn{rbend}, \vn{sbend}, \vn{sol_quad},
\vn{quadrupole}, \vn{sextupole}, and \vn{octupole} elements.
The default tilt is $\pi/n$ where $n$ is the number of poles of the
element (bends have 2, quadrupoles have 4, etc.) 


The \vn{roll} attribute is only used for bends
and rotates the bend, along an axis that runs through the entrance
point and exit point as shown in figure~\ref{f:roll}. A \vn{roll} 
does not affect the reference orbit. The major effect of a \vn{roll}
is to give a vertical kick to the beam.
\begin{figure}[ht]
  \centering
  \includegraphics{roll.eps}
  \caption{Geometry of a Roll}
  \label{f:roll}
\end{figure}


%-----------------------------------------------------------------
\section{Hkick, Vkick, and Kick Attributes}
\label{s:kick}
\index{Hkick|textbf}\index{BL_hkick|textbf}
\index{Vkick|textbf}\index{BL_vkick|textbf}
\index{Kick|textbf}\index{BL_kick|textbf}


\index{Hkicker}
\index{Vkicker}
\index{Elseparator}
\index{Kicker}
The kick attributes that an element may have are:
\begin{example}
  kick,  bl_kick  = <Real>  ! Used only with a Hkicker or Vkicker
  hkick, bl_hkick = <Real>
  vkick, bl_vkick = <Real>
\end{example}
\vn{kick}, \vn{hkick}, and \vn{vkick} attributes are the integrated
kick of an element in radians. \vn{kick} is only used for \vn{Hkicker}
and \vn{Vkicker} elements. All other elements that can kick use
\vn{hkick} and \vn{vkick}. The \vn{tilt} attribute will only rotate a
kick for \vn{Hkicker}, \vn{Vkicker}, \vn{Elseparator} and \vn{Kicker}
elements. This rule was implemented so that, for example, the
\vn{hkick} attribute for a skew quadrupole would represent a
horizontal steering. The \vn{bl_kick}, \vn{bl_hkick}, and
\vn{bl_vkick} attributes are the integrated field kick in
\vn{meters-Tesla}. Normally these are dependent attributes except if
they appear in the lattice file (\sref{s:depend}).

%-----------------------------------------------------------------
\section{Aperture and Limit Attributes}
\label{s:limit}
\index{Aperture|textbf}
\index{Limit|textbf}
\index{Aperture_at|textbf}

\begin{figure}[ht]
  \centering
  \includegraphics{apertures.eps}
  \caption{Apertures for ecollimator and rcollimator elements}
  \label{f:limit}
\end{figure}

\index{Ecollimator}
\index{Rcollimator}
\index{X_limit|textbf}
\index{Y_limit|textbf}
\index{X1_limit|textbf}
\index{Y1_limit|textbf}
\index{X2_limit|textbf}
\index{Y2_limit|textbf}
\index{X_offset|textbf}
\index{Offset_moves_aperture|textbf}
The aperture attributes are:
\begin{example}
  x1_limit    = <Real>      ! Horizontal, negative side, aperture limit
  x2_limit    = <Real>      ! Horizontal, positive side, aperture limit
  y1_limit    = <Real>      ! Vertical, negative side, aperture limit
  y2_limit    = <Real>      ! Vertical, positive side, aperture limit
  x_limit     = <Real>      ! Alternative to specifying x1_limit and x2_limit
  y_limit     = <Real>      ! Alternative to specifying y1_limit and y2_limit
  aperture    = <Real>      ! Alternative to specifying x_limit and y_limit
  aperture_at = <Switch>    ! What end aperture is at.
  offset_moves_aperture = <Logical> ! Element offsets affect aperture position
\end{example}
\vn{x1_limit}, \vn{x2_limit}, \vn{y1_limit}, and \vn{y2_limit} specify
the half--width of the aperture of an element as shown in
figure~\ref{f:limit}. Apertures are assumed to be rectangular except
that an \vn{Ecollimator} has a elliptical aperture. 
A zero \vn{x1_limit}, \vn{x2_limit}, \vn{y1_limit}, or
\vn{y2_limit} is interpreted as no aperture in the appropriate plane.

To avoid numerical overflow and other errors in tracking, a particle
will be considered to have hit an aperture in an element, even if
there are no apertures set for that element, if its orbit exceeds 1000
meters. Additionally, there are other situations where a particle will
be considered lost. For example, if a particle cannotrajectory does
not intersect the output face in a bend.

For convenience, \vn{x_limit} can be used to set \vn{x1_limit} and
\vn{x2_limit} to a common value. Similarly, \vn{y_limit} can be used
to set \vn{y1_limit} and \vn{y2_limit}.  The \vn{aperture} attribute
can be use to set all four \vn{x1_limit}, \vn{x2_limit}, \vn{y1_limit}
and \vn{y2_limit} to a common value. Internally, the \bmad code does {\em not}
store \vn{x_limit}, \vn{y_limit}, or \vn{aperture}. This means that
using \vn{x_limit}, \vn{y_limit} or aperture in arithmetic expressions is
an error:
\begin{example}
  q2: quad, aperture = q1[aperture]   ! THIS IS AN ERROR!
  q2: quad, aperture = q1[x1_limit]   ! Correct
\end{example}

\index{Tilt}
\index{X_offset}
\index{Y_offset}
\index{X_pitch}
\index{Y_pitch}
Normally, whether a particle hits an aperture or not is evaluated
independent of any element offsets (\sref{s:offset}). This is equivalent
to the situation where a beam pipe containing an aperture is
independent of the element the beam pipe passes through. This can be
changed by setting the \vn{offset_moves_aperture} attribute to
\vn{True}. In this case any offsets or pitches will be considered to
have shifted the aperture boundary. Notice that even in this case
\vn{tilt}s will not affect the aperture calculation. This is done, for
example, so that the tilt of a skew quadrupole does not affect the
aperture.

\index{Entrance_end|textbf}
\index{Exit_end|textbf}
\index{Aperture_at|textbf}
By default the aperture is evaluated at the exit face only of the
element. This can be changed by setting the \vn{aperture_at} attribute.
Possible settings for \vn{aperture_at} are:
\begin{example}
  entrance_end
  exit_end  ! default
  both_ends
\end{example}
Note that the entrance and exit ends of an element are independent of
which direction particles are tracked through an element. Thus if a
particle is tracked backwards it enters an element at the ``exit end''
and exits at the ``entrance end''.

Example:
\begin{example}
  q1: quad, l = 0.6, x1_limit = 0.045, offset_moves_aperture = T
  q1[y1_limit] = 0.03
  q1[y2_limit] = 0.03
  q1[y_limit] = 0.03  ! equivalent to the proceeding 2 lines.  
  q1[aperture_at] = both_ends
\end{example}

%-----------------------------------------------------------------
\section{Length Attributes}
\label{s:l}

\index{L}
\index{L_chord}
\index{Rbend}
\index{Sbend}
The length attributes are
\begin{example}
  l       = <Real>  ! 
  l_chord           ! Chord length of a bend. Dependent attribute.
\end{example}
The length \vn{l} is the path length of the reference
particle. The one exception that that for an \vn{Rbend} the length
\vn{l} is the chord length (\sref{s:bend}). Internally, \bmad converts
all \vn{Rbend}s to \vn{Sbend}s and stores the chord length
under the \vn{l_chord} attribute.

\index{Wiggler}
Note that for \vn{Wiggler}s
the length \vn{l} is not the same as the path length for a particle
with the reference energy starting on the reference orbit.

%-----------------------------------------------------------------
\section{Is_on Attribute}
\label{s:is.on}
\index{Is_on}

The \vn{is_on} attribute
\begin{example}
  is_on = <Logical>
\end{example}
is used to turn an element off. Turning
an element off essentially converts it into a drift.
Example
\begin{example}
  q1: quad, l = 0.6, k1 = 0.95
  q1[is_on] = False
\end{example}

\vn{is_on} does not affect any apertures that are set. Additionally,
\vn{is_on} does not affect the reference orbit. Therefore, turning 
off an \vn{LCavity} will not affect the reference energy.

%-----------------------------------------------------------------
\section{Multipole Attributes: An, Bn, KnL, Tn}
\label{s:multip}

\index{Multipole!an, bn} 
\index{Multipole!KnL, Tn} 
\index{AB_Multipole}
\index{Multipole}
\index{Radius}
A \vn{Multipole} element specifies its multipole components using an
Amplitude (\vn{KnL}) and a tilt (\vn{Tn})
\begin{example}
  KnL = <Real>
  Tn  = <Real>
\end{example}
\vn{AB_Multipole} and all other elements that
have multipole attributes specify the multipoles using normal
(\vn{Bn}) and skew (\vn{An}) components 
\begin{example}
  An = <Real>
  Bn = <Real>
\end{example}
Here \vn{n} ranges from 0
(dipole component) through 20. Example:
\begin{example}
  q1: quadrupole, b0 = 0.12, a20 = 1e7, radius = 0.045
\end{example}

Multipole formulas for are given in \sref{s:fields}.  Note that for
\vn{Multipole} and \vn{AB_multipole} (but not any other element) a
non-zero dipole component will affect the reference orbit (just like a
normal dipole will).

For everything other than a \vn{Multipole} and \vn{AB_multipole}, the
multipole strength is scaled by a factor $F \, r_0^{n_\text{ref}} /
r_0^n$ (cf.~\Eq{ababf}) where $F$ is the strength of the element (for
example $F$ is $K1 \cdot L$ for a quadrupole), and $r_0$ is the
``measurement radius'' and is set by the \vn{radius} attribute. The
default value of $r_0$, if the \vn{radius} is not given, is 1.0.

%-----------------------------------------------------------------
\section{Instrumental Attributes}
\label{s:inst.var}

\index{Instrument}\index{Monitor}\index{Marker}
\index{X_gain_err}\index{Y_gain_err}\index{Crunch}\index{Noise}
\index{X_gain_calib}\index{Y_gain_calib}\index{Crunch_calib}
\index{X_offset}\index{Y_offset}\index{Tilt}
\index{X_offset_calib}\index{Y_offset_calib}\index{Tilt_calib}

\vn{Instrument}, \vn{Monitor}, and \vn{Marker} elements have special
attributes to describe the beam position measurement process. These
attributes are:
\begin{example}
  tilt           = <Real>    ! \sref{s:offset}
  x_offset       = <Real>    ! \sref{s:offset}
  y_offset       = <Real>    ! \sref{s:offset}
  x_gain_err     = <Real>    ! Horizontal gain error
  y_gain_err     = <Real>    ! Vertical gain error
  crunch         = <Real>    ! Crunch angle
  tilt_calib     = <Real>    ! tilt angle calibration
  x_offset_calib = <Real>    ! Horizontal offset calibration
  y_offset_calib = <Real>    ! Vertical offset calibration
  x_gain_calib   = <Real>    ! Horizontal gain calibration
  y_gain_calib   = <Real>    ! Vertical gain calibration
  crunch_calib   = <Real>    ! Crunch angle calibration
  noise          = <Real>    ! Noise factor
\end{example}
A program can use
these quantities to calculate the ``measured'' beam position from the
``actual'' (that is, as calculated via tracking) using the equations
\begin{alignat}{1}
  x_m &= N * r_1 + (1 + dg_x) * 
          \left[ (x - dx_{\mss{off}}) * \cos (d\theta_t + d\theta_c) +
                  (y - dy_{\mss{off}}) * \sin (d\theta_t + d\theta_c) 
          \right] \\ 
  y_m &= N * r_2 + (1 + dg_y) * 
          \left[ -(x - dx_{\mss{off}}) * \sin (d\theta_t - d\theta_c) +
                  (y - dy_{\mss{off}}) * \cos (d\theta_t - d\theta_c)  
          \right]
\end{alignat}
where $(x,y)$ is the actual beam position, $(x_m, y_m)$ is the
measured position, $N$ is the noise factor, $r_1$ and $r_2$ are
Gaussian random numbers whose distribution has unit width, $dg_x$ and
$dg_y$ are the net gains
\begin{alignat}{1}
  dg_x &= g_{x\mss{err}} - g_{x\mss{calib}} \CRNO
  dg_y &= g_{y\mss{err}} - g_{x\mss{calib}}
\end{alignat}
$g_{x\mss{err}}$ and $g_{y\mss{err}}$ are the gain errors and
$g_{x\mss{calib}}$ and $g_{y\mss{calib}}$ are the gain calibration
factors.  $g_{x\mss{calib}}$ and $g_{y\mss{calib}}$ represent the
measured gain error and are useful for simulating the real world
situation where there has been a measurement of the gain error. $dg$
is thus the difference between the actual gain error and the measured
gain error. Similarly:
\begin{alignat}{1}
  dx_{\mss{off}} &= x_{\mss{off}} - x_{\mss{calib}} \CRNO
  dy_{\mss{off}} &= y_{\mss{off}} - y_{\mss{calib}} \\
  d\theta_t &= \theta_t - \theta_{t\mss{calib}} \CRNO
  d\theta_c &= \theta_c - \theta_{c\mss{calib}} \CRNO
\end{alignat}
$(x_{\mss{off}}, y_{\mss{off}})$ is the transverse offset of the
element and $(x_{\mss{calib}}, y_{\mss{calib}})$ is the measured
offset.  $\theta_t$ is the tilt angle and $\theta_{t\mss{calib}}$ is
the measured tilt angle. $\theta_c$ is the crunch angle, and
$\theta_{c\mss{calib}}$ is the measured tilt angle. The measured
position $(x_m, y_m)$ thus represents the beam position corrected for
``known'' offsets, tilts, and gain errors.
