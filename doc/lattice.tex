\chapter{Lattice File Overview}
\index{lattice files|hyperbf}

%---------------------------------------------------------------------------
\section{Lattice Files}
\label{s:lattice.file.formats}

\index{XSIF|hyperbf}
\index{Bmad!lattice file format}
A lattice file (or files) defines an accelerator: That is, a lattice
file defines the sequence of elements that a particle will travel
through along with the attributes of the elements (their lengths,
their strengths, etc.). The \bmad software library comes with
routines to read in (parse) lattice files. There are two input formats
that \bmad understands: The \bmad standard format and
XSIF\cite{b:xsif}. XSIF stands for ``Extended Standard Input Format.''
XSIF is essentially a subset of the MAD input format. XSIF has its own
documentation which can be found at:
\begin{example}
  http://www-project.slac.stanford.edu/
              lc/ilc/TechNotes/LCCNotes/PDF/LCC-0060%20rev.1.pdf
\end{example}
\index{parameter statement!lattice_type}
\index{XSIF!lcavity and lattice_type}
Since XSIF does not have a \vn{lattice_type} statement
(\sref{s:param}), the type of the lattice (whether circular or linear)
is determined by the presence or absence of any \vn{LCavity} elements
in the XSIF file. This is independent of whether \vn{LCavity} elements
are actually used in the lattice.

An XSIF lattice file may be called from within a \bmad lattice
file. See Section~\sref{s:call} for more details.

Since XSIF is separately documented it will not be discussed in detail
here and throughout this manual, unless explicitly stated otherwise,
the lattice format under discussion will always pertain to the \bmad
standard format. One feature of the \bmad implementation of XSIF
Note: One point that is not covered in the XSIF
documentation is that for a \vn{MATRIX} element, unlike \mad, the
\vn{R$ii$} terms (the diagonal terms of the linear matrix) are not
unity by default. Thus
\index{MAD}
\begin{example}
  m: matrix
\end{example}
in an XSIF file will give a matrix with all elements being zero.

\index{MAD!lattice format}
The syntax that a \bmad standard lattice file must conform to is
modeled after the lattice input format of the \mad program.
Essentially, a \bmad lattice file is similar to a \mad lattice file
except that a \bmad file has no ``action'' commands (action commands
tell the program to calculate the Twiss parameters, do tracking,
etc.).  Interacting with the user to determine what actions a program
should take is left to the program and is not part of \bmad (although
the \bmad library provides the routines to perform many of the standard
calculations). A program is not required to use the \bmad parser
routine but if it does the following chapters describe how to
construct a valid lattice file.

%---------------------------------------------------------------------------
\section{File Example and Syntax}
\index{Bmad!statement syntax}

\index{parameter statement}
\index{use statement}
The following (rather silly) example shows some of the features of a
\bmad lattice file:
\begin{example}
  ! This is a comment
  parameter[E_TOT] = 5e9                   ! Parameter definition
  pa1 = sin(3.47 * pi / c_light)                 ! Constant definition
  bend1: sbend, type = "arc bend", l = 2.3,      ! An element definition
      g = 2*pa1, tracking_method = bmad_standard
  bend2: bend1, l = 3.4                          ! Another element def
  bend2[g] = 105 - exp(2.3) / 37.5               ! Redefining an attribute
  ln1: line = (ele1, ele2, ele3)                 ! A line definition
  ln2: line = (ln1, ele4, ele5)                  ! Lines can contain lines
  arg_ln(a, b) = (ele1, a, ele2, b)              ! A line with arguments.
  use, ln2                                       ! Which line to use for the lattice
\end{example}

\index{"! comment symbol}
\index{comment symbol ("!)}
A \bmad lattice file consists of a sequence of statements. An
exclamation mark (!) denotes a comment and the exclamation mark and
everything after the exclamation mark on a line are ignored.  \bmad is
case insensitive. All names are converted to uppercase except strings
(\sref{s:var.types}).

\index{& continuation symbol}
\index{continuation symbol (&)}
Normally a statement occupies a single line in the file. Several
statements may be placed on the same line by inserting a semicolon
(``;'') between them. A long statement can occupy multiple lines by
putting an ampersand (``\&'') at the end of each line of the statement
except for the last line. Additionally, lines that end with ``,''
(comma), ``+'', ``-'', ``*'', ``/'', ``('', ``\{'', ``['', or ``='' are automatically
considered to be continued to the next line.

\index{lattice files!name syntax}
Names of constants, elements, lines, etc. are limited to 40
characters. The first character must be a letter (\vn{A} --- \vn{Z}).
The other characters may be a letter, a digit (\vn{0} --- \vn{9}) or
an underscore (\vn{_}). Other characters may appear but should be avoided
since they are used by Bmad for various purposes. For example, the 
backslash (\vn{\B}) character is used to by Bmad when forming the names of
superposition slaves (\sref{s:super}) and dots (\vn{.}) are used by Bmad 
when creating names of \vn{tagged} elements (\sref{s:tag}). Also use of
special characters may make the lattice files less portable to non-Bmad programs.

\index{parameter statement}
\index{parameter statement}
\index{parameter statement}
\index{beginning statement}
The following example constructs a linear lattice with two elements: 
\begin{example}
  parameter[lattice_type] = LINEAR_LATTICE
  parameter[e_tot] =2.7389062E9
  parameter[particle] = POSITRON
  beginning[beta_a] = 14.5011548
  beginning[alpha_a] = -0.53828197
  beginning[beta_b] = 31.3178048
  beginning[alpha_b] = 0.25761815
  q: quadrupole, l = 0.6, b1_gradient = 9.011
  d: drift, l = 2.5
  t: line = (q, d)
  use, t 
\end{example}
here \vn{parameter[lattice_type]} (\sref{s:param}) is set to \vn{LINEAR_LATTICE}
which specifies that the lattice is not circular. In this case, the beginning 
Twiss parameters need to be specified and this is done by the \vn{beginning}
statements (\sref{s:beginning}). A quadrupole named \vn{q}
and a drift element named \vn{d} are specified
and the entire lattice consists of element \vn{q} followed by element \vn{d}.

%----------------------------------------------------------------------------
\section{Digested Files}
\label{s:lattice.files}
\index{digested files}

Normally the \bmad parser routine will create what is called a
``digested file'' after it has parsed a lattice file so that when a
program is run and the same lattice file is to be read in again, to save
time, the digested file can be used to load in the lattice information.
This digested file is in binary format and is not human readable. The
digested file will contain the transfer maps for all the elements. 
Using a digested file can save considerable time if some of the
elements in the lattice need to have Taylor maps computed.
(this occurs typically with map--type wigglers).

\bmad creates the digested file in the same area as the lattice file.
If \bmad is not able to create a digested file (typically because it
does not have write permission in the directory), an error message will
be generated but otherwise program operation will be normal.

\index{ran}
\index{ran_gauss}
Digested files contain the names of the lattice files used to create
them. If a lattice file has been modified since the digested file has
been created then the lattice files will be reread and a new
digested file will be generated. 

Note: If any of the random number functions (\sref{s:functions}) are
used in the process of creating the lattice, the digested file will be
ignored. In this case, each time the lattice is read into a program,
different random numbers will be generated for expressions that use such
random numbers.

Digested files can also be used for easy transport of lattices between
programs or between sessions of a program. For example, using one
program you might read in a lattice, make some adjustments (say to model
shifts in magnet positions) and then write out a digested version of the
lattice. This adjusted lattice can now be read in by another program.

%---------------------------------------------------------------------------
\section{Element Sequence Definition}

\index{line}\index{use statement|hyperbf}
A \vn{line} defines a sequence of elements. \vn{lines} may contain
other \vn{lines} and so a hierarchy may be established. One line is
selected, via a \vn{use} statement, that defines the lattice. For
example:
\begin{example}
  l3: line = (l1, l2)   ! Concatenate two lines
  l1: line = (a, b, c)  ! Line with 3 elements
  l2: line = (a, z)     ! Another line 
  use, l3               ! Use l3 as the lattice definition.
\end{example}
In this case the lattice would be
\begin{example}
  (a, b, c, a, z)
\end{example}
\vn{Lines} can be defined in any order. See \cref{c:sequence} for more
details.

\index{superimpose}
The \vn{superimpose} construct allows elements to be placed in a
lattice at a definite longitudinal position. What happens is that
after a lattice is expanded, there is a reshuffling of the elements to
accommodate any new superimpose elements. See \sref{s:super} for more
details.

%---------------------------------------------------------------------------
\section{Lattice Elements}

The syntax for defining a lattice element roughly follows \mad:
\begin{example}
  label: keyword [, attributes]
\end{example}
\vn{Overlay} and \vn{Group} elements have a slightly different syntax
\begin{example}
  label: keyword = \{ list \}, master-attribute [= value] [, attributes]
\end{example}
and \vn{Girder} elements have the syntax
\begin{example}
  label: keyword = \{ list \} [, attributes]
\end{example}  
For example:
\begin{example}
  q01w: quadrupole, type = "A String", l = 0.6, tilt = pi/2
  h10e: overlay = \{ b08e, b10e \}, hkick
\end{example}

\cref{c:elements} gives a list of elements with their attributes.

%---------------------------------------------------------------------------
\section{Element Attributes}
\index{element attribute|hyperbf}

Any lattice element has various attributes like its name, its length,
its strength, etc. The values of element attributes can be specified
when the element is defined. For example:
\begin{example}
  b01w: sbend, l = 6.0, rho = 89.0 ! Define an element with attributes.
\end{example}
After an element's definition, an individual attribute may be referred
to using the syntax
\begin{example}
  element-name[attribute-name]
\end{example}
Element attributes can be set or used in an algebraic expression:
\begin{example}
  bo1w[roll] = 6.5                  ! Set an attribute value.
  b01w[l] = 6.5                     ! Change an attribute value.
  b01w[l] = b01w[rho] / 12          ! OK to reset an attribute value.
  my_const = b01w[rho] / b01w[l]      ! Use of attribute values in an expression.
\end{example}
Notice that there can be no space between the element name and the
\vn{[} opening bracket.  

When setting an attribute value, if more than one element has the
\vn{element-name} then {\it all} such elements will be set.  When
setting an attribute value, if \vn{element-name} is the name of a type
of element, all elements of that type will be set. For example
\begin{example}
  q_arc[k1] = 0.234                      ! Set all elements named Q_ARC. 
  rfcavity[voltage] = 3.7                ! Set all RFcavity elements.
\end{example}

Additionally with element attribute sets, The wildcards \vn{``*''},
and \vn{``\%''} can be used to can be used where \vn{``*''} denotes
any number of characters and \vn{``%''} denotes a single character. Examples:
\begin{example}
  *[tracking_method] = bmad_standard  ! Matches all elements.
  Q*[k1] = 0.234                      ! Matches all elements with names beginning with Q.
  Q%1[k1] = 0.234                     ! Matches to "Q01" but not "Q10".
\end{example}
Note: A name with wildcards will never match to the \vn{BEGINNING} element (\sref{s:use}).

\cref{c:elements} gives a list of elements with their attributes.

%---------------------------------------------------------------------------
\section{Variable Types}
\label{s:var.types}
\index{arithmetic expressions!variables}

\index{logicals|hyperbf}
There are five types of variables in \bmad: reals, integers, switches,
logicals (booleans), and strings. Acceptable logical values are
\begin{example}
   true    false
   t       f
\end{example}
For example
\begin{example}
  rf1[is_on] = False
\end{example}

\index{strings|hyperbf}
String literals can be quoted using double quotes (") or single quotes ('). 
If there are no
blanks or commas within a string, the quotes can be omitted. For example:
\begin{example}
  Q00W: Quad, type = "My Type", alias = Who_knows, &
                                  descrip = "Only the shadow knows"
\end{example}
Unlike most everything else, strings are not converted to uppercase.

\index{switches|hyperbf}
Switches are variables that take discrete values. For example:
\begin{example}
  parameter[particle] = positron          
  q01w: quad, tracking_method = bmad_standard 
\end{example}
The name ``switch'' can refer to the variable (for example,
\vn{tracking_method}) or to a value that it can take (for example,
\vn{bmad_standard}). The name ``method'' is used interchangeably with switch.

%-----------------------------------------------------------------
\section{Units and Constants}
\label{s:constants}
\index{constants|hyperbf}

\bmad uses SI (Syst\'eme International) units as shown in
Table~\ref{t:units}.

\bmad defines commonly used physical and mathematical constants
shown in Table~\ref{t:constants}.  All symbols use straight SI units
except for \vn{e_mass} and \vn{p_mass} which are provided for
compatibility with \mad.

\begin{table}
\centering
\begin{tabular}{|l|l|l|l|} \hline
  {\em Symbol}  & {\em Value}       & {\em Units} &  {\em Name}       \\ \hline
  pi            & 3.14159265359          &        &                   \\
  twopi         & 2 * pi                 &        &                   \\
  fourpi        & 4 * pi                 &        &                   \\
  e_log         & 2.718281828            &        &                   \\
  sqrt_2        & 1.4142135623731        &        &                   \\
  degrees       & 180 / pi               &        &                   \\
  m_electron    & $0.51099906 \pow{6}$   & eV     & Electron mass     \\
  m_proton      & $0.938271998 \pow{9}$  & eV     & Proton mass       \\
  c_light       & $2.99792458 \pow{8}$   & m/sec  & Speed of light    \\
  r_e           & $2.8179380 \pow{-15}$  & m      & Electron radius   \\
  r_p           & $1.5346980 \pow{-18}$  & m      & Proton radius     \\
  e_charge      & $1.6021892 \pow{-19}$  & C      & Electron charge   \\
  h_planck      & $4.13566733 \pow{-15}$ & eV*sec & Planck's constant \\
  h_bar_planck  & $6.58211899 \pow{-16}$ & eV*sec & Planck / $2\pi$   \\
  e_mass        & $0.51099906 \pow{-3}$  & GeV    & Electron mass     \\
  p_mass        & $0.938271998$          & GeV    & Proton mass       \\ \hline
\end{tabular}
\caption{Physical and mathematical constants recognized by \bmad.}
\label{t:constants}
\end{table}

%---------------------------------------------------------------------------
\section{Arithmetic Expressions}
\index{arithmetic expressions} 

Arithmetic expressions can be used in a place where a real value is required.
The standard operators are defined: \hfil\break
\hspace*{0.15in}
\begin{tabular}{ll}
  $a + b$           & Addition        \\
  $a - b$           & Subtraction     \\
  $a \, \ast \, b$  & Multiplication  \\
  $a \; / \; b$     & Division        \\
  $a \, \land \, b$ & Exponentiation  \\
\end{tabular}
\bmad also has a set of intrinsic functions. A list of these is given
in \sref{s:functions}.

\index{arithmetic expressions!constants}
Literal constants can be entered with or without a decimal point. An
exponent is marked with the letter E. For example
\begin{example}
  1, 10.35, 5E3, 314.159E-2
\end{example}
Symbolic constants can be defined using the syntax
\begin{example}
  parameter_name = expression
\end{example}
\index{MAD!syntax compatibility with BMAD}
Alternatively, to be compatible with \mad, using ``:='' instead of ``='' is accepted
\begin{example}
  parameter_name := expression
\end{example}
Examples:
\begin{example}
  my_const = sqrt(10.3) * pi^3
  abc     := my_const * 23
\end{example}
\index{MAD!delayed substitution}
Unlike \mad, \bmad uses immediate substitution so that all constants
in an expression must have been previously defined. For example, the
following is not valid:
\begin{example}
  abc      = my_const * 23      ! No: my_const needs to be defined first.
  my_const = sqrt(10.3) * pi^3
\end{example}
here the value of \vn{my_const} is not known when the line ``\vn{abc}
= $\ldots$'' is parsed. Once
defined, symbolic constants cannot be redefined. For example:
\begin{example}
  my_const = 1
  my_const = 2  ! No: my_const cannot be redefined.
\end{example}

%---------------------------------------------------------------------------
\section{Intrinsic functions}
\label{s:functions}
\index{intrinsic functions}

\index{sqrt}\index{log}\index{exp}\index{sin}\index{cos}\index{tan}
\index{asin}\index{acos}\index{atan}\index{abs}\index{ran}\index{ran_gauss}
The following intrinsic functions are recognized by \bmad: \hfil\break
\hspace*{0.15in}
\begin{tabular}{ll}
  \vn{sqrt}(x)      & Square Root    \\
  \vn{log}(x)       & Logarithm      \\
  \vn{exp}(x)       & Exponential    \\
  \vn{sin}(x)       & Sine           \\
  \vn{cos}(x)       & Cosine         \\
  \vn{tan}(x)       & Tangent        \\
  \vn{asin}(x)      & Arc sine       \\
  \vn{acos}(x)      & Arc cosine     \\
  \vn{atan}(x)      & Arc Tangent    \\
  \vn{abs}(x)       & Absolute Value \\
  \vn{ran}()        & Random number between 0 and 1 \\
  \vn{ran_gauss}()  & Gaussian distributed random number \\
\end{tabular}

\index{ran_seed}
\vn{ran_gauss} is a Gaussian distributed random number with unit RMS. 
Both \vn{ran} and \vn{ran_gauss} use a seeded random number generator. 
To choose the seed set 
\begin{example}
  parameter[ran_seed] = <Integer>
\end{example}
A \vn{value} of zero will set the seed using the system clock so that
different sequences of random numbers will be generated each time a
program is run.  The default behavior if \vn{parameter[ran_seed]} is
not present is to use the system clock for the seed.

\index{expand_lattice}
If an element is used multiple times in a lattice, and if \vn{ran} or
\vn{gauss_ran} is used to set an attribute value of this element, then
to have all instances of the element have different attribute values
the setting of the attribute must be after the lattice has been
expanded (\sref{s:expand}). For example:
\begin{example}
  a: quad 
  a[x_offset] = 0.001*ran_gauss()
  my_line: line = (a, a)
  use, my_line
\end{example}
Here, because \bmad does immediate evaluation, the \vn{x_offset}
values for \vn{a} gets set in line 2 and so both copies of \vn{a} in
the lattice get the same value. This is probably not what is wanted.
On the other hand if the attribute is set after lattice expansion:
\begin{example}
  a: quad 
  my_line: line = (a, a)
  use, my_line
  expand_lattice
  a[x_offset] = 0.001*ran_gauss()
\end{example}
Here the two \vn{a} elements in the lattice get different values for
\vn{x_offset}.
