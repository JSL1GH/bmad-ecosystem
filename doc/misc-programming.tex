\chapter{Miscellaneous Programming}

{\bf NOTE: THIS CHAPTER IS UNDER CONSTRUCTION!}

%-----------------------------------------------------------------------------
\section{Custom Elements}
\label{s:custom.ele}
\index{twiss parameters!calculation with custom elements}
\index{custom}

\index{custom}
\index[routine]{radiation_integrals}\index[routine]{em_field}
\index[routine]{make.mat6}\index[routine]{track1}
Routines to handle \vn{custom} elements (\sref{s:custom}) must be supplied
by the creator of the elements.
There are potentially four routines that must be written to implement a custom 
element:
\begin{example}
   \Hyperref{r:radiation.integrals.custom}{radiation_integrals_custom}
   \Hyperref{r:em.field.custom}{em_field_custom}
   \Hyperref{r:make.mat6.custom}{make_mat6_custom}
   \Hyperref{r:track1.custom}{track1_custom}
   \Hyperref{r:track1.bunch.custom}{track1_bunch_custom}
\end{example}
[Use \vn{getf} for more details about the argument lists for these
routines.]  The \bmad library has dummy routines of the same name to
keep the linker happy when custom routines are not implemented. These
dummy routines, if called, will print an error message and stop the
program. The custom routines are called by their corresponding regular
routines. By ``regular'' routine it is meant the routine without the
``\vn{_custom}'' suffix. For example, \vn{radiation_integrals} will
call \vn{radiation_integrals_custom}. Thus if a program using the
custom code does not call a particular regular routine, the program
does not have to implement the corresponding custom routine.

The following attributes are defined in a custom element and may be set:
\begin{example}
    ele%value(val1$)
    ele%value(val2$)
    ele%value(val3$)
    ele%value(val4$)
    ele%value(val5$)
    ele%value(val6$)
    ele%value(val7$)
    ele%value(val8$)
    ele%value(val9$)
    ele%value(val10$)
    ele%value(val11$)
    ele%value(val12$)
    ele%value(field_calc$)
    ele%value(field_master$)
    ele%value(delta_e$)
    ele%value(delta_ref_time$)
\end{example}

The following attributes are set by standard bmad routines:
\begin{example}
    ele%value(e_tot_start$)
    ele%value(p0c_start$)
    ele%value(e_tot$)
    ele%value(p0c$)
\end{example}


%-----------------------------------------------------------------------------
\section{Physical and Mathematical Constants}
\label{s:physical.constants}

\index{constants}
Common physical and mathematical constants that can be used in any expression
are defined in the file:
\begin{example}
 sim_utils/interfaces/physical_constants.f90
\end{example}

The following constants are defined
\begin{example}
  pi = 3.14159265358979d0
  twopi = 2 * pi
  fourpi = 4 * pi
  sqrt_2 = 1.41421356237310d0
  sqrt_3 = 1.73205080757d0
  complex: i_imaginary = (0.0d0, 1.0d0)

  e_mass = 0.51099906d-3   ! DO NOT USE! In GeV
  p_mass   = 0.938271998d0   ! DO NOT USE! In GeV

  m_electron = 0.51099906d6  ! Mass in eV
  m_proton   = 0.938271998d9 ! Mass in eV

  c_light = 2.99792458d8             ! speed of light
  r_e = 2.8179380d-15                ! classical electron radius
  r_p = r_e * m_electron / m_proton  ! proton radius
  e_charge = 1.6021892d-19           ! electron charge

  h_planck = 4.13566733d-15          ! eV*sec Planck's constant
  h_bar_planck = 6.58211899d-16      ! eV*sec h_planck/twopi

  mu_0_vac = fourpi * 1e-7                   ! Permeability of free space
  eps_0_vac = 1 / (c_light**2 * mu_0_vac)    ! Permittivity of free space

  classical_radius_factor = r_e * m_electron ! Radiation constant

  g_factor_electron = 0.001159652193    ! Anomalous gyro-magnetic moment
  g_factor_proton   = 1.79285           ! Anomalous gyro-magnetic moment
\end{example}

%-----------------------------------------------------------------------------
\section{Global Coordinates and S-positions}
\label{s:global.coords}

\index{global coordinates}
\index{s-positions}
The routine \Hyperref{r:lat.geometry}{lat_geometry} will compute the
global floor coordinates at the end of every element in a lattice.
\vn{lat_geometry} works by repeated calls to \Hyperref{r:ele.geometry}{ele_geometry} which
takes the floor coordinates at the end of one element and calculates
the coordinates at the end of the next. For conversion between
orientation matrix $\Bf W$ (\sref{s:global}) and the orientation
angles $\theta, \phi, \psi$, the routines \Hyperref{r:floor.angles.to.w.mat}{floor_angles_to_w_mat}
and \Hyperref{r:floor.w.mat.to.angles}{floor_w_mat_to_angles} can be used.

The routine \Hyperref{r:s.calc}{s_calc} calculates the longitudinal $s$ positions for
the elements in a lattice.

%-----------------------------------------------------------------------------
\section{Reference Energy}
\label{s:ref.energy}

\index {reference energy}
The reference energy for the elements in a lattice is calculated by
\Hyperref{r:lat.compute.reference.energy}{lat_compute_reference_energy}.
The reference energy associated with a lattice element is gnerally stored in
\begin{example}
  ele%value(E_tot\$)      ! Total energy (eV)
  ele%value(p0c\$)        ! Momentum * c_light (eV)
\end{example}

\index{multipass!reference energy}
\vn{multipass} lord (\sref{s:multipass}) elements have a
reference energy but only if the \vn{n_ref_pass} attribute is set. In
this case, the \vn{multipass} lord inherits the reference energy of
the referenced slave.

\index{group!reference energy}\index{overlay!reference energy}
\index{superposition!reference energy}
\vn{group} (\sref{s:group}), \vn{overlay} (\sref{s:overlay}), and
\vn{super_lord} elements inherit the reference from the last slave in
their slave list (\sref{s:lat.control}). For \vn{super_lord} elements
this corresponds to inheriting the reference energy of the slave at
the exit end of the \vn{super_lord}. For \vn{group} and \vn{overlay}
elements a reference energy only makes sense if all the elements under
control have the same reference energy.

\index{lcavity!referece energy}\index{cutom!referece energy}\index{hybrid!referece energy}
Generally, the reference energy is constant throughout an
element. Exceptions are \vn{lcavity}, \vn{custom} and \vn{hybrid}
elements. For these types of elements, the above reference energy
components refer to the exit end of the element and there are two
additional attributes that give the reference energy at the start of
the element
\begin{example}
  ele%value(E_tot_start\$)      ! Total energy at entrance end of element (eV)
  ele%value(p0c_start\$)        ! Momentum * c_light at entrance end of element (eV)
\end{example}
These starting energies are the same as the exit end energies of the upstream element in the lattice.

Additionally, photonic elements like \vn{crystal}, \vn{capillay},
\vn{mirror} and \vn{multilayer_mirror} elements have an associated photon reference wavelength
\begin{example}
  ele%value(ref_wavelength\$)      ! Meters.
\end{example}

%-----------------------------------------------------------------------------
\section{Common Structures}
\label{s:common.struct}

\index{bmad_com}
\index{bmad_status}

There are two common structures used by Bmad for communication between
routines. These are \vn{bmad_com} which is a \vn{bmad_common_struct}
structure and \vn{bmad_status} which is a \vn{bmad_status_struct}
structure.


\index{status}\index{ok}
\index{type_out}\index{sub_type_out}
\index{exit_on_error}
The \vn{bmad_status_struct} structure is:
\begin{example}
type bmad_status_struct
  integer :: status         = ok\$     ! Computation status 
  logical :: ok             = .true.   ! Error flag
  logical :: type_out       = .true.   ! Print error messages?
  logical :: sub_type_out   = .true.   ! 
  logical :: exit_on_error  = .true.   ! Exit program on error?
end type
\end{example}




