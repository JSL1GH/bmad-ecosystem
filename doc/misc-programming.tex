\chapter{Miscellaneous Programming}

%-----------------------------------------------------------------------------
\section{Custom Elements and Custom Calculations}
\label{s:custom.ele}
\index{custom}

In this context, a ``custom'' calculation is a calculation, normally
done by \bmad, that is instead handled by having the appropriate \bmad
code call the appropriate custom code. Implementing custom
calculations involve writing custom code and linking this code into a
program. There are essentially two ways to do custom calculations. One
method involves using a \vn{custom} element (\sref{s:custom}). The
other method involves setting the appropriate component of an element
to \vn{custom}. An appropriate component is one of
\begin{example}
  tracking_method       \sref{s:tkm}
  mat6_calc_method      \sref{s:xfer}
  field_calc            \sref{s:integ}
  aperture_type         \sref{s:limit}
\end{example}

There are seven routines that implement custom calculations:
\begin{example}
   \Hyperref{r:check.aperture.limit.custom}{check_aperture_limit_custom}
   \Hyperref{r:em.field.custom}{em_field_custom}
   \Hyperref{r:init.custom}{init_custom}
   \Hyperref{r:make.mat6.custom}{make_mat6_custom}
   \Hyperref{r:make.mat6.custom2}{make_mat6_custom2}
   \Hyperref{r:radiation.integrals.custom}{radiation_integrals_custom}
   \Hyperref{r:track1.custom}{track1_custom}
   \Hyperref{r:track1.custom2}{track1_custom2}
   \Hyperref{r:track1.bunch.custom}{track1_bunch_custom}
   \Hyperref{r:track1.spin.custom}{track1_spin_custom}
\end{example}
[Use \vn{getf} for more details about the argument lists for these
routines.]  The \bmad library has ``dummy'' routines of the same name to
keep the linker happy when custom routines are not implemented. These
dummy routines, if called, will print an error message and stop the
program. The exception is the dummy \vn{init_custom} routine which will
simply do nothing when called.

If a particular custom routine is not called in a program, then,
obviously, a non-dummy version does not have to be implemented. To
link in a non-dummy version of a custom routine, put the code file in
the same directory as the program code and relink.

While coding a custom routine, it is important to remember that it is
{\em not} permissible to modify any routine argument that does not
appear in the list of output arguments shown in the comment section at
the top of the file.

\index{descrip}
The \Hyperref{r:init.custom}{init_custom} routine is called by
\Hyperref{r:bmad.parser}{bmad_parser} at the end of parsing for any
lattice element that is a \vn{custom} element or has set any one of
the element components as listed above to \vn{custom}. The
\vn{init_custom} routine can be used to initialize the internals of
the element. For example, consider a \vn{custom} element defined in a
lattice file by
\begin{example}
  my_element: custom, val1 = 1.37, descrip = "field.dat", mat6_calc_method = tracking
\end{example}
In this example, the \vn{descrip} (\sref{s:alias}) component is used
to specify the name of a file that contains parameters for this
element. When \vn{init_custom} is called for this element (see below),
the file can be read and the parameters stored in the element
structure. Besides the \vn{ele%value} array, parameters may be stored
in the general use components given in \sref{s:ele.gen}.

The
\Hyperref{r:check.aperture.limit.custom}{check_aperture_limit_custom}
routine is used to check if a particle has hit an aperture in
tracking. It is called by the standard \bmad routine
\Hyperref{r:check.aperture.limit}{check_aperture_limit} when
\vn{ele%aperture_type} is set to \vn{custom\$}. A \vn{custom} element
has the standard limit attributes (\sref{s:limit}) so a \vn{custom}
element does not have to implement custom aperture checking code.

The \Hyperref{r:em.field.custom}{em_field_custom} routine is called by
the electro-magnetic field calculating routine
\Hyperref{r:em.field.calc}{em_field_calc} when \vn{ele%field_calc} is
set to \vn{custom\$}. As an alternative to \vn{em_field_custom}, a
\vn{custom} element can use the \vn{field} attribute
(\sref{s:em.fields}) to characterize the element's electromagnetic
fields.

Note: When tracking through a \vn{patch} element, the first step is to
transform the particle's coordinates from the entrance frame to the
exit frame. This is done since it simplifies the tracking. [The
criterion for stopping the propagation of a particle through a
\vn{patch} is that the particle has reached the exit face and the
calculation to determine if a particle has reached the exit face is
simplified if the particle's coordinates are expressed in the
coordinate frame of the exit face.] Thus for \vn{patch} elements,
unlike all other elements, the particle coordinates passed to
\Hyperref{r:em.field.custom}{em_field_custom} are the coordinates with
respect to the exit coordinate frame and not the entrance coordinate
frame.

The \Hyperref{r:make.mat6.custom}{make_mat6_custom} and
\Hyperref{r:make.mat6.custom2}{make_mat6_custom2} routines are called
by the \Hyperref{r:make.mat6}{make_mat6} routine when calculating the
6x6 transfer matrix (Jacobian) through an element. Two routines are
needed here due to the specifics of the coding for the \vn{make_mat6}
routine. This routine is divided into three sections: The code in the
first section is at the start of \vn{make_mat6} and looks like:
\begin{example}
  if (ele%mat6_calc_method == custom$) then
    call make_mat6_custom (ele, param, a_start_orb, a_end_orb)
    return
  endif
\end{example}
Call this the ``custom'' section. The next section in \vn{make_mat6}
uses \vn{ele%mat6_calc_method} to call the appropriate routine for the
indicated calculational method.  This section looks like:
\begin{example}
  select case (ele%mat6_calc_method)
  case (custom2\$)
    call make_mat6_custom2 (ele, param, a_start_orb, a_end_orb)
  case (taylor\$)
    call make_mat6_taylor (ele, param, a_start_orb)
    if (.not. end_input) call track1_taylor (a_start_orb, ele, param, a_end_orb)
  case (bmad_standard\$)
    call make_mat6_bmad (ele, param, a_start_orb, a_end_orb, end_in, err)
  ... etc ...
  end select
\end{example} 
Let us call this the ``method specific'' section. Notice that when
\vn{ele%mat6_calc_method} is set to \vn{custom2\$} -- not \vn{custom\$} -- then
\vn{make_mat6_custom2} is called. The last section, call it the
``common'' section, is everything else. The common section involves
modifying the transfer matrix to include the effect of space charge,
symplectifying the matrix, etc.

The two custom routines are meant to handle two different cases. In
this first case, \vn{ele%mat6_calc_method} is set to \vn{custom\$} and
the \vn{make_mat6_custom} is used to handle the entire matrix
calculation. That is, only the custom section of \vn{make_mat6} is
executed. In this case, a revised \vn{make_mat6_custom2} does not need
to be implemented.

In the second case, it is desired to not to ``reinvent the wheel'' and
to have \vn{make_mat6} handle the ``common'' calculation in the common
section of \vn{make_mat6}. In this case, \vn{ele%make_mat6_custom} needs
to be set to \vn{custom2\$} and then \vn{make_mat6_custom2} will be
called. Since setting to \vn{custom2\$} is not possible in the input
lattice file (this is done to hide this implementation detail from the
``user''), The set to \vn{custom2\$} is done in \vn{make_mat6_custom}
which should look like:
\begin{example}
  ele%mat6_calc_method = custom2\$  ! Was, of course, custom\$
  call make_mat6 (ele, param, start_orb, end_orb) ! Recursive call back to make_mat6
  ele%mat6_calc_method = custom\$   ! Restore
\end{example}

The \Hyperref{r:track1.custom}{track1_custom} and
\Hyperref{r:track1.custom}{track1_custom} routines are called by the
\Hyperref{r:track1}{track1} routine when calculating the transfer
matrix through an element. Two routines are needed here due to the
specifics of the coding for the \vn{track1} routine. See the
discussion on the \vn{make_mat6_custom} and \vn{make_mat6_custom2}
routines above.


%-----------------------------------------------------------------------------
\section{Physical and Mathematical Constants}
\label{s:physical.constants}

\index{constants}
Common physical and mathematical constants that can be used in any expression
are defined in the file:
\begin{example}
 sim_utils/interfaces/physical_constants.f90
\end{example}

The following constants are defined
\begin{example}
  pi = 3.14159265358979d0
  twopi = 2 * pi
  fourpi = 4 * pi
  sqrt_2 = 1.41421356237310d0
  sqrt_3 = 1.73205080757d0
  complex: i_imaginary = (0.0d0, 1.0d0)

  e_mass = 0.51099906d-3   ! DO NOT USE! In GeV
  p_mass   = 0.938271998d0   ! DO NOT USE! In GeV

  m_electron = 0.51099906d6  ! Mass in eV
  m_proton   = 0.938271998d9 ! Mass in eV

  c_light = 2.99792458d8             ! speed of light
  r_e = 2.8179380d-15                ! classical electron radius
  r_p = r_e * m_electron / m_proton  ! proton radius
  e_charge = 1.6021892d-19           ! electron charge

  h_planck = 4.13566733d-15          ! eV*sec Planck's constant
  h_bar_planck = 6.58211899d-16      ! eV*sec h_planck/twopi

  mu_0_vac = fourpi * 1e-7                   ! Permeability of free space
  eps_0_vac = 1 / (c_light**2 * mu_0_vac)    ! Permittivity of free space

  classical_radius_factor = r_e * m_electron ! Radiation constant

  g_factor_electron = 0.001159652193    ! Anomalous gyro-magnetic moment
  g_factor_proton   = 1.79285           ! Anomalous gyro-magnetic moment
\end{example}

%-----------------------------------------------------------------------------
\section{Global Coordinates and S-positions}
\label{s:global.coords}

\index{global coordinates}
\index{s-positions}
The routine \Hyperref{r:lat.geometry}{lat_geometry} will compute the
global floor coordinates at the end of every element in a lattice.
\vn{lat_geometry} works by repeated calls to \Hyperref{r:ele.geometry}{ele_geometry} which
takes the floor coordinates at the end of one element and calculates
the coordinates at the end of the next. For conversion between
orientation matrix $\Bf W$ (\sref{s:global}) and the orientation
angles $\theta, \phi, \psi$, the routines \Hyperref{r:floor.angles.to.w.mat}{floor_angles_to_w_mat}
and \Hyperref{r:floor.w.mat.to.angles}{floor_w_mat_to_angles} can be used.

The routine \Hyperref{r:s.calc}{s_calc} calculates the longitudinal $s$ positions for
the elements in a lattice.

%-----------------------------------------------------------------------------
\section{Reference Energy}
\label{s:ref.energy}

\index {reference energy}
The reference energy for the elements in a lattice is calculated by
\Hyperref{r:lat.compute.ref.energy.and.time}{lat_compute_ref_energy_and_time}.
The reference energy associated with a lattice element is generally stored in
\begin{example}
  ele%value(E_tot\$)      ! Total energy (eV)
  ele%value(p0c\$)        ! Momentum * c_light (eV)
\end{example}

\index{multipass!reference energy}
\vn{multipass} lord (\sref{s:multipass}) elements have a
reference energy but only if the \vn{n_ref_pass} attribute is set. In
this case, the \vn{multipass} lord inherits the reference energy of
the referenced slave.

\index{group!reference energy}\index{overlay!reference energy}
\index{superposition!reference energy}
\vn{group} (\sref{s:group}), \vn{overlay} (\sref{s:overlay}), and
\vn{super_lord} elements inherit the reference from the last slave in
their slave list (\sref{s:lat.control}). For \vn{super_lord} elements
this corresponds to inheriting the reference energy of the slave at
the exit end of the \vn{super_lord}. For \vn{group} and \vn{overlay}
elements a reference energy only makes sense if all the elements under
control have the same reference energy.

\index{lcavity!reference energy}\index{custom!reference energy}\index{hybrid!reference energy}
Generally, the reference energy is constant throughout an
element. Exceptions are \vn{lcavity}, \vn{custom} and \vn{hybrid}
elements. For these types of elements, the above reference energy
components refer to the exit end of the element and there are two
additional attributes that give the reference energy at the start of
the element
\begin{example}
  ele%value(E_tot_start\$)      ! Total energy at entrance end of element (eV)
  ele%value(p0c_start\$)        ! Momentum * c_light at entrance end of element (eV)
\end{example}
These starting energies are the same as the exit end energies of the upstream element in the lattice.

Additionally, photonic elements like \vn{crystal}, \vn{capillary},
\vn{mirror} and \vn{multilayer_mirror} elements have an associated photon reference wavelength
\begin{example}
  ele%value(ref_wavelength\$)      ! Meters.
\end{example}

%-----------------------------------------------------------------------------
\section{Common Structures}
\label{s:common.struct}

\index{bmad_com}
\index{bmad_status}

There are two common variables used by Bmad for communication between
routines. These are \vn{bmad_com}, which is a \vn{bmad_common_struct}
structure, and \vn{bmad_status} which is a \vn{bmad_status_struct}
structure. The \vn{bmad_com} structure is documented in
Section~\sref{s:bmad.params}. The \vn{bmad_status_struct}
\index{status}\index{ok}
\index{type_out}\index{sub_type_out}
\index{exit_on_error}
The \vn{bmad_status_struct} structure is, along with the default values:
\begin{example}
type bmad_status_struct
  logical :: ok             = .true.   ! Error flag
  logical :: type_out       = .true.   ! Print error messages?
  logical :: exit_on_error  = .true.   ! Exit program on error?
end type
\end{example}
The \vn{%ok} component can be set to indicate that an error has been
encountered in a routine. Using \vn{%ok} is deprecated for a number of
reasons. For one, it is not thread safe. The long term goal is to
replace this by adding error flag arguments to the appropriate
routines.

The \vn{%type_out} component tells a routine if warning or error
messages should be printed. With Severe errors, the code may ignore
\vn{%type_out} and print an error message irregardless.

The \vn{%exit_on_error} component tell a routine if it is ok to stop a
program on a severe error.



