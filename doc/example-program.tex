\chapter{Introduction to Bmad programming}
\label{c:program.info}

To get the general feel for how \bmad works before
getting into the nitty--gritty details in subsequent chapters, this
chapter analyzes a simple test program.

%-----------------------------------------------------------------------------
\section{A First Program}
\index{programming!example program}

Consider the simple test program shown in Figure~\ref{f:program}.
This program is provided with the \bmad distribution in a file called
\vn{simple_program.f90}. \vn{simple_program.f90} is in the \vn{bmad}
library area in a directory called \vn{bmad/simple_program}.

\begin{figure}[ht]
\begin{listing}{1}
program test

  use bmad                 ! Define the structures we need to know about.
  implicit none
  type (lat_struct) lat   ! This structure holds the lattice info
  type (ele_pointer_struct), allocatable :: eles(:)
  integer i, ix

! Read in a lattice and calculate the twiss parameters.

  call bmad_parser ("simple_program/lat.bmad", lat) ! Read in a lattice.
  call twiss_at_start (lat)           ! Calculate starting Twiss params.
  call twiss_propagate_all (lat)      ! Propagate Twiss parameters

! Print info on the first 11 elements

  print *, ' Ix  Name              Ele_type                   S      Beta_a'
  do i = 0, 10
    print '(i4, 2x, a16, 2x, a, 2f12.4)', i, lat%ele(i)%name, &
                    key_name(lat%ele(i)%key), &
                    lat%ele(i)%s, lat%ele(i)%a%beta
  enddo

! Find the CLEO_SOL element and print information on it.

  call lat_ele_locator ('CLEO_SOL', lat, eles)
  print *
  print *, '!---------------------------------------------------------'
  print *, '! Information on element: CLEO_SOL'
  print *
  call type_ele (eles(1)%ele, .false., 0, .false., 0, .true., lat)

  deallocate (eles)

end program
\end{listing}
\caption{A simple first program}
\label{f:program}
\end{figure}

\index{programming!gmake}
\index{programming!production executable}
\index{programming!debug executable}
Making \vn{bmad} the working directory, the \vn{gmake -f M.simple_program}
command will compiling and link the program.  The
executables, \vn{simple_program} and \vn{simple_program_g}, are to be
found in \vn{../bin/}. Running the program with the command
\vn{../bin/simple_program} gives the output as shown in
Figure~\ref{f:output}.

\begin{figure}[ht]
\small
\begin{listing}{1}
  Ix  Name              Ele_type                   S      Beta_a
   0  BEGINNING         INIT_ELEMENT          0.0000      0.9381
   1  IP_L0             MARKER                0.0000      0.9381
   2  CLEO_SOL#3        SOLENOID              0.6223      1.3500
   3  DET_00W           MARKER                0.6223      1.3500
   4  CLEO_SOL#4        SOLENOID              0.6380      1.3710
   5  Q00W\CLEO_SOL     SOL_QUAD              1.7550      7.8619
   6  Q00W#1            QUADRUPOLE            2.1628     16.2350
   7  D003              DRIFT                 2.4934     27.4986
   8  DET_01W           MARKER                2.4934     27.4986
   9  D004              DRIFT                 2.9240     46.6018
  10  Q01W              QUADRUPOLE            3.8740     68.1771

 !---------------------------------------------------------
 ! Information on element: CLEO_SOL 

  Element #         871
  Element Name: CLEO_SOL
  Key: SOLENOID
  S:              1.7550
  Ref_time:   0.0000E+00
 
  Attribute values [Only non-zero values shown]:
      1   L                      =  3.5100000E+00
      7   KS                     = -8.5023386E-02
     32   P0C                    =  5.2890000E+09
     33   E_TOT                  =  5.2890000E+09
     34   BS_FIELD               = -1.5000000E+00
     50   DS_STEP                =  2.0000000E-01
 
          TRACKING_METHOD        =  Bmad_Standard
          MAT6_CALC_METHOD       =  Bmad_Standard
          FIELD_CALC             =  Bmad_Standard
          APERTURE_AT            =  Exit_End
          OFFSET_MOVES_APERTURE  =  F
          INTEGRATOR_ORDER:      =     2
          NUM_STEPS              =    18
          SYMPLECTIFY            =  F
          FIELD_MASTER           =  F
          CSR_CALC_ON            =  T
 
 Lord_status:  SUPER_LORD
 Slave_status: FREE
 Slaves: Number:   6
      Name                           Lat_index  Attribute           Coefficient
      Q00E\CLEO_SOL                        865  --------              3.182E-01
      CLEO_SOL#1                           866  --------              4.460E-03
      CLEO_SOL#2                           868  --------              1.773E-01
      CLEO_SOL#3                             2  --------              1.773E-01
      CLEO_SOL#4                             4  --------              4.460E-03
      Q00W\CLEO_SOL                          5  --------              3.182E-01
\end{listing}
\caption{Output from a simple first program}
\label{f:output}
\end{figure}

%-----------------------------------------------------------------------------
\section{Explanation of the Simple_Program}

\index{lat_struct!example use of}
A line by line explanation of the simple test program follows. 
The \vn{use bmad} statement at line 3
defines the \bmad structures and defines the interfaces
(argument lists) for the \bmad subroutines. In particular, the
\vn{lat_struct} structure (line 5) holds all of the lattice
information: The list of elements, their attributes,
etc. \vnr{bmad_parser} (line 10) is the routine which parses a lattice
file and transfers the information to a
\vn{lat_struct} variable. Note: Despite its name, \bmad does
not make any assumption about whether a \vn{lat_struct} is actually
closed or open like a LINAC. To get a listing of the \vn{lat_struct}
components or to find out more about \vn{bmad_parser} use the \vn{getf}
command as discussed in \sref{s:getf}.

After \vnr{bmad_parser} is called, the program uses the
routine \vnr{twiss_at_start} (line 11) to multiply the transfer
matrices of the individual elements together to form the 1--turn
matrix from the start of the lat back to the start. [Of course,
if the lattice is not closed you would not want the program to do
this.] From this matrix
\vn{twiss_at_start} calculates the Twiss parameters at the start of
the lattice and puts the information into the \vn{lat} variable. The
next call, to \vnr{twiss_propagate_all} (line 12), takes the starting
Twiss parameters and, using the transfer matrices of the individual
elements, calculates the Twiss parameters at all the elements. Again
the results of the calculation are stored in \vn{lat}. 

\index{ele_struct!\%x}
\index{ele_struct!\%key}
\index{ele_struct!\%s}
\index{lat_struct!\%ele(:)}
The program is now ready to print out the results of the calculation
which it does on lines 16 through 21 of the program and lines 1 through 12
of the output. \vn{lat} has within it an array
\vn{lat%ele(0:)}.  Each element of the array holds the information
about an individual element as explained in
Chapter~\ref{c:ele.struct}. \vn{lat%ele(0)} is basically a marker
element to denote the beginning of the array. \vn{lat%ele(i)%key} is
an integer denoting what type of element (quadrupole, wiggler, etc.)
it is. \vn{key_name} is an array that translates the key of an element
to a string. \vn{lat%ele(i)%s} is the longitudinal position at the
exit end of the i\Th\ element. \vn{lat%ele(i)%x%beta} is the
$a$--mode (nearly horizontal mode) beta.

The next section of the program, lines 25 through 30, uses the routine
\vnr{element_locator} to find the index of an
element in the \vn{lat%ele(:)} array with the name \vn{CLEO_SOL}.
\vnr{type_ele} is used to type out the element's attributes and other
information as shown on lines 14 through 41 of the output (more on this later).

This brings us to the lattice file used for the input to the program.
The name of the lattice file is 
  \begin{example}
  lat.bmad
  \end{example} 
if you look at this file you will find a call to another file
  \begin{example}
  call, file = "layout.bmad"
  \end{example}
\index{line}
It is in this second file
that the layout of the lattice is defined. In particular, the \vn{line} used
to define the element order looks like
\begin{example}
  cesr: line = (IP_L0, d001, DET_00W, d002, Q00W, d003, ...)
  use, cesr
\end{example}
If you compare this to the listing of the elements in
Figure~\ref{f:output} you will find differences. For example, element
\#2 in the program listing is named \vn{CLEO_SOL\B3}. From the
definition of the \vn{cesr} line this should be \vn{d001} which, if
you look up its definition in \vn{layout.bmad} is a drift.  The
difference between lattice file and output is due to the presence
the \vn{CLEO_SOL} element which appears in \vn{lat.bmad}:
\begin{example}
  ks_solenoid    := -1.0e-9 * clight * solenoid_tesla / beam[energy]
  cleo_sol: solenoid, l = 3.51, ks = ks_solenoid, superimpose 
\end{example}
\index{superimpose!example}
The solenoid is 3.51 meters long
and it is superimposed upon the lattice with its center at $s = 0$ (this
is the default if the position is not specified). 
When \vn{bmad_parser} constructs the lattice list of elements
the superposition of \vn{IP_L0}, which is a zero--length marker, with the
solenoid does not modify \vn{IP_L0}. The superposition of the
\vn{d001} drift with the solenoid gives a solenoid with the same
length as the drift. Since this is a ``new'' element, \vn{bmad_parser}
makes up a name that reflects that it is basically a section of the
solenoid it came from.  Next, since the \vn{CLEO_SOL} element happens to
only cover
part of the \vn{Q00W} quadrupole, \vn{bmad_parser} breaks the
quadrupole into two pieces. The piece that is inside the solenoid is a
\vn{sol_quad} and the piece outside the solenoid is a regular
quadrupole. See \sref{s:super} for more details. Since the
center of the \vn{CLEO_SOL} is at $s = 0$, half of it extends to
negative $s$. In this situation, \vn{bmad_parser} will wrap this half
back and superimpose it on the elements at the end of the lattice list
near $s = s_{lat}$ where $s_{lat}$ is the length of the lattice.  As
explained in Chapter~\ref{c:lat.struct}, the lattice list that is used
for tracking extends from \vn{lat%ele(0)} through \vn{lat%ele(n)}
where \vn{n = lat%n_ele_track}. The \vn{CLEO_SOL} element is put in the
section of \vn{lat%ele(n)} with \vn{n > lat%n_ele_track} since it is
not an element to be tracked through. The \vn{Q00W} quadrupole also
gets put in this part of the list.  The bookkeeping information that
the \vn{cleo_sol\B3} element is derived from the \vn{cleo_sol} is put
in the \vn{cleo_sol} element as shown in lines 33 through 41 of the
output.  It is now possible in the program to vary, say, the strength
of the \vn{ks} attribute of the \vn{CLEO_SOL} and have the \vn{ks}
attributes of the dependent (``\vn{super_slave}'') elements updated
with one subroutine call. For example, the following code increases the
solenoid strength by 1\%
\begin{example}
  call element_locator ('CLEO_SOL', lat, ix)
  lat%ele(ix)%value(ks$) = lat%ele(ix)%value(ks$) * 1.01 
  call control_bookkeeper (lat, ix)
\end{example}
\bmad takes care of the bookkeeping. In fact \vn{control_bookkeeper} is
automatically called when transfer matrices are remade so the direct call
to \vn{control_bookkeeper} may not be necessary.

