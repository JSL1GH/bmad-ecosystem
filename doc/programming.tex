\chapter{Bmad Programming Overview}
\label{c:programming}

%-----------------------------------------------------------------------
\section {The Bmad Distribution}
\label{s:libs}
\index{Bmad!distribution}

The \bmad distribution consists of the \bmad library and six subsidiary
libraries which \bmad depends upon. The \bmad distribution can be obtained at:
\begin{example}
    http://www.lepp.cornell.edu/~dcs/bmad
\end{example}
Supported platforms are Tru64 (aka OSF) and Linux. On Linux the \bmad
distribution has been built with the Lahey--Fujitsu f95 compiler. The
\bmad distribution has also been built on VMS and Windows and an
initial check indicates that the distribution should be build able
under Sun Solaris. The \bmad web site has contact information for
questions about platform support and building problems.

\index{Libraries, Software}
The subsidiary libraries are: 
\begin{description}
\index{Cesr_Utils library}
\item[cesr_utils] 
This is a low level library. Despite its name the
routines in this library do not have anything to do with the Cornell
CESR storage ring.  In \vn{cesr_utils} the module \vn{precision_def}
defines the precision that \bmad works at (see
\sref{s:precision}) and the module \vn{physical_constants}
gives the physical and mathematical constants (\vn{pi}, \vn{c_light},
etc.) that \bmad knows about.

\index{Dcslib library}
\item[dcslib] 
This library defines a set of miscellaneous helper
routines.  Routines include spline fitting, Gaussian random number
generation, etc. The library is named after its creator.

\index{PTC/FPP!library}
\item[forest] 
This is the PTC/FPP (Polymorphic Tracking Code /
Fully Polymorphic Package) library of Etienne Forest that handles
Taylor maps to any arbitrary order (this is also known as Truncated
Power Series Algebra (TPSA)). See Chapter~\ref{c:etienne} for more
details.  FPP/PTC is a very general package and \bmad only makes use
of a small part of its features.  For more information see the FPP/PTC
web site at
\begin{example} 
   http://acc-physics.kek.jp/forest/PTC/Introduction.html
\end{example}

\index{Numerical Recipes!library}
\item[recipes] 
Numerical Recipes is a set of subroutines for doing
scientific computing including Runge--Kutta integration, FFT's,
interpolation and extrapolation, etc., etc. The documentation for this
library is the books ``Numerical Recipes, in Fortran, The Art of
Scientific Computing'' and ``Numerical Recipes in
Fortran90, the Art of Parallel Scientific Computing''\cite{b:nr}.
The first book explains how the subroutines work and the second book
explains what the argument lists for the Fortran90 version of the
subroutines are. You do need both books if you want to use Numerical
Recipes. For \bmad this library has been modified to handle both
single or double precision reals as needed in the other libraries (See
\sref{s:precision}).

\index{PGPLOT!library}
\item[PGPLOT] 
The PGPLOT Graphics Subroutine Library is a Fortran or
C-callable, device-independent graphics package for making simple
scientific graphs. Documentation including a user's manual may be
obtained from the PGPLOT web site at
\begin{verbatim}
    http://www.astro.caltech.edu/~tjp/pgplot.
\end{verbatim} 
One disadvantage of PGPLOT for the programmer is that it is not the
most user friendly. To remedy this, there is a set of Fortran90
wrapper subroutines called \vn{quick_plot}.  The \vn{quick_plot}
suite is part of the dcslib library and is documented in
Chapter~\ref{c:quick.plot}.

\index{XSIF!library}
\item[XSIF] 
XSIF is a library from SLAC to read in XSIF format files. See 
\sref{s:lattice.file.formats} for more details. The only
\bmad routine to use this library is \vn{xsif_parser}.

\end{description}

The \bmad distribution also contains the \tao library. \tao is a program 
which uses \bmad as the simulation engine and is meant as a general 
purpose tool for simulating accelerators. See the \tao documentation, which 
can be obtained from the \bmad web page, for more information.

%-----------------------------------------------------------------------------
\section{Getf and Listf}
\label{s:getf}
\index{Getf}
\index{Listf}

As can be seen from the program example in Chapter~\ref{c:program.info}
there is a lot going on behind the scenes even for this
simple program. This shows that programming with \bmad can be both easy
and hard. Easy in the sense that a lot can be done with just a few
lines. The hard part comes about since there are many details that
have to be kept in mind in order to make sure that the subroutines
are calculating what you really want them to calculate.

To help with the details all \bmad subroutines have in their source (.f90)
files a comment block that explains the arguments needed by the
subroutines and explains what the subroutine does. To help quickly
access these comments there are two Perl scripts that are supplied
with the \bmad distribution that are invoked with the commands
\vn{listf} and \vn{getf}.

The \vn{getf} command is used to locate routines and structures, and
to type out information on them.  The form of the command is
\begin{verbatim}
    getf <name>
\end{verbatim}
This searches for any routine or structure with the name
\vn{<name>}. \vn{<name>} may contain the wild--cards ``*'' and ``.'' where
``*'' matches to any number of characters and ``.'' matches to any
single character. For example:
\begin{example}
    getf bmad_parser
    getf lat_struct
    getf twiss_at_.
\end{example}
The third line in this example will match to the routine
\vn{twiss_at_s} but not the routine \vn{twiss_at_start}. You may or
may not have to put quotation marks if you use wild card characters.
As an example, the command \vn{getf twiss_struct} produces:
\begin{example}
  /home/cesrulib/cesr_libs/devel/cvssrc/bmad/modules/twiss_mod.f90
    type twiss_struct
      real(rp) beta, alpha, gamma, phi, eta, etap
      real(rp) sigma, emit
    end type
\end{example}
The first line shows the file where the structure is located (This is
system and user dependent so don't be surprised if you get a different
directory when you use \vn{getf}). The rest of the output shows the
definition of the \vn{twiss_struct} structure.  The result of issuing
the command \vn{getf element_locator} is:
\begin{example}
  /home/cesrulib/cesr_libs/devel/cvssrc/bmad/code/element_locator.f90
  !+
  ! Subroutine element_locator (ele_name, lat, ix_ele)
  !
  ! Subroutine to locate an element in a lat. 
  !
  ! Modules Needed:
  !   use bmad
  !
  ! Input:
  !   ele_name -- Character*16: Name of the element to find.
  !   lat     -- Lat_struct: Lat to search through
  !
  ! Output:
  !   ix_ele -- Integer: Index of element in lat%ele(:) array. 
  !               ix_ele set to -1 if not found.
  !-
\end{example}
The first line again shows in what file the subroutine is located.
The rest of the output explains what the routine does and how it
can be called.

The \vn{listf} command is like the \vn{getf} command except that only
the file name where a routine or structure is found is printed.
The \vn{listf} command is useful if you
want to just find out where a routine or structure definition lives.
For example, the \vn{listf *locator*} command would produce
\begin{example}
  /home/cesrulib/cesr_libs/devel/cvssrc/bmad/code/element_locator.f90
  /home/cesrulib/cesr_libs/devel/cvssrc/bmad/code/elements_locator.f90
  /home/cesrulib/cesr_libs/devel/cvssrc/dcslib/code/cesr_locator.f90
\end{example}

The way \vn{getf} and \vn{listf} work is that they search a list of
directories to find the \vn{bmad}, \vn{dcslib}, \vn{cesr_utils}, and \vn{tao}
libraries. Currently the libraries in the \bmad distribution that were
not developed at Cornell are not searched. This is primarily due to
the fact that, to save time, \vn{getf} and \vn{listf} make assumptions
about how documentation is arranged in a file and the non--Cornell libraries 
do not follow this format.

%-----------------------------------------------------------------------
\section{Precision}
\label{s:precision}
\index{Programming!precision (rp)}
\index{RP}

\bmad comes in two flavors: One version where the real numbers are single
precision and a second version with double precision reals. Which
version you are working with is controlled by the kind parameter \vn{rp}\
(Real Precision) which is defined in the \vn{precision_def}
module. [Note: For compatibility with older programs the kind parameter
\vn{rdef} is defined to be equal to \vn{rp}.]  On most platforms single
precision translates to \vn{rp}\ = 4 and double precision to \vn{rp}\ =
8. Normally the double precision version is used since round-off
errors can be significant in some calculations. Long--term tracking is
an example where the single precision version is not adequate. Changing 
the precision means recompiling all the libraries except PTC and PGPLOT. 
You cannot mix and match. Either you are using the single precision version
or you are using the double precision version.

To define your variables in Fortran with the correct precision use the syntax
{\tt real(rp)}. For example:
\begin{example}
    real(rp) var1, var2, var3
\end{example}
When you want to define a literal constant, for example to pass an
argument to a subroutine, add the suffix \vn{_rp} to the end of the
constant. For example
\begin{example}
   var1 =  2.0_rp * var2
   call my_sub (var1, 1.0e6_rp)
\end{example}
Note that \vn{2_rp} is different from \vn{2.0_rp}. \vn{2_rp} is an
integer of kind \vn{rp}, not a real.

Independent of the setting of \vn{rp}, the parameters \vn{sp} and
\vn{dp} are defined to give single and double precision numbers
respectively.

%-----------------------------------------------------------------------------
\section{Programming Conventions}
\index{Programming!conventions}

\bmad subroutines follow the following conventions:

\begin{description}

\index{Programming!\$}
\item[\$ Denotes Parameter:] A ``\$'' at the end of a name denotes an 
integer parameter. For example, in the above program, to check
whether an element is a quadrupole one would write:
\begin{verbatim}
  if (lat%ele(i)%key == quadrupole$) ...
\end{verbatim}
Checking the source code one would find in the module \vn{bmad_struct}
\begin{verbatim}
  integer, parameter :: drift$ = 1, sbend$ = 2, quadrupole$ = 3, group$ = 4
\end{verbatim}
One should always use the parameter name instead of the integer it represents.
That is, one should never write
\begin{verbatim}
  if (lat%ele(i)%key == 3) ...  ! DO NOT DO THIS!
\end{verbatim}
For one, using the name makes the code clearer. However, more
importantly, the integer value of the parameters may at times be
shuffled for practical internal reasons. The use of the integer value
could thus lead to disastrous results.  

\index{Programming!structures}
\item[Structure names have a _struct suffix:]
For example: \vn{lat_struct}, \vn{ele_struct}, etc. Structures without a 
\vn{_struct} are usually part of Etienne's PTC/FPP package.

\end{description}