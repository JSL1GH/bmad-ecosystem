\chapter{Bmad Programming Overview}
\label{c:programming}

%-----------------------------------------------------------------------
\section {The Bmad Libraries}
\label{s:libs}
\index{Bmad!distribution}

The code that goes into a program based upon \bmad is divided up into
a number of libraries. The \bmad web site has general information on
the organization of these libraries including information on obtaining
and compiling programs. The \bmad web site is at:
\begin{example}
    http://www.lepp.cornell.edu/~dcs/bmad
\end{example}

The \bmad libraries are divided into two groups. One group of
libraries contains the Cornell developed code. The other
\vn{``package''} libraries consist of non-Cornell code that \bmad
relies upon.

The Cornell developed code can further be divided into CESR storage
ring specific code and non-CESR specific code. The CESR specific code
will not be discussed in this Manual.

The Cornell developed non-CESR specific code libraries are:
subsidiary libraries are: 
\begin{description}
  \index{sim_utils library}
  \item[bmad]
The \vn{bmad} library contains the routines for relativistic charged
particle simulation including particle tracking, Twiss calculations,
symplectic integration, etc., etc.
  \item[sim_utils] 
The \vn{sim_utils} library contains a set of miscellaneous helper routines. 
Included are routines for string manipulation, file manipulation,
matrix manipulation, spline fitting, Gaussian random number generation, etc. 
\end{description}

The \vn{package} libraries are:
\begin{description}
  \index{fftw!library}
  \item{FFTW}
FFTW is a C subroutine library for computing the discrete Fourier
transform in one or more dimensions. FFTW has a Fortran 2003 API.
  \index{gsl!library}
  \index{fgsl!library}
  \item[GSL / FGSL]
The Gnu Scientific Library (GSL), written in C,
provides a wide range of mathematical routines
such as random number generators, special functions and least-squares
fitting. There are over 1000 functions in total. The FGSL library provides a Fortran
interface to the GSL library.
  \index{pgplot!library}
  \item[pgplot] 
The \vn{pgplot} Graphics Subroutine Library is a Fortran or
C-callable, device-independent graphics package for making simple
scientific graphs. Documentation including a user's manual may be
obtained from the \vn{pgplot} web site at
\begin{verbatim}
    http://www.astro.caltech.edu/~tjp/pgplot.
\end{verbatim} 
One disadvantage of \vn{pgplot} for the programmer is that it is not the
most user friendly. To remedy this, there is a set of Fortran90
wrapper subroutines called \vn{quick_plot}.  The \vn{quick_plot}
suite is part of the sim_utils library and is documented in
Chapter~\ref{c:quick.plot}.
  \index{LAPACK!library}
  \index{LAPACK95!library}
  \item[LAPACK / LAPACK95]
LAPACK is a widely used package of linear algebra routines written in
Fortran77.  The LAPACK95 library provides a Fortran95 interface to
LAPACK.
  \index{PTC/FPP!library}
  \item[forest] 
This is the PTC/FPP (Polymorphic Tracking Code / Fully Polymorphic
Package) library of \'Etienne Forest that handles Taylor maps to any
arbitrary order (this is also known as Truncated Power Series Algebra
(TPSA)). See Chapter~\ref{c:ptc} for more details.  FPP/PTC is a
very general package and \bmad only makes use of a small part of its
features.  For more information see the FPP/PTC
manual\cite{b:ptc}. The core Differential Algebra (DA) package used
by PTC was developed by Martin Berz\cite{b:berz}.
  \index{numerical recipes!library}
  \item[recipes] 
Numerical Recipes is a set of subroutines for doing scientific
computing including Runge--Kutta integration, FFTs, interpolation and
extrapolation, etc., etc. The documentation for this library is the
books ``Numerical Recipes, in Fortran, The Art of Scientific
Computing'' and ``Numerical Recipes in Fortran90, the Art of Parallel
Scientific Computing''\cite{b:nr}.  The first book explains how the
subroutines work and the second book explains what the argument lists
for the Fortran90 version of the subroutines are. You do need both
books if you want to use Numerical Recipes. For \bmad, this library
has been modified to handle double precision reals which is the
standard for the other libraries (See \sref{s:precision}).
  \index{xraylib!library}
  \item{XRAYLIB}
The XRAYLIB library provides routines for obtaining parameters
pertinent to the X-ray interaction with matter.
  \index{xsif!library}
  \item[xsif] 
\vn{xsif} is a library from \vn{SLAC} to read in \vn{xsif} format files. See 
\sref{s:lattice.file.formats} for more details. The only
\bmad routine to use this library is \vn{xsif_parser}.
\end{description}

%-----------------------------------------------------------------------------
\section{Using getf and listf for Viewing Routine and Structure Documentation}
\label{s:getf}
\index{getf}
\index{listf}

As can be seen from the program example in Chapter~\ref{c:program.info}
there is a lot going on behind the scenes even for this
simple program. This shows that programming with \bmad can be both easy
and hard. Easy in the sense that a lot can be done with just a few
lines. The hard part comes about since there are many details that
have to be kept in mind in order to make sure that the subroutines
are calculating what you really want them to calculate.

To help with the details, all \bmad subroutines have in their source (.f90)
files a comment block that explains the arguments needed by the
subroutines and explains what the subroutine does. To help quickly
access these comments, there are two Perl scripts that are supplied
with the \bmad distribution that are invoked with the commands
\vn{listf} and \vn{getf}.

The \vn{getf} command is used to locate routines and structures, and
to type out information on them.  The form of the command is
\begin{verbatim}
    getf <name>
\end{verbatim}
This searches for any routine or structure with the name
\vn{<name>}. \vn{<name>} may contain the wild--cards ``*'' and ``.'' where
``*'' matches to any number of characters and ``.'' matches to any
single character. For example:
\begin{example}
    getf bmad_parser
    getf lat_struct
    getf twiss_at_.
\end{example}
The third line in this example will match to the routine
\vn{twiss_at_s} but not the routine \vn{twiss_at_start}. You may or
may not have to put quotation marks if you use wild card characters.
As an example, the command \vn{getf twiss_struct} produces:
\begin{example}
  /home/cesrulib/cesr_libs/devel/cvssrc/bmad/modules/twiss_mod.f90
    type twiss_struct
      real(rp) beta, alpha, gamma, phi, eta, etap
      real(rp) sigma, emit
    end type
\end{example}
The first line shows the file where the structure is located (This is
system and user dependent so don't be surprised if you get a different
directory when you use \vn{getf}). The rest of the output shows the
definition of the \vn{twiss_struct} structure.  The result of issuing
the command \vn{getf element_locator} is:
\begin{example}
  /home/cesrulib/cesr_libs/devel/cvssrc/bmad/code/element_locator.f90
  !+
  ! Subroutine element_locator (ele_name, lat, ix_ele)
  !
  ! Subroutine to locate an element in a lat. 
  !
  ! Modules Needed:
  !   use bmad
  !
  ! Input:
  !   ele_name -- Character(40): Name of the element to find.
  !   lat      -- Lat_struct: Lattice to search through.
  !
  ! Output:
  !   ix_ele -- Integer: Index of element in lat%ele(:) array. 
  !               ix_ele set to -1 if not found.
  !-
\end{example}
The first line again shows in what file the subroutine is located.
The rest of the output explains what the routine does and how it
can be called.

The \vn{listf} command is like the \vn{getf} command except that only
the file name where a routine or structure is found is printed.
The \vn{listf} command is useful if you
want to just find out where a routine or structure definition lives.
For example, the \vn{listf *locator*} command would produce
\begin{example}
  /home/cesrulib/cesr_libs/devel/cvssrc/bmad/code/element_locator.f90
  /home/cesrulib/cesr_libs/devel/cvssrc/bmad/code/elements_locator.f90
  /home/cesrulib/cesr_libs/devel/cvssrc/cesr_utils/cesr_locator.f90
\end{example}

The way \vn{getf} and \vn{listf} work is that they search a list of
directories to find the \vn{bmad}, \vn{sim_utils}, and \vn{tao}
libraries. Currently the libraries in the \bmad distribution that were
not developed at Cornell are not searched. This is primarily due to
the fact that, to save time, \vn{getf} and \vn{listf} make assumptions
about how documentation is arranged in a file and the non--Cornell libraries 
do not follow this format.

%-----------------------------------------------------------------------
\section{Precision of Real Variables}
\label{s:precision}
\index{programming!precision (rp)}
\index{rp}


Historically, \bmad come in two flavors: One version where the real
numbers are single precision and a second version with double
precision reals. Which version you are working with is controlled by
the kind parameter \vn{rp}\ (Real Precision) which is defined in the
\vn{precision_def} module. On most platforms, single precision
translates to \vn{rp}\ = 4 and double precision to \vn{rp}\ = 8. The
double precision version is used by default since round-off errors can
be significant in some calculations. Long--term tracking is an example
where the single precision version is not adequate. Changing the
precision means recompiling all the libraries except \vn{PTC} and
\vn{pgplot}.  You cannot mix and match. Either you are using the
single precision version or you are using the double precision
version. Currently, \bmad is always compiled double precision and it
is a near certainty that there would have to be some fixes if there
was ever a need for compiling single precision.

To define floating point variables in Fortran with the correct precision,
 use the syntax {\tt ``real(rp)''}. For example:
\begin{example}
    real(rp) var1, var2, var3
\end{example}
When you want to define a literal constant, for example to pass an
argument to a subroutine, add the suffix \vn{_rp} to the end of the
constant. For example
\begin{example}
   var1 =  2.0_rp * var2
   call my_sub (var1, 1.0e6_rp)
\end{example}
Note that \vn{2_rp} is different from \vn{2.0_rp}. \vn{2_rp} is an
integer of kind \vn{rp}, not a real.

Independent of the setting of \vn{rp}, the parameters \vn{sp} and
\vn{dp} are defined to give single and double precision numbers
respectively.

%-----------------------------------------------------------------------------
\section{Programming Conventions}
\index{programming!conventions}

\bmad subroutines follow the following conventions:

\begin{description}

\index{\$!character to denote a parameter}
\item[A ``\$'' suffix denotes a parameter:] 
A ``\$'' at the end of a name denotes an 
integer parameter. For example, in the above program, to check
whether an element is a quadrupole one would write:
\begin{verbatim}
  if (lat%ele(i)%key == quadrupole$) ...
\end{verbatim}
Checking the source code one would find in the module \vn{bmad_struct}
\begin{verbatim}
  integer, parameter :: drift$ = 1, sbend$ = 2, quadrupole$ = 3, group$ = 4
\end{verbatim}
One should always use the parameter name instead of the integer it represents.
That is, one should never write
\begin{verbatim}
  if (lat%ele(i)%key == 3) ...  ! DO NOT DO THIS!
\end{verbatim}
For one, using the name makes the code clearer. However, more
importantly, the integer value of the parameters may at times be
shuffled for practical internal reasons. The use of the integer value
could thus lead to disastrous results.  

\index{structures}
\item[Structure names have a ``_struct'' suffix:]
For example: \vn{lat_struct}, \vn{ele_struct}, etc. Structures without a 
\vn{_struct} are usually part of \'Etienne's PTC/FPP package.

\end{description}

%-----------------------------------------------------------------------------
\section{Manual Notation}
\label{s:component}

\bmad defines a number of structures and these structures may contain
components which are structures, etc. In order to keep the text in
this manual succinct when referring to components, the enclosing
structure name may be dropped. For example, the \vn{lat_struct}
structure looks like
\begin{example}
  type lat_struct
    character(40) name               
    type (mode_info_struct) a, b, z  
    type (lat_param_struct) param    
    type (ele_struct), pointer ::  ele(:)
    type (branch_struct), allocatable :: branch(:)  
    ... etc. ...
  end type
\end{example}
In this example, ``\vn{%a}'' could be used to refer to, the \vn{a}
component of the \vn{lat_struct}.  To make it explicit that this is a
component of a \vn{lat_struct}, ``\vn{lat_struct%a}'' is an alternate
possibility. Since the vast majority of structures have the
``_struct'' suffix, this may be shortened to ``\vn{lat%a}''. A similar
notation works for subcomponents. For example, a \vn{branch_struct}
looks like
\begin{example}
  type branch_struct
    character(40) name
    integer ix_from_ele                  ! Index of branching element
    integer, pointer :: n_ele_track      ! Number of tracking elements
    integer, pointer :: n_ele_max
    type (ele_struct), pointer :: ele(:) ! Element array
    ... etc. ...
  end type
\end{example}
The \vn{ele} component of the \vn{branch} component of the
\vn{lat_struct} can be referred to using ``\vn{lat%branch%ele}'',
``\vn{%branch%ele}'', or ``\vn{%ele}''. Potentially, the last of these
could be confused with the ``\vn{lat%ele}'' component so ``\vn{%ele}''
would only be used if the meaning is unambiguous in the context.
