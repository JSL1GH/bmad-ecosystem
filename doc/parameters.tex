\chapter{Bmad Parameter Structures}

\bmad has various parameters which affect various
calculations that \bmad performs. A given program may give the user
access to some of these parameters so, in order to allow the intelligent
setting of these parameters, this chapter gives an in-depth description.

A set of parameters are grouped that affect a particular type
of calculation are grouped into \vn{``structures''}. Each structure
has a \vn{``structure name''} (also called a \vn{``type name''}) which identifies
the list of parameters in the structure. 
Additionally, there will be an
\vn{``instance name''} which is what the user uses to refer to this
\vn{structure}. For global parameters there will be a unique instance name.
For non-global parameters the instance name will be program specific. 
It is possible to have multiple instance names. For example, in the situation
where a program is simulating multiple particle beams, there could be
multiple \vn{beam_init_struct} (\sref{s:beam.init}) instances. 
To refer to a particular parameter use the syntax
\begin{example}
  instance_name%parameter_name
\end{example}
For example, To refer to the \vn{max_aperture_limit} parameter in
Section~\sref{s:bmad.params} the syntax is
\begin{example}
  bmad_com%max_aperture_limit
\end{example}

%-----------------------------------------------------------------
\section{Bmad Global Parameters}
\label{s:bmad.params}
\index{Bmad!general parameters|hyperbf}

\index{max_aperture_limit}\index{d_orb(6)}
\index{grad_loss_sr_wake}\index{default_ds_step}
\index{rel_tolerance}\index{abs_tolerance}
\index{taylor_order}\index{default_integ_order}
\index{sr_wakes_on}\index{lr_wakes_on}
\index{mat6_track_symmetric}\index{auto_bookkeeper}
\index{trans_space_charge_on}\index{coherent_synch_rad_on}
\index{spin_tracking_on}\index{radiation_damping_on}
\index{radiation_fluctuations_on}\index{compute_ref_energy}
Some overall parameters are stored in the \vn{bmad_common_struct}
structure. The instance name here is \vn{bmad_com}. The parameters of
this structure are:
\begin{example}
  type bmad_common_struct
    real(rp) :: max_aperture_limit = 1e3       ! Max Aperture.
    real(rp) :: d_orb(6)           = 1e-5      ! for the make_mat6_tracking routine.
    real(rp) :: grad_loss_sr_wake  = 0         ! Internal var for Cavities.
    real(rp) :: default_ds_step    = 0.2       ! Integration step size.  
    real(rp) :: significant_longitudinal_length = 1e-10 ! meter 
    real(rp) :: rel_tolerance = 1e-5           ! Runge-Kutta: Relative tolerance.
    real(rp) :: abs_tolerance = 1e-8           ! Runge-Kutta: Absolute tolerance.
    real(rp) :: rel_tol_adaptive_tracking = 1e-6  ! Tracking relative tolerance.
    real(rp) :: abs_tol_adaptive_tracking = 1e-7  ! Tracking absolute tolerance.
    integer :: taylor_order = 3                ! 3rd order is default
    integer :: default_integ_order = 2         ! PTC integration order
    logical :: sr_wakes_on = .true.            ! Short range wake fields?
    logical :: lr_wakes_on = .true.            ! Long range wake fields
    logical :: mat6_track_symmetric = .true.   ! symmetric offsets
    logical :: auto_bookkeeper = .true.        ! Automatic bookkeeping?
    logical :: trans_space_charge_on = .false. ! Space charge switch
    logical :: coherent_synch_rad_on = .false. ! csr 
    logical :: spin_tracking_on = .false.      ! spin tracking?
    logical :: radiation_damping_on = .false.       ! Damping toggle.
    logical :: radiation_fluctuations_on = .false.  ! Fluctuations toggle.
    logical :: compute_ref_energy = .true.          ! Enable recomputation?
    logical :: conserve_taylor_maps = .true.        ! Enable bookkeeper to set
                                                    ! ele%map_with_offsets = F?
  end type
\end{example}

\vn{max_aperture_limit} is the maximum amplitude a particle can have
during tracking. If this amplitude is exceeded, the particle is
lost even if there is no element aperture set. Having a maximum
aperture limit helps prevent numerical overflow in the tracking calculations.

\vn{d_orb} is the orbit displacement used in the routine that
calculates the transfer matrix through an element via tracking.

%-----------------------------------------------------------------
\section{Beam Initialization Parameters}
\label{s:beam.init}
\index{beam initialization parameters|hyperbf}

\index{beam_init_struct}
Beams of particles are used for simulating inter-bunch intra-bunch effects.
The \vn{beam_init_struct} structure holds parameters which are used to initialize
the beam. The parameters of this structure are:
\begin{example}
  type beam_init_struct
    character(16) distribution_type(3)         ! "ELLIPSE", "KV", "GRID", "" (default).
    type (ellipse_beam_init_struct) ellipse(3) ! For ellipse beam distribution
    type (kv_beam_init_struct) KV              ! For KV beam distribution
    type (grid_beam_init_struct) grid(3)       ! For grid beam distribution
    !!! The following are for Random distributions
    character(16) :: random_engine          ! "pseudo" (default) or "quasi". 
    character(16) :: random_gauss_converter ! "exact" (default) or "limited". 
    real(rp) :: random_sigma_cutoff = 4.0   ! Used with "limited" converter. 
    real(rp) :: center_jitter(6) = 0.0  ! Bunch center rms jitter
    real(rp) :: emitt_jitter(2)  = 0.0  ! %RMS a and b mode bunch emittance jitter
    real(rp) :: sig_z_jitter     = 0.0  ! bunch length RMS jitter 
    real(rp) :: sig_e_jitter     = 0.0  ! energy spread RMS jitter 
    integer :: n_particle = 0           ! Number of simulated particles per bunch.
    logical :: renorm_center = .true.   ! Renormalize centroid?
    logical :: renorm_sigma = .true.    ! Renormalize sigma?
    !!! The following are used  by all distribution types
    type(beam_spin_struct)  spin        ! Spin
    real(rp) a_norm_emitt               ! a-mode emittance
    real(rp) b_norm_emitt               ! b-mode emittance
    real(rp) :: dPz_dz = 0              ! Correlation of Pz with long position.
    real(rp) :: center(6) = 0           ! Bench center offset.
    real(rp) dt_bunch                   ! Time between bunches.
    real(rp) sig_z                      ! Z sigma in m.
    real(rp) sig_e                      ! dE/E (pz) sigma.
    real(rp) bunch_charge               ! Charge in a bunch.
    integer :: n_bunch = 1              ! Number of bunches.
    logical :: init_spin     = .false.  ! initialize beam spinors
  end type
\end{example}
The number of bunches in the beam is set by \vn{n_bunch}. 
The \vn{%distributeion_type(:)} array determines what algorithms are used to generate
the particle distribution for a bunch. \vn{%distributeion_type(1)} sets the distribution 
type for the $(x, p_x)$ 2D phase space, etc. 
Possibilities for \vn{%distributeion_type(:)} are:
\begin{example}
  "", or "RAN_GAUSS"  ! Random distribution (default).
  "ELLIPSE"           ! Ellipse distribution (\sref{ss:ellipse.init})
  "KV"                ! Kapchinsky-Vladimirsky distribution (\sref{ss:kv.init})
  "GRID"              ! Uniform distribution.
\end{example}
Since the Kapchinsky-Vladimirsky distribution is for a 4D
phase space, if the Kapchinsky-Vladimirsky distribution is used,
\vn{"KV"} must appear exactly twice in the \vn{%distributeion_type(:)}
array. 

The parameters common to all the distribution types are marked in the 
\vn{beam_init_struct} above. The parameters for the random distribution
are also indicated. These random distribution parameters are:
  \begin{description}
  \item[\%random_engine] \Newline
This component sets the algorithm to use in generating a uniform distribution
of random numbers in the interval [0, 1]. \vn{"pseudo"} is a pseudo random
number generator and "quasi" is a quasi random generator. "quasi random" is
a misnomer in that the distribution generated is fairly uniform.
  \item[\%random_gauss_converter, \%random_sigma_cutoff] \Newline
To generate Gaussian random numbers, a conversion alogorithm from the 
flat distribution generated according to \vn{%random_engine} is needed.
\vn{%random_gauss_converter} selects the algorithm. The \vn{"exact"} conversion
uses an exact conversion. The \vn{"limited"} limits the maximum sigma generated
to the value of \vn{%random_sigma_cutoff}. The \vn{"limited"} method is also
somewhat faster than the \vn{"exact"} method. Note that the sigma cutoff
is ignored in the \vn{"exact"} method.
  \item[\%n_parcicle] \Newline
Number of random particles generated per bunch.
  \item[\%renorm_center, \%renorm_sigma] \Newline 
If set to True, these components will ensure that the actual beam center 
and sigmas will correspond to the input values. 
Otherwise, there will be fluctuations due to the finite number of 
particles generated. 
  \item[\%center_jitter, \%emitt_jitter, \%sig_z_jitter, \%sig_e_jitter] \Newline
These components can be used to provide a bunch-to-bunch 
random variation in the emittance and bunch center.
\end{description}

The \vn{%ellipse(:)} array sets the parameters for the 
\vn{ellipse} distribution (\sref{ss:ellipse.init}). 
Each component of this array looks like
\begin{example}
  type ellipse_beam_init_struct
    integer part_per_ellipse  ! number of particles per ellipse.
    integer n_ellipse         ! number of ellipses.
    real(rp) sigma_cutoff     ! sigma cutoff of the representation.
  end type
\end{example}

The \vn{%kv} component of the \vn{beam_init_struct} sets the parameters for the 
Kapchinsky-Vladimirsky distribution (\sref{ss:kv.init})
\begin{example}
  type kv_beam_init_struct
    integer part_per_phi(2)    ! number of particles per angle variable.
    integer n_I2               ! number of I2
    real(rp) A                 ! A = I1/e
  end type
\end{example}

The \vn{%grid} component of the \vn{beam_init_struct} sets the parameters 
for a uniformly spaced grid of particles.
\begin{example}
  type grid_beam_init_struct
    integer n_x        ! number of columns.
    integer n_px       ! number of rows.
    real(rp) x_min     ! Lower x limit.
    real(rp) x_max     ! Upper x limit.
    real(rp) px_min    ! Lower px limit.
    real(rp) px_max    ! Upper px limit.
  end type
\end{example}

The total number particles generated is the product of the individual
distributions. For example:
\begin{example}
  type (beam_init_struct) bi
  bi%distribution_type = ELLIPSE", "ELLIPSE", "GRID"
  bi%ellipse(1)%n_ellipse = 4
  bi%ellipse(1)%part_per_ellipse = 8
  bi%ellipse(2)%n_ellipse = 3
  bi%ellipse(2)%part_per_ellipse = 100
  bi%grid(3)%n_x = 20
  bi%grid(3)%n_px = 30
\end{example}
The total number of particles per bunch will be $32 \times 300 \times
600$. The exception is that when \vn{RAN_GAUSS} is mixed with other
distributions, the random distribution is overlayed with the other distributions
instead of multiplying. For example:
\begin{example}
  type (beam_init_struct) bi
  bi%distribution_type = RAN_GAUSS", "ELLIPSE", "GRID"
  bi%ellipse(2)%n_ellipse = 3
  bi%ellipse(2)%part_per_ellipse = 100
  bi%grid(3)%n_x = 20
  bi%grid(3)%n_px = 30
\end{example}
Here the number of particle is $300 \times 600$. Notice that when
\vn{RAN_GAUSS} is mixed with other distributions, the value of
\vn{beam_init%n_particle} is ignored.

%-----------------------------------------------------------------
\section{CSR Parameters}
\label{s:csr.params}
\index{CSR parameters|hyperbf}

The Coherent Synchrotron Radiation (CSR) calculation is discussed in
Section~\sref{s:csr}. Besides the parameters discussed below, the
\vn{coherent_synch_rad_on} parameter in Section~\sref{s:bmad.params}
must be set True to enable the CSR calculation.

The CSR parameter structure has a \vn{type name}
of \vn{csr_parameter_struct} and an \vn{instance name} of \vn{csr_param}.
This structure has components
\begin{example}
  type csr_parameter_struct 
    real(rp) :: ds_track_step = 0          ! Tracking step size
    real(rp) :: beam_chamber_height = 0    ! Used in shielding calculation.
    real(rp) :: sigma_cutoff = 0.1         ! Cutoff for the lsc calc. If a bin sigma
                                           !  is < cutoff * sigma_ave then ignore.
    integer :: n_bin = 0                   ! Number of bins used
    integer :: particle_bin_span = 2       ! Longitudinal particle length / dz_bin
    integer :: n_shield_images = 0         ! Chamber wall shielding. 0 = no shielding.
    logical :: lcsr_component_on = .true.  ! Longitudinal csr component
    logical :: lsc_component_on = .true.   ! Longitudinal space charge component
    logical :: tsc_component_on = .true.   ! Transverse space charge component
    logical :: small_angle_approx = .true. ! Use lcsr small angle approximation?
  end type
\end{example}
The values for the various quantities shown above are their default values. 

\vn{ds_track_step} is the nominal longitudinal distance traveled by
the bunch between CSR kicks. The actual distance between kicks within
a lattice element is adjusted so that there is an integer number of
steps from steps from the element entrance to the element exit.  This
parameter must be set to something positive otherwise an error will
result. Larger values will speed up the calculation at the expense of
accuracy.

\vn{beam_chamber_height} is the height of the beam chamber in
meters. This parameter is used when shielding is taken into account.
See also the description of the parameter \vn{n_shield_images}.

\vn{sigma_cutoff} is used in the longitudinal space charge (LSC)
calculation and is used to prevent bins with only a few particles in
them to give a large contribution to the kick when the computed
transverse sigmas are abnormally low.

\vn{n_bin} is the number of bins used. The bind width is dynamically
adjusted at each kick point so that the bins will span the bunch
length.  This parameter must be set to something positive. Larger
values will slow the calculation while smaller values will lead to
inaccuracies and loss of resolution. \vn{n_bin} should also not be set
so large that the average number of particles in a bin is too small. 
``Typical'' values are in the range 100 --- 1000.

\vn{particle_bin_span} is the width of a particle's triangular density
distribution (cf.~\sref{s:csr}) in multiples of the bin width. A
larger span will give better smoothing of the computed particle
density with an attendant loss in resolution.

\vn{n_shield_images} is the number of shielding current layers used in
the shielding calculation. A value of zero results in no
shielding. See also the description of the parameter
\vn{beam_chamber_height}. The proper setting of this parameter depends
upon how strong the shielding is. Larger values give better accuracy
at the expense of computation speed. ``Typical'' values are in the
range 0 --- 5.

\vn{lcsr_component_on} toggles on or off the (longitudinal) CSR kick.

\vn{lsc_component_on} toggles on or off the transverse space charge
kick. Currently this calculation is not implemented so this parameter
does not have any affect.

\vn{small_angle_approx} toggles whether the small angle approximation
is used in the calculation. This is generally an excellent
approximation.

