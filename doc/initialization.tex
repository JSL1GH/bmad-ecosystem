\chapter{Tao Initialization}
\index{Initialization}
\label{c:init}

\tao is customized for specific machines and specific calculations using input files and custom
software routines. Writing custom software is covered in the programmer's guide section. This
chapter covers the input files.

In general, the input files tell \tao:
\begin{example}
  * What \bmad lattice or lattices to use (\sref{s:init.lat}).
  * What the variables and data should be when running optimizations (\sref{c:opti}).
  * What to plot and how plots should be laid out in the plotting window (\sref{s:init.plot}).
  * What kind of calculations are to be done. EG: a dynamic aperture calculation, etc.
  * Etc.
\end{example}

Example initialization files can be found in the \tao distribution in sub-directories of the
directory:
\begin{example}
  tao/examples
\end{example}

%-----------------------------------------------------------------
\section{Namelist Syntax}
\label{s:format}

Parameters are read in from an initialization file using Fortran namelist input. Fortran namelist
breaks up the input file into blocks. The first line of a namelist block starts with an ampersand
``\&'' followed by the block identifying name. Variables are assigned using an equal sign ``='' and
the end of the block is denoted by a slash ``/'' For example:
\begin{example}
  &namelist_block_name
    var1 = 0.123   ! exclamation marks are used for comments
    var2 = 0.456
  /
\end{example}
Variables that have default values can be omitted from the block.  The
order of the variables inside a block is irrelevant except if the
same variable appears twice in which case the last occurrence is determinative.
In between namelist blocks all text is ignored. Inside a block comments may be
included by using an exclamation mark ``!''.

Care must be taken when setting arrays in a namelist as the following example
shows:
\begin{example}
  &namelist_name
    var_array(8:11) = 34             ! Only sets var_array(8)
    var_array(8:11) = 34 34 81 81    ! OK. Sets all 4 values
    var_array(8:11) = 34, 34, 81, 81 ! OK. Same as above
    var_array(8:11) = 34, 34,        ! Lines may be continued ...
                      81, 81         !   ... like this.
    var_array(8:11) = 2*34 2*81      ! Equivalent to the preceding examples
    var_array(8:)   = 2*34 2*81      ! Also equivalent
    var_array(1:2) = 1 2 3           ! Error: Too many RHS values.
    string_arr = '1st' "2nd" '3rd'   ! Setting a string array.
    string_arr(1:3) = 1st 2nd 3rd    ! Same as above. [Not accepted by all compilers.]
    string_arr(1:3) = 1st,2nd,3rd    ! Same as above. [Not accepted by all compilers.]
    string_arr = 'A B' "2/" "&"      ! Quotes needed here.
  /
\end{example}
The first line to set the \vn{var_array} may look like it is setting the four values
\vn{var_array(8:11)} but the general rule is that with \vn{n} values on the RHS, only \vn{n} values
in the array are set.

IMPORTANT: The notation \vn{n*number} does not denote multiplication but instead can be used to
denote multiple values. There should be no blank spaces here. Some compilers may accept something
like ``2 * 34'' but you cannot count on it. Using ``2*34'' is safe.

For string input it is always best to use quotes. Some compilers will accept strings without
quotes. Even those that do will generally not accept strings with special characters.  Thus the
following characters should not be used in unquoted strings:
\begin{example}
  Blank or Tab character.
  Period if it is the first character in the string.
  &   ,   /    !   %   *   (   )   =   ?   '   "
\end{example}
Note: While there are exceptions, in general \tao string variables are
case sensitive.

Logical variables should be set to \vn{T} or \vn{TRUE} when true and \vn{F} or \vn{FALSE} when
false. This is case insensitive. It is possible to use the words \vn{.true.} and \vn{.false.} for
logicals, however this may not always work. The reason for this is that a variable that is
documented to be a logical may actually be a string variable! In this case a beginning period will
cause problems. Why use string variables? String variables are used in place of logical variables
when \tao needs to know if the variable has been explicitly set.

When setting an array in a namelist where the array components are a structure, the set can be
structured in several ways. To make this clear, consider the \vn{ele_shape(:)} array that can be set
in the \vn{lat_layout_drawing} namelist as explained in \sref{s:shapes}. Each component
of the \vn{ele_shape(:)} array is a structure and the elements of this structure are:
\begin{example}
  ele_shape(i) = "<ele_id>" "<shape>" "<color>" "<size>" "<label>" <draw> <multi> <line_width>
\end{example}
Setting a given \vn{ele_shape(:)} array component looks like:
\begin{example}
  &lat_layout_drawing
    !               ele_id                  Shape      Color     Size  Label  ..etc..
    ele_shape(2) = "quadrupole::*"          "xbox"     "red"     0.75  "none" 
  /
\end{example}
This sets the \vn{ele_id} component of \vn{ele_shape(2)} to \vn{"quadrupole::*"}, etc.

Alternatively, a given structure component can be set for multipole array components. Example:
\begin{example}
  &lat_layout_drawing
    ele_shape(5:6)%line_width = 5, 6
    ele_shape(3)%multi = T
  /
\end{example}
Here the \vn{line_width} structure component for \vn{ele_shape(5)} and \vn{ele_shape(6)} is set along
with the \vn{multi} structure component for \vn{ele_shape(3)}.

%-----------------------------------------------------------------
\section{Beginning Initialization}
\index{Initialization!beginning}
\label{s:init.global} 

\index{tao_start}\index{tao.init}\index{lattice_file}
\index{data_file}\index{var_file}\index{plot_file}
\index{single_mode_file}\index{startup_file}\index{startup_single_mode}
\index{beam_file}\index{hook_init_file}
The initialization starts with the \vn{root} \tao initialization file. The default name for this
file is \vn{tao.init} but this default may be overridden when \tao is started using the \vn{-init_file}
switch (\sref{s:command.line}). The first namelist block read in from the root initialization file is a
\vn{tao_start} namelist. This block is optional (in which case the defaults are used).  This
namelist contains the variables:
\begin{example}
  &tao_start
    beam_file          = "<file_name>"  ! Default = Tao root init file.
    building_wall_file = "<file_name>"  ! No Default.
    data_file          = "<file_name>"  ! Default = Tao root init file.
    var_file           = "<file_name>"  ! Default = Tao root init file.
    plot_file          = "<file_name1> \{<file_name2>\} ..."  
                                        ! Default = Tao root init file.
    single_mode_file   = "<file_name>"  ! Default = Tao root init file.
    startup_file       = "<file_name>"  ! Default = "tao.startup"
    hook_init_file     = '<file_name>'  ! Default = 'tao_hook.init'
    init_name          = "<init_name>"  ! Default = "Tao"
  /
\end{example}
Rule: A file name obtained from the \tao root initialization file (as opposed to being present on
the command line) is always relative to the directory that the \tao root initialization file lives
in. Example: If \tao is started from the system command line like:
\begin{example}
    tao -data data.cl -init ../tao.init
\end{example}
And if the \vn{tao_start} namelist in \vn{../tao.init} looks like:
\begin{example}
  &tao_start
    data_file = "dat.in"
    plot_file = "plot.in"
    var_file  = "/nfs/var.in"
  /
\end{example}
Then, relative to the current working directory, the files used will be
\begin{example}
  data_file: "data.cl"      ! Command line arguments have preference
  plot_file: "../plot.in"   ! Relative to ../tao.init.
  var_file:  "/nfs/var.in"  ! Absolute paths are never modified.
\end{example}

\vn{init_name} is for naming the initialization. This is useful to distinguish between multiple
initialization files with custom versions of \tao. The other parameters specify which files to find
the other initialization namelists. The \vn{plot_file} variable can be an array of plot files.

\tao will open an execute a command file (\sref{s:command.files}) at startup if it exists.  The
default name is \vn{tao.startup} but this name can be changed by setting the \vn{startup_file}
component in the \vn{tao_start} namelist.

The following sections describe each of these initialization namelists and their locations are
listed in table~\ref{t:init.files}. Note: If \vn{plot_file} specifies multiple files, the
\vn{tao_plot_page}, \vn{lat_layout_drawing} and \vn{floor_plan_drawing} namelists are taken from the
first file on the list. All files, however, can contain \vn{tao_template_plot} and
\vn{tao_template_graph} namelists.

\index{tao_design_lattice}\index{tao_params}
\index{tao_beam_init}\index{tao_var}\index{tao_d2_data}
\index{tao_d1_data}\index{tao_plot_page}\index{tao_template_plot}
\index{tao_template_graph}\index{lat_layout_drawing}
\index{floor_plan_drawing}
\begin{table}[ht]
\centering {\tt
\begin{tabular}{llll} \toprule
  {\it Namelist}                     & {\it Type of Parameters Initialized}  & {\it Section} \\ \midrule
  \vn{lat_layout_drawing}            & Plotting           & \sref{s:shapes}            \\ 
  \vn{floor_plan_drawing}            & Plotting           & \sref{s:shapes}            \\ 
  \vn{tao_beam_init}                 & Particle beams     & \sref{s:beam.init}         \\ 
  \vn{building_wall_section}         & Building Walls     & \sref{s:building.wall}     \\ 
  \vn{tao_design_lattice}            & Lattice Files      & \sref{s:init.lat}          \\ 
  \vn{tao_d1_data}                   & Data               & \sref{s:init.data}         \\ 
  \vn{tao_d2_data}                   & Data               & \sref{s:init.data}         \\ 
  \vn{tao_params}                    & Global Variables   & \sref{s:globals}           \\ 
  \vn{tao_plot_page}                 & Plotting           & \sref{s:init.plot}         \\ 
  \vn{tao_template_graph}            & Plotting           & \sref{s:init.plot}         \\ 
  \vn{tao_template_plot}             & Plotting           & \sref{s:init.plot}         \\ 
  \vn{tao_var}                       & Variables          & \sref{s:init.var}          \\ \bottomrule
\end{tabular}}
\break
\caption{Table of \vn{tao} Initialization Namelists.}
\label{t:init.files}
\end{table}

%-----------------------------------------------------------------
\section{Lattice Initialization}\index{initialization!lattice}
\label{s:init.lat} 

In the \vn{tao_start} namelist (\sref{s:init.global}), the \vn{lattice_file} variable gives the name
of the file that contains the \vn{tao_design_lattice} namelist. The default, if \vn{lattice_file} is
not present is to look in the \tao root initialization file. The \vn{tao_design_lattice} namelist
defines where the lattice input files are. The variables that are set in the \vn{tao_design_lattice}
namelist are:
\index{tao_design_lattice}\index{design_lattice}\index{design_lattice!file}
\index{design_lattice!parser}\index{n_universes}\index{common_lattice}
\begin{example}
  &tao_design_lattice
    n_universes        = <integer>      ! Number of universes. Default = 1.
    unique_name_suffix = "<string>"
    combine_consecutive_elements_of_like_name = <logical>
    common_lattice = <logical>                        ! Default = False
    design_lattice(i) = "<lattice_file>", \{"<lattice2_file>"\}
    design_lattice(i)%one_turn_map_calc = <logical>     ! Default = False
    design_lattice(i)%dynamic_aperture_calc = <logical> ! Default = False
    design_lattice(i)%reverse_tracking = <logical>      ! Default = False
    design_lattice(i)%slice_lattice = "<element_list>"             
  /
\end{example}

\vn{n_universes} is the number of universes to be created not counting the possible common universe
created when using \vn{CRL} analysis. The default is 1.  \vn{design_lattice(i)} gives the lattice
file name for universe \vn{i}.  The syntax for \vn{<lattice_file>} is:
\begin{example}
  \{<parser>::\}<lattice_file>\{@<use_line>\}
\end{example}
Possible choices for the <parser> are:
\index{bmad}\index{xsif}\index{digested}
\begin{example}
  bmad      ! For a standard bmad lattice file. This is the default.
  xsif      ! For an xsif lattice file.
  digested  ! For a digested BMAD file.
\end{example}
The \vn{@<use_line>} optional suffix is used to specify what \vn{line} in the lattice file to use as
a basis for constructing the lattice. This overrides the \vn{use} statement in the lattice file.

If the \vn{%reverse_tracking} logical is present, tracking will be in the reverse direction from the end
of the lattice to the beginning. The sign of the charge of the tracked particle will also be
reversed from the setting in the lattice file. This is useful for simulating beams that go in the
backward direction.

The \vn{%slice_lattice} parameter specifies a list of elements to be used to pare down the lattice
so that the only elements that appear in the list are keept in the lattice.  In addition, any lord
elements that control elements in the list are also retianed. This is identical to putting a
\vn{slice_lattice} command directly in the lattice file. For example:
\begin{example}
  design_lattice(1)%slice_lattice = "Q1:35"
\end{example}
In this example, everthing outside of the range from element \vn{Q1} to the element with index 35
will be discarded.  See the \bmad manual for more details about the \vn{slice_lattice} command.
Note: There is also a \vn{-slice_lattice} initalization argument (\sref{s:command.line} that can be
used.

Example:
\begin{example}
  &tao_design_lattice
    n_universe = 4
    design_lattice(1) = "this.lat"              ! Default: Bmad format lattice file.
    design_lattice(1)%slice_lattice = "Q1:Q2"   ! Discard element outside range [Q1:Q2]
    design_lattice(2) = "xsif::that.lat", "floor_coords.bmad"
                                                ! XSIF file. For universe \#2 
    design_lattice(3) = "third.lat@my_line"     ! Specify a different line.
    design_lattice(3)%one_turn_map_calc = True  ! Calculate higher order maps.
  /
\end{example}
In this example, the lattice of universe 1 is given by the file \vn{this.lat} and the lattice of
universe 2 is given by the file \vn{that.lat}. The \vn{"xsif::"} prefix for \vn{design_lattice(2)}
indicates that the xsif parser is to be used. Alternatively, a \vn{".xsif"} suffix signals that a
file uses the \vn{xsif} format.  \vn{design_lattice(2)} in the example also specifies a ``secondary
lattice file'' called \vn{floor_coords.bmad} which will be parsed after the ``primary''
\vn{that.lat} file is read. This secondary lattice file must only have statements that are valid
post lattice expansion.  See the \bmad manual manual for a discussion of lattice expansion. A
secondary lattice file must be in Bmad standard format. This can be especially useful if
\vn{lattice_file} is not a bmad file. For example, a \vn{lattice2_file} can be used to set non-zero
floor coordinates to an XSIF lattice file. Note: If a \vn{%slice_lattice} parameter is used with
a secondary lattice file then the paring specified by \vn{%slice_lattice} is applied before
the secondary lattice file is parsed.

If there is no \vn{design_lattice} specified for a given universe then the last \vn{design_lattice}
is used. Thus, in the above example, universes 4 use the same lattice as universe 3.

The \vn{design_lattice(i)%one_turn_map_calc} sets whether a one-turn-map calculation for a ring
using PTC will be done. If the calculation is made, the \vn{normal.} data type is populated.  See
Eq.~\ref{normalform1} and Eq.~\ref{normalform2}. After startup, the map calculation can be toggled
on/off by using the \vn{set universe one_turn_map_calc} command (\sref{s:set}).

The \vn{design_lattice(i)%dynamic_aperture} component sets whether the dynamic aperture calculation
(\sref{s:dynamicaperture}) will be done. After startup, this calculation can be toggled on/off by
using the \vn{set universe dynamic_aperture_calc} command (\sref{s:set}).

Normally, a lattice file will specify which ``line'' will be used to specify the
lattice. Occasionally, it is convenient to override this specification and to use a different
line. To do this in \tao, the name of the line to be used to specify the lattice can be appended to
the lattice file name. Thus, in the example above, universe 3 will have the lattice specified by the
line ``my\_line'' from the lattice ``third.lat''.

\vn{global%combine_consecutive_elements_of_like_name} takes a lattice and combines all pairs of
consecutive elements that have the same name and attributes. Why is this useful? Some programs, not
based on \bmad, cannot generate the Twiss parameters inside the element. If the Twiss parameters at
the center of an element are desired, a lattice where the element has been split into two identical
pieces is needed. This, however, makes tasks like setting up lattice optimization cumbersome. Note:
The recombination of like elements happens when the lattice is read in during initialization.

\vn{unique_name_suffix} is used to append a unique character string to element names that are not
unique. \vn{unique_name_suffix} uses element list format (\sref{s:ele.list.format}). The class is
used to restrict which elements can have their names changed. The \vn{name} part is used as a
suffix. This suffix must have a single \vn{``?''}  character.  When this suffix is applied to an
element's name, a unique integer is inserted in place of the \vn{``?''}. For example, if
\vn{unique_name_suffix} is \vn{"quad::\#\#?"}, and if the following quadrupoles are in the lattice:
\begin{example}
        QA    QB    QX    QA    QB     QB
\end{example}
then after initialization, the names will be:
\begin{example}
        QA##1  QB##1  QX    QA##2  QB##2   QB##3
\end{example}
Using \vn{\#\#?"} as the suffix is convenient since it corresponds
to the \bmad standard convention for distinguishing elements of the
same name. See the \bmad manual for more details on this.

Setting \vn{aperture_limit_on} to \vn{False} will turn off the
aperture limits set in all lattices. This overrides the setting of
\vn{parameter[aperture_limit_on]} in a lattice file.

The \vn{common_lattice} switch can be used when there is a baseline
lattice that is common to all universes. See \sref{s:crl} for more
details.

%-----------------------------------------------------------------
\section{Initializing Globals}
\index{initialization!globals}
\label{s:globals} 

Global variables are initialized in the root initialization file using a 
namelist named \vn{tao_params}.

The syntax of this block is:
\index{tao_params}\index{global}\index{bmad_com}\index{csr_param}\index{opti_de_param}
\begin{example}
  &tao_params
    global        = <tao_global_struct>     ! global parameters. \sref{s:tao.global.struct}
    bmad_com      = <bmad_com_struct>       ! Bmad global parameters. \sref{s:bmad.com.struct}
    csr_param     = <csr_parameter_struct>  ! CSR global parameters. \sref{s:csr.param.struct}
    opti_de_param = <opti_de_param_struct>  ! de optimizer parameters. \sref{s:opti.de.param.struct}
  /
\end{example}
Example:
\begin{example}
  &tao_params
    global%optimizer = "lm"  ! Set the default optimizer.
  /
\end{example}

%-----------------------------------------------------------------
\subsection{tao\_global\_struct Structure}
\label{s:tao.global.struct} 

The \vn{tao_global_struct} structure contains \tao global parameters.
\index{n_opti_cycles}\index{ix_key_bank}
\index{n_lat_layout_label_rows}\index{phase_units}
\index{bunch_to_plot}\index{random_seed}\index{concatenate_maps}
\index{beam_random_engine}\index{beam_random_gauss_converter}
\index{track_type}\index{prompt_string}\index{Optimization!setting the optimizer}
\index{write_file}\index{var_limits_on}\index{only_limit_opt_vars}
\index{plot_on}\index{opt_with_ref}\index{opt_with_base}
\index{single_mode}\index{lm_opt_deriv_reinit}
\index{label_lattice_elements}\index{label_keys}\index{derivative_recalc}
\index{lattice_calc_on}\index{command_file_print_on}
\index{print_command}\index{default_init_file}\index{derivative_uses_design}
\index{current_init_file}\index{var_out_file}\index{draw_curve_off_scale_warn}
\begin{example}
type tao_global_struct
  real(rp) lm_opt_deriv_reinit = -1   ! Derivative matrix cutoff. -1 => ignore this.
  real(rp) de_lm_step_ratio = 1       ! Step sizes between DE and LM optimizers.
  real(rp) de_var_to_population_factor = 5 
  real(rp) lmdif_eps = 1e-12          ! tolerance for lmdif optimizer.
  real(rp) lmdif_negligible_merit = 1d-30  ! lmdif stops if merit is smaller.
  real(rp) svd_cutoff = 1e-5          ! SVD singular value cutoff limit.
  real(rp) unstable_penalty = 1e-3    ! Used in unstable_ring datum merit calculation.
  real(rp) merit_stop_value = -1      ! Value below which an optimizer will stop.
  real(rp) dmerit_stop_value = 0      ! Fractional change below which an optimizer will stop.
  real(rp) random_sigma_cutoff = -1   ! Cut-off in sigmas.
  real(rp) delta_e_chrom = 0          ! delta E used from chromaticity calc.
  integer n_opti_cycles = 20          ! number of optimization cycles
  integer n_opti_loops = 1            ! number of optimization loops
  integer n_lat_layout_label_rows = 1 ! How many rows with a lat_layout
  integer phase_units = radians\$      ! Phase units on output.
  integer bunch_to_plot = 1           ! Which bunch to plot
  integer random_seed = 0             ! use system clock by default
  integer n_top10_merit = 10          ! Number of top constraints to print.
  character(16)  random_engine = "pseudo"         ! Random number engine to use
  character(16)  random_gauss_converter = "exact" ! Uniform to gauss conversion method
  character(16)  track_type = "single"            ! "single" or "beam" 
  character(16)  prompt_string = "Tao"
  character(16)  prompt_color = 'DEFAULT'         ! See read_a_line routine for possible settings.
  character(16)  optimizer     = "de"             ! optimizer to use.
  character(40)  print_command = "lpr"
  character(80)  var_out_file  = "var#.out"
  logical beam_timer_on = F             ! For timing the beam tracking calculation.
  logical concatenate_maps = F          ! False => tracking using DA.
  logical command_file_print_on = T     ! Toggle printing when using a command file.
  logical derivative_recalc = T         ! Recalc derivatives before each optimizer loop?
  logical derivative_uses_design = F    ! Derivative matrix uses the design lattice?
  logical disable_smooth_line_calc = F  ! Disable the plotting smooth line calc?
  logical draw_curve_off_scale_warn = T ! Display warning on graphs when any part of the 
                                        !   curve is out-of-bounds
  logical label_lattice_elements = T    ! For lat_layout plots
  logical label_keys = T                ! For lat_layout plots
  logical lattice_calc_on = T           ! Turn on/off beam and single particle calculations.
  logical opt_with_ref = F              ! use reference data in optimization?
  logical opt_with_base = F             ! use base data in optimization?
  logical optimizer_var_limit_warn = T  ! Warn when vars reach a limit when optimizing?
  logical plot_on = T                   ! Do plotting?
  logical force_plot_data_calc = F      ! Always calc plot curve points even with %plot_on = F?
  logical rf_on = F                     ! RF cavities on?
  logical svd_retreat_on_merit_increase = T    
  logical var_limits_on = T             ! Respect the variable limits?
  logical only_limit_opt_vars = F       ! Apply limits only if variable is used in optimization?
  logical silent_run = F                ! Suppress terminal output when running a command file?
  logical single_step = F               ! Single step through a command file?
  logical stop_on_error = T             ! For debugging: True -> Tao will not exiting on an error.
  logical optimizer_allow_user_abort = T ! See below.
  logical optimizer_var_limit_warn = T   ! Warn when vars reach a limit with optimization.
  logical quiet = F                      ! Print commands on terminal when running a command file?
end type
\end{example}

All global parameters can be changed from their initial value using
the \vn{set} command (\sref{s:set}).

  \begin{description}
  \item{\vn{global%command_file_print_on}} \Newline
This switch controls whether printing to the terminal is suppressed when a command file is called.

  \item{\vn{global%concatenate_maps}} \Newline
When constructing transfer Taylor maps the default method, used with \vn{global%concatenate_maps} =
False, is to use Differential Algebra (DA) to integrate the map from the starting point to the
ending point.  Alternatively, with \vn{global%concatenate_maps} = True, if an element within the
integration region has an associated map, that map is concatenated with the map under construction.
This saves time but the potential drawback is a loss of accuracy. Note that a lattice element
will only have an associate map if the \vn{tracking_method} or \vn{make_mat6_method} components
of the lattice element are such that a map is needed for tracking (see the \bmad manual for more
details).

  \item{\vn{global%derivative_recalc}} \Newline
The \vn{global%derivative_recalc} logical determines whether the derivative matrix is
recalculated every optimization loop. The \vn{global%derivative_uses_design} logical
determines if the design lattice is used in the derivative matrix calculation instead of
the model lattice.

  \item{\vn{global%disable_smooth_line_calc}} \Newline
The \vn{global%disable_smooth_line_calc} is used to disable computation of the ``smooth
curves'' used in plotting.  This can be used to speed up \tao as discussed in
\sref{s:plot.data}.

  \item{\vn{global%dmerit_stop_value}} \Newline
When optimizing, if the fractional change in the merit function over one \vn{loop} (set by
\vn{global%n_opti_loops}) is below the value of \vn{global%dmerit_stop_value}, optimization 
will stop. The default value is zero. Also see \vn{global%merit_stop_value}.

  \item{\vn{global%lattice_calc_on}} \Newline
\vn{global%lattice_calc_on} controls whether lattice calculations are done when there are changes in
the lattice. Lattice calculations include the calculation of orbits, Twiss parameters, beam
tracking, etc. This switch is useful in controlling unnecessary calculational overhead.  A typical
scenario where this switch is used involves first setting \vn{%lattice_calc_on} to \vn{False} (using
the \vn{set} command (\sref{s:set})), then executing a set of commands, and finally setting
\vn{%lattice_calc_on} back to \vn{True}. This saves some of the calculational overhead that each
command generates. Similarly, \vn{global%plot_on} can be toggled to save even more time. Also see
the \vn{set universe} command (\sref{s:set.universe}) for ways to suppress certain types of
calculations (for example, calculating the Twiss parameters) that are not needed.

  \item{\vn{global%force_plot_data_calc}} \Newline
Sometimes it is convenient to have \tao calculate plotting curve points even when \tao is not doing
any plotting (that is, \vn{global%plot_on} = F). For example, when \tao is run as a server by a client
(such as a graphic user interface) program where the client program is taking care of the plotting but
the data to be plotted is calculated by \tao. In this case by setting \vn{global%force_plot_data_calc} to
True will force \tao to always calculate curve data points even when \vn{global%plot_on} = F.

  \item{\vn{global%merit_stop_value}} \Newline
The \vn{global%merit_stop_value} establishes a point such that, during optimization, if
the merit function falls below that value, the optimization stops. If the value is
negative (the default), \vn{global%merit_stop_value} is ignored. Also see \vn{global%dmerit_stop_value}.

  \item{\vn{global%optimizer_allow_user_abort}} \Newline
Normally \vn{optimizer_allow_user_abort} defaults to True which allows the optimizer, when
it is run, to look for user input from the terminal (\sref{s:tao.opti}). If the user types
a period ``.'', the optimization is aborted cleanly. However, if \tao is started with
standard input redirected from a file (using the ``<'' character) \tao will not be able to
distinguish between input meant as a \tao command and input meant for aborting the
optimization. In this case, \vn{optimizer_allow_user_abort} will default to False so that
the optimizer will not do any checking.

  \item{\vn{global%random_engine}} \Newline
\vn{global%random_engine} selects the algorithm used for generating the random
numbers. \vn{"pseudo"} causes \tao to use a pseudo-random number generator. \vn{"quasi"}
uses Sobel quasi-random number generator which generates a distribution that is smoother
then the pseudo-random number generator. \vn{"pseudo"} is the default.

  \item{\vn{global%random_gauss_converter}} \Newline
\vn{global%random_gauss_converter} selects the algorithm used in the conversion from a
uniform distribution to a Gaussian distribution.  \vn{"exact"} is an exact conversion and
\vn{"limited"} has a cut-off so that no particles are generated beyond. This cutoff is set
by \vn{global%random_sigma_cutoff}.

  \item{\vn{global%random_sigma_cutoff}} \Newline
See \vn{global%random_gauss_converter}.

  \item{\vn{global%random_seed}} \Newline
\vn{global%random_seed} sets the seed number for the pseudo-random number generator. A
value of \vn{0} (the default) causes the seed number to be picked based upon the system
clock. Use the \vn{show global} command to see what the seed number is.

  \item{\vn{global%rf_on}} \Newline
The rf cavities in circular lattices can be be toggled on or off using the \vn{global%rf_on}
switch. The default is False. Notice that with the RF off, the beam energy will be independent of
the closed orbit which is not the case when the RF is on.  Note: If you want to see orbit changes
with RF frequency changes then you will need to set \vn{parameter[absolute_time_tracking]} to
True. See the ``Relative Versus Absolute Time Tracking'' section in the\bmad manual for more
details.

  \item{\vn{global%silent_run}} \Newline
For use with command files. If set True, output to the terminal during command file running will be
suppressed (except for warning and error messages) until the command file (or files) returns to the
command line level at wich point \vn{global%silent_run} is automatically reset to False. That is,
\vn{global%silent_run} must be set to True each time it is desired to run a command file(s)
silently.

  \item{\vn{global%single_step}} \Newline
For use with command files. If set True, this is equivalent to putting a "pause -1" after
each line in a command file. Useful for debugging or for talk demonstrations. 

  \item{\vn{global%track_type}} \Newline
The setting of the \vn{global%track_type} parameter can be
\begin{example}
  "single"
  "beam"
\end{example}
The \vn{"single"} setting is used when single particle tracking is desired and \vn{"beam"}
is used when tracking with a beam of particles. Note that with \vn{"single"} tracking,
synchrotron radiation fluctuations (but not damping) is always turned off.

  \item{\vn{global%var_limits_on}} \Newline
The \vn{global%var_limits_on} switch controls whether a variable's model value is limited
by the variable's \vn{high_lim} and \vn{low_lim} settings (\sref{s:init.var}). This is
particularly important during optimization. If a variable's model value moves outside of
the limits, the value is set at the limit and the variable's \vn{good_user} parameter is
set to \vn{False} so it will not be further varied in the optimization.

  \item{\vn{global%only_limit_opt_vars}} \Newline
The \vn{global%only_limit_opt_vars} switch controls whether only the variables being
optimized are limited or whether all variables are limited. The
\vn{global%optimizer_var_limit_warn} switch controls whether a warning is printed when a
variable value goes past a limit.

\end{description}

Random number generation in \tao is divided into two categories: Random numbers used for
generating the initial coordinates of the particles in a beam and random numbers used for
everything else.  As explained below, there are four parameters that govern how random
numbers are generated. For beam particle generation, three of the four (everything except
the random number seed) are accessed through the \vn{beam_init} structure
(\sref{s:beam.init}). For everything else, these parameters are accessed through the
\vn{tao_global_struct}.

%-----------------------------------------------------------------
\subsection{bmad\_com\_struct Structure}
\label{s:bmad.com.struct} 

The \vn{bmad_com_struct} holds bmad global variables. 
\index{radiation_damping_on}\index{taylor_order}
\index{radiation_fluctuations_on}\index{sr_wakes_on}\index{lr_wakes_on}
\begin{example}
  type bmad_com_struct
    real(rp) max_aperture_limit = 1e3    
    real(rp) d_orb(6) = 1e-5  ! for the make_mat6_tracking routine
    real(rp) default_ds_step    = 0.2_rp    ! Integration step size.
    real(rp) significant_length = 1e-10     ! meter
    real(rp) rel_tol_tracking = 1e-8
    real(rp) abs_tol_tracking = 1e-10
    real(rp) rel_tol_adaptive_tracking = 1e-8   ! Adaptive tracking relative tolerance.
    real(rp) abs_tol_adaptive_tracking = 1e-10  ! Adaptive tracking absolute tolerance.
    real(rp) init_ds_adaptive_tracking = 1e-3   ! Initial step size
    real(rp) min_ds_adaptive_tracking = 0       ! Min step size to take.
    real(rp) fatal_ds_adaptive_tracking = 1e-8  ! particle lost if step size is below this.
    real(rp) autoscale_amp_abs_tol = 0.1_rp     ! Autoscale absolute amplitude tolerance (eV).
    real(rp) autoscale_amp_rel_tol = 1d-6       ! Autoscale relative amplitude tolerance
    real(rp) autoscale_phase_tol = 1d-5         ! Autoscale phase tolerance.
    real(rp) electric_dipole_moment = 0         ! Particle's EDM.
    real(rp) ptc_cut_factor = 0.006             ! Cut factor for PTC tracking
    real(rp) sad_eps_scale = 5.0d-3             ! Used in sad_mult step length calc.
    real(rp) sad_amp_max = 5.0d-2               ! Used in sad_mult step length calc.

    integer space_charge_mesh_size(3) = [32, 32, 64]  ! Gird size for fft_3d space charge calc.
    integer sad_n_div_max = 1000                ! Used in sad_mult step length calc.
    integer runge_kutta_order = 4               ! Runge Kutta order.
    integer default_integ_order = 2             ! PTC integration order.
    integer ptc_max_fringe_order = 2            ! PTC max fringe order (2  = > Quadrupole !).
                                                !   Must call set_ptc after changing.
    integer max_num_runge_kutta_step = 10000    ! Maximum number of RK steps before particle is considered lost.
    logical rf_phase_below_transition_ref = F   ! Autoscale uses below transition stable point for RFCavities?
    logical use_hard_edge_drifts = T            ! Insert drifts when tracking through cavity?
    logical sr_wakes_on = T                     ! Short range wakefields?
    logical lr_wakes_on = T                     ! Long range wakefields
    logical mat6_track_symmetric = T            ! symmetric offsets
    logical auto_bookkeeper = T                 ! Automatic bookkeeping?
    logical csr_and_space_charge_on = F         ! Space charge switch
    logical spin_tracking_on = F                ! spin tracking?
    logical backwards_time_tracking_on = F      ! Track backwards in time?
    logical spin_sokolov_ternov_flipping_on = F ! Spin flipping during synchrotron radiation emission?
    logical radiation_damping_on = F            ! Damping toggle.
    logical radiation_fluctuations_on = F       ! Fluctuations toggle.
    logical conserve_taylor_maps = T            ! Enable bookkeeper to set ele%taylor_map_includes_offsets = F?
    logical absolute_time_tracking_default = F  ! Default for lat%absolute_time_tracking
    logical twiss_normalize_off_energy = F
    logical convert_to_kinetic_momentum = F     ! Cancel finite vector potential edge kicks with symplectic tracking?
    logical aperture_limit_on = T               ! use apertures in tracking?
    logical ptc_print_info_messages = F         ! Allow PTC to print informational messages?
    logical debug = F                           ! Used for code debugging.




    integer taylor_order = 3               ! 3rd order is default
    integer default_integ_order = 2        ! PTC integration order.
    integer ptc_max_fringe_order = 2       ! PTC max fringe order (2 => Quadrupole !).
                                           !   Must call set_ptc after changing.
    logical use_hard_edge_drifts = T       ! Insert drifts when tracking through cavity?
    logical sr_wakes_on = T                ! Short range wakefields?
    logical lr_wakes_on = T                ! Long range wakefields
    logical mat6_track_symmetric = T       ! symmetric offsets
    logical auto_bookkeeper = T            ! Automatic bookkeeping?
    logical space_charge_on = F            ! Space charge switch
    logical coherent_synch_rad_on = F      ! Longitudinal csr 
    logical spin_tracking_on = T           ! Do particle spin tracking
    logical radiation_damping_on = F       ! Damping toggle.
    logical radiation_fluctuations_on = F  ! Fluctuations toggle.
    logical conserve_taylor_maps = T       ! Enable bookkeeper to set ele%map_with_offsets = F?
    logical absolute_time_tracking_default = F  ! Default for lat%absolute_time_tracking
    logical rf_auto_scale_phase_default = T     ! Default for lat%rf_auto_scale_phase
    logical rf_auto_scale_amp_default = T       ! Default for lat%rf_auto_scale_amp
    logical use_ptc_layout_default = F          ! Default for lat%use_ptc_layout
  end type
\end{example}
See the \bmad manual for more details.

%-----------------------------------------------------------------
\subsection{csr\_param\_struct Structure}
\label{s:csr.param.struct} 

The \vn{csr_parameter_struct} holds global variables for the coherent
synchrotron radiation calculations. 
\begin{example}
  type csr_parameter_struct
    real(rp) ds_track_step = 0          ! Tracking step size
    real(rp) beam_chamber_height = 0    ! Used in shielding calculation.
    real(rp) sigma_cutoff = 0.1         ! Cutoff for the lsc calc. If a bin sigma
                                        !  is < cutoff * sigma_ave then ignore.
    integer n_bin = 0                   ! Number of bins used
    integer particle_bin_span = 2       ! Longitudinal particle length / dz_bin
    integer n_shield_images = 0         ! Chamber wall shielding. 0 = no shielding.
    integer sc_min_in_bin = 10          ! Min number of particles in a bin for sigmas to be valid.
    logical print_taylor_warning = True ! Print warning if Taylor element is present?
    logical write_csr_wake = False      ! Write the CSR wake? For diagnostics.
    logical lsc_kick_transverse_dependence = F
  end type
\end{example}
See the \bmad manual on the \vn{csr_parameter_struct} for more details. In \tao,
Besides setting the \vn{csr_parameter_struct} components, the following must
be done to enable CSR computations:
\begin{Itemize}
\item 
The \vn{global%track_type} (see above this section) must be set to \vn{"beam"} and the appropriate
beam initialization parameters (\sref{s:beam.init}) must be set.
\item 
The parameter \vn{bmad_com%coherent_synch_radiation} (see above this section) must be set to \vn{True}.
\item
In the \bmad lattice file, \vn{csr_calc_on} must be set for the elements where CSR tracking is to be
done (see the \bmad manual).
\end{Itemize}

%-----------------------------------------------------------------
\subsection{opti\_de\_param\_struct Structure}
\label{s:opti.de.param.struct}

The \vn{opti_de_param_struct} holds parameters that influence the behavior
of the \vn{de} optimizer (\sref{s:tao.opti})
\begin{example}
                         Default
  real(rp) CR               0.8    ! Crossover Probability.
  real(rp) F                0.8    !
  real(rp) l_best           0.0    ! Percentage of best solution used.
  logical  binomial_cross   False  ! IE: Default = Exponential.
  logical  use_2nd_diff     False  ! use F * (x_4 - x_5) term
  logical  randomize_F      False  !
  logical  minimize_merit   True   ! F => maximize the Merit func.
\end{example}
See the \bmad manual for more details.

If \vn{ix1_ele_csr} and \vn{ix2_ele_csr} are set, The effect of
coherent synchrotron radiation is only included in tracking in the
region from the exit end of the lattice element with index
\vn{ix1_ele_csr} through the exit end of the lattice element with index
\vn{ix2_ele_csr}. By restricting the CSR calculation,
the calculational time to track through a lattice is reduced.

See \sref{s:lattice.correction} for more details on
\vn{global%n_opti_cycles} and \vn{global%n_opti_loops}. 

%-----------------------------------------------------------------
\section{Initializing Particle Beams}
\index{initialization!beams}
\label{s:beam.init}

A particle beam is initialized in the \vn{tao_beam_init} namelist block.  The file that \tao looks
in to find this namelist is set by the \vn{beam_file} component of the \vn{tao_start} namelist
(\sref{s:init.global}). The default, if \vn{beam_file} is not set, is the root initialization file.

The syntax of the \vn{tao_beam_init} namelist is:
\index{tao_beam_init}\index{ix_universe}
\index{beam_init}\index{beam_init!a_norm_emit}
\index{beam_init!b_norm_emit}
\index{beam_init!dPz_dZ}\index{beam_init!center}\index{beam_init!sig_e}
\index{beam_init!sig_z}\index{beam_init!n_bunch}\index{beam_init!dt_bunch}
\index{beam_init!n_particle}\index{beam_init!bunch_charge}
\index{beam_init!renorm_center}\index{beam_init!renorm_sigma}
\index{beam_init!center_jitter}\index{beam_init!emit_jitter}
\index{beam_init!sig_z_jitter}\index{beam_init!sig_e_jitter}
\index{beam_init!polarization}\index{beam_track_start}\index{beam_track_end}
\begin{example}
  &tao_beam_init
    ix_universe                 = <integer>    ! Universe to apply to.
    beam_track_data_file               = <string>     ! File used in place of beam tracking.
    beam_saved_at               = "<ele_list>" ! Where to save the beam info.
    beam_track_start            = "<ele_name>" ! Beam tracking start element name or index.
    beam_track_end              = "<ele_name>" ! Beam tracking end element name or index.
    beam_init%position_file     = <string>     ! Beam position init file.
    beam_init%distribution_type(3) = "<type>"  ! "ELLIPSE", "KV", "GRID", "" (default)
    beam_init%ellipse(3)%...    = ...          ! Parameters for an ellipse type distribution.
    beam_init%KV%...            = ...          ! Parameters for a KV distribution
    beam_init%grid(i)%...       = ...          ! Parameters for a grid distribution.
    beam_init%a_norm_emit       = <real>       ! A-mode energy normalized emittance
    beam_init%b_norm_emit       = <real>       ! B-mode energy normalized emittance
    beam_init%a_emit            = <real>       ! A-mode emittance
    beam_init%b_emit            = <real>       ! B-mode emittance
    beam_init%dPz_dZ            = <real>       ! Energy-Z correlation
    beam_init%center            = <real>*6     ! Bunch center offset relative to
                                               !   reference particle (BMAD coords)
    beam_init%sig_e             = <real>       ! e_sigma in dE/E0
    beam_init%sig_z             = <real>       ! Z sigma in m
    beam_init%n_bunch           = <integer>    ! Number of bunches
    beam_init%dt_bunch          = <real>       ! Time between bunches (meters)
    beam_init%n_particle        = <real>       ! Number of particles per bunch
    beam_init%bunch_charge      = <real>       ! charge per bunch (Coulombs)
    beam_init%renorm_center     = <logical>    ! Default is T
    beam_init%renorm_sigma      = <logical>    ! Default is F
    beam_init%center_jitter     = <real>*6     ! Bunch center rms jitter (meters)
    beam_init%emit_jitter       = <real>*2     ! Emittance rms jitter (\(d\epsilon/\epsilon\)) 
    beam_init%sig_z_jitter      = <real>       ! bunch length rms jitter (dz/z)
    beam_init%sig_e_jitter      = <real>       ! bunch energy spread rms jitter (dE/E)
    beam_init%spin(3)           = <real>*3     ! (x, y, z) spin components.
    beam_init%init_spin         = <logical>    ! Initialize the spin (default: False)
    beam_init%preserve_dist     = <logical>    ! Use the same particle distribution.
    beam_init%random_engine     = "pseudo"     ! random number engine to use
    beam_init%random_gauss_converter = "exact" ! Uniform to gauss conversion method
    beam_init%random_sigma_cutoff = 4.0        ! Cut-off in sigmas.
    beam_init%use_t_coords      = <logical>    ! Use time coords (for e_guns)?
    beam_init%use_z_as_t        = <logical>    ! Use time instead of z (for e_guns)?
  /
\end{example}

The \vn{beam_init} parameter is an instance of a \vn{beam_init_struct} structure which holds
parameters (for example, the beam emittances) from which a distribution of particles can be
constructed. Documentation on this can be found in the \bmad manual in the \vn{Beam Initialization}
chapter. In particular, \vn{beam_init%position_file} if it is non-blank, specifies a file (which can
be created with the \vn{write beam -at <ele_name>} command) which contains a beam's particle
coordinates which are to be used at the start of the lattice.  Note: The file name can be overridden
by using the \vn{-beam_init_position_file} argument on the command line (\sref{s:command.line}). The
file can either be in binary format (binary files can be created by the \vn{write beam} command), or
written in ASCII.  Note: When the particle coordinates are read in from the
\vn{beam_init%position_file} file, the centroid will be shifted by the setting of
\vn{beam_init%center}.  To vary the centroid of the beam on the \tao command line, the \vn{set
beam_init center} command (\sref{s:set}) can be used.

\vn{ix_universe} refers to the universe index.  See the \bmad documentation on the
\vn{beam_init_struct} for what the \vn{beam_init} parameters refer to. The charge per particle is
set to $\vn{bunch_charge} / \vn{n_particle}$ and is used when calculating wakefield effects.

The emittances used construct to the beam's particle distribution can be set using the energy
normalized emittances \vn{%a_norm_emit} and \vn{%b_norm_emit} or the unnormalized (``geometric'')
\vn{%a_emit} and \vn{%b_emit}. If not set, the emittances set in the lattice file are used. These
emittances are also used as the initial emittance in a linear lattice for the emittance calculation
using the radiation integrals.

The \vn{beam_track_data_file} component specifies a beam tracking data file (which can be created
with the \vn{write beam} command) which contains the particle coordinates of the tracked beam at
every element where the beam distribution is saved at. This causes \tao to use the data from the
file in lieu of actual tracking. This can be helpful when to reanalyze old data if the time for \tao
to track a bunch through the lattice becomes long. The file name can be overridden by using the
\vn{-beam_track_data_file} argument on the command line (\sref{s:command.line}). Note: \tao will set
the variable \vn{use_saved_beam_in_tracking} to \vn{True} to prevent actual tracking.

When \vn{beam_init%position_file} is blank, the Twiss parameters at the beginning of the lattice are used in
initializing the beam distribution.  For circular lattices the Twiss parameters will be found from
the closed orbit, and the emittance will be calculated using the \bmad routine
\vn{radiation_integrals}.

\vn{beam_track_start} and \vn{beam_track_end} are used when it is desired to only track the beam
through part of the root lattice branch.  \vn{beam_track_start} gives the starting element name or
index. Tracking will start at the exit end of this element so the beam {\em will not} be tracked
through this element. The tracking will end at the exit end of the lattice element with name or
index \vn{beam_track_end}. The default, if \vn{beam_track_start} and \vn{beam_track_end} are not
present, is to track through the entire root lattice branch.  \vn{beam_track_start} and
\vn{beam_track_end} is ignored for lattice branches other than the root branch (branch 0). After
initialization, the \vn{set beam_init} (\sref{s:set.beam.init}) command can be used to set
\vn{beam_track_start} and \vn{beam_track_end}. Note: Deprecated names for \vn{beam_track_start} and
\vn{beam_track_end} are \vn{track_start} and \vn{track_end} respectively.

If spin tracking is desired then \vn{beam_init%init_spin} must be set to true.  If it is desired to
use the exact same distribution of particles for each time the beam is tracked then set
\vn{beam_init%preserve_dist} to True. Otherwise, a new random distribution will be generated. The
initialization routine does attempt to renormalize the beam to the specified parameters,
nevertheless if tracking a small number of particles the distribution is subject to small random
fluctuations unless \vn{beam_init%prserve_dist} is True.

\tao re-tracks the beam through the lattice every time a lattice parameter is changed. For example,
during optimizations or when the \vn{set} command (\sref{s:set}) is used. For the re-tracking, the
particle distribution at the beginning of the lattice is fixed. That is, the a new random
distribution is {\emph not} generated. To force a new distribution, use the \vn{reinitialize beam}
command (\sref{s:reinit}).

The default is single particle tracking. To turn on particle tracking the \vn{global%track_type}
parameter must be set to \vn{"beam"}. This can be placed in the \vn{tao_params} namelist above, for
example,
\begin{example}
  &tao_params
    global%optimizer = "lm"  ! Set the default optimizer.
    global%track_type = "beam"
  /
\end{example}

\vn{beam_saved_at} is used to specify at what elements the beam particle positions are saved
at. Note that, independent of the setting of \vn{beam_saved_at}, beam statistics (like the beam
sigma matrix) are always saved at each lattice element. Element list format, as explained in
\sref{s:ele.list.format}, is used to specify a list of elements for \vn{beam_saved_at}. The beam is
automatically saved at the beginning position and end position of beam tracking and at \vn{fork} and
\vn{photon_fork} elements.
\begin{example}
  &tao_beam_init
    beam_saved_at = "marker::m* *34w*" ! Save beam at all markers starting with "m"
                                       !   and all elements that have "34w" in their name. 
  /
\end{example}
The elements where the beam is saved may be modified while \tao is running by using the \vn{set beam saved_at},
\vn{set beam add_saved_at}, and \vn{set beam subtract_saved_at} commands (\sref{s:set.beam}).

The three random number generator parameters (\vn{%random_engine}, \vn{%random_gauss_converter}, and
\vn{%random_sigma_cutoff}) used for initializing the beam are set in the \vn{tao_global_struct}
(\sref{s:globals}). They may, however, be overridden for beam particle generation by setting the
corresponding parameters in the \vn{beam_init} structure. That is, separate parameters may be setup
for beam particle generation verses everything else.  These parameters are explained in
Section~\sref{s:globals}.

%-----------------------------------------------------------------
\section{Initializing Variables}\index{initialization!variables}
\label{s:init.var} 

\tao \vn{variable}s (\sref{c:var} are used in lattice correction or design (\sref{c:opti}). 

The file that \tao looks in to find information on \tao variables is set by the \vn{var_file} component of
the \vn{tao_start} namelist (\sref{s:init.global}). The default, if \vn{data_file} is not set, is
the root initialization file.

Variables are initialized using the \vn{tao_var} namelist. The format for this is
\index{tao_var}\index{v1_var!name}\index{default_universe}
\index{default_attribute}\index{default_weight}\index{default_step}
\index{default_merit_type}\index{default_low_lim}\index{default_high_lim}
\index{ix_min_var}\index{ix_max_var}\index{var!name}
\index{var!ele_name}\index{var!attribute}\index{var!universe}
\index{var!weight}\index{var!step}\index{var!low_lim}
\index{var!high_lim}\index{var!merit_type}\index{var!good_user}
\index{use_same_lat_eles_as}\index{search_for_lat_eles}
\begin{example}
  &tao_var
    v1_var%name          = "<var_array_name>"  ! Variable array name.
    use_same_lat_eles_as = "<d1_name>"         ! Reuse a previous element list.
    search_for_lat_eles  = "<element_list>"    ! Find elements by name.
    default_universe     = "<integer>"         ! Universe variables belong in.
    default_attribute    = "<attribute_name>"  ! Attribute to control.
    default_weight       = <real>              ! Merit_function weight.
                                               ! default = 0.0
    default_step         = <real>              ! Small step value.
                                               ! default = 0.0
    default_merit_type   = "<merit_type>"      ! Sets how the merit is calculated.
                                               ! default = "limit"
    default_low_lim      = <real>              ! Lower variable value limit. 
                                               ! default = -1e30
    default_high_lim     = <real>              ! Upper variable value limit. 
                                               ! default =  1e30
    default_key_bound    = <logical>           ! Variables to be bound?
    default_key_delta    = <real>              ! Change when key is pressed.
    ix_min_var           = <integer>           ! Minimum array index.
    ix_max_var           = <integer>           ! Maximum array index.
    var(i)%ele_name      = "<ele_name>"        ! Name or index of element to be controlled.
    var(i)%attribute     = "<attrib_name>"     ! Attribute to be controlled.
    var(i)%universe      = "<uni_list>"        ! Universe containing variable to 
                                               !    be controlled. "*" => All.
    var(i)%weight        = <real>              ! Merit function weight.
    var(i)%step          = <real>              ! Small step size.
    var(i)%low_lim       = <real>              ! Lower variable value limit
    var(i)%high_lim      = <real>              ! Upper variable value limit
    var(i)%merit_type    = "<merit_type_name>" ! Sets how the merit is calculated.
    var(i)%good_user     = <logical>           ! Good optimization variable?
    var(i)%key_bound     = <logical>           ! Variable bound to a key
    var(i)%key_delta     = <real>              ! Change when key is pressed.
  /
\end{example}
Example:
\begin{example}
  &tao_var
    v1_var%name      = "v_steer"   ! vertical steerings
    default_universe  = "clone 2,3"
    default_attribute = "vkick"     ! vertical kick attribute
    default_weight    = 1e3
    default_step      = 1e-5
    ix_min_var        = 0
    ix_max_var        = 99
    var(0:99)%ele_name  = "v00w", "v01w", "v02w", "    ", "v04w", ...
  /
\end{example}

A \vn{tao_var} block is needed for each variable array to be defined.
\vn{v1_var%name} is the name of the array to be used with \tao
commands. The \vn{var(i)} array of variables has an index \vn{i} that
runs from \vni{ix_min_var} to \vni{ix_max_var}. A lattice element name
\vn{var(i)%ele_name} and the element's attribute to vary
\vn{var(i)%attribute} needs to specified. Not all elements need to
\vn{exist} and the element names of non--existent elements should be
undefined or set to a name with only spaces in it. For those variables
where \vn{var(i)%attribute} is not specified in the namelist the
\vn{default_attribute} will be used.

\vn{var(i)%key_bound} and \vn{var(i)%key_delta} are used to bind
variables to keys on the keyboard. The default values for these
parameters are set by \vn{default_key_bound} and
\vn{default_key_delta}. If not set, \vn{default_key_bound} is set to
\vn{False} and \vn{default_key_delta} is set to \vn{0}.
See~\sref{s:key.bind} for more details.

\vn{var(i)%step} establishes what a ``small'' variation of the
variable is. This is used, for example, by some optimizers when
varying variables. If \vn{var%step(i)} is not given for a
particular variable then the default \vn{default_step} is
used. 

\vn{var(i)%good_user} is a logical that the user can toggle when
running \tao (\sref{c:var}). The initial default value of
\vn{%good_user} is True.

\vn{var(i)%universe} gives the universe that the lattice element lives
in. Multiple universes can be specified using a comma delimited list.
For example:
\begin{example}
  var(10)%universe = "2, 3"
\end{example}
If \vn{var(i)%universe} is not present, or is blank, the value of
\vn{default_universe} is used instead. If both \vn{var(i)%universe} and
\vn{default_universe} are not present or blank then all universes are assumed.
In addition to a number (or numbers), 
\vn{default_universe} can have values:
\index{gang}\index{clone}
\begin{example}
  "gang"     -- Multiple universe control (default).
  "clone"    -- Make a var array block for each universe.
\end{example}
\vn{"gang"} means that each variable will control the given attribute
in each universe simultaneously. \vn{"clone"} means that the array of
variables will be duplicated, one for each universe.  To differentiate
variables from different universes \vn{_u<n>} will be appended to each
\vn{v1_var%name} where \vn{<n>} is the universe number.  For example,
if \vn{v1_var%name} is \vn{quad_k1} then the variable block name for
the first universe will be \vn{quad_k1_u1}, 
second universe will be \vn{quad_k1_u2}, etc. With \vn{"clone"},
individual \vn{var(i)%universe} may not be set in the namelist. The
default if both \vn{default_universe} and all \vn{var(i)%universe} are
not given is for \vn{default_universe} to be \vn{"gang"}. Examples:
\begin{example}
  default_universe = "gang"        ! Gang all universes together.
  default_universe = "gang 2, 3"   ! Gang universes 2 and 3 together.
  default_universe = "2, 3"        ! Same as "gang 2, 3".
  default_universe = "clone 2, 3"  ! Make two var arrays. 
                                   !   One for universe 2 and one for universe 3. 
\end{example}

\vn{var(i)%weight} gives the weight coefficient for the contribution
of a variable to the merit function.  If not present then the default
weight of \vn{default_weight} is used.  \vn{var(i)%low_lim} and
\vn{var(i)%high_lim} give the lower and upper bounds outside of which
the value of a variable should not go. If not present
\vn{default_low_lim} and \vn{default_high_lim} are used. If these are
not present as well then by default
\begin{example}
  low_lim  = -1e30
  high_lim =  1e30
\end{example}
\vn{var(i)%merit_type} determines how the merit contribution is calculated.
Possible values are:
\index{limit}\index{target}
\begin{example}
  "limit"       ! Default
  "target"      
\end{example}
For details on \vn{limit} and \vn{target} constraints see Chapter~\ref{c:opti}
on Optimization.

If elements in the \vn{var} array do not exist the corresponding
\vn{var%ele_name} should be left blank. Lists of names can be reused
using the syntax:
\index{use_same_lat_eles_as}
\begin{example}
  use_same_lat_eles_as = "<d1_name>"     ! Reuse a previous element list.
\end{example}
For example:
\begin{example}
  &tao_var
    v1_var%name     = "quad_tilt"  
    default_attribute = "tilt"
    ...
    use_same_lat_eles_as = "quad_k1"
  /
\end{example}

\index{search_for_lat_eles}
Instead of specifying a list of lattice element names for \vn{var(:)%ele_name}, 
\tao can be told to search for the elements by name using the syntax:
\begin{example}
   search_for_lat_eles = "{-no_grouping} <element_list>"  
\end{example}
Where \vn{<element_list>} is a list of elements using the element list format
(\sref{s:ele.list.format}). The searching will
automatically exclude any superposition and multipass slaves elements.
If the \vn{-no_grouping} flag is not present, the default behavior
is that all matched elements with the same name are grouped under a single
variable. That is, a single variable can control multiple elements.
On the other hand, if the \vn{-no_grouping} flag is present, each
element will be assigned an individual variable.  For example:
\begin{example}
  search_for_lat_eles = "sbend::b*"
\end{example}
will search for all non-lord bend lattice elements whose names begins
with \vn{"B"} followed by any set of characters. In this example, if,
for example, two bends have the name, say "bend0", then a single variable will be
set up to control these two bends.

\vn{Warning}: Generally \vn{-no_grouping} should be used with \vn{unique_name_suffix}
(\sref{s:init.lat}) to avoid the problem that if different lattice elements have the same name but
differing parameter values, the \vn{write bmad_lattice} command (\sref{s:write}) will not produce
a valid lattice.

Note: \vn{search_for_lat_eles} and \vn{use_same_lat_eles_as} cannot be
used together.

%-----------------------------------------------------------------
\section{Initializing Data and Constraints}
\index{initialization!data}\index{initialization!constants}
\label{s:init.data} 

Tao \vn{data} (\sref{c:data}) is used with lattice correction or design (\sref{c:opti}). A set of
data is initialized using a \vn{tao_d2_data} namelist block and one or more \vn{tao_d1_data}
namelist blocks.

The file that \tao looks in to find these two namelists is set by the \vn{data_file} component of
the \vn{tao_start} namelist (\sref{s:init.global}). The default, if \vn{data_file} is not set, is
the root initialization file.

The format of the \vn{tao_d2_data} namelist is
\index{tao_d2_data}
\index{d2_data!name}
\index{Universe}
\index{default_merit_type}
\index{n_d1_data}
\begin{example}
  &tao_d2_data
    d2_data%name = "<d2_name>"          ! d2_data name.
    universe     = "<list>"             ! Universes data belong in.
                                        !   "*" => all universes (default).
    default_merit_type = "<merit_type>" ! Sets how the merit is calculated.
    n_d1_data          = <integer>      ! Number associated d1_data arrays.
  /
\end{example}
For example:
For example:
\begin{example}
  &tao_d2_data
    d2_data%name = "orbit"
    universe     = "1,3:5"  ! Apply to universes 1, 3, 4, and 5
    n_d1_data    = 2
  /
\end{example}
A \vn{tao_d2_data} block is needed for each \vn{d2_data} structure defined. The \vn{d2_data%name}
component gives the name of the structure. The \vn{universe} component gives a list of the universes
that the data is associated with. A value of \vn{"*"} means that a \vn{d2_data} structure is set up
in each universe. Ranges of universes can be specified in the list using a \vn{:}.

The \vn{default_merit_type} component determines how the merit function terms are calculated for the
individual datum points. Possibilities are:
\index{target}\index{max}\index{min}
\index{abs_max}\index{abs_min}
\begin{example}
  "target"
  "max"
  "min"
  "abs_max"
  "abs_min"
  "average"   ! Only used when datum specifies a range of elements.
  "max-min"   ! Only used when datum specifies a range of elements.
\end{example}
The \vn{average} and \vn{max-min} merit types are used when there is a range of elements associated
the the datum. That is, \vn{ele_start} is specified (see below). For the \vn{average} data type, the
datum value is the average of the values computed for all lattice elements in the specified
range. With \vn{max-min}, the value of the datum is the difference between the maximum value in the
range minus the minimum in the range. See Chapter~\ref{c:opti} on optimization for more details.

The associated \vn{tao_d1_data} namelists must come directly after their associated \vn{tao_d2_data}
namelist.  The \vn{n_d1_data} parameter in the \vn{tao_d2_data} namelist defines how many
\vn{d1_data} structures are associated with the \vn{d2_data} structure. For each \vn{n_d1_data}
structure there must be a \vn{tao_d1_data} namelist which has the form:
\index{tao_d1_data}\index{ix_d1_data}\index{d1_data!name}
\index{default_data_type}\index{default_weight}\index{ix_min_data}
\index{ix_max_data}\index{data!name}\index{data!data_type}
\index{data!ele_name}\index{data!ele_ref_name}\index{data!ele_start_name}\index{data!merit_type}
\index{data!meas}\index{data!weight}\index{data!good_user}
\index{data!ix_bunch}\index{use_same_lat_eles_as}\index{search_for_lat_eles}
\begin{example}
  &tao_d1_data
    ix_d1_data             = <integer>           ! d1_data index
    use_same_lat_eles_as   = "<d1_name>"         ! Reuse previous element list.
    search_for_lat_eles    = "<element_list>"    ! Find elements by name.
    d1_data%name           = "<d1_name>"         ! d1_data name.
    default_data_type      = <type_name>         ! Eg: orbit.x, e_tot, etc...
    default_weight         = <real>              ! Merit function weight. Dflt: 0.0
    default_data_source    = "<source>"          ! "lat" (dflt), "data", "var", or "beam". 
    ix_min_data            = <integer>           ! Minimum array index.
    ix_max_data            = <integer>           ! Maximum array index.
    datum(j)%data_source    = "<source>"         ! "lat" (dflt), "data", "var", or "beam". 
    datum(j)%data_type      = "<type_name>"      ! Eg: "orbit.x", etc.
    datum(j)%ele_name       = "<ele_name>"       ! Lattice element name.
    datum(j)%ele_start_name = "<ele_start_name>" ! Start element name.
    datum(j)%ele_ref_name   = "<ele_ref_name>"   ! Reference element names.
    datum(j)%merit_type     = "<merit_type>"     ! Sets how the merit is calculated.
    datum(j)%meas           = <real>             ! Datum "measured" value
    datum(j)%weight         = <weight>           ! Merit function weight.
    datum(j)%good_user      = <logical>          ! Use for optimization and plotting?
    datum(j)%ix_bunch       = <integer>          ! Bunch index. Dflt: 0 = all bunches.
    datum(j)%eval_point     = "<where>"          ! "beginning", "center", or "end" (dflt).
    datum(j)%s_offset       = <real>             ! Default: 0.
  /
\end{example}
For example:
\begin{example}
  &tao_d1_data
    ix_d1_data        = 1 
    d1_data%name      = "x"  
    default_weight    = 1e6
    ix_min_data       = 0
    ix_max_data       = 99
    datum(0:)%ele_name = "DET_00W", " ", "DET_02W", ...
  /
\end{example}
Alternatively, one can specify a datum in a single line. For example, 
\begin{example}
  &tao_d1_data
    ix_d1_data        = 1 
    d1_data%name      = "t"  
    !           data_      ele_ref  ele_start ele     merit    meas   weight good
    !           type       name     name      name    type     value         user ..
    datum( 1) = "beta.a"   "S:2.3"  ""       "Q16_1"  "max"     30    0.1     T  ...
    datum( 2) = "phase.b"  "Q09_1"  "B22"    "Q16_1"  "max"     30    0.1     T  ...
    datum( 3) = "floor.x"  ""        ""      "end"    "target"   3    0.01    T  ...     
    datum( 4) = "floor.x"  "B1"      ""      "B2"     "target"   3    0.01    T  ...     
    ... etc. ...
  /
\end{example}
When specifying data one line at a time, the columns are
\begin{example}
  data_type
  ele_ref_name
  ele_start_name
  ele_name
  merit_type
  meas_value
  weight
  good_user
  data_source
  eval_point
  s_offset
  ix_bunch
\end{example}
Default values will be used if an individual line does not include all columns.

\vn{ix_min_data} and \vn{ix_max_data} give the bounds for the
\vn{datum(i)} structure array that is associated with the \vn{d1_data}
structure. \vn{datum(:)%ele_name} gives the lattice element names
associated with the data points.

\vn{datum(i)%good_user} is a logical that the user can toggle when
running \tao (\sref{s:data.anatomy}). The initial default value of
\vn{%good_user} is True.

A range of elements can be specified by giving an \vn{ele_start_name} that is not a blank string.
Thus, in the above example, the value of \vn{datum(2)} is the maximum horizontal beta in the range
between the end of element \vn{B22} to the end of element \vn{Q16_1}. Elements can be specified by
name (Eg: \vn{Q16_1}) or by longitudinal position using the notation \vn{"S:<s_distance>"}. This
will match to the element whose longitudinal position at the exit end is closest to
\vn{<s_distance>}.

\index{data_source}
\index{default_data_source}
The \vn{datum(:)%data_source} component specifies where the data is 
coming from. Possible values are:
\begin{example}
  "beam"        ! Value is from multiparticle beam tracking.
  "data"        ! Used with expressions.
  "lat"         ! Value is from the lattice.
  "var"         ! Used with expressions.
\end{example}
With \vn{%data_source} set to \vn{"beam"}, the particular bunch that the data is extracted
from can be specified via \vn{datum(:)%ix_bunch}.  The default is \vn{0} which combines
all the bunches for the datum calculation.  If the \vn{%data_source} is not set, the value
of the \vn{default_data_source} is used. If both \vn{%data_source} and
\vn{default_data_source} are not specified, \vn{"lat"} is the default. A \vn{%data_source}
of \vn{"data"} or \vn{"var"} establishes the default data source for evaluating
expressions (see \vn{"expression:"} in \sref{s:data.types}).

If elements in the \vn{data} array do not exist the corresponding
\vn{data%ele_name} should be left blank. Lists of names can be reused
using the syntax:
\index{use_same_lat_eles_as}
\begin{example}
  use_same_lat_eles_as = "<d1_name>"     ! Reuse previous element list.
\end{example}
For example:
\begin{example}
  &tao_d1_data
    ix_d1_data       = 2
    d1_data%name     = "y"  
    ...
    use_same_lat_eles_as = "orbit.x"
  /
\end{example}

\index{search_for_lat_eles}
\tao can search for the elements in the lattice to be associated with 
each data type by using the syntax:
\begin{example}
   search_for_lat_eles = "\{-no_lords\} \{-no_slaves\} <element_list>"
\end{example}
\vn{<element_list>} specifies elements using the standard element list
format (\sref{s:ele.list.format}). The \vn{-no_lords} and
\vn{-no_slaves} switches, if present, are used to restrict the counting
of lord or slave elements. The \vn{-no_lords} switch excludes all group,
overlay, and girder elements. The \vn{-no_slaves} switch vetoes
superposition or multipass slave elements. For example:
\begin{example}
  search_for_lat_eles = "-no_lords sbend::b*
\end{example}
This will search for all non-lord bend lattice elements whose names
begins with \vn{"B"} followed by any set of characters.
\vn{search_for_lat_eles} and \vn{use_same_lat_eles_as} cannot be used
together.

\index{data!data_type}
If \vn{datum(j)%data_type} is not given, and \vni{default_data_type} is not specified,
then the \vni{d2_data} name and the \vni{d1_data} name are combined for each datum to form
the datum's \vn{type}. For example, if the \vn{d2_data} name is \vn{orbit}, and the
\vn{d1_data} name is \vn{x}, then the \vn{data_type} is \vn{orbit.x}. The \vn{data_type}s
recognized by \tao. are given by Table~\ref{t:con.type}. Custom data types not
specified in this table must have a corresponding definition in
\vn{tao_hook_load_data_array.f90}. See Chapter~\ref{c:custom.tao} for details.

\index{datum%weight}
\vn{datum(:)%weight} gives the weight coefficient for a datum in the
merit function. If not present then the default weight of
\vni{default_weight} is used. 

%-----------------------------------------------------------------
\subsection{Old Data Format}

In the present data format there are three elements that are
associated with a given datum: \vn{ele_ref}, \vn{ele_start}, and
\vn{ele}. There exists an old, deprecated, data format where only two
elements are given for a given datum. These elements are called
\vn{ele0} and \vn{ele}. In this old format, \vn{data} is used in place
of \vn{datum}. For example:
\begin{example}
  &tao_d1_data
    ! OLD SYNTAX. DO NOT USE!
    !          data_      ele0_     ele_     merit_   meas_    weight good_
    !            type       name      name     type     value           user
    data( 1) = "beta.a"   "S:12.3"  "Q16_1"  "max"      30      0.1     T
    data( 2) = "phase.b"  "Q09_1"   "Q16_1"  "max"      30      0.1     T
    data( 3) = "floor.x"  " "       "end"    "target"    3      0.01    T       
    data( 4) = "floor.x"  "B1"      "B2"     "target"    3      0.01    T       
    ... etc. ...
  /
\end{example}
The interpretation of \vn{ele0} was dependent upon the data type. With
data types denoted as ``\vn{relative}'', \vn{ele0} was interpreted as
\vn{ele_ref}. For non-relative data types, \vn{ele0} was interpreted
as being equivalent to \vn{ele_start}. The relative data types where:
\begin{example}
  floor.x, floor.y, floor.z, floor.theta
  momentum_compaction         
  periodic.tt.\(ijklm\ldots\)    
  phase.a, phase.b             
  phase_frac.a, phase_frac.b            
  phase_frac_diff            
  r.\(ij\)                       
  rel_floor.x, rel_floor.y,
  rel_floor.z, rel_floor.theta
  s_position                  
  t.\(ijk\)                      
  tt.\(ijklm\ldots\)
\end{example}

%-----------------------------------------------------------------
\section{Initializing a Building Wall}
\index{building walls}
\label{s:building.wall}

\begin{figure}
  \centering
  \includegraphics[width=5in]{building-wall.pdf}
  \caption[Floor plot showing the walls of the building]
{Floor plot showing the walls of the building (along with a section of a recirculation
arc). Defining building walls can be useful for such things as floor plots and designing a machine
to fit in an existing building.}
  \label{f:building.wall}
\end{figure}

A two dimensional outline of the building containing the machine under simulation may be defined in
\tao. This may be useful when drawing floor plans of the machine (\sref{s:floor.plan}) or to design
a machine to fit within an existing building by using optimization (\sref{c:opti}).

The walls of a building are defined by a set of ``sections'' which are just curves that mark the
wall boundaries. One such section is highlighted in Figure~\ref{f:building.wall} starting at the
point marked ``point(1)'' and ending at the point marked ``point(N)''. Each section is defined by a
set of points which are connected together using straight lines or circular arcs.

The name of the file containing the building wall definition is given by the \vn{building_wall_file}
variable in the \vn{tao_start} namelist (\sref{s:init.global}). In general, this file will contain a
number of \vn{building_wall_section} namelists. Each \vn{building_wall_section} namelist defines a
single wall section. The syntax of this namelist is
\begin{example}
  &building_wall_section
    \{name = <string>\}
    \{constraint = <type>\}
    point(1) = <z1>, <x1>
    point(2) = <z2>, <x2>, \{<r2>\}
    point(3) = <z3>, <x3>, \{<r3>\}
    ... etc ...
    point(N) = <zN>, <xN>, \{<rN>\}
  /
\end{example}
The optional \vn{name} component allows for matching wall sections to \vn{floor_plan} shapes
(\sref{s:shapes}) so that different portions of the wall can be drawn in different colors.

The global coordinate system in \bmad (see the \bmad manual) defines the $(Z, X)$ plane as being
horizontal.  [Note: $(Z, X)$ is used instead of $(X, Z)$ since $(Z, X, Y)$ forms a right handed
coordinate system.] The points that define a wall section are specified in this coordinate system.
In the \vn{building_wall_section} namelist, the $(Z, X)$ position of each point defining a wall
section is given along with an optional radius $r$. If a non-zero radius is given for point $j$,
then the segment between point $j-1$ and $j$ is a circular arc of the given radius. If no radius is
given, or if it is zero, the segment is a straight line. A radius for the first point, number 1,
cannot be specified since this does not make sense. Additionally, a radius must be at least half the
distance between the two points that define the end points of the arc.

In general, given two end points and a radius, there are four possible
arcs that can be drawn. The arc chosen follows the following convention:
\begin{enumerate}
\item
The angle subtended by the arc is 180 degrees or less.
\item
If the radius for the arc from $j-1$ to $j$ is positive, the arc
curves in a clockwise manner. If the radius is negative, the arc
curves counterclockwise. This convention mimics the convention used
for \vn{rbend} and \vn{sbend} elements.
\end{enumerate}
To define a wall that is circular, use three points with two 180
degree arcs in between.

When designing a machine to fit within the walls of a building, the
\vn{constraint} variable of the namelist is used to designate whether
the given wall section is on the $+x$ (left) side of the machine or the $-x$ (right)
side. Here $x$ is the local reference frame transverse coordinate. See
the write up of the \vn{wall.right_side} and \vn{wall.left_side} constraints in
\sref{s:data.types} for more details. Possible values for
\vn{constraint} are:
\begin{example}
  "right_side"  ! Section is to be used with wall.right_side constraints
  "left_side"   ! Section is to be used with wall.left_side constraints
  "none"        ! Default. Section is ignored in any constraint calculation.
\end{example}
Using \vn{"none"} for \vn{constraint} is convenient for drawing building components on a
\vn{floor_plan} that are not used as a optimization constraint.

Example:
\begin{example}
  &building_wall_section
    constraint = "left_side"   
    point(1) =  23.2837,    8.2842
    point(2) = -10.9703,   13.8712, 107.345
    point(3) = -10.8229,   14.7737
  /
\end{example}
In this example, point 1 is at $(Z, X) = (23.2837, 8.2842)$, the segment between points 1 and 2 is
an arc with a radius of 107.345 meters, and the segment between points 2 and 3 is a straight
line. Also this wall section is to be used when evaluating any \vn{wall.x+} constraint.

If the machine varies vertically ($y$-direction), vertical constraints may be imposed using the
\vn{floor.y} data type (\sref{s:data.types}).

Note: To position a machine in the global coordinate system, the starting point and starting
orientation can be adjusted using \vn{beginning[...]} statements as explained in the \bmad manual.

%-----------------------------------------------------------------
\section{Initializing Dynamic Aperture}
\index{dynamic aperture}
\label{s:dynamicaperture}

For rings, the dynamic aperture can be calculated if \vn{tao_dynamic_aperture} is defined:

\begin{example}
  &tao_dynamic_aperture
   da_init(ix_uni)%ix_branch = 1         ! Lattice branch to use. 0 = default value.
   da_init(ix_uni)%pz = 0, 0.01, ...     ! List of particle energies to use
   da_init(ix_uni)%n_angle = 64          ! Number of angles in scan of each energy
   da_init(ix_uni)%min_angle = 0         ! Starting scan angle.
   da_init(ix_uni)%max_angle = 3.14159   ! Ending scan angle.
   da_init(ix_uni)%n_turn = 100          ! Number of turns a particle must survive
   da_init(ix_uni)%x_init = 1e-3_rp      ! initial estimate for horizontal aperture
   da_init(ix_uni)%y_init = 1e-3_rp      ! initial estimate for vertical aperture
   da_init(ix_uni)%accuracy = 1e-5_rp    ! resolution of bracketed aperture (meters)
  /
\end{example}

where \vn{ix_uni} indicates the universe number. Here \vn{pz} is a list of relative momenta
to calculate the aperture for. If the RF is off, then a new closed orbit will be calculated 
for each of these momenta.

Currently the dynamic aperture assumes that tracking is to be done with the root lattice branch
(branch 0).

Optionally parameters \vn{n_angle}, \vn{min_angle}, and \vn{max_angle} can be set to indicate
the angle in the $x-y$ plane to scan about the closed orbit.

By default, the dynamic aperture calculation is off for all universes. To turn it on, use the
\vn{set} command (\sref{s:set.universe}):
\begin{example}
  set universe 1 dynamic_aperture_calc on
\end{example}

The \vn{show dynamic_aperture} command (\sref{s:show.da}) shows parameter values and the
\vn{set dynamic_aperture} command (\sref{s:set.da}) can be used to change parameter values.

If Tao is compiled with the appropriate OpenMP flags, the dynamic aperture calculation will be done
in parallel.

The results can be plotted. See \sref{s:dynamicapertureplot}. 

Example input files are at:
\begin{example}
  \$ACC_ROOT_DIR/tao/examples/dynamic_aperture
\end{example}

\clearpage
%-----------------------------------------------------------------
\section{Initializing Plotting}
\index{plotting initializing}
\label{s:init.plot} 

\subsection{Plot Window}
\label{s:plot.page}
\index{initialization!plotting!plot window}

Plotting is defined by an initialization file whose name is defined by the \vn{plot_file} component
of the \vn{tao_start} namelist (\sref{s:init.global}).  The first namelist block in the file has a
block name of \vn{tao_plot_page}. This block sets the size of the plot window (also called the plot
page) and defines the ``regions'' where plots go. The syntax of this block is:
\index{tao_plot_page}\index{plot_page!n_curve_pts}
\index{plot_page!size}\index{plot_page!border}
\index{plot_page!text_height}\index{plot_page!title}
\index{region!name}\index{region!location}\index{place}
\begin{example}
  &tao_plot_page
    plot_page%plot_display_type        = <string>  ! Display type: 'X' or 'TK'
    plot_page%size                     = <x_size>, <y_size>         ! size in POINTS 
    plot_page%border                   = <x1\(_{\dstyle{b}}\)>, <x2\(_{\dstyle{b}}\)>, <y1\(_{\dstyle{b}}\)>, <y2\(_{\dstyle{b}}\)>, "<units>"
    plot_page%text_height              = <real>   ! height in POINTS. Def = 12
    plot_page%main_title_text_scale    = <real>   ! Relative to text_height. Def = 1.3
    plot_page%graph_title_text_scale   = <real>   ! Relative to text_height. Def = 1.1
    plot_page%axis_number_text_scale   = <real>   ! Relative to text_height. Def = 0.9
    plot_page%axis_label_text_scale    = <real>   ! Relative to text_height. Def = 1.0
    plot_page%legend_text_scale        = <real>   ! Relative to text_height. Def = 0.8
    plot_page%key_table_text_scale     = <real>   ! Relative to text_height. Def = 0.9
    plot_page%floor_plan_shape_scale   = <real>   ! Floor_plan shape size scaling.
    plot_page%lat_layout_shape_scale   = <real>   ! Lat_layout shape size scaling.
    plot_page%title(i)                 = <string>, {<x>, <y>, "<units>", "<justify>"}
    plot_page%n_curve_pts              = <int>    ! Num points used to construct a 
                                                  !   smooth curve. Default = 401
     = <T/F>    ! Used with "show plot" command.
    plot_page%box_plots                = <T/F>    ! For debugging. Default = F.
    include_default_plots              = <T/F>    ! Include default templates? Def = T.
    region(i) = "<region_name>" <x1\(_{\dstyle{r}}\)>, <x2\(_{\dstyle{r}}\)>, <y1\(_{\dstyle{r}}\)>, <y2\(_{\dstyle{r}}\)>  
    place(i)  = "<region_name>", "<template_name>"
    default_plot%...                            ! See below.
    default_graph%...                           ! See below. 
  /
\end{example}

%-----------------------

\begin{figure}[bt]
  \centering
  \includegraphics{plot-page.pdf}
  \caption[The plot window.]{The plot window has a boarder whose position is determined by 
the \vn{plot_page\%border} parameter in the tao_plot_page namelist.  Plots are placed
in ``\vn{regions}'' whose location is determined by the setting of the \vn{region(i)} parameters in
the same namelist. Regions may overlap.} 
  \label{f:plot.page}
\end{figure}

%-----------------------

For example:
\begin{example}
  &tao_plot_page
    plot_page%plot_display_type = "X"        ! X11 window.  "TK" is alternative.
    plot_page%size        = 700, 800         ! Points
    plot_page%border      = 0, 0, 0, 50, "POINTS"  
    plot_page%text_height = 12.0
    plot_page%title(1)    = "CESR Lattice", 0.5, 0.996, "%PAGE", "CC"
    region(1) = "top"    0.0, 1.0, 0.5, 1.0
    region(2) = "bottom" 0.0, 1.0, 0.0, 0.5
    place(1)  = "top",    "orbit"
    place(2)  = "bottom", "phase"
    default_plot%x%min = 100
    default_plot%x%max = 200
  /
\end{example}

\vn{plot_page%size} sets the horizontal and vertical size of the plot
window in \vn{points} units (72 points = 1 inch. Roughly 1 point = 1
pixel). 

\vn{plot_page%text_height} sets the overall height of the text that is
drawn. Relative to this, various parameters can be used to scale
individual types of text:
\begin{example}
  plot_page%main_title_text_scale  = 1.3 ! Main title height. 
  plot_page%graph_title_text_scale = 1.1 ! Graph title height.
  plot_page%axis_number_text_scale = 0.9 ! Axis number height
  plot_page%axis_label_text_scale  = 1.0 ! Axis label height.
  plot_page%key_table_text_scale   = 0.8 ! Key Table text (\sref{s:key.table}).
  plot_page%legend_text_scale      = 0.9 ! Lat Layout or floor plan text.
\end{example}
The default values for these scales are given above.

The \vn{plot_page%plot_display_type} component sets the type of plot display
window used. possibilities are:
\begin{example}
  "X"      X11 window
  "TK"     tk window
  "QT"     Available only when using PLPLOT (and not the default PGPLOT)
\end{example}
Note: The environmental variable \vn{ACC_PLOT_DISPLAY_TYPE} sets the default display
type. You can set this variable in your login file to avoid having to setup a \tao
init file to set this.

\vn{plot_page%border} sets a border around the edges of the window. As shown in
Figure~\ref{f:plot.page} x1$_{\dstyle{b}}$, x2$_{\dstyle{b}}$ are the right and left border widths
and y1$_{\dstyle{b}}$ and y2$_{\dstyle{b}}$ are the bottom and top border widths respectively.  The
rectangle within this border is called the plot area.

\vn{plot_page%title(i)} set the page title. There are two title areas (i = 1,2). If only the title
string is given then the other variables are set to the defaults \vn{x} = 0.5, \vn{y} = 0.995,
\vn{justify} = "CC" and \vn{units} = "\vn{%PAGE}". See the QuickPlot documentation
(\sref{s:line.symb}) for more details.

The plot area is divided up into rectangular regions where plots may be placed (what defines a plot
is discussed below).  \vn{region(i)} in the \vn{tao_plot_page} namelist is an array of five elements
that defines the i\Th region. The first element of this array is the name of the region. This name
may not contain a dot ``.''.  The last four elements of the \vn{retion(i)} array, x1$_{\dstyle{r}}$,
x2$_{\dstyle{r}}$, y1$_{\dstyle{r}}$ and y2$_{\dstyle{r}}$ define the location of the region as
illustrated in Figure~\ref{f:plot.page}.  x1$_{\dstyle{r}}$ and x2$_{\dstyle{r}}$ are normalized to
the width of the plot area and y1$_{\dstyle{r}}$ and y2$_{\dstyle{r}}$ are normalized to the height
of the plot area. That is, these four number should be in the range $[0, 1]$.  Regions may overlap
any one can define as many regions as one likes.

Besides the regions that the user sets up in the \vn{tao_plot_page} namelist, \tao defines a number
of default regions whose names begin with the letter '\vn{r}'. Use the \vn{show plot} command
(\sref{s:plot}) to view a list of these plots.

When \vn{plot_page%delete_overlapping_plots} is True (the default), Placing a plot (using
the \vn{place} command \sref{s:place}) causes any existing plots that overlap the
placed plot to become invisible. 

The \vn{plot_page%n_curve_pts} parameter sets the default number of points to use for drawing
``smooth'' curves. The default is 401. This default may be overridden for individual plots by
setting the \vn{plot%n_curve_pts} component of a plot (\sref{s:template}). If \vn{plot%n_curve_pts}
is set for an individual plot, that value overrides the value of
\vn{plot_page%n_curve_pts}. Warning: \tao will cache intermediate calculations used to compute a
smooth curve to use in the computation of other smooth curves. \tao will only do this for curves
that have \vn{plot_page%n_curve_pts} number of points. Depending upon the circumstances, setting
\vn{plot%n_curve_pts} for individual plots may slow down plotting calculations significantly.

\vn{place(i)} determines the initial placement of plots.

\vn{default_plot} sets the defaults for any \vn{plot}s defined in the \vn{tao_template_plot}
namelists (\sref{s:template}). Similarly, \vn{default_graph} sets defaults for the \vn{graph}
structure defined in the \vn{tao_template_graph} namelist (\sref{s:template}). In the example above,
the default x-axis min and max are set to 100 and 200 respectively.

If \vn{include_default_plots} is set to \vn{False}, the collection of default template
plots (\sref{s:template}) that \tao uses by default are not used along with the template
plots defined in the plotting file.

%-----------------------------------------------------------------
\subsection{Plot Templates}
\label{s:template}
\index{plot templates}

As shown in Figure~\ref{f:plot}, a ``plot'' is made up of a collection of ``graphs'' and a graph
consists of axes plus a set of ``curves''. To define custom plots, there needs to be defined
a set of ``template plots''. A template plot specifies the layout of a plot: How the graphs are
placed within a plot, what curves are associated with what graphs, etc. When running \tao, the
information in a template plot may then be transferred to a region using the \vn{place} command and
this will produce a visible plot.

The file that \tao looks in to find plotting information is set by the \vn{plot_file} component of
the \vn{tao_start} namelist (\sref{s:init.global}). The default, if \vn{plot_file} is not set, is
the root initialization file.

Template plots are defined using namelists with a name of \vn{tao_template_graph}. The general
syntax is:
\index{tao_template_plot}
\index{plot!name}
\index{plot!x}
\index{plot!x_axis_type}
\index{plot!n_graph}
\index{plot!autoscale_gang_x}
\index{plot!autoscale_gang_y}
\index{plot!autoscale_x}
\index{plot!autoscale_y}
\begin{example}
  &tao_template_plot
    plot%name        = "<plot_name>"
    plot%x           = <qp_axis_struct>
    plot%x_axis_type = "<x_axis_type>"   ! "index", "ele_index" "s", "lat", or "var". 
                                         ! Default is "index".
    plot%n_graph     = <n_graphs>
    plot%autoscale_gang_x = <logical>    ! Default: True.
    plot%autoscale_gang_y = <logical>    ! Default: True.
    plot%autoscale_x = <logical>         ! Default: False.
    plot%autoscale_y = <logical>         ! Default: False.
    plot%n_curve_pts = <integer>         ! Used to override plot_page%n_curve_pts.
    default_graph%...                    ! See below
  /
\end{example}
For example:
\begin{example}
  &tao_template_plot
    plot%name                = "orbit"
    plot%x%min               =   0
    plot%x%max               = 100
    plot%x%major_div_nominal = 10
    plot%x%label             = "Index"
    plot%n_graph             = 2
    default_graph%y%max      = 10
  /
\end{example}

\vn{default_graph} sets defaults for the \vn{graph} structure defined in the \vn{tao_template_graph}
namelist (\sref{s:template}). This overrides \vn{default_graph} settings made in the
\vn{tao_template_plot} namelist (\sref{s:init.plot}) but only for graphs associated with the
\vn{tao_template_plot} the \vn{default_graph} is defined in.

\vn{plot%x} sets the properties of the horizontal axis. For more information see the \vn{QuickPlot}
documentation (\sref{s:line.symb}) on the \vn{qp_axis_struct}.  If \vn{min} and \vn{max} are absent,
then \tao will autoscale the axis.  If it is desired to have differing scales for different graphs,
the \vn{graph%x} component can be used (see below).

Both \vn{major_div} and \vn{major_div_nominal} set the number of major divisions in the plot. The
difference between the two is that with \vn{major_div} the number of major divisions is fixed at the
set value and with \vn{major_div_nominal} the number of major divisions can vary from the set value
when \tao scales a graph. If \vn{major_div_nominal} is set, this will override any setting of
\vn{major_div}. If neither \vn{major_div} nor \vn{major_div_nominal} is set, a value will be chosen
for \vn{major_div_nominal} by \tao. If you are unsure which to set, it is recommended that
\vn{major_div_nominal} be used.

Plots with \vn{plot%autoscale_x} and/or \vn{plot%autoscale_y} logicals, set to true will
automatically rescale after any calculation. The \vn{plot%autoscale_gang_x} and
\vn{plot%autoscale_gang_y} components set how the \vn{x_scale} (\sref{s:x.scale}) and \vn{scale}
(\sref{s:scale}) commands behave when autoscaling entire plots. See these individual commands for
more details.

The \vn{plot%n_plot_pts} parameter sets the number of points to use for drawing ``smooth''
curves. This overrides the setting of \vn{plot_page%n_plot_pts} (\sref{s:init.plot}). Warning: \tao
will cache intermediate calculations used to compute a smooth curve to use in the computation of
other smooth curves. \tao will only do this for curves that have \vn{plot_page%n_curve_pts} number
of points. Depending upon the circumstances, setting \vn{plot%n_curve_pts} for individual plots may
slow down plotting calculations significantly.

\vn{plot%name} is the name that is used with \tao commands to identify the plot. It is important
that this name not contain any blank spaces since \tao uses this fact in parsing the command line.

\vn{plot%x_axis_type} sets what is plotted along the
\vn{x_axis}. Possibilities are:
\index{index}
\index{ele_index}
\index{s}
\begin{example}
    "index"      ! Data Index
    "ele_index"  ! Element lattice number index
    "s"          ! Longitudinal position in the lattice.
    "data"       ! From a data array
    "lat"        ! Lattice variable. See \sref{s:plot.var}.
    "var"        ! Tao variable value. See \sref{s:plot.var}.

\end{example}
The \vn{ele_index} switch is used when plotting data arrays. In this
case the \vn{index} switch refers to the index of the data array and
\vn{ele_index} refers to the index of the lattice element that the
datum was evaluated at.

\vn{n_graph} sets the number of graphs associated with the plot and
each one needs a \vn{tao_template_graph} namelist to define it. These
namelists should be placed directly after their respective
\vn{tao_template_graph} namelists. The general format of the
\vn{tao_template_graph} namelist is:
\index{tao_template_graph}\index{graph!y}\index{curve!name}
\index{graph_index}\index{graph}\index{graph!name}\index{curve}
\index{graph!type}\index{graph!box}\index{graph!title}\index{graph!margin}
\index{graph!y2}\index{graph!n_curve}\index{graph!clip}\index{graph!component}
\index{graph!symbol_size_scale}
\index{graph!floor_plan_rotation}\index{graph!floor_plan_flip_label_side}
\index{graph!floor_plan_view}
\index{curve!data_type}\index{curve!data_source}
\index{curve!x_axis_units_factor}\index{curve!y_axis_units_factor}
\index{curve!use_y2}\index{curve!line}\index{curve!ele_ref_name}
\index{curve!draw_line}\index{curve!draw_symbols}\index{curve!ix_universe}
\index{curve!symbol}\index{curve!symbol_every}\index{curve!convert}
\index{curve!ix_bunch}\index{curve!data_type_x}
\begin{example}
  &tao_template_graph
    graph_index             = <integer>
    graph%name              = "<string>"       ! Default is  "g<n>" <n> = graph_index. 
    graph%type              = "<string>"       ! "data", "floor_plan", etc.
    graph%box               = <ix>, <iy>, <ix_tot>, <iy_tot>
    graph%title             = "<string>"       ! Title above the graph.
    graph%margin            =  <ix1>, <ix2>, <iy1>, <iy2>, "<Units>"
    graph%scale_margin      =  <ix1>, <ix2>, <iy1>, <iy2>, "<Units>"
    graph%x                 = <qp_axis_struct> ! Horizontal axis.
    graph%y                 = <qp_axis_struct> ! Left axis.
    graph%x2                = <qp_axis_struct> ! Top axis (only used for floor_plan plots).
    graph%y2                = <qp_axis_struct> ! Right axis.
    graph%clip              = <logical>        ! Clip curves at boundary? Default = T
    graph%draw_axes         = <logical>        ! Default = T
    graph%draw_grid         = <logical>        ! Default = T
    graph%allow_wrap_around = <logical>        ! Wrap curves around lattice ends?
    graph%component         = "<string>"       ! Eg: "model - design"
    graph%symbol_size_scale      = <real>      ! Phase_space plots symbol scale factor
    graph%correct_xy_distortion  = <logical>   ! For Floor Plan plots: Default = F
    graph%ix_universe            = <integer>   ! Default = -1 => Use default universe
    graph%floor_plan_rotation    = <real>      ! Rotation of floor plan plot: 1.0 -> 360 deg. 
    graph%floor_plan_view        = <string>    ! View plane for floor plan plot. default = 'zx'
    graph%floor_plan_orbit_scale = <real>      ! Scale for drawing orbits. Default: 0 -> Do not draw.
    graph%floor_plan_orbit_color = <string>    ! Color of orbit. Default = 'RED'
    graph%floor_plan_flip_label_side      = <logical> ! Draw element label on other side of element?
    graph%floor_plan_size_is_absolute     = <logical> ! Shape sizes scaled to absolute dimensions?
    graph%floor_plan_draw_only_first_pass = <logical> ! Draw only first pass with multipass elements?
    graph%draw_only_good_user_data_or_vars     ! Veto data or variables with good_user = F?
                                 = <logical>   !   Default = T.
    graph%x_axis_scale_factor    = <factor>    ! Scale the x-axis by this.
    graph%n_curve                = <integer>   ! number of curves
    curve(i)%name                = "<string>"  ! Default is "c<i>", <i> = curve num.
    curve(i)%data_source         = "<string>"  ! Source for the data curve points
    curve(i)%data_type_x         = "<string>"  ! Used with plot%x_axis_type = "data" or "var".
    curve(i)%data_type           = "<string>"  ! Default = plot%name.graph%name
    curve(i)%component           = "<string>"  ! Eg: "model - design". Overrides graph%component.
    curve(i)%data_index          = "<string>"  ! Index number for data points.
    curve(i)%legend_text         = "<string>"  ! Text for curve legend. 
                                               !   Default is the data_type.
    curve(i)%y_axis_scale_factor = <factor>    ! Scale the y-axis by this.
    curve(i)%use_y2              = <logical>   ! Use left-axis scale?
    curve(i)%draw_line           = <logical>   ! Connect data with lines?
    curve(i)%draw_symbols        = <logical>   ! Draw data symbols?
    curve(i)%draw_symbol_index   = <logical>   ! Print index number next to the data symbol?
    curve(i)%ix_universe         = <integer>   ! Default = -1 => Use graph%ix_universe.
    curve(i)%ix_branch           = <integer>   ! Default = 0  => Use main lattice.  
    curve(i)%ix_bunch            = <integer>   ! Bunch index. Default = 0 (all bunches).
    curve(i)%line        = <qp_line_struct>    ! Line spec (color, width, etc.)
    curve(i)%symbol      = <qp_symbol_struct>  ! Symbol spec (color size, etc.)
    curve(i)%symbol_every     = <integer>      ! Plot symbol every # datums
    curve(i)%ele_ref_name     = "<string>"     ! Name of reference element.
    curve(i)%smooth_line_calc = <Logical>      ! Calc data between symbol points? 
    curve(i)%units            = "<string>"     ! Data units
  /
\end{example}
For example:
\begin{example}
  &tao_template_graph
    graph_index               = 1
    graph%name                = "x"
    graph%type                = "data"
    graph%box                 = 1, 1, 1, 2
    graph%title               = "Horizontal Orbit (mm)"
    graph%margin              =  60, 200, 30, 30, "POINTS"
    graph%y%label             = "X"
    graph%y%max               =  4
    graph%y%min               = -4
    graph%y%major_div_nominal = 4
    graph%n_curve             = 1
    graph%component           = "model - design"
    curve(1)%data_source      = "data"
    curve(1)%data_type        = "orbit.x"
    curve(1)%units_factor     = 1000
    curve(1)%use_y2           = F
  /
\end{example}
See the QuickPlot documentation (\sref{s:line.symb}) description of the \vn{qp_symbol_struct} and the
\vn{qp_line_struct}.

\vn{graph%title} is the string just above the graph. The full string will also include information
about what is being plotted and the horizontal axis type. To fully suppress the title leave it
blank.

If there are multiple curves drawn with a graph then a curve legend showing what lines are
associated with what data will be drawn. The default is to draw this legend in the upper left hand
corner of the graph. By default, the \vn{data_type} of each curve will be used as the text for that
curve's line in the legend.  This default can be changed by setting a curve's \vn{curve%legend_tex}.

\vn{graph%name} and \vn{curve%name} define names to be used with commands. The default names are
just the letter \vn{g} or \vn{c} with the index of the graph or curve. Thus, in the example above,
the name of the curve defaults to \vn{c1} and it would be referred to as \vn{orbit.x.c1}.  It is
important that these names do not contain any blank spaces since \tao uses this fact in parsing the
command line.

\vn{graph%box} sets the layout of the box which the \vn{graph} is placed in. For a definition of
what a box is see the QuickPlot documentation (\sref{s:line.symb}). In the above example the graph
divides the region into two vertically stacked boxes and places itself into the bottom one.

\vn{graph%allow_wrap_around} sets if, for a lattice with closed geometry, the curves contained in
the graph are ``wrapped'' around the ends of the lattice. The default is \vn{True}.

\vn{graph%margin} sets the margin between the \vn{graph} and the \vn{box}
it is drawn in.

\vn{graph%scale_margin} is used to set the minimum space between what is being drawn and the edges
of the \vn{graph} when a \vn{scale}, \vn{x_scale}, or a \vn{xy_scale} command is issued. Normally
this is zero but is useful for \vn{floor plan} drawings.

\vn{graph%type} is the type of graph. \tao knows about the
following types:
\index{data}\index{lat_layout}\index{key_table}\index{phase_space}
\index{floor_plan}\index{beam_chamber_wall}
\begin{example}
  "data"               ! Data and/or variable plots (default) (\sref{s:plot.data}).
  "floor_plan"         ! A 2-dimensional birds-eye view of the machine (\sref{s:floor.plan}).
  "histogram"          ! Histogram of plot (\sref{s:histogram}).
  "key_table"          ! Key binding table for single mode (\sref{s:key.table}).
  "lat_layout"         ! Schematic showing placement of the lattice elements (\sref{s:lat.layout}).
  "phase_space"        ! Phase space plots (\sref{s:phase.space}).
\end{example}

With \vn{graph%type} set to \vn{"beam_chamber_wall"} (\sref{s:beam.wall.draw}), the beam chamber
wall is drawn if it has been defined in the \bmad lattice file.

With \vn{graph%type} set to \vn{"data"} (\sref{s:plot.data}), data such as orbits and/or variable
values such as quadrupole strengths are plotted. Here ``data'' can be data from a defined data
structure (\sref{c:data}) or computed directly from the lattice, beam tracking, etc. A \vn{"data"}
graph type will contain a number of \vn{curves} and multiple data and variable curves can be drawn
in one graph.

With \vn{graph%type} set to \vn{floor_plan} (\sref{s:floor.plan}), the two dimensional layout of the
machine is drawn.

With \vn{graph%type} set to \vn{histogram} (\sref{s:histogram}), such things such as beam densities
can be histogrammed.

With \vn{graph%type} set to \vn{"key_table"} (\sref{s:key.table}), the key bindings for use in
single mode (\sref{s:key.bind}) are displayed.  Note: The \vn{"key_table"} graph type does not have
any associated \vn{curve}s.

With \vn{graph%type} set to \vn{lat_layout} (\sref{s:lat.layout}), the elements of the lattice are
symbolical drawn in a one dimensional line as a function of the longitudinal distance along the
machine centerline.

With \vn{graph%type} set to \vn{phase_space} (\sref{s:phase.space}), phase space plots are produced.

%-----------------------------------------------------------------
\subsection{Data and Variable plotting}
\label{s:plot.data}

A \vn{graph} (\sref{s:template}), with \vn{graph%type} equal to \vn{"data"}, is used to draw
``data'' such as orbits and/or variable values such as quadrupole strengths. A data \vn{graph} will
have a number of associated \vn{curve}s with each curve defining a particular data type to plot.

The data values will depend upon where the data comes from. This is determined, in part, by the
setting of \vn{graph%component} and \vn{curve%component}. \vn{graph%component} and
\vn{curve%component} may be one of:
\index{model}\index{design}\index{base}\index{meas}\index{ref}
\begin{example}
  "model"             ! model values. Default.
  "design"            ! design values.
  "base"              ! Base values
  "meas"              ! data values.
  "ref"               ! reference data values.
  "beam_chamber_wall" ! Beam chamber wall
\end{example}
Additionally, \vn{graph%component} may be set to plot a linear combination of the above. For
example:
\begin{example}
  graph%component = "model - design"
\end{example}
This will plot the difference between the \vn{model} and \vn{design} values.

If \vn{curve%component} is set, it will override \vn{graph%component}. If \vn{graph%component} is
not set in the initialization file, and if there are curves of the graph that have not been set,
\vn{graph%component} will be given a default setting of \vn{model}.

\index{data}\index{var}\index{calculation}
\index{curve!data_source}
The \vn{curve} structure is used to define the data that is plotted in each graph.
\vn{curve%data_source} is the type of information for the source of the data points.
\vn{curve%data_source} must be one of:
\begin{example}
  "data"              ! A d1_data array is the source of the curve points.
  "var"               ! A v1_var array is the source of the curve points.
  "lat" (Default)     ! The curve points are computed directly from the lattice.
  "beam"              ! The curve points are computed tracking a beam of particles.
  "multi_turn_orbit"  ! Computation is from multi-turn tracking. 
\end{example}
The default for \vn{curve%data_source} is \vn{"lat"}. With \vn{curve%data_source} set to \vn{data},
the values of the curve points come from the \vn{d1_data} array structure named by
\vn{curve%data_type}. Thus in the above example the curve point values are obtained from
\vn{orbit.x} data. To be valid the data structure named by \vn{curve%data_type} must be set up in an
initialization file. If not given, the default \vn{curve%data_type} is
\begin{example}
  <plot%name>.<graph%name>
\end{example}
If \vn{curve%data_source} is set to \vn{var}, the values of the curve points come from a \vn{v1_var}
array structure. If it is set to \vn{lat} the curve data points are calculated from the lattice
without regard to any data structures. \vn{curve%data_source} can be set to \vn{beam} when tracking
beams of particles. In this case, the curve points are calculated from the tracking. With \vn{beam},
the particular bunch that the data is extracted from can be specified via \vn{curve%ix_bunch}. The
default is \vn{0} which combines all the bunches of the beam for the calculation.

Example: With \vn{curve%data_type} set to \vn{beta.x}, the setting of \vn{curve%data_source} to
\vn{lat} gives the beta as calculated from the lattice and \vn{beam} gives the beta as calculated
from the shape of the beam.

\vn{curve%draw_symbols} determines whether a symbol is drawn at the data points. The size, shape and
color of the symbols is determined by \vn{curve%symbol}. A given symbol point that is drawn has
three numbers attached to it: The $(x, y)$ position on the graph and an index number to help
identify it. The index number of a particular symbol is the index of the datum or variable
corresponding the symbol in the \vn{d1_data} or \vn{v1_var} array. These three numbers can be
printed using the \vn{show curve -symbol} command (\sref{s:show}).  \vn{curve%draw_symbol_index}
determines whether the index number is printed besides the symbol. Use the \vn{set curve} command
(\sref{s:set}) to toggle the drawing of symbols. The default value for \vn{curve%draw_symbol} is
False if \vn{plot%x_axis_type} is \vn{"s"} and True otherwise. The
default\vn{curve%draw_symbol_index} is always False.

\vn{curve%draw_line} determines whether a curve is drawn through the data point symbols. The
thickness, style (solid, dashed, etc.), and color of the line can be controlled by setting
\vn{curve%line}. If \vn{plot%x_axis_type} is \vn{"s"}, and \vn{graph%component} does not contain
\vn{"meas"} or \vn{"ref"}, \tao will attempt to calculate intermediate values in order to draw a
smooth, accurate curve is drawn. Occasionally, this process is too slow or not desired for other
reasons so setting \vn{curve%smooth_line_calc} to False will prevent this calculation and the curve
will be drawn as a series of lines connecting the symbols. The default of
\vn{curve%smooth_line_calc} is True. Use the \vn{set curve} command (\sref{s:set}) to toggle the
drawing of lines. Alternatively, the \vn{-disable_smooth_line_calc} switch can be used on the
command line (\sref{s:command.line}) or the global variable \vn{global%disable_smooth_line_calc} can
be set in the \tao initialization file (\sref{s:globals}).

The \vn{graph%draw_only_good_user_data_or_vars} switch determines whether datums
(\sref{s:init.data}) or variables (\sref{s:init.var}) with a \vn{good_user} component set to
\vn{False} are drawn. The default is to not draw them which means that data or variables not used in
an optimization are not drawn.

A graph has two vertical axes. The one on the left is called \vn{"y"} and the one on the right is
called \vn{"y2"}. For example, \vn{graph%y%label} sets the axis label for the \vn{y} axis and
\vn{graph%y2%label} sets the axis label for the \vn{y2} axis. Normally there is only one vertical
scale for a graph and this is associated with the \vn{y} axis. However, if any curve of a given
graph has \vn{curve%use_y2} set to \vn{True} then the \vn{y2} axis will have an independent second
scale. In this case, the \vn{y2} axis numbers will be drawn. Notice that simply giving the \vn{y2}
axis a label does {\em not} make the \vn{y2} axis scale independent of the \vn{y} axis scale.

Typically, a graph's horizontal scale is set by the \vn{plot%x} component. If it is desired to have
differing scales for different graphs, the \vn{graph%x} component can be used.

%-----------------------------------------------------------------
\subsection{Graphing a Data Slice}\index{plot!data slice}
\label{s:graph.data.slice}

The standard data graph, as presented in the previous subsection,
plots data from a given \vn{d1_data} array. It is also possible to
graph data that has been ``sliced'' in other ways. For example,
suppose a number of universes have been established, with each
universe representing the same machine but with different steerings
powered. If in each universe an \vn{orbit} \vn{d2_data} structure has
been defined, an example of a data slice is the collection of
points (x, y) where:
\begin{example}
  (x, y) = (<n>@orbit.x[23], <n>@orbit.y[23]),   <n> = 1, ..., n_universe
\end{example}
When defining a template for graphing a data slice, the
plot%x_axis_type is set to \vn{"data"}, and the \vn{graph%type} must
be set to \vn{"data"}, the \vn{curve(:)%data_source} must be set to
\vn{"data"} and the \vn{curve(:)%data_type_x} and
\vn{curve%data_type} are used to define the x and y axes respectively.
In the strings given by \vn{<curve%data_type_x} or
\vn{<curve%data_type}, all substrings that look like \vn{\#ref} are
eliminated and the string given by \vn{curve%ele_ref_name} is
substituted in its place.  Similarly, a \vn{\#comp} string is used as a
place holder for the \vn{graph%component} Example:
\begin{example}
  &tao_template_plot
    plot%name = "at_bpm"
    plot%x%label = "x"
    plot%x_axis_type = "data"
    plot%n_graph = 1
  /

  &tao_template_graph
    graph_index = 1
    graph%title = "Orbit at BPM"
    graph%y%label = "y"
    graph%component = "meas - ref"
    graph%type = "data"
    graph%n_curve = 1
    graph%x_axis_scale_factor = 1000
    curve(1)%data_source = "data"
    curve(1)%data_type_x = "[2:57]@orbit.x[#ref]|#comp"
    curve(1)%data_type   = "[2:57]@orbit.y[#ref]|#comp"
    curve(1)%data_index  = "[2:57]@orbit.y[#ref]|ix_uni"
    curve(1)%y_axis_scale_factor = 1000
    curve(1)%ele_ref_name = "23"
    curve(1)%draw_line = F
  /
\end{example}
In this example, \vn{curve(1)%data_type_x} expands to
\vn{"[2:57]@orbit.x[23]|meas-ref"}. That is, the \vn{meas - ref}
values of \vn{orbit.x[23]} from universes 2 through 57 is used for the
x-axis.  Similarly, \vn{orbit.y[23]} is used for the y-axis. The
\vn{set} command (\sref{s:set}) can be used to change
\vn{curve%ele_ref_name} and \vn{graph%component} strings. 

\vn{curve%data_index} sets the index number for the symbol points
(\sref{s:template}). In the above example, \vn{curve%data_index} is
set to \vn{"[2:57]@orbit.y[\#ref]|ix_uni"}. The \vn{|ix_uni} component
will result in the symbol index number being the universe number.
Additionally, the component \vn{|ix_d1} can be used to specify the
index in the \vn{d1_data} array, and the component \vn{|ix_ele} can be
used to specify the lattice element index. Setting the symbol index
number is important when \vn{curve%draw_symbol_index} is set to True
so that the symbol index is drawn with the curve. Additionally, the
command \vn{show curve -symbol} (\sref{s:show}) will print the symbol
index number along with the $(x, y)$ coordinates of the symbols.

Arithmetic expressions (\sref{s:arithmetic.exp}) may be mixed with
explicit datum components in the specification of
\vn{curve(:)%data_type_x} and \vn{curve(:)%data_type}. Example:
\begin{example}
  curve(1)%data_type_x = "[#ref]@orbit.x|model"
  curve(1)%data_type   = "[#ref]@orbit.x|meas-ref"
  curve(1)%ele_ref_name = "3"
\end{example}
The plots the \vn{model} values of \vn{orbit.x} verses \vn{meas - ref}
of \vn{orbit.x} for the data in universe 3. Note: Whenever explicit
components are specified, the \vn{graph%component} settings are ignored for
that expression.

%-----------------------------------------------------------------
\subsection{Plotting With a Variable Parameter on the X-Axis}
\index{plot!plotting as a function of a variable}
\label{s:plot.var}

Data can be plotted as a function of a lattice parameter by setting
\vn{plot%x_axis_type} to \vn{"lat"} (for lattice variables) or
\vn{"var"} (for \tao variables) and setting \vn{curve(:)%data_type_x}
to the name of the variable. In this case, the \vn{curve(:)%data_type}
must evaluate to a single number.

Example:
\begin{example}
  &tao_template_plot
    plot%x_axis_type = "lat"
    plot%n_curve_pts = 50
    ...
  /

  &tao_template_graph
    ...
    curve(1)%data_type_x = "particle_start[x]"  ! X-axis values.
    curve(1)%data_type   = "orbit.x[10]"        ! Y-axis values.
    ...
  /
\end{example}
Here the number of curve points has been set to 50 to reduce the evaluation overhead.

Note: \tao treats the \vn{design} and \vn{base} lattices as static so
that varying a variable will not affect these lattices. Thus,
constructing a plot with \vn{graph%component} set to, for example,
\vn{"model - design"} will {\em not} produce a plot that is the
difference between varying a variable in both \vn{model} and
\vn{design} lattices. In the case where such a plot is desired, a
second universe needs to be established. In this case, one would set
\vn{curve(:)%data_type} to something like
\begin{example}
    curve(1)%data_type   = "1@orbit.x[10] - 2@orbit.x[10]"    
\end{example}
where the universe \#2 \vn{model} lattice would be setup to be equal
to the universe \#1 \vn{design} lattice.

%-----------------------------------------------------------------
\subsection{Drawing a Lattice Layout}
\index{lattice layout}
\label{s:lat.layout}

\begin{figure}
  \centering
  \includegraphics[width=5in]{layout-graph-table.pdf}
  \caption[Example lattice layout and data plots]
{A lattice layout plot (top) above a data plot (middle) 
which in turn is above a key table plot (bottom). The points on the
curves in the data plot mark the edges of the elements displayed in
the lattice layout. Elements that have attributes that are varied as
shown in the key table have the corresponding key table number printed
above the element's glyph in the lattice layout.}
  \label{f:layout.table}
\end{figure}

A lattice layout plot draws the lattice
along a straight line with colored rectangles representing the various elements.
An example is shown in Figure~\ref{f:layout.table}.
The \vn{tao_template_plot} needed to define a lattice layout looks like:
\index{tao_template_plot}\index{plot!name}
\index{plot!x!min}\index{plot!x!max}\index{plot!n_graph}
\index{tao_template_graph}\index{graph_index}\index{graph!name}
\index{graph!type}\index{graph!title}\index{graph!box}
\index{graph!ix_universe}\index{graph!margin}\index{graph!n_curve}
\begin{example}
  &tao_template_plot
    plot%name        = "<plot_name>"
    plot%x%min       = <real>  
    plot%x%max       = <real>  
    plot%n_graph     = <integer>
    plot%x_axis_type = "s"
  /
  &tao_template_graph
    graph_index       = <integer>
    graph%name        = <name>
    graph%type        = "lat_layout"
    graph%title       = "Layout Title"
    plot%box          = <ix>, <iy>, <ix_tot>, <iy_tot>
    graph%ix_universe = <integer> ! -1 => use current default universe
    graph%ix_branch   = <integer> !  0 => use main lattice.
    graph%margin      = <ix1>, <ix2>, <iy1>, <iy2>, "<Units>"
    graph%y%min       = <real>    ! Default: -100
    graph%y%max       = <real>    ! Default:  100
  /
\end{example}
Example:
\begin{example}
  &tao_template_plot
    plot%name        = "layout"
    plot%x%min       =   0
    plot%x%max       = 100
    plot%n_graph     = 1
    plot%x_axis_type = "s"
  /

  &tao_template_graph
    graph_index       = 1
    graph%name        = "u1"
    graph%type        = "lat_layout"
    graph%box         = 1, 1, 1, 1
    graph%ix_universe = 1
    graph%margin      = 0.12, 0.12, 0.30, 0.06, "%BOX"
  /
\end{example}

Which elements are drawn is under user control and is defined 
using an \vn{lat_layout_drawing} namelist. See Section~\sref{s:shapes}
for more details.

The longitudinal distance markers at either end of the lattice layout can be 
suppressed by setting
\begin{example}
  graph%x%draw_numbers = F
\end{example}

%-----------------------------------------------------------------
\subsection{Drawing a Floor Plan}
\index{floor plan drawing}
\label{s:floor.plan}

\begin{figure}
  \centering
  \includegraphics[width=5in]{floor-plan.pdf}
  \caption{Example Floor Plan drawing.}
  \label{f:floor.plan}
\end{figure}

A \vn{floor plan} drawing gives a display of the machine projected onto the horizontal plane.  An
example is shown in Figure~\ref{f:floor.plan}. Like a \vn{Lattice Layout} (\sref{s:lat.layout}),
Elements are represented by colored rectangles and which elements are drawn is determined by an
\vn{floor_plan_drawing} namelist (see~\sref{s:shapes}).

The placement of an element in the drawing is determined by the element's coordinates in \vn{global
reference system}.  See the Bmad manual for more information on the \vn{global reference system}.
In the \vn{global reference system}, the $(Z, X)$ plane is the horizontal plane.

What plane a floor plan is projected onto is determined by the setting of the
\vn{graph%floor_plan_view} switch. This switch is a two character string.  Each character is either
'x', 'y', or 'z' and the characters must not be both the same. Default is 'zx'. The first character
determines which global coordinate are mapped to the horizontal axis of the graph and the second
character determines which global coordinate is mapped to the vertical axis of the graph. There are
six possible two character combinations. The default 'zx' setting represents looking at the
horizontal plane from above. A setting of 'xz' represents looking at the horizontal plane from
below. Etc.

Documentation on \vn{graph%floor_plan_size_is_absolute} is in section~\sref{s:shapes}

An overall rotation of the floor plan can be controlled by setting
\vn{graph%floor_plan_rotation}. A setting of 1.0 corresponds to
360$^\circ$. Positive values correspond to counter-clockwise
rotations. Example: (\sref{s:init.plot})
\begin{example}
  &tao_plot_page
    ...
    graph%floor_plan_rotation = 0.5  ! Rotate 180 degrees
  /
\end{example}

If element labels are to be drawn, on which side the labels are drawn can be flipped by setting 
\vn{graph%floor_plan_flip_label_side} to True.


The beam orbit can be drawn upon the floor plan. This is done by setting
\vn{graph%floor_plan_orbit_scale} to something nonzero. A value of zero suppresses the drawing of
the orbit. This scale is used to scale the distance between the centerline of the elements and the
orbit. So a with a value of 100.0, a 1~cm orbit is drawn 1~meter from the centerline.  Note: If
\vn{graph%floor_plan_orbit_scale} is not unity, the plotted orbit when going through a \vn{patch}
element with a finite transverse offset will show a discontinuity due to the discontinuity of the
reference orbit.

The color of a drawn beam orbit is controlled by \vn{graph%floor_plan_orbit_color}. The default
color is 'RED'.

Alternatively, the global coordinates at the start of the lattice can be defined in the lattice file
and this can rotate the floor plan.  Unless there is an offset specified in the lattice file, a
lattice will start at $(x, y) = (0, 0)$. Assuming that the machine lies in the horizontal plane with
no negative bends, the reference orbit will start out pointing in the negative $x$ direction and
will circle clockwise in the $(x, y)$ plane.

If \vn{graph%ix_universe} is set to -1 the current viewed universe is used.  If
\vn{graph%ix_universe} is set to -2, all universes are plotted.

Example Floor Plan template:
\begin{example}
  &tao_template_plot
    plot%name = "floor"
    plot%x%min = -12  
    plot%x%max = 0    
    plot%x%major_div_nominal = 4
    plot%x%minor_div = 3
    plot%n_graph = 1
  /

  &tao_template_graph
    graph_index = 1
    graph%name = "1"
    graph%type = "floor_plan"
    graph%box = 1, 1, 1, 1
    graph%margin = 0.10, 0.10, 0.10, 0.10, "%BOX"
    graph%ix_universe = -2   ! Draw all universes.
    graph%x%label = "SMART LABEL"
    graph%y%label = "SMART LABEL"
    graph%y%max = 2  
    graph%y%min = -1 
    graph%correct_xy_distortion = T
    graph%floor_plan_size_is_absolute = T
    graph%floor_plan_view = 'xz'  ! Looking from beneath
    graph%floor_plan_orbit_scale = 100
  /
\end{example}

Having \vn{graph%x%label} and \vn{graph%y%label} set to ``\vn{SMART LABEL}'' means that the actual axis labels will be 
picked appropriately based upon the setting of \vn{graph%floor_plan_view}.

To prevent the drawing of the axes set \vn{graph%draw_axes} to False.  To prevent the drawing of a
grid at the major division points set \vn{graph%draw_grid} to False.

By default, the horizontal or vertical margins of the graph will be increased so that the horizontal
scale (meters per plotting inch) is equal to the vertical scale.  If
\vn{graph%correct_xy_distortion} is set to \vn{False}, this scaling will not be done.

Note: The \vn{show ele -floor} command (\sref{s:show}) can be used to view an element's global
coordinates.

%-----------------------------------------------------------------
\subsection{Defining Shapes for Lat_layout and Floor_plan Drawings}
\label{s:shapes}
\index{lat_layout drawings}
\index{floor_plan drawings}

\vn{Floor plan} (\sref{s:floor.plan}) and \vn{lattice layout} drawings use various shapes, sizes,
and colors to represent lattice elements. The association of a particular element with a given shape
is determined via two namelists: \vn{lat_layout_drawing} for the lattice layout and
\vn{floor_plan_drawing} for floor plan drawings.  Two different namelists are used since, for
example, a size that is good for a layout will not necessarily be good for a floor plan.

The file that \tao looks in to find these two namelists is set by the first file specified in the
\vn{plot_file} array set in the \vn{tao_start} namelist (\sref{s:init.global}). The default, if
\vn{plot_file} is not set, is the root initialization file.

The namelist syntax is the same for both:
\begin{example}
  &lat_layout_drawing
    ele_shape(i) = "<ele_id>" "<shape>" "<color>" "<size>" "<label>" <draw> 
                                                                <multi> <line_width>
  /

  &floor_plan_drawing
    ... same as lat_layout_drawing ...
  /
\end{example}
For Example:
\begin{example}
  &floor_plan_drawing
    !               ele_id                  Shape      Color     Size  Label  ..etc..
    ele_shape(1) = "quadrupole::q*"         "box"      "red"     0.75  "name"  
    ele_shape(2) = "quadrupole::*"          "xbox"     "red"     0.75  "none" 
    ele_shape(3) = "sbend::sb*"             "box"      "blue"    0.37  "none"
    ele_shape(4) = "sbend::*"               "box"      "blue"    0.37  "none"  
    ele_shape(5) = "wiggler::*"             "xbox"     "green"   0.50  "name"
    ele_shape(6) = "var::quad_k1"           "circle"   "purple"  0.25  "name"
    ele_shape(7) = "data::orbit.x|design"   "vvar_box" "orange"  0.25  "name"
    ele_shape(8) = "building_wall::*"       "-"        "black"    0    "none"
    ele_shape(3)%multi = T
    ele_shape(5:6)%line_width = 5, 6
  /
\end{example}
A figure is drawn for each lattice element in the lattice that matches the \vn{<ele_id>}
specification (\sref{s:ele.list.format}) of any \vn{ele_shape(:)}.  Thus, in the example above,
\vn{ele_shape(1)} will match to all quadrupoles whose name begins with ``q'' and \vn{ele_shape(2)}
will match all quadrupoles. If an element matches more than one shape, what is drawn depends upon
the setting of \vn{<multi>}. If \vn{<multi>} is False (the default) for the first shape matched in
the list of shapes, only this shape will be used.  If \vn{<multi>} is True, \tao will draw this
shape and then look for additional matches. Each time an additional match is found, the shape is
drawn and the setting of \vn{<multi>} for that shape will be used to determine whether additional
shapes are searched for. Thus \vn{<multi>} can be use to draw, for example, a \vn{circle} shape
superimposed upon a \vn{bow_tie} shape.

For a floor plan, for \vn{wiggler}s or \vn{undulators} that have an \vn{x_ray_line_len} attribute
(see the \bmad manual), The X-ray line will be drawn if an \vn{ele_shape} for a \vn{photon_branch}
is present.

Use the \vn{show plot -shape} command to see the defined shapes.  use the \vn{set shape} command
(\sref{s:set})) to set shape parameters on the command line.

Data and variables can also be specified to be drawn by using a \vn{<ele_id>} beginning with
\vn{data::} for drawing data and \vn{var::} for drawing variable locations. In the above example, it
is assumed that a \vn{quad_k1} variable array and a \vn{orbit.x} data array have been setup. A
circle will be drawn at each element under control of a \vn{quad_k1} variable. For the \vn{orbit.x}
data, an ``x'' will de drawn where the data is being evaluated but only for datums whose
\vn{useit_opt} parameter is True.

For \vn{floor_plan} drawings, the building wall (\sref{s:building.wall}) can be drawn by specifying
an \vn{ele_shape} whose name is \vn{"building_wall::<name>"} where \vn{<name>} is used to match to
the building wall section name. Use ``\vn{*}'' for \vn{<name>} to match to all names. For the
building wall, the only attribute that is relevant is the \vn{<color>} attribute.

The width of a drawn shape is the width of the associated element. The exception is the \vn{"x"}
shape whose width is always the same as the height determined by the \vn{<size>} setting.

\vn{<size>} is the half height of the shape. That is, the size transverse to the longitudinal
dimension. For \vn{lat_layout} drawings, \vn{<size>} = 1.0 corresponds to full scale if the default
\vn{graph%y%min} = -1 and \vn{graph%y%max} = 1 are used. For {floor_plan} drawings, to determine the
size of a shape, \vn{<size>} is combined with the \vn{graph} parameter
\begin{example}
  floor_plan_size_is_absolute  ! Default: False.
\end{example}
If \vn{floor_plan_size_is_absolute} is False (the default), \vn{<size>} is taken to be the size of
the shape in points (1 point is approximately 1 pixel). If \vn{floor_plan_size_is_absolute} is True,
\vn{<size>} is taken to be the size in meters. That is, if \vn{floor_plan_size_is_absolute} is
False, zooming in or out will not affect the size of an element shape while if
\vn{floor_plan_size_is_absolute} is True then the size of an element will scale with the zoom.

The \vn{graph%floor_plan_draw_only_first_pass} logical, if set True, suppresses drawing of
\vn{multipass_slave} lattice elements that are associated with the second and higher passes. This
logical defaults to False. Setting to True is only useful in some extreme circumstances where the
plotting of additional passes leads to large pdf/ps file sizes.

The overall size of all the shapes can be scaled using the \vn{plot_page} (\sref{s:init.plot})
parameters
\begin{example}
  floor_plan_shape_scale     ! For floor_plan drawings. Default = 1
  lat_layout_shape_scale     ! For lat_layout drawings. Default = 1
\end{example}

The text size in both \vn{floor_plan} and \vn{lat_layout}
plots can be scaled by using the \vn{plot_page} parameter
\begin{example}
  legend_text_scale          ! Default = 1
\end{example}
Use the \vn{show plot} command to view these parameters. Use the
\vn{set plot_page} command to set these parameters.

\vn{<color>} is the color of the shape. Good colors to use are:
\index{element shape!color}
\begin{example}
  "black"
  "blue"
  "cyan"
  "green"
  "magenta"
  "orange"
  "purple"
  "red"
  "yellow"
\end{example}

The \vn{<line_width>} parameter is an integer that specifies the width of the lines drawn. The
default is 1.

The \vn{<label>} indicates what type of label to print next to the corresponding
element glyph. Possibilities are:
\begin{example}
  name            -- The element name (default).
  none            -- No label is drawn.
  s               -- Draw longitudinal s position.
\end{example}
The default is \vn{"name"}

The \vn{<draw>} field determines if a shape is drawn or not. The
default is \vn{T}. This can be useful for toggling on and off the
drawing of shapes using the \vn{set shape} command (\sref{s:set}).

Note: There is an old, deprecated syntax where both the lattice layout
and floor plan drawings are specified via one \vn{element_shapes}
namelist.

The \vn{<shape>} parameter is the shape of the figure
drawn. Valid Shapes are:
\index{box}\index{xbox}
\begin{example}
  "asym_var_box"   -- Like var_box but is not symmetric about the center line.
  "asym_vvar_box"  -- Like asym_var_box except scaled to associated variable or datum.
  "box"            -- Rectangular box
  "var_box"        -- Rectangular box with variable height. 
                       The box is symmetric about the center line.
  "vvar_box"       -- Like var_box except scaled to associated variable or datum.
  "bow_tie"        -- Bow-tie shape.
  "rbow_tie"       -- Bow-tie shape rotated 90 degrees.
  "circle"         -- Circle centered at center of element.
  "diamond"        -- Diamond shape.
  "pattern:<pattern_name>" 
                   -- Custom curve specified by <name>.
  "x"              -- "X" centered at center of element
  "xbox"           -- Rectangular box with an x through it.
  "-"              -- Used with ele_id set to "building_wall" .
\end{example}

If an element's shape is set to \vn{var_box} or \vn{asym_var_box}, the drawn size of the
element is proportional to the element's magnetic or electric strength. The associated
\vn{<size>} setting is the multiplier used to scale from element strength to height. For
example, for a quadrupole the height is proportional to the \vn{K1} focusing strength. The
difference between \vn{var_box} or \vn{asym_var_box} is that with \vn{var_box} the drawn
box is symmetric with respect to the centerline with a size independent of the sign of the
element strength. On the other hand, with \vn{asym_var_box}, the drawn box will terminate
with one side on the centerline and the side on which it is drawn will depend upon the the
sign of the element strength. Note: Not all lattice elements can be used with a
\vn{var_box} or \vn{asym_var_box}.

A \vn{vvar_box} shape is like a \vn{var_box} and a \vn{asym_vvar_box} is like a
\vn{asym_var_box}. The difference is that \vn{vvar_box} and \vn{asym_vvar_box} shapes may only be
used when the \vn{<ele_id>} is associated with data or variables. That is, when the \vn{<ele_id>}
string starts with ``\vn{data::}'' or ``\vn{var::}''. In this case, the height of the box, instead
of being proportional to the strength of the element, is proportional to the value of the associated
datum or variable. If no datum or variable component is specified in the \vn{ele_id}, the model
value will be used. Thus, in the above example, where \vn{<ele_id>} was set to
\vn{"data::orbit.x|design"}, the design value is used.

The \vn{-} setting for \vn{<shape>} is used when \vn{<ele_id>} is set to \vn{building_wall} to
indicate that the shape attribute is ignored when drawing the building wall.

The \vn{pattern:<pattern_name>} shape allows for a custom pattern to be specified. Custom
patterns are specified by a \vn{shape_pattern} namelist:
\begin{example}
  &shape_pattern
    name = "<curve_name>"
    line%width = <line_width>
    pt(1) = <s>, <x>
    pt(2) = <s>, <x>
    pt(3) = ...
  /
\end{example}
Example:
\begin{example}
  &floor_plan_drawing
    ...
    ele_shape(2) = "quadrupole::*"     "pattern:q_pat"     "red"     0.75     "none" 
    ...
  /

  &shape_pattern
    name = "q_pat"
    pt(1) = 0, -1
    pt(2) = 1, -1
    pt(3) = 0.9, 1
    pt(4) = 0.1, 1
    pt(5) = 0, -1
  /
\end{example}
The \vn{name} of the \vn{shape_pattern} namelist (in this example it is "q_pat") must match the name
given by \vn{"pattern:<pattern_name>"}. The pattern is specified by a number of points. Between the
points, a line segment is drawn. In the above example, the pattern is an isosceles trapezoid.  When
drawn, the \vn{s} coordinate is scaled so that $s = 0$ corresponds to the entrance end of the
element and $s = 1$ corresponds to the exit end. The \vn{x} coordinate is scaled by the \vn{size}
attribute of the \vn{ele_shape}. The color of the line segments is set by the definition and the width
of the line segments is set by the pattern definition.

%-----------------------------------------------------------------
\subsection{Drawing a Dynamic Aperture}
\index{dynamic aperture drawing}
\label{s:dynamicapertureplot}


\begin{figure}
  \centering
  \includegraphics[width=5in]{dynamic-aperture.pdf}
  \caption{Example dynamic aperture plot.}
  \label{f:dynamic-aperture}
\end{figure}

A \vn{dynamic_aperture} drawing displays the results of the dynamic aperture
calculation (\sref{s:dynamicaperture}). Example plot setup:
\begin{example}
&tao_template_plot
  plot%name = 'da'
  plot%x%min = -20
  plot%x%max =  20
  plot%x%major_div_nominal = 10
  plot%x%label = 'x (mm)'
  plot%x_axis_type = 'phase_space'
  plot%n_graph = 1
/

&tao_template_graph
  graph%name = 'g1'
  graph%type = 'dynamic_aperture'
  graph_index = 1
  graph%title = 'dynamic aperture'
  graph%margin =  0.15, 0.06, 0.12, 0.12, '%BOX'
  graph%x_axis_scale_factor = 1000
  graph%y%label = 'y (mm)'
  graph%y%label_offset = .2
  graph%y%max = 0
  graph%y%min = 0
  graph%y%major_div = 4
  graph%n_curve = 3
  curve(1)%y_axis_scale_factor = 1000
  curve(2)%y_axis_scale_factor = 1000
  curve(3)%y_axis_scale_factor = 1000
  curve(1)%draw_symbols = F
  curve(2)%draw_symbols = F
  curve(3)%draw_symbols = F
  curve(3)%data_type = 'physical_aperture'
  curve(3)%line%color = 'red'
  curve(3)%line%width = 5 
/
\end{example}
This produces the plot on Fig.~\ref{f:dynamic-aperture}.  Each curve represents a single momentum
calculation.  If there are more momenta than curves (as in this case), additional curves will
automatically be created using the styles of the previous curves. Note that apertures are calculated
at element 0.

If there is a curve with \vn{%data_type} set to \vn{"physical_aperture"}, and if there is a lattice
element at $s = 0$ that has an aperture set, this physical aperture will be drawn. Example: In the
\bmad lattice file define a marker element with an aperture and superimpose the marker at the
beginning of the lattice:
\begin{example}
  m: marker, x_limit = 0.045, y_limit = 0.025, superimpose
\end{example}

Dynamic aperture curves can have the following \vn{%data_type}:
\begin{example}
  'dynamic_aperture' or ''    ! (default) points include the reference orbit
  'dynamic_aperture_centered' ! points are centered (relative to) the reference orbit
  'physical_aperture'         ! draws the physical aperture based on x1_limit, etc. 
\end{example}

%-----------------------------------------------------------------
\subsection{Drawing a Histogram}
\index{histogram drawing}
\label{s:histogram}

A \vn{histogram} drawing displays a histogram of phase space beam density. Histogram plotting is
associated with a \vn{graph} by setting \vn{graph%type} equal to \vn{"histogram"}. The concepts here
are similar to \vn{phase space} plotting (\sref{s:phase.space}). An example is shown in
Fig.~\ref{f:histogram}, using the example histogram template:
\begin{example}
&tao_template_plot
  plot%name = 'zhist'
  plot%x%min = -6
  plot%x%max =  6
  plot%x%label = 'z (mm)'	
  plot%n_graph = 1
/

&tao_template_graph
  graph_index = 1
  graph%name = 'z'
  graph%type = 'histogram'
  graph%box = 1, 1, 1, 1
  graph%title = 'Bunch Histogram: Z'
  graph%margin =  0.15, 0.06, 0.12, 0.12, '%BOX'
  graph%y%label = 'Current (A)'
  graph%n_curve = 1
  graph%y%label_offset = .1
  graph%x_axis_scale_factor = 1000.00 !m->mm

  curve1%hist%density_normalized = T
  curve1%hist%weight_by_charge = T
  curve1%hist%number = 100
  curve1%line%color = 'blue'
  curve1%line%pattern = 'dashed'
  curve1%y_axis_scale_factor = 299792458  !Q/m * c_light
  curve1%data_type = 'z' 
  curve1%data_source = 'beam_tracking'
  curve1%ele_ref_name = "BEGINNING"
  curve1%symbol%type = 'dot'
/
\end{example}

\begin{figure}
  \centering
  \includegraphics[width=5in]{histogram.pdf}
  \caption{Example histogram plot.}
  \label{f:histogram}
\end{figure}

For a \vn{"histogram"} type graph, \vn{curve%data_type} determines
what coordinate is plotted along the x-axis.
Valid \vn{curve%data_type} values are:
\index{x}\index{px}\index{y}\index{py}\index{z}\index{pz}
\begin{example}
  "x"
  "px"
  "y"
  "py"
  "z"
  "pz"
  "intensity"       -- Photon total intensity 
  "intensity_x"     -- Photon intensity along x-axis 
  "intensity_y"     -- Photon intensity along y-axis
  "phase_x"         -- Photon phase along x-axis
  "phase_y"         -- Photon phase along y-axis
\end{example}
In this example above, the $x$-axis of the plot will correspond to the
$z$ phase space coordinate.

The maximum and minimum of the bins is set automatically to fit the data.
The \vn{curve%hist%number} establishes the number of bins. Alternatively, 
if \vn{curve%hist%number = 0}, then \vn{curve%hist%width}  establishes
 the width of the histogram bins and sets the number automatically. 

If \vn{curve%hist%density_normalized = T}, then the height of a bin will be
divided by its width. If \vn{curve%hist%weight_by_charge = T}, then the particle
charge will be used to bin, otherwise the particle count will be used to bin.

The \vn{curve%hist%center} will insure that a bin will be centered at this location.

\index{curve!ele_ref_name}
To change the place in the lattice where the data for the
\vn{histogram} is evaluated, use the \vn{set curve ele_ref_name}
command.

If \vn{graph%type} is \vn{"histogram"} then \vn{curve%data_source} 
must be either:
\begin{example}
  "beam"
  "multi_turn_orbit"
\end{example} 
\vn{"beam"} indicates that the points of the histogram plot
will be obtained correspond to the positions of the particles within a
tracked beam. \vn{multi_turn_orbit"} is used for rings where a single
particle is tracked multiple turns and the position of this particle
is recorded each turn. In this case, a \vn{d2_data} structure must
have been set up to hold the turn--by--turn orbit. This \vn{d2_data}
structure must be called \vn{multi_turn_orbit} and must have
\vn{d1_data} data arrays for the histogram planes to be plotted. For
example, if the histogram plot is \vn{x} versus \vn{px}, then there
must be \vn{d1_data} arrays named \vn{"x"} and \vn{"px"}. The number
of turns is determined by the setting of \vn{ix_max_data} in the
\vn{tao_d1_data} namelist (\sref{s:init.data}).

%-----------------------------------------------------------------
\subsection{Drawing the Beam Chamber Wall}
\index{beam chamber wall}
\label{s:beam.wall.draw}

If a beam chamber wall has been defined in the lattice file, This wall
can be drawn in a \vn{curve} by setting \vn{curve%type} to
\vn{"beam_chamber_wall"}.

Beam chamber walls are drawn, like a \vn{lat_layout}, on a one
dimensional line as a function of longitudinal position along the
machine centerline.

Note: Use the command \vn{show ele -wall} to print information about the
beam chamber wall for a particular element.

%-----------------------------------------------------------------
\subsection{Drawing a Key Table}
\index{key table}
\label{s:key.table}

The \vn{key table} is explained more fully in
Section~\sref{s:key.bind}.  An example is shown in
Figure~\ref{f:layout.table}. A template to create a key table looks
like:
\begin{example}
  &tao_template_plot
    plot%name = "table" 
    plot%n_graph = 1
  /

  &tao_template_graph
    graph%type = "key_table" 
    graph_index = 1
    graph%n_curve = 0
  /
\end{example}

The number in the upper left corner, to the left of the first column, 
(\vn{1} in Fig.~\ref{f:layout.table})
shows the active \vn{key bank}. The columns in the Key Table are:
\begin{example}
  Ix         ! Key index.
  Name       ! Element name whose attribute is bound.
  Attrib     ! Name of the element attribute that is bound.
  Value      ! Current value of bound attribute.
  Value0     ! Initial value of bound attribute.
  Delta      ! Change in value when the appropriate key is pressed.
  Uni        ! Universe that contains the element.
  Opt        ! Shows if bound attribute is used in an optimization.
\end{example}

Note that in a \vn{Lattice Layout}, if a displayed element has a bound
attribute, then the key index number will be displayed just above the
element's glyph.

The \vn{key_table} is drawn with respect to the upper left hand corner
of the region in which it is placed.

%-----------------------------------------------------------------
\subsection{Phase Space Plotting}
\index{phase space plotting}
\label{s:phase.space}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{plot-color-xpx}
    \caption{Horizontal phase space}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{plot-color-zpz}
    \caption{Longitudinal phase space}
  \end{subfigure}  
  \caption{Example Phase Space plot, with points colored by the \vn{pz} coordinate.}
  \label{f:phase.space}
\end{figure}

A \vn{phase space} plot displays a particle or particles phase space
coordinates at a given location. Phase space plotting is associated
with a \vn{graph} by setting \vn{graph%type} equal to
\vn{"phase_space"}. The concepts here are similar to data plotting
(\sref{s:plot.data}). An example is show in Figure~\ref{f:phase.space}.
Example Phase Space template:
\begin{example}
&tao_template_plot
  plot%name = "xphase"
  plot%x%min =   -2.5
  plot%x%max = 0.5
  plot%x%label = "x (mm)"
  plot%n_graph = 1
/

&tao_template_graph
  graph_index = 1
  graph%name = "x"
  graph%type = "phase_space"
  graph%box = 1, 1, 1, 1
  graph%title = "X-Px"
  graph%margin =  0.15, 0.06, 0.12, 0.12, "%BOX"
  graph%x_axis_scale_factor = 1000.00 !m->mm
  graph%y%label =  "p\textbackslash{}dx\textbackslash{}u/p\textbackslash{}d0\textbackslash{}u (mrad)"
  graph%y%major_div = 4
  graph%n_curve = 1
  graph%y%label_offset=.4
  curve(1)%data_type = "x-px" 
  curve(1)%y_axis_scale_factor = 1000 !rad->mrad
  curve(1)%data_source = "beam_tracking"
  curve(1)%ele_ref_name = "END"
  curve(1)%symbol%type = 1
  curve(1)%data_type_z = "pz"
  curve(1)%use_z_color = T
  /
\end{example}

For a \vn{"phase_space"} type graph, \vn{curve%data_type_x} determines
what phase space coordinate is plotted along the x-axis and
\vn{curve%data_type} determines what phase space coordinate is plotted
along the y-axis. The phase space coordinates are:
\index{x}\index{px}\index{y}\index{py}\index{z}\index{pz}
\begin{example}
  "x"
  "px"
  "y"
  "py"
  "z"
  "pz"
  "intensity"       -- Photon total intensity 
  "intensity_x"     -- Photon intensity along x-axis 
  "intensity_y"     -- Photon intensity along y-axis
  "phase_x"         -- Photon phase along x-axis
  "phase_y"         -- Photon phase along y-axis
\end{example}
In this example above, the $x$-axis of the plot will correspond to the
$z$ phase space coordinate and the $pz$-axis will correspond to the
$px$ coordinate.

\index{curve!ele_ref_name}
To change the place in the lattice where the data for the
\vn{phase_space} curve is evaluated, use the \vn{set curve
ele_ref_name} command.

Points can be colored by another phase space coordinate by activating
\vn{use_z_color = T}. 
The available curve options and defaults are:
\begin{example}
  use_z_color = F
  data_type_z = "" 
  z_color0 = 0
  z_color1 = 0
  autoscale_z_color = T
\end{example}
These can be the init file, or in Tao using the \vn{set curve} command. 
The \vn{data_type_z} can be set to any of the available phase space coordinates.
\vn{z_color0} and \vn{z_color1} specify the minimum and maximum of this coordinate
to be used in the color range. Values above or below this range will be colored
Black or Grey, respectively. 
If \vn{autoscale_z_color=T}, then these will be set automatically based on the
limits of the \vn{data_type_z} coordinate. 

If \vn{graph%type} is \vn{"phase_space"} then \vn{curve%data_source} 
must be either:
\begin{example}
  "beam"
  "multi_turn_orbit"
  "twiss"
\end{example} 
\vn{"beam"} indicates that the points of the phase space plot
will be obtained correspond to the positions of the particles within a
tracked beam. \vn{multi_turn_orbit"} is used for rings where a single
particle is tracked multiple turns and the position of this particle
is recorded each turn. In this case, a \vn{d2_data} structure must
have been set up to hold the turn--by--turn orbit. This \vn{d2_data}
structure must be called \vn{multi_turn_orbit} and must have
\vn{d1_data} data arrays for the phase space planes to be plotted. For
example, if the phase space plot is \vn{x} versus \vn{px}, then there
must be \vn{d1_data} arrays named \vn{"x"} and \vn{"px"}. The number
of turns is determined by the setting of \vn{ix_max_data} in the
\vn{tao_d1_data} namelist (\sref{s:init.data}). Using \vn{"twiss"} as
the \vn{curve%data_source} indicates that the phase space plot will be
an ellipse whose shape is based upon the Twiss and coupling
parameters, and the normal mode emittances. If the normal mode
emittances have not been computed then a nominal value of 1e-6~m-rad
is used.


%-----------------------------------------------------------------
\subsection{QuickPlot Plotting}
\label{s:line.symb}

\vn{QuickPLot} is an interface library developed for \bmad for graphics plotting. QuickPlot uses
the following concepts:
\begin{example}
  PAGE  -- The entire drawing surface.
  BOX   -- The area that the graph with axes, titles, etc. is placed into.
  GRAPH -- The actual plotting area within the bounds of the axes.
\end{example}

For text that has an associated \vn{justify} parameter, the \vn{justify} parameter is a two
character string.  The first character gives the horizontal justification:
\begin{example}
   'L' -- Left justify
   'C' -- Center justify
   'R' -- Right justify
\end{example}
The second character gives the vertical justification
\begin{example}
   'B' -- Bottom justify
   'C' -- Center justify
   'T' -- Top justify
\end{example}

For text that has an associated \vn{units} parameter, the \vn{units} parameter is a character string
which is divided up into three parts. The syntax of the \vn{units} parameter is:
\begin{example}
   'unit_type/ref_object/corner'
\end{example}
Where \vn{unit_type} is the type of units:
\begin{example}
   '%'       - Percent.
   'DATA'    - Data units.
   'MM'      - millimeters.
   'INCH'    - Inches.
   'POINTS'  - Printers points (72 points = 1 inch, 1pt ~ 1pixel).
\end{example}
\vn{ref_object} is a reference object (optional except if \vn{unit_type} = "\%").
\begin{example}
   'PAGE'  -- Relative to the page.
   'BOX'   -- Relative to the box.
   'GRAPH' -- Relative to the graph.
\end{example}
And \vn{corner} is the origin location (optional):
\begin{example}
   'LB' -- Left Bottom.
   'LT' -- Left Top.
   'RB' -- Right Bottom.
   'RT' -- Right Top.
\end{example}

\vn{QuickPlot} defines a number of structures to parameterize such things like line and symbol
properties. The structures that \tao uses are as follows.

The \vn{qp_axis_struct} structure defines the properties of a graph axis
\begin{example}
  type qp_axis_struct
    label             = <string>   ! Axis label string.
    min               = <real>     ! Min is the left or bottom axis number.
    max               = <real>     ! Max is the right or top axis number.
    number_offset     = <real>     ! Offset from axis line in inches.
    label_offset      = <real>     ! Offset from numbers in inches.
    major_tick_len    = <real>     ! Major tick length in inches.
    minor_tick_len    = <real>     ! Minor tick length in inches.
    label_color       = <string>   ! Color of the label string
    major_div         = <integer>  ! Number of major divisions
    major_div_nominal = <integer>  ! Major divisions nominal value.
    minor_div         = <integer>  ! Minor divisions. 0 = Tao will choose.
    minor_div_max     = <integer>  ! Max minor div number if Tao chooses.
    places            = <integer>  ! Number of digits to print
    type              = <string>   ! Axis type: 'LINEAR' or 'LOG'.
    bounds            = <string>   ! Axis bounds: 'GENERAL', 'ZERO_AT_END' or 'ZERO_SYMMETRIC'
    tick_side         = <integer>  ! 1 = draw to the inside, 0 = both, -1 = outside.
    number_side       = <integer>  ! 1 = draw to the inside, -1 = outside.
    draw_label        = <logical>  ! Draw the label string
    draw_numbers      = <logical>  ! Draw the numbers.
  end type
\end{example}

\begin{table}
\begin{tabular}{ll} \toprule
{\B}u       & Start a superscript or end a subscript \\[0.3ex]
{\B}d       & Start a subscript or end a superscript.
              {\B}u and {\B}d must always be used in pairs \\[0.3ex]
{\B}b       & Backspace (i.e., do not advance text pointer  
               after plotting the previous character) \\[0.3ex]
{\B}fn      & Switch to Normal font (1)       \\[0.3ex]
{\B}fr      & Switch to Roman font (2)        \\[0.3ex]
{\B}fi      & Switch to Italic font (3)       \\[0.3ex]
{\B}fs      & Switch to Script font (4)       \\[0.3ex]
{\B}{\B}    & Backslash character (\B)        \\[0.3ex]
{\B}x       & Multiplication sign ($\times$)  \\[0.3ex]
{\B}.       & Centered dot ($\cdot$)          \\[0.3ex]
{\B}A       & Angstrom symbol (\AA)         \\[0.3ex]
{\B}gx      & Greek letter corresponding to roman letter x. See Table~\ref{t:greek}. \\[0.3ex]
{\B}mN {\B}mNN & Graph marker number \vn{N} or \vn{NN} (1-31) \\[1ex]
{\B}(NNNN)  & 
\parbox{5.2in} {Character number NNNN (1 to 4 decimal digits) from the Hershey character set which
includes a number of special characters including mathematical, musical, astronomical, and
cartographical symbols.} \\ \bottomrule
\end{tabular}
\caption{Escape Sequences for Labels.}
\label{t:plot.escape}
\end{table}

The \vn{major_div} parameter is not settable directly. Rather, \vn{major_div_nominal} may be set by
the user and then \tao will calculate the value of \vn{major_div} such that the value of
\vn{major_div} is ``close'' to the value of \vn{major_div_nominal} with the constraint that the value
of \vn{major_div} ``nicely'' divides the range from given by the values for \vn{min} and \vn{max}.

The \vn{places} parameter set the number of places to display a number. \tao will automatically
calculate this number and it is not user settable.

The \vn{label} parameter may include Greek letters, subscripts, superscripts, and special characters.
Encoding for these are given in Table~\ref{t:plot.escape}. 

The \vn{label_color} parameter sets the color of the label string. Possible settings for the color are:
\begin{example}
  White   (actually the background color)       Orange          
  Black   (actually the foreground color)       Yellow_Green    
  Red                                           Light_Green         
  Green                                         Navy_Blue       
  Blue                                          Purple          
  Cyan                                          Reddish_Purple  
  Magenta                                       Dark_Grey        
  Yellow                                        Light_Grey       
\end{example}
Color names are case insensitive.

Table~\ref{t:greek} shows how the character string \vn{"{\B}g<r>"}, where \vn{"<r>"} 
is a Roman letter, map onto the Greek character set.
\begin{table}
  \centering
  \includegraphics[width=5.0in]{greek.pdf}
  \caption[Roman to Greek Character Conversion]{Conversion for the string 
\vn{"{\B}g<r>"} where \vn{"<r>"} is a Roman character to the corresponding 
Greek character.}
\label{t:greek}
\end{table}

The parameters associated with data lines drawn in a graph are contained in the \vn{qp_line_struct}:
\begin{example}
  type qp_line_struct
    width          = <integer>  ! Default = 1
    color          = <string>   ! Default = 'black'
    pattern        = <string>   ! Default = 'solid'
  end type
\end{example}

The possible colors for a line are given above. The \vn{pattern} parameter sets how the line is
drawn. Possible settings are:
\begin{example}
  solid      ! Solid line                 dotted     ! Dotted line             
  dashed     ! Dashed line                dash_dot3  ! Dash--dot--dot--dot line
  dash_dot   ! Dash--dot line
\end{example}
Pattern names are case insensitive.

The parameters associated with symbols that are drawn are contained in the \vn{qp_symbol_struct}:
\begin{example}
  type qp_symbol_struct
    type          = <string>  ! Default = 'dot'
    height        = <real>    ! Size in points. Default = 10
    color         = <string>  ! Default = 'black'
    fill_pattern  = <string>  ! Default = 'solid_fill'
    line_width    = <integer> ! Default = 1.
  end type
\end{example}

Possible \vn{fill_pattern} settings are:
\begin{example}
  solid_fill                    hatched           
  no_fill                       cross_hatched     
\end{example}
Fill pattern names are case insensitive.

The symbol types are:
\begin{example}
  square                 triangle                    square_concave              
  dot                    circle_plus                 diamond                     
  plus                   circle_dot                  star5                       
  times                  square_filled               triangle_filled           
  circle                 circle_filled               red_cross                 
  x                      star5_filled                star_of_david             
\end{example}
These symbols are illustrated in Table~\ref{t:plot.syms}. Symbol type names are case insensitive.

\begin{table}
  \centering
  \includegraphics[width=5in]{plot-syms.pdf}
  \caption{Plotting Symbols.}
  \label{t:plot.syms}
\end{table}
