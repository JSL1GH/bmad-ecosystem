\chapter{Etienne Forest's PTC/FPP}
\label{c:ptc}
\index{PTC/FPP}
%----------------------------------------------------------------------------

Etienne Forest\cite{b:forest} has written what is actually two
software libraries: FPP and PTC.  FPP stands for ``Fully Polymorphic
Package.'' What this library does is implement Taylor maps (aka
Truncated Power Series Algebra or TPSA) and Lie algebraic
operations. Thus in FPP you can define a Hamiltonian and then generate
the Taylor map for this Hamiltonian. FPP is very general. It can work
with an arbitrary number of dimensions.  FPP, however, is a purely
mathematical package in the sense that it knows nothing about
accelerator physics. That is, it does not know about bends,
quadrupoles or any other kind of element, it has no conception of a
lattice (a string of elements), it doesn't know anything about Twiss
parameters, etc. This is where PTC (Polymorphic Tracking Code) comes
in PTC. PTC implements the high energy physics stuff and uses FPP as
the engine to do the Lie algebraic calculations.  For the purposes of
this discussion, PTC and FPP are considered one package and the
combined PTC/FPP will be referred to as simply ``PTC''.

%--------------------------------------------------------------------------

\begin{figure}
  \centering
  \includegraphics{ptc-structures.pdf}
  \caption[PTC structure relationships] { 
Simplified diagram showing the organization of the major PTC
structures involved in defining a lattice contrasted with \Bmad. With
PTC, The top level structure is an array of \vn{layout_array}
structures. Each \vn{layout_array} holds a \vn{layout} structure. A
\vn{layout} structure has pointers to the previous and next
\vn{layout}s making a linked list of \vn{layout}s indicated by the
horizontal arrows. Each layout has pointers to a linked list of
\vn{fibre} structures. The \vn{fibre} structures represent the
reference trajectory through an element. Each \vn{fibre} structure has
a pointer to a \vn{element} and an \vn{elementp} structures which
represent the physical element. With \bmad, the \vn{lat_struct}
roughly corresponds to the PTC \vn{layout_array(:)}, the
\vn{branch_struct} roughly corresponds to the PTC \vn{layout} and the
\vn{element_struct} roughly corresponds to the PTC \vn{fibre},
\vn{element} and \vn{elementp} structures.

%--------------------------------------------------------------------------
\section{Accessing PTC}
\label{s:ptc.structures}

\bmad uses a \vn{lat_struct} structure to hold the information on a
machine and a \vn{lat_struct} has an array of \vn{branch_struct}s with
each \vn{branch_struct} holding an array of \vn{ele_struct}s. The
\vn{ele_struct} holds the information on the individual elements. An
\vn{ele_struct} holds information about both the physical element and
the reference orbit through it.

PTC has a somewhat different philosopy as illustrated in . A PTC \vn{layout} structure is
roughly equivalent to a \bmad \vn{branch_struct}. A \vn{layout} has a
pointer to a linked list of \vn{fibre} structures. Each \vn{fibre} has
a pointer to a \vn{magnet} structure which holds the information about
the physical element and each \vn{fibre} holds information about the
reference orbit through the element.

separates the actual uses
a \vn{layout} structure

%--------------------------------------------------------------------------
\section{Accessing PTC}
\label{s:ptc.access}

\index{PTC!single element mode}
\bmad uses PTC in two ways: One way, called ``single element'' mode,
uses PTC on a per element basis. Single element mode is used whenever
the tracking method (\sref{c:tracking}) of a given element is set to a
tracking method that uses PTC. The advantage of single element mode is
that it is quite flexible in that different tracking methods,
including non-PTC methods, can be assigned to different element. The
drawback of single element mode is that PTC's powerful analysis tools,
which rely on the entire lattice being tracked via PTC, cannot be used
in this case. Such tools include normal form analysis beam envelope
tracking, etc.

\index{PTC!whole lattice mode}
The alternative to single element mode is ``whole lattice'' mode where
a PTC \vn{layout} is created from a Bmad lattice. The routine
\zzz{lat_to_ptc_layout} creates a PTC layout from a \bmad lattice.

%--------------------------------------------------------------------------
\section{Phase Space}
\label{s:etienne.space}
\index{PTC/FPP!phase space}

PTC uses different longitudinal phase space coordinates compared to \bmad.
\bmad's phase space coordinates are (\sref{s:phase.space})
\Begineq
  (x, p_x, y, p_y, z, p_z)
\Endeq
In PTC one can choose between several different coordinate systems. The one
that Bmad uses is 
\Begineq
  (x, p_x, y, p_y, p_t, c \Delta t)
\Endeq
where
\Begineq
  p_t = \frac{\Delta E}{P_0}
\Endeq
This choice of phase space is set in \Hyperref{r:set.ptc}{set_ptc}.  Specificially,
the PTC global variable \vn{DEFAULT}, which is of type
\vn{internal_states}, has the \vn{%time} switch set to \vn{True}.

\vn{vec_bmad_to_ptc} and \vn{vec_ptc_to_bmad} are conversion routines
that translate between the two. Actually there are a number of
conversion routines that translate between \bmad and PTC
structures. See \sref{r:ptc} for more details.

%--------------------------------------------------------------------------
\section{Initialization}
\label{s:etienne.init}
\index{PTC/FPP!initialization}

One important parameter in PTC is the order of the Taylor maps.
By default \bmad will set this to 3. The order can be set within
a lattice file using the \vn{parameter[taylor_order]} attribute.
In a program the order can be set using \vn{set_ptc}. In fact
\vn{set_ptc} must be called by a program before PTC can be used.
\vn{bmad_parser} will do this when reading in a lattice file.
That is, if a program does not use \vn{bmad_parser} then to use PTC it
must call \vn{set_ptc}. Note that resetting PTC to a different order
reinitializes PTC's internal memory so one must be careful if one wants
to change the order in mid program.

%--------------------------------------------------------------------------
\section{Correspondence between Bmad elements and PTC fibres}.
\label{s:ele.fib}
\index{fibre}

When a PTC \vn{layout} is created from a \bmad \vn{lat_struct}
instance using the routine \Hyperref{r:lat.to.ptc.layout}{lat_to_ptc_layout}, the correspondence
between the \bmad elements and the PTC fibres is maintained through
the \vn{ele%ptc_fiber} pointer. The following rules apply:
  \begin{enumerate}
  \item There will be marker \vn{fibre}s at the beginning and end 
of the \vn{layout}. The beginning \vn{fibre} will correspond to
\vn{branch%ele(0)}. The end \vn{fibre} will not have a corresponding
\bmad element.
  \item Generally there will be a one-to-one correspondence between
\vn{fibre}s and \vn{branch%ele} elements. The exception is where a
``hard edge'' model is used for tracking. In this case, there will be
three \vn{fibre}s for the \bmad element: Two drift \vn{fibre}s with a
\vn{fibre} of the appropriate type inbetween.  In this case,
\vn{ele%ptc_fiber} will point to the last (drift) \vn{fibre}.
  \end{enumerate}

Remember: The attributes like reference energy, etc. for a \bmad
\vn{ele_struct} instance are referenced to the exit end of the
element. For PTC the reference edge for a \vn{fibre} is the entrance
end.

%--------------------------------------------------------------------------
\section{Taylor Maps}
\label{s:etienne.taylor}
\index{PTC/FPP!Taylor Maps}

\index{PTC/FPP!real_8}\index{PTC/FPP!universal_taylor}
FPP stores its \vn{real_8} Taylor maps in such a way that it is not
easy to access them directly to look at the particular terms. To
simplify life, Etienne has implemented the
\vn{universal_taylor}structure:
\begin{example}
  type universal_taylor
    integer, pointer  :: n       ! Number of coefficients
    integer, pointer  :: nv      ! Number of variables
    real(dp), pointer :: c(:)    ! Coefficients C(N)
    integer, pointer  :: j(:,:)  ! Exponents of each coefficients J(N,NV)
  end type
\end{example}
\bmad always sets \vn{nv} = 6. \bmad overloads the equal sign to call 
routines to convert between Etienne's
\vn{real_8} Taylor maps and \vn{universal_taylor}:
\begin{example}
  type (real_8) tlr(6)           ! Taylor map
  type (universal_taylor) ut(6)  ! Taylor map
  ...
  tlr = ut                       ! Convert universal_taylor -> real_8
  ut = tlr                       ! Convert real_8 -> universal_taylor
\end{example}
