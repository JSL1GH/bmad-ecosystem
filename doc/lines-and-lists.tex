\chapter{Beam Lines, Replacement Lists, and Branching}
\label{c:sequence}

%-----------------------------------------------------------------------------
\section{Use Statement}
\label{s:use}

\index{MAD}
\index{use statement|hyperbf}
\index{lattice}
To \bmad, a ``lattice''\index{lattice} is the sequence of physical
elements that is to be studied. The lattice is constructed in the
input lattice file using what are know as Beam Lines and Replacement
Lists. Beam Lines are further subdivided into Lines with and without
replacement arguments. This essentially corresponds to the \mad
definition of Lines and Lists. There can be multiple Beam Lines and
Replacement Lists defined in a lattice file and Lines and Lists can be
nested inside other Lines and Lists. The particular Line that defines
the lattice to be analyzed by \bmad is selected by the \vn{use}
statement. For example
\begin{example}
  use, my_line
\end{example}
would pick the Line \vn{my_line} for analysis. If there are multiple \vn{use}
statements in a lattice file, the last \vn{use} statement defines which
\vn{line} to use.

\index{beginning element}
\bmad associates a number with each element staring at 1 for the first
element in the lattice, 2 for the second element, etc. Additionally,
\bmad always automatically creates a 0\Th element to mark the
beginning of the lattice. The name of this element is always \vn{BEGINNING}.

%-----------------------------------------------------------------------------
\section{Beam Lines without Arguments}
\label{s:lines.wo.arg}
\index{line|hyperbf}

A Beam Line without arguments has the format
\begin{example}
  label: line = (member1, member2, ...)
\end{example}
where \vn{member1}, \vn{member2}, etc. are either elements, other Beam
Lines or Replacement Lists, or sublines enclosed in parentheses.
Example:
\begin{example}
  line1: line = (a, b, c)
  line2: line = (d, line1, e)
  use, line2
\end{example}
This example shows how an Line member can refer to another Beam Line.
This is helpful if the same sequence of elements appears repeatedly in
the lattice. When \vn{line2} is expanded to form the lattice the
definition of \vn{line1} will be inserted in to produce the following
lattice for analysis
\begin{example}
  (d, a, b, c, e)
\end{example}
Note: In the expanded lattice, any \vn{Null_Ele} type elements
(\sref{s:null.ele}) will be discarded. For example, if element \vn{b}
in the above example is a \vn{Null_Ele} then the actual expanded
lattice will be:
\begin{example}
  (d, a, c, e)
\end{example}

A member that is a Line or List can be reflected 
(elements taken in reverse order) if
a negative sign is put in front of it. For example:
\begin{example}
  line1: line = (a, b, c)
  line2: line = (d, -line1, e)
\end{example}
\vn{line2} when expanded gives
\begin{example}
  (d, c, b, a, e)
\end{example}
Reflecting a subline will also reflect any sublines of the subline. For
example:
\begin{example}
  line0: line = (y, z)
  line1: line = (line0, b, c)
  line2: line = (d, -line1, e)
\end{example}
\vn{line2} when expanded gives
\begin{example}
  (d, c, b, z, y, e)
\end{example}

A repetition count, which is an integer followed by an asterisk, 
means that the member is
repeated. For example
\begin{example}
  line1: line = (a, b, c)
  line2: line = (d, 2*line1, e)
\end{example}
\vn{line2} when expanded gives
\begin{example}
  (d, a, b, c, a, b, c, e)
\end{example}
Repetition count can be combined with reflection. For example
\begin{example}
  line1: line = (a, b, c)
  line2: line = (d, -2*line1, e)
\end{example}
\vn{line2} when expanded gives
\begin{example}
  (d, c, b, a, c, b, a, e)
\end{example}
Instead of the name of a line, subline members can also be given as an explicit 
list using parentheses. For example, the previous example could be rewritten as
\begin{example}
  line2: line = (d, -2*(a, b, c), e)
\end{example}

A line can have the \vn{multipass} attribute. This is covered in
\sref{s:multipass}.

%-----------------------------------------------------------------------------
\section{Beam Lines with Replaceable Arguments}
\index{line!with arguments}

Beam lines can have an argument list using the following syntax
\begin{example}
  line_name(dummy_arg1, dummy_arg2, ...): LINE = (member1, member2, ...)
\end{example}
The dummy arguments are replaced by the actual arguments when the Line is used
elsewhere. For example:
\begin{example}
  line1(DA1, DA2): line = (a, DA2, b, DA1)
  line2: line = (h, line1(y, z), g)
\end{example}
When \vn{line2} is expanded the actual arguments of \vn{line1}, in this
case \vn(y, z), replaces the dummy arguments \vn{(DA1, DA2)} to give for
\vn{line2}
\begin{example}
  h, a, z, b, y, g
\end{example} 
\index{MAD}
Unlike \mad, Beam Line actual arguments can only be elements or Beam Lines. 
Thus the following is not allowed
\begin{example}
  line2: line = (h, line1(2*y, z), g)   ! NO: 2*y NOT allowed as an argument.
\end{example}

%-----------------------------------------------------------------------------
\section{Replacement Lists}
\index{list|hyperbf}

When a lattice is expanded, all the lattice members that correspond to a 
name of a Replacement List 
are replaced successively, by the members
in the Replacement List. The general syntax is
\begin{example}
  label: LIST = (member1, member2, ...)
\end{example}
For example:
\begin{example}
  list1: list = (a, b, c)
  line1: line = (z1, list1, z2, list1, z3, list1, z4, list1)
  use, line1
\end{example}
When the lattice is expanded the first instance of \vn{list1} in
\vn{line1} is replaced by \vn{a} (which is the first element of
\vn{list1}), the second instance of \vn{list1} is replaced by \vn{b},
etc. If there are more instances of \vn{list1} in the lattice then
members of \vn{list1}, the replacement starts at the beginning of
\vn{list1} after the last member of \vn{list1} is used. In this case the
lattice would be:
\begin{example}
  z1, a, z2, b, z3, c, z4, a
\end{example}
\index{MAD}
Unlike \mad members of a replacement list can only be simple elements 
without reflection or repetition count and not other Lines or Lists. 
For example the following is not allowed:
\begin{example}
  list1: list = (2*a, b)  ! NO: No repetition count allowed.
\end{example}

%-----------------------------------------------------------------------------
\section{Line and List Tags}
\index{tags for Lines and Lists|hyperbf}
\label{s:tag}

When a lattice has repeating lines, it can be desirable to differentiate
between repeated elements. This can be done by tagging lines with a \vn{tag}. 
An example will make this clear:
\begin{example}
  line1: line = (a, b)
  line2: line = (line1, line1)
  use, line2
\end{example}
When expanded the lattice would be:
\begin{example}
  a, b, a, b
\end{example}
The first and third elements have the same name ``a'' and the second and fourth
elements have the same name ``b''. Using tags the lattice elements can be given
unique names. lines or lists are tagged  
using brackets \vn{[...]}. The general syntax is:
\begin{example}
  line_name[tag_name]                           ! Syntax for lines
  list_name[tag_name]                           ! Syntax for lists
  replacement_line[tag_name](arg1, arg2, ...)   ! Syntax for replacement lines.
\end{example}
Thus to differentiate the lattice elements in the above example \vn{line2} needs to
be modified using tags:
\begin{example}
  line1: line = (a, b)
  line2: line = (line1[t1], line1[t2])
  use, line2
\end{example}
In this case the lattice elements will have names of the form:
\begin{example}
  tag_name.element_name
\end{example}
In this particular example, the lattice with tagging will be:
\begin{example}
  t1.a, t1.b, t2.a, t2.b
\end{example}
Of course with this simple example one could have just as easily not used tags:
\begin{example}
  t1.a: a;   t2.a: a
  t1.b: b;   t2.b: b
  line1: line = (t1.a, t1.b, t2.a, t2.b)
  use, line2
\end{example}
But in more complicated situations tagging can make for compact lattice files.

When lines are nested, the name of an element is formed by concatenating the tags
together with dots in between in the form:
\begin{example}
  tag_name1.tag_name2. ... tag_name_n.element_name
\end{example}
An example will make this clear:
\begin{example}
  list1 = (g, h)
  line1(y, z) = (a, b)
  line2: line = (line1[t1](a, b))
  line3: line = (line2, list1[hh])
  line4: line = (line3[z1], line3[z2])
  use, line4
\end{example}
The lattice elements in this case are:
\begin{example}
  z1.t1.a, z1.t1.b, z1.hh.g, z2.t1.a, z2.t1.b, z1.hh.h 
\end{example}

\index{expand_lattice}
To modify a particular tagged element the lattice must be expanded
first (\sref{s:expand}). For example:
\begin{example}
  line1: line = (a, b)
  line2: line = (line1[t1], line1[t2])
  use, line2
  expand_lattice
  t1.b[k1] = 1.37
  b[k1] = 0.63       ! This statement does not have any effect
\end{example}
After the lattice has been expanded there is no connection between 
the original \vn{a} and \vn{b} elements and the elements in the lattice like
\vn{t1.b}. Thus the last line in the example where the \vn{k1} attribute of\vn{b} 
is modified do not have any effect on the lattice elements. 

%-----------------------------------------------------------------------------
\section{Branching}
\index{branching}\index{photon_branch}\index{branch}
\label{s:branching}

The ``root'' lattice (also called the ``root branch'') is defined by
the \vn{use} (\sref{s:use}) statement. To defined such things as dump
lines, x-ray beam lines, transfer lines, etc., that branch off from
the root lattice can be defined in \bmad. The place in the lattice
where a branch line starts is defined by using a \vn{branch} or
\vn{photon_branch} element (collectively they can be called branching elements).
\vn{Branch} elements can define where the particle beam
can branch off, say to a beam dump. \vn{photon_branch} elements can
define the source point for X-ray beams.  Example:
\begin{example}
  erl: line = (..., dump, ...)               ! Define the root lattice with a branch 
  use, erl
  dump: branch, to = d_line, direction = -1  ! Define the branch point

  d_line: line = (..., q3d, ...)             ! Define the branch line
\end{example}
The difference between a \vn{branch} element and a \vn{photon_branch}
element is that for a \vn{branch} element the default particle for the
branch is the same as the line that the branch branches off from. The
default particle of the branch from a \vn{photon_branch} element is a
\vn{photon}. The actual particle associated with a branch can be set
by setting the \vn{particle} attribute of the branching element
(\sref{s:branch}).

\index{patch}
Branch lines can themselves have branching elements. A branch line always
starts out tangential to the line it is branching from. The
\vn{direction} attribute of the branch element indicates whether the
branch line is outgoing in the forward direction (direction = +1) or
incoming (direction = -1). A \vn{patch} element (\sref{s:patch}) can
be used at the beginning of a branch line to reorient the reference
orbit as needed.

Like the root lattice, \bmad always automatically creates a zeroth
element at the beginning of each branch called \vn{BEGINNING}. The
longitudinal \vn{s} position of an element in a branch is determined
by the distance from the beginning of the branch.

\index{root_branch_name}
Branches are named after the branching element name. In the above
example, the branch line would be named \vn{DUMP}. The root lattice,
by default, is called \vn{ROOT}. This default name for the root branch
can be changed using the \vn{parameter[root_branch_name]} parameter
(\sref{s:param}).

For branch lines (\sref{s:branching}), the full ``branch
qualified'' name of an element is of the form
\begin{example}
  branch_name>>element_name
\end{example}
where \vn{branch_name} is the name of the branch and \vn{element_name} is the
``regular'' name of the element. Example:
\begin{example}
  root>>q10w
  xline>>cryst3
\end{example}
Using the full name is only needed to distinguish elements that have
the same regular name in separate branches.  When parsing a lattice
file, branches are not formed until the lattice is expanded
(\sref{s:expand}). Therefore an \vn{expand_lattice} statement is
required before full names can be used in statements.

Branch parameters, like whether the branch is open
(``linear_lattice'') or closed (``circular_lattice''), can be set
by setting the appropriate attribute of the branching element
see \sref{s:branch} for more details.
