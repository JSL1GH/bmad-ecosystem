\chapter{Twiss Parameters, Tunes, Chromaticity, Etc.}
\label{c:twiss}

%-----------------------------------------------------------------------------
\section{Twiss Parameter Calculations}
\label{s:twiss}
\index{twiss parameters}
\index{twiss parameters!calculation}

The Twiss parameters for an element are stored in the
\vn{ele_struct}. See Chapter~\ref{c:ele.struct} for more details.

Before any Twiss parameters can be calculated the transfer matrices
stored in the lattice elements must be computed. \vnr{bmad_parser} does
this automatically about the zero orbit. If, to see nonlinear effects,
a different orbit needs to be used for the reference, The routine
\vnr{lat_make_mat6} can be used. For example
\begin{example}
  type (lat_struct) lat
  type (coord_struct), allocatable :: orbit(:)
  call bmad_parser ('my_lattice', lat)
  call closed_orbit_calc (lat, orbit, 4)
  call lat_make_mat6 (lat, -1, orbit)
\end{example}
This example reads in a lattice, finds the closed orbit which may be
non--zero due to, say, kicks due to a separator, and then remakes the
transfer matrices (which are stored in \vn{lat%ele(i)%mat6} around
the closed orbit.

Once the transfer matrices are calculated the Twiss parameters at the
start of the lattice need to be defined. The Twiss parameters at the
start are in \vn{lat%ele(0)}. If the lattice is open then generally
the Twiss parameters are set in the lattice file or may easily be set
in a program. For example
\begin{example}
  lat%ele(0)%x%beta = 1.2
  lat%ele(0)%x%alpha = 0.1
  lat%ele(0)%x%gamma = (1 + lat%ele(0)%x%alpha**2) / lat%ele(0)%beta
  lat%ele(0)%x%eta  = 0
\end{example}
Note that \vn{%beta}, \vn{%alpha}, and \vn{%gamma} all must be specified.

If the lattice is closed then \vnr{twiss_at_start} may be used to
calculate the self--consistent starting Twiss parameters:
\begin{example}
  type (lat_struct) lat
  call bmad_parser ('my_lattice', lat)
  call twiss_at_start (lat)
\end{example}

Once the starting Twiss parameters are set, \vnr{twiss_propagate_all}
can be used to propagate the Twiss parameters to the rest of the
elements
\begin{example}
  call twiss_propagate_all (lat)
\end{example}
It is important to keep in mind that \vn{lat%ele(i)%x%eta} is the $a$--mode
dispersion, not the dispersion along the $x$--axis (\sref{s:ele.twiss}).

The routine \vnr{twiss_and_track_at_s} can be used to calculate the
Twiss parameters at any given longitudinal location. Alternatively, to
propagate the Twiss parameters partially through a given element use
the the routine \vnr{twiss_and_track_partial}.


%-----------------------------------------------------------------------------
\section{Tune Calculation}
\label{s:tune}
\index{tune calculation}

For a closed lat the tune is calculated via the routine \vnr{twiss_at_start}.
This routine multiplies the transfer matrices of the elements together to form
the one--turn transfer matrix. From this the routine extracts the initial Twiss
parameters and the tune. The tune is placed in the variables
\begin{example}
  type (lat_struct) lat 
  lat%x%tune     ! a-mode tune
  lat%y%tune     ! b-mode tune
\end{example}

The routine \vnr{set_tune} To set the transverse tunes of a closed lat:
\begin{example}
  set_tune (phi_a_set, phi_b_set, dk1, lat, orb_, ok)
\end{example}
\vn{set_tune} varies quadrupole strengths until the desired tunes are
achieved. As input \vn{set_tune} takes an argument \vn{dk1(:)} which is an array
that specifies the relative change to be make to the quadrupoles in the lattice.

To set the longitudinal (synchrotron) tune the routine \vnr{set_z_tune} can be
used. \vn{set_z_tune} works by varying rf cavity voltages until the desired tune
is achieved.

%-----------------------------------------------------------------------------
\section{Chromaticity Calculation}
\label{s:chrom}

For a closed lat \vnr{chrom_calc} calculates the chromaticity by calculating
the tune change with change in beam energy.

\vnr{chrom_tune} sets the chromaticity by varying the sextupoles. This is a 
very simple routine that simply divides the sextupoles into two families
based upon the local beta functions at the sextupoles.

%-----------------------------------------------------------------------------
\section{Custom Elements}
\label{s:custom.ele}
\index{twiss parameters!calculation with custom elements}
\index{custom}

There are up to six routines that must be written to implement a custom 
element they are:
\index{routine!custom_emitt_calc}\index{routine!custom_radiation_integrals}
\index{routine!em_field_custom}\index{routine!field_rk_custom}
\index{routine!make_mat6_custom}\index{routine!track1_custom}
\begin{example}
   custom_emitt_calc            ! only needed if emitt_calc is called in a program.
   custom_radiation_integrals   ! only needed if radiation_integrals is called.
   em_field_custom              ! only needed if em_field is called.
   field_rk_custom              ! only needed if field_rk is called.
   make_mat6_custom             ! only needed if make_mat6 is called.
   track1_custom                ! only needed if track1 is called.
\end{example}
use \vn{getf} for more details about the argument lists for these
routines.  The \bmad library has dummy routines of the same name to
keep the linker happy when custom routines are not implemented. These
dummy routines, if called, will print an error message and stop the
program. To make the linker preferentially link in new custom routines
the new routines should be explicitly listed in the linking list.

%-----------------------------------------------------------------------------
\section{Custom Field Calculations}
\label{s:custom.field}
\index{Fields (electric and magnetic)!custom calculation} 
\index{ele_struct!\%field_calc}

\index{runge_kutta}\index{boris}\index{ele_struct!\%field_calc}
\index{routine!em_filed_custom}
Custom Electric and Magnetic field calculations are used with
\vn{runge_kutta} and \vn{boris} tracking (See \sref{s:integ}).  To
implement custom field calculations the \vn{ele%field_calc} component
of an element must be set to \vn{custom\$}. This can be done either
through the lattice input file or within a program. Additionally a
routine \vn{em_field_custom} must be linked with any program using the
custom calculations.

%-----------------------------------------------------------------------------
\section{Particle Information}
\label{s:particle}
\index{particle!information}

In a \vn{lat_struct} structure the particle type is stored in the
integer variable \vn{%param%particle}. The value of this variable will
correspond to one of the constants:
\index{positron}\index{electron}\index{proton}\index{antiproton}
\begin{example}
  positron\$
  electron\$
  proton\$
  antiproton\$
\end{example}
To print the name of the particle use the function
\vnr{particle_name}. A particles mass and charge can be obtained from
the functions \vnr{mass_of} and \vnr{charge_of} respectively. 
\vn{charge_of} returns the particle's charge in units of the fundamental
electron charge. Example:
\begin{example}
  type (lat_struct) lat
  call bmad_parser (input_file_name, lat)
  print *, 'Beam Particles are: ', particle_name(lat%param%particle)
  if (lat%param%particle == proton\$) print *, 'I do not like protons!'
  print *, 'Particle mass (eV):    ', mass_of(lat%param%particle)
  print *, 'Particle charge (Coul):', &
                          e_charge * charge_of(lat%param%particle)
\end{example}
