\chapter{Twiss Parameters, Coupling, Chromaticity, Etc.}
\label{c:twiss}

%-----------------------------------------------------------------------------
\section{Ele\_struct Components}
\label{s:twiss.ele}

\index{ele_struct!\%gamma_c}
\index{ele_struct!\%c_mat}
\index{ele_struct!\%a}\index{ele_struct!\%b}\index{ele_struct!\%z}

The \vn{ele_struct} (\sref{c:ele.struct}) has a number of components that
hold information on the Twiss parameters, dispersion, and coupling
at the exit end of the element. The Twiss parameters of the three 
normal modes (\sref{s:coupling})
are contained in the \vn{%a}, \vn{%b}, and \vn{%z} components which are 
of type \vn{twiss_struct}:
\index{twiss_struct}
\begin{example}
  type twiss_struct
    real(rp) beta         ! Twiss Beta function
    real(rp) alpha        ! Twiss Alpha function
    real(rp) gamma        ! Twiss gamma function
    real(rp) phi          ! Normal mode Phase advance
    real(rp) eta          ! Normal mode dispersion
    real(rp) etap         ! Normal mode dispersion derivative
    real(rp) sigma        ! Normal mode beam size
    real(rp) sigma_p      ! Normal mode beam size derivative
    real(rp) emit         ! Geometric emittance
    real(rp) norm_emit    ! Normalized emittance
  end type 
\end{example}
The projected horizontal and vertical dispersions in an \vn{ele_struct}
are contained in the \vn{%x} and \vn{%y} components. These components are
of type \vn{xy_disp_struct}:
\index{xy_disp_struct}
\begin{example}
  type xy_disp_struct
    real(rp) eta     ! Projected dispersion 
    real(rp) etap    ! Projected dispersion derivative.
  end type 
\end{example}

The relationship between the projected and normal mode dispersions are
given in \Eq{avx}. 
The 2x2 coupling matrix $\bfC$ (\Eq{vgicc1}) is stored in the \vn{%c(2,2)}
component of the \vn{ele_struct} and the $\gamma$ factor of \Eq{vgicc1}
is stored in the \vn{gamma_c} component.
There are several
routines to manipulate the coupling factors. For example:
\begin{example}
  c_to_cbar(ele, cbar_mat)             ! Form Cbar(2,2) matrix
  make_v_mats(ele, v_mat, v_inv_mat)   ! Form V matrices.
\end{example}
See \sref{r:mat} for a complete listing of such routines.

The \vn{%mode_flip} logical component of an \vn{ele_struct} indicates
whether the $a$ and $b$ normal modes have been flipped relative to the
beginning of the lattice. See Sagan and Rubin\cite{b:coupling} for a
discussion of this. The convention adopted  by \bmad is that all the
\vn{%a} component of all the elements in a lattice will all correspond
to the same physical normal mode. Similary, the \vn{%b} component of all
the elements will all correspond to some (other) physical normal mode.
That is, at an element where there is a mode flip (\vn{%mode_flip} is
True), the \vn{%a} component actuall corresponds to the $\bfB$ matrix
element in \Eq{ua00b} and vice versa. The advantage of this convention
is that routines that calculate properties of the modes (for example the
emittance), can ignore whether the modes are flipped or not.

The normal mode analysis of Sagan and Rubin,
while it has the benefit of simplicity, is strictly
only applicable to lattices where the RF cavities are turned off. 
The full 6-dimensional analysis is summerized by Wolski\cite{b:wolski.coupling}. 
The \hyperref[r:normal.mode3.calc]{normal_mode3_calc} routine proform 
the full analysis. The results are put in
the \vn{%mode3} component of the \vn{ele_struct} which is of type \vn{mode3_struct}:
\index{ele_struct!\%mode3}
\begin{example}
  type mode3_struct
    real(rp) v(6,6)
    type (twiss_struct) a, b, c
    type (twiss_struct) x, y
  end type
\end{example}

%-----------------------------------------------------------------------------
\section{Twiss Parameter Calculations}
\label{s:twiss}
\index{twiss parameters}
\index{twiss parameters!calculation}

A calculation of the Twiss parameters starts with the Twiss parameters
at the beginning of the lattice. For linear machines, these twiss parameter
need to be set in the input lattice file (\sref{s:beginning}). For
circular machines, 
the routine \vnr{twiss_at_start} may be used (\sref{s:beginning})
\begin{example}
  type (lat_struct) lat
  ...
  if (lat%param%lattice_type == circular_lattice$) call twiss_at_start(lat)
\end{example}
The initial twiss parameters are placed in \vn{lat%ele(0)}. 

To propagate the Twiss, coupling and dispersion 
parameters from the start of the lattice to the end, the routine
\hyperref[r:twiss.propagate.all]{twiss_propagate_all} can be used. This
routine works by repeated calls to \vnr{twiss_propagate1} which does
a single propagation from one element to another. The Twiss propagation
depends upon the transfer matrices having already computed (\sref{c:tracking}).


In propagating the Twiss
parameters, the dispersion values in \vn{%x} and \vn{%y} are assumed
to be correct and the dispersion values in \vn{%a} and \vn{%b} are
ignored. [Notice, though, in an input lattice file, if
beginning[eta_a] is set, Bmad does the correct bookkeeping.] In
general, setting one Twiss parameter will affect the others. To make
sure everything is consistent, the \vnr{changed_attribute_bookkeeper}
routine can be used.

If the Twiss parameters need to be transfered from 
one element to another The three components \vn{%a}, \vn{%b}, and \vn{%c}
need to be copied. Additionally, to transfer the dispersion, the two
components \vn{%x} and \vn{%y} need to be copied since the standard
dispersion propagation routine, \vn{twiss_propagate1}, computes normal mode
dispersions from the projected ones. Thus a full transfer looks like
\begin{example}
  ele2%a = ele1%a
  ele2%b = ele1%b
  ele2%x = ele1%x
  ele2%y = ele1%y
  ele2%z = ele1%z
\end{example}

Before any Twiss parameters can be calculated the transfer matrices
stored in the lattice elements must be computed. \vnr{bmad_parser} does
this automatically about the zero orbit. If, to see nonlinear effects,
a different orbit needs to be used for the reference, The routine
\vnr{lat_make_mat6} can be used. For example
\begin{example}
  type (lat_struct) lat
  type (coord_struct), allocatable :: orbit(:)
  call bmad_parser ('my_lattice', lat)
  call closed_orbit_calc (lat, orbit, 4)
  call lat_make_mat6 (lat, -1, orbit)
\end{example}
This example reads in a lattice, finds the closed orbit which may be
non--zero due to, say, kicks due to a separator, and then remakes the
transfer matrices (which are stored in \vn{lat%ele(i)%mat6} around
the closed orbit.

Once the transfer matrices are calculated the Twiss parameters at the
start of the lattice need to be defined. The Twiss parameters at the
start are in \vn{lat%ele(0)}. If the lattice is open then generally
the Twiss parameters are set in the lattice file or may easily be set
in a program. For example
\begin{example}
  lat%ele(0)%x%beta = 1.2
  lat%ele(0)%x%alpha = 0.1
  lat%ele(0)%x%gamma = (1 + lat%ele(0)%x%alpha**2) / lat%ele(0)%beta
  lat%ele(0)%x%eta  = 0
\end{example}
Note that \vn{%beta}, \vn{%alpha}, and \vn{%gamma} all must be specified.



If the lattice is circular, the routine \vnr{twiss_at_start} may be used to
calculate the self--consistent starting Twiss parameters:
\begin{example}
  type (lat_struct) lat
  call bmad_parser ('my_lattice', lat)
  call twiss_at_start (lat)
\end{example}

Once the starting Twiss parameters are set, \vnr{twiss_propagate_all}
can be used to propagate the Twiss parameters to the rest of the
elements
\begin{example}
  call twiss_propagate_all (lat)
\end{example}
It is important to keep in mind that \vn{lat%ele(i)%x%eta} is the $a$--mode
dispersion, not the dispersion along the $x$--axis (\sref{s:ele.twiss}).

The routine \vnr{twiss_and_track_at_s} can be used to calculate the
Twiss parameters at any given longitudinal location. Alternatively, to
propagate the Twiss parameters partially through a given element use
the the routine \vnr{twiss_and_track_partial}.


twiss_and_track_at_s \aaaa

%-----------------------------------------------------------------------------
\section{Tune Calculation}
\label{s:tune}
\index{tune calculation}

For a closed lat the tune is calculated via the routine \vnr{twiss_at_start}.
This routine multiplies the transfer matrices of the elements together to form
the one--turn transfer matrix. From this the routine extracts the initial Twiss
parameters and the tune. The tune is placed in the variables
\begin{example}
  type (lat_struct) lat 
  lat%a%tune     ! a-mode tune
  lat%b%tune     ! b-mode tune
\end{example}

The routine \vnr{set_tune} To set the transverse tunes of a closed lat:
\begin{example}
  set_tune (phi_a_set, phi_b_set, dk1, lat, orb_, ok)
\end{example}
\vn{set_tune} varies quadrupole strengths until the desired tunes are
achieved. As input \vn{set_tune} takes an argument \vn{dk1(:)} which is an array
that specifies the relative change to be make to the quadrupoles in the lattice.

To set the longitudinal (synchrotron) tune the routine \vnr{set_z_tune} can be
used. \vn{set_z_tune} works by varying rf cavity voltages until the desired tune
is achieved.

%-----------------------------------------------------------------------------
\section{Chromaticity Calculation}
\label{s:chrom}

For a closed lat \vnr{chrom_calc} calculates the chromaticity by calculating
the tune change with change in beam energy.

\vnr{chrom_tune} sets the chromaticity by varying the sextupoles. This is a 
very simple routine that simply divides the sextupoles into two families
based upon the local beta functions at the sextupoles.

%-----------------------------------------------------------------------------
\section{Custom Elements}
\label{s:custom.ele}
\index{twiss parameters!calculation with custom elements}
\index{custom}

There are up to six routines that must be written to implement a custom 
element they are:
\index{routine!custom_emitt_calc}\index{routine!custom_radiation_integrals}
\index{routine!em_field_custom}\index{routine!field_rk_custom}
\index{routine!make_mat6_custom}\index{routine!track1_custom}
\begin{example}
   custom_emitt_calc            ! only needed if emitt_calc is called in a program.
   custom_radiation_integrals   ! only needed if radiation_integrals is called.
   em_field_custom              ! only needed if em_field is called.
   field_rk_custom              ! only needed if field_rk is called.
   make_mat6_custom             ! only needed if make_mat6 is called.
   track1_custom                ! only needed if track1 is called.
\end{example}
use \vn{getf} for more details about the argument lists for these
routines.  The \bmad library has dummy routines of the same name to
keep the linker happy when custom routines are not implemented. These
dummy routines, if called, will print an error message and stop the
program. To make the linker preferentially link in new custom routines
the new routines should be explicitly listed in the linking list.

%-----------------------------------------------------------------------------
\section{Custom Field Calculations}
\label{s:custom.field}
\index{Fields (electric and magnetic)!custom calculation} 
\index{ele_struct!\%field_calc}

\index{runge_kutta}\index{boris}\index{ele_struct!\%field_calc}
\index{routine!em_filed_custom}
Custom Electric and Magnetic field calculations are used with
\vn{runge_kutta} and \vn{boris} tracking (See \sref{s:integ}).  To
implement custom field calculations the \vn{ele%field_calc} component
of an element must be set to \vn{custom\$}. This can be done either
through the lattice input file or within a program. Additionally a
routine \vn{em_field_custom} must be linked with any program using the
custom calculations.

