\chapter {Control Elements}
\label{c:control}
\index{Element!control}
\index{Element!lord}
\index{Element!slave}

It is possible to have elements controlling the attributes of other
elements. These \vn{lord} elements are meant, for example, to mimic
the effect of changing a knob in the control room. For this purpose
the lattice is split into two sections: The first section is the list
of elements that \bmad uses for any analysis (tracking, Twiss
parameter calculations, etc.). This first part is called the
\vn{tracking} part of the lattice.
Elements in the \vn{tracking} part are either
\vn{slave} elements if they have a controlling lord or \vn{free}
elements if they do not.  The second section consists solely of
\vn{lord} elements. \vn{Lord} elements can control other \vn{lord}
elements and a hierarchy of \vn{lord} elements may be established.

There are five types of lord elements: 
\begin{Itemize}
\item 
\index{group}
\vn{Group} lord elements are used to make variations in
attributes. For example, to simulate the action of a control room knob
that changes the beam tune in a storage ring, a \vn{Group} can be used
to vary the strength of selected quads in a specified
manner. \vn{Groups} are covered in \sref{s:group}.
\item
\index{overlay}
An \vn{Overlay} lord is like a \vn{group} except that \vn{overlays}
set the value (not a change in) the attributes they
control. \vn{Overlays} are covered in \sref{s:overlay}.
\item
A \vn{superposition} lord is created when elements are superimposed on
top of other elements. This is covered in \sref{s:super}.
\item
\index{girder}
\vn{Girder} elements mimic the effect of a support girder. This is
covered in \sref{s:girder}.
\item
\index{multipass}
\vn{Multipass} elements are used when the beam recirculates through
the same element multiple times. This is covered in
\sref{s:multipass}.
\end{Itemize}

%-----------------------------------------------------------------------------
\section{Overlay Elements}
\label{s:overlay}

An \vn{overlay} element is used to control the attributes of other elements. 
For example: 
\begin{example}
  over1: overlay = \{a_ele, b_ele/2.0\}, hkick = 0.003
  over2: overlay = \{b_ele\}, hkick
  over2[hkick] = 0.9
  a_ele: quad, hkick = 0.05, ...
  b_ele: rbend, ...
  this_line: line = ( ... a_ele, ... b_ele, ... )
  use, this_line
\end{example}

In the example the overlay \vn{over1} controls the \vn{hkick}
attribute of the "slave" elements \vn{a_ele} and
\vn{b_ele}. \vn{over2} controls the hkick attribute of just
\vn{b_ele}. \vn{over1} has a \vn{hkick} value of 0.003 and \vn{over2}
has been assigned a value for \vn{hkick} of 0.9.

There are coefficients associated with the control of a slave element. 
The default coefficient is 1.0. To specify a coefficient use a slash "/" 
after the element name followed by the coefficient. In the above example 
the coefficient for the control of \vn{b_ele} from \vn{over1} is 2.0 
and for the others the default 1.0 is used. thus 
\begin{example}
  a_ele[hkick] = over1[hkick]
               = 0.003
  b_ele[hkick] = over2[hkick] + 2 * over1[hkick] 
               = 0.906
\end{example}

An \vn{overlay} will control all elements of a given name.  Thus, in
the above example, if there are multiple elements in \vn{this_line}
with the name \vn{b_ele} then the \vn{over1} and \vn{over2} overlays
will control the hkick attribute of all of them.

Note: Overlays completely determine the value of the attributes that
are controlled by the overlay. in the above example, the hkick of 0.05
assigned directly to \vn{a_ele} is overwritten by the overlay action
of \vn{over1}.

\noindent The default value for an overlay is 0 so for example
\begin{example}
  over3: overlay = \{c_ele\}, k1
\end{example}
will make \vn{c_ele[k1]} = 0. Overlays can also control more than one
type of attribute as the following example shows
\begin{example}
  over4: overlay = \{this_quad[k1]/3.4, this_sextupole[k2], ...\}, hkick
\end{example}


%-----------------------------------------------------------------------------
\section{Group Elements}
\label{s:group}
\index{group}
 
\vn{group} is like \vn{overlay} in that a \vn{group} element controls
the attribute values of other ``slave'' elements.  A \vn{group}
element is used to make changes in value. This is unlike an
\vn{overlay} which sets a specific value directly. An example will
make this clear
\begin{example}
  gr: group = \{q1\}, k1 
  gr[command] = 0.34 
  q1, quad, l = ...
  q1[k1] = 0.57
\end{example}
In this example the group \vn{gr} controls the \vn{k1} attribute of
the element \vn{q1}. Unlike overlays, values are assigned to group
elements using the \vn{command} attribute.  When a lattice file is
read in then command values for any groups are always applied
last. This is independent of the order that they appear in the file.
Thus in this example the value of q1[k1] would be $0.91 = 0.57 + 0.34$.
When the changes are made to the slave attributes the value of
\vn{command} is stored in the \vn{group}'s \vn{old_command} attribute.
After the lattice is read in a program can change the \vn{gr[command]}
attribute and this change will be added to the value of
\vn{q1[k1]}. The bookkeeping routine that transfers the change from
\vn{gr[command]} to \vn{q1[k1]} doesn't care what the current value of
\vn{q1[k1]} is. It only knows it has to change it by the change in
\vn{gr[command]}.

\index{accordion_edge}
\index{start_edge}
\index{end_edge}
\index{symmetric_edge}
\index{s_offset}
A \vn{group} can be used to control an elements position and length
using the attributes
\begin{example}
  accordion_edge  ! Element grows or shrinks symmetrically
  start_edge      ! Varies element's starting edge s-position
  end_edge        ! Varies element's ending edge s-position
  symmetric_edge  ! Varies element's overall s-position. Constant length.
  s_offset        ! Similar to symmetric_edge
\end{example}
With \vn{accordion_edge}, \vn{start_edge}, \vn{end_edge}, and
\vn{symmetric_edge} the longitudinal position of an elements edges are
varied. This is done by appropriate control of the element's length
and the lengths of the elements to either side. With \vn{s_offset} the
physical element is offset from its reference position
(\sref{s:offset}) and the elements on either side are untouched.
In all cases the total length of the lattice is kept invariant.

As an example, consider \vn{accordion_edge} which varies the edges of
an element so that the center of the element is fixed but the length
varies. With \vn{accordion_edge} a change of, say, 0.1 in a
\vn{group}'s \vn{command} attribute moves both edges of the element by
0.1 meters so that the length of the element changes by 0.2 meters. To
keep the total lattice length invariant the lengths of the elements to
either side are varied accordingly.  For example
\begin{example}
  q10: quad, l = ...
  q11: quad, l = ...
  d1: drift, l = ...
  d2: drift, l = ...
  this_line: line = (... d1, q10, d2, q11, ...)
  gr2: group = \{q10\}, start_edge = 0.1
\end{example}
This last line that defines \vn{gr2} is just a shorthand notation for
\begin{example}
  gr2: group = \{q10\}, start_edge 
  gr2[command] = 0.1
\end{example}
The effect will be to lengthen the length of \vn{q10} and shorten the
length of \vn{d1}.

\index{old_command}
\index{Command}
\index{coef}
\index{type}
\index{alias}
\index{descrip}
The full list of attributes of a group are
\begin{example}
  command         
  old_command     
  coef            
  type            ! See section \ref{s:string}
  alias           ! See section \ref{s:string}
  descrip         ! See section \ref{s:string}
\end{example}
The \vn{coef} attribute is not used by any \bmad\ routine. It is
defined for individual programs to store, say, a needed conversion
factor.

Like \vn{overlay}s, coefficients can be specified for the individual
elements under a \vn{group}'s control and \vn{group}s can control more
than one type of attribute. For example
\begin{example}
  gr3: group = \{q1[k1]/-1.0, q2[tilt], oct1/-2.0\}, k3
  gr3[command] = 2.0
  gr3[old_command] = 1.5
\end{example}
In this example \vn{gr3} controls 3 attributes of 3 different
elements.  The change in \vn{gr3} when the lattice is read in is $0.5
= 2.0 - 1.5$.  this 0.5 change will change \vn{q1[k1]} by $-0.5 = -1
\times 0.5$, \vn{q2[tilt]} will change by 0.5 and \vn{oct1[k3]} will
change by $-1.0 = -2.0 * 0.5$.

%-----------------------------------------------------------------------------
\section{Superposition}
\label{s:super}
\index{superimpose|hyperbf}

In practice the field at a particular point in the lattice may be due
to more than one physical element. A common example is a quadrupole
inside a solenoid. \bmad has a mechanism to handle some of these
cases using what is called ``superposition''. A simple example shows
how this works:
\begin{example}
  Q: quad, l = 10
  D: drift, l = 4
  S: solenoid, l = 6, superimpose, ref = q, ref_end
  lat: line = (Q, D)
  use, lat
\end{example}
The \vn{superimpose} attribute of element \vn{S} superimposes \vn{S}
over the lattice \vn{(Q, D)}. The placement of \vn{S} is such that the
center of \vn{S} coincides with the end of \vn{Q} (more on how
superimposed elements get placed later). The tracking part of the
lattice list (the part that one does tracking through) Looks like:
\begin{example}
        Element   Key         Length
  1)    Q{\#}1       Quadrupole   7
  2)    Q{\B}S       Sol_quad     3
  3)    S{\#}1       Solenoid     3
  4)    D{\#}2       Drift        1
\end{example}
What \bmad has done is to split the original elements \vn{(Q, D)} at
the edges of \vn{S}.  The first element \vn{Q\#1} is the part of \vn{Q}
that is outside of \vn{S}. Since this is only part of \vn{Q} \bmad
has put a \vn{\#1} in the name so that there will be no confusion.
(\vn{\#} has no special meaning other than the fact that \bmad uses
it for mangling names). The next element, \vn{Q{\B}S}, is the part of
\vn{Q} that is inside \vn{S}. \vn{Q{\B}S} is a combination
solenoid/quadrupole element as one could expect. \vn{S{\#}1} is the part
of \vn{S} that is outside \vn{Q} so this element is just a
solenoid. Finally, \vn{D\#2} is the rest of the drift outside \vn{S}.

\begin{figure}[tb]
\centering 
\includegraphics{superimpose.eps} 
\caption[Superposition Illustration.]
{Illustration of a superposition.}
\label{f:superimpose}
\end{figure}

With the lattice broken up like this \bmad has constructed something
that can be easily analyzed. However, the original elements \vn{Q} and
\vn{S} still exist within the lord section of the lattice. \bmad has
bookkeeping routines so that if a change is made to the \vn{Q} or
\vn{S} elements then these changes can get propagated to the
corresponding slaves.  It does not matter which element is
superimposed. Thus, in the above example, \vn{S} could have been put
in the Beam Line (with a drift before it) and \vn{Q} could then have
been superimposed on top and the result would have been the same
(except that the split elements could have different names).

Superpositions are restricted in that \bmad may not have an
appropriate element for the superimposed fields. For example, a
solenoid can not be superimposed over an octupole.  If a zero length
element, such as a marker, is superimposed with some other element (or
vice versa) the element is just split in two. For example:
\begin{example}
  Q: quad, l = 10
  M: marker, superimpose, offset = 6
  lat: line = (Q)
  use, lat
\end{example}
The resulting lattice (first part) would be
\begin{example}
        Element   Key           Length
  1)    Q{\#}1       Quadrupole    6
  2)    M         Marker        0
  3)    Q{\#}2       Quadrupole    4
\end{example}
and the second part of the lattice would have the \vn{Q} element.
 
A superposition is illustrated in Figure~\ref{f:superimpose} The
placement of a superimposed element is determined by three factors: A
reference point on the superimposed element, a reference point in the
lattice line, and an offset between the points. The attributes that
determine these three quantities are: 
\index{ref}\index{offset}
\index{ref_beginning}\index{ref_center}\index{ref_end}
\index{ele_beginning}\index{ele_center}\index{ele_end}
\begin{example}
  ref = <element name in lattice>
  offset = <length>      (default = 0)
  ref_beginning
  ref_center             (default)
  ref_end
  ele_beginning
  ele_center             (default)
  ele_end
\end{example}
\vn{ref} sets the reference element. If \vn{ref} is not present then
the start of the lattice is used. \vn{ref_beginning}, \vn{ref_center}
or \vn{ref_end} can be used to indicate where on the reference element
the reference point is. Default is \vn{ref_center}. Similarly,
\vn{ele_beginning}, \vn{ele_center}, or \vn{ele_end} can be used to
indicate the reference point on the superimposed element at the
beginning (entrance) edge, the center, or the end (exit) edge
respectively. If neither of these attributes are given the default is
to use the element center. \vn{offset} is the longitudinal offset
between the reference point on the reference element and the reference
point on the superimposed element. The default if not present is zero.

\index{lattice_type}
\index{linear_lattice}
\index{drift}
\index{overlay}
\index{group}
\index{girder}
Superposition may be done with any element except \vn{Drift},
\vn{Group}, \vn{Overlay}, and \vn{Girder} control elements. A superimposed element that
extends beyond either end of the lattice will be wrapped around. For consistency's sake
this is done even if the \vn{lattice_type} is set to \vn{linear_lattice} but in this case
a warning message will be issued.

When a superposition is made that overlaps a drift the drift, not being a "real" 
element, vanishes. That is, it does not get put in the lord section of the lattice.
Thus, it is an error if a second superposition uses the drift as the reference element.
For example
\begin{example}
  dft1: drift, l = 10
  q1: quad, l = 1, superposition, ref = dft1   ! OK 
  q2: quad, l = 2, superposition, ref = dft1   ! ERROR! 
\end{example}

\index{overlay}
\index{group}
\index{expand_lattice}
When the lattice is constructed, superposition of elements is done
before the addition of any \vn{group} or \vn{overlay} elements. This
is done since \vn{overlay}s and \vn{group}s are allowed to refer
to elements that are superimposed. This can lead to some unexpected
results. For example:
\begin{example}
  q1: quad, l = 10
  q2: quad, l = 10
  lat: line = (q1, q2)
  use, lat
  o: overlay = {q1}, l = 12
  m: marker, superimpose, offset = 15
\end{example} 
The application of the overlay will increase the length of \vn{q1} by
2~meters which will put the marker \vn{m} at 17~meters instead of the
expected 15. To avoid this problem, an \vn{expand_lattice} statement
(\sref{s:expand}) can be placed after the overlay, but before the
superimpose, statement
\begin{example}
  ...
  o: overlay = {q1}, l = 12
  expand_lattice
  m: marker, superimpose, offset = 15
\end{example} 

%-----------------------------------------------------------------------------
\section{Multipass}
\label{s:multipass}
\index{multipass|hyperbf}

Some lattices have the beam recirculating through the same element
multiple times. For example, an Energy Recovery Linac (ERL) will
circulate the beam back through the LINAC part to retrieve the energy
in the beam. In \bmad this situation can simulated using the
\vn{multipass} attribute. A simple example shows how this works.
\index{expand_lattice}
\begin{example}
  A: lcavity
  linac_part: line[multipass] = (A, ...)
  my_line: line = (linac_part, ..., linac_part)
  use, my_line
  expand_lattice
  A\B2[dphi0] = 0.5
\end{example}
The tracking part of the lattice consists of two slave elements
\begin{example}
  A\B1, ..., A\B2, ...
\end{example}
Since the two elements are derived from a \vn{multipass} line they are
given unique names by adding a \vn{{\B}n} suffix. In addition there is
a lord element (that doesn't get tracked through) called \vn{A} in the
lord part of the lattice. Changes to attributes of the lord \vn{A}
element will be passed to the slave elements by \bmad's bookkeeping
routines. Assuming \vn{A\B1} is an accelerating cavity, to make
\vn{A\B2} a decelerating cavity the \vn{dphi0} attribute of
\vn{A\B2} is set to 0.5. This is the one attribute that \bmad's
bookkeeping routines will not touch when transferring attribute values
from \vn{A} to its slaves. Notice that the \vn{dphi0} attribute had to
be set after \vn{expand_lattice} (\sref{s:expand})
is used to expand the lattice since
\bmad does immediate evaluation and \vn{A\B2} does not exist before
the lattice is expanded.

Sublines of a multipass line are automatically multipass:
\begin{example}
  a_line: line = (...)
  m_line: line[multipass] = (..., a_line, ...)
\end{example}
In this example \vn{a_line} is implicitly multipass.

Multiple elements of the same name in a multipass line are considered 
physically distinct:
\begin{example}
  m_line: line[multipass] = (A, A, B)
  u_line: line = (m_line, m_line)
  use, u_line
\end{example}
In this example the tracking part of the lattice is
\begin{example}
  A\B1, A\B1, B\B1, A\B2, A\B2, B\B2
\end{example}
In the control section of the lattice there will be two multipass
lords called \vn{A} and one called \vn{B}. The first \vn{A} lord 
controls the 1\St and 4\Th elements in the tracking part of the lattice 
and the second \vn{A} lord controls the 2\Nd and 5\Th elements.

If a multipass line is reversed then the elements are considered to be
transversed backwards:
\begin{example}
  m_line: line[multipass] = (A, A, B)
  u_line: line = (m_line, -m_line)
  use, u_line
\end{example}
In this example the tracking part of the lattice is
\begin{example}
  A\B1, A\B1, B\B1, B\B2, A\B2, A\B2
\end{example}
Here the 1\St and 6\Th elements are connected to a multipass lord and the
2\Nd and 5\Th elements are connected to a different multipass lord.

\index{lcavity}
\index{p0c}\index{e_tot}
If there are \vn{lcavity} elements in the lattice then the reference
energy at a given element may differ from pass to pass. In this case,
the normalized strength (k1, kick, etc.) for magnetic and electric
elements will not be the same from pass to pass. To avoid an
ambiguity, all magnetic and electric elements that are used in a
multipass line must have their magnetic or electric field strength set
as the independent attribute (\sref{s:depend}), {\em or} a reference
energy (\sref{s:energy}) must be defined. A reference energy is
defined by setting \vn{e_tot} or \vn{p0c}, or by setting
\vn{n_ref_pass} as described below. 

\begin{figure}[tb]
\centering 
\includegraphics{multipass_bend.eps} 
\caption[The reference orbit with a multipass bend.]  
{With \vn{ref_orbit} = \vn{match_at_entrance}, the reference orbits of
different pass will be assumed, for the sake of calculating the slave bend parameters, 
to be the same at the entrance end of the magnet.  If
there is a variation of the reference energy through a bend from pass
to pass, the assumed reference orbit through the bend will vary from pass to
pass.}
\label{f:multipass.bend}
\end{figure}

\index{sbend}\index{rbend}\index{patch}
For a bend in a multipass line, there is the added complication of how
to define the reference orbit when the reference energy is different
from pass to pass. If, say, a different reference orbit is used for
each pass there is a problem of how to interpret multipole values
like \vn{k1}. On the other hand, it is sometimes very convenient to be
able to use separate reference orbits. 

A bend element has a \vn{ref_orbit} attribute that, when combined with
the reference energy, define the reference orbit. \vn{ref_orbit} is a
switch that can take the values:
\begin{example}
  single_ref            ! Default. Must be used with n_ref_pass.
  match_at_entrance
  match_at_exit
\end{example}
A value of \vn{single_ref} (the default) means that the {\em same}
reference orbit will be used for all passes. The
\vn{match_at_entrance} and \vn{match_at_exit} values are used when
{\em separate} reference orbits are desired as described below.

To set the reference energy, one (and only one) of the attributes
\vn{n_ref_pass}, \vn{e_tot} or \vn{p0c} needs to be
set. \vn{n_ref_pass} is an integer indicating which pass is used to
define the reference energy for the lord element. Note: If
\vn{ref_orbit} is set to \vn{single_ref}, \vn{n_ref_pass} must be
used.

An example will make this clear. Consider a bend defined by
\begin{example} 
  B: sbend, l = 1, b_field = 1.0, n_ref_pass = 1, ref_orbit = single_ref
\end{example}
Here the same reference orbit will be used for all passes.  Assume
that positrons are being used and that the reference energy on the
first pass is 5~GeV and on the second pass it is 10~GeV. Since
\vn{n_ref_pass} has a value of \vn{1}, the first pass reference energy
of 5~GeV will be used, along with the attribute values of \vn{B}, to
define the reference orbit. In this case, this translates
into a bending radius \vn{rho} of 16.7~m.  In the tracking lattice,
the first pass element \vn{B\B1} will have a value for \vn{b_field} of
\vn{1.0} just like its lord element. On the second pass, the reference
orbit is the same so the bending radius of the reference orbit 
is unchanged at 16.7~m. However, the bending radius is
related to the \vn{b_field} by
\begin{example}
  rho = p0c / (c_light * b_field)
\end{example}
Since, on the second pass, \vn{p0c} is a factor of 2 larger, to keep
the bending radius invariant the value of \vn{b_field} for the second
pass element \vn{B\B2} will be a factor of 2 larger. That is, it will
be \vn{2.0}. Since the total field must be the same on all passes
(\vn{B\B1} and \vn{B\B2} represent the same physical element after
all), and since the total field is the sum of \vn{b_field} and
\vn{b_field_err}, \vn{B\B2} must have a value for \vn{b_field_err} of
\vn{-1.0}.

Now consider the same situation as above except that the value of
\vn{ref_orbit} is changed:
\begin{example} 
  B: sbend, l = 1, b_field = 1.0, n_ref_pass = 1, ref_orbit = match_at_entrance
\end{example}
Here the reference orbit will be different on the two passes. The two
reference orbits will coincide at the entrance edge of the magnet.
This is illustrated in Figure~\ref{f:multipass.bend}. In both
\vn{B\B1} and \vn{B\B2} the value of \vn{b_field} will be \vn{1.0}
giving bending radii of \vn{16.7}~m and \vn{33.4}~m
respectively. In the second pass, the element length \vn{l} will be
increased slightly to \vn{1.0000045}. There will also be a non-zero
exit face angle \vn{e2} of \vn{0.003}. With the different reference
orbit for the second pass, there is no good way to handle a non-zero
multipole attribute so \bmad disallows them in this case.

\vn{match_at_exit} is similar to \vn{match_at_entrance} except that
the different reference orbits will coincide at the exit edge of the
magnet. If \vn{match_at_exit} is used with the parameters in the above
example, the only change for \vn{B\B2} is that \vn{e1} will now be
\vn{0.003} and \vn{e2} will be zero.

The \vn{match_at_entrance} value for \vn{ref_orbit} is useful
for simulating a bend at the end of a multipass line that is used to
separate the beams on the various passes. Notice that the next
elements downstream (labeled \vn{Q1} and \vn{Q2} in
Figure~\ref{f:multipass.bend}) will be physically separated in
space. That is, it does not make sense to use \vn{match_at_entrance}
for a bend that is {\em not} at the end of a multipass
line. Similarly, the \vn{match_at_exit} value is useful for simulating
a bend that combines beams of different energies. Such a bend should
be placed at the beginning of a multipass line.
