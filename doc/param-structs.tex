%\input{simple_header}

\chapter{Bmad Parameter Structures}

\bmad has various parameters which affect various
calculations that \bmad performs. A given program may give the user
access to some of these parameters so, in order to allow the intelligent
setting of these parameters, this chapter gives an in-depth description.

A set of parameters are grouped that affect a particular type of
calculation are grouped into \vn{``structures''}. Each structure has a
\vn{``structure name''} (also called a \vn{``type name''}) which
identifies the list of parameters in the structure.  Additionally,
there will be an \vn{``instance name''} which is what the user uses to
refer to this \vn{structure}. For global parameters there will be a
unique instance name.  For non-global parameters, the instance name
will be program specific.  It is possible to have multiple instance
names. For example, in the situation where a program is simulating
multiple particle beams, there could be multiple \vn{beam_init_struct}
(\sref{s:beam.init}) instances.  To refer to a particular parameter
use the syntax
\begin{example}
  instance_name%parameter_name
\end{example}
For example, To refer to the \vn{max_aperture_limit} parameter in
Section~\sref{s:bmad.params} the syntax is
\begin{example}
  bmad_com%max_aperture_limit
\end{example}

%-----------------------------------------------------------------
\section{Bmad Global Parameters}
\label{s:bmad.params}
\index{Bmad!general parameters|hyperbf}

\index{max_aperture_limit}\index{d_orb(6)}
\index{grad_loss_sr_wake}\index{default_ds_step}
\index{rel_tol_tracking}\index{abs_tol_tracking}
\index{rel_tol_adaptive_tracking}\index{abs_tol_adaptive_tracking}
\index{taylor_order}\index{default_integ_order}
\index{sr_wakes_on}\index{lr_wakes_on}
\index{mat6_track_symmetric}\index{auto_bookkeeper}
\index{space_charge_on}\index{coherent_synch_rad_on}
\index{spin_tracking_on}\index{radiation_damping_on}
\index{radiation_fluctuations_on}\index{be_thread_safe}
\index{absolute_time_tracking_default}

Some overall parameters are stored in the \vn{bmad_common_struct}
structure. The instance name here is \vn{bmad_com}. The parameters of
this structure along with the default values are:
\begin{example}
  type bmad_common_struct
    real(rp) max_aperture_limit = 1e3          ! Max Aperture.
    real(rp) d_orb(6)           = 1e-5         ! for the make_mat6_tracking routine.
    real(rp) default_ds_step    = 0.2          ! Integration step size.  
    real(rp) significant_length = 1e-10        ! meter 
    real(rp) rel_tol_tracking = 1e-6           ! Runge-Kutta: Relative tolerance.
    real(rp) abs_tol_tracking = 1e-8           ! Runge-Kutta: Absolute tolerance.
    real(rp) rel_tol_adaptive_tracking = 1e-8  ! Tracking relative tolerance.
    real(rp) abs_tol_adaptive_tracking = 1e-10 ! Tracking absolute tolerance.
    real(rp) init_ds_adaptive_tracking = 1e-3  ! Initial step size.
    real(rp) min_ds_adaptive_tracking = 0      ! Minimum step size to use.
    real(rp) fatal_ds_adaptive_tracking = 1e-8 ! Threshold for loosing particles.
    integer taylor_order = 3                   ! 3rd order is default
    integer default_integ_order = 2            ! PTC integration order
    integer ptc_max_fringe_order = 2           ! PTC max fringe order (2 => Quadrupole !).
    logical sr_wakes_on = T                    ! Short range wake fields?
    logical lr_wakes_on = T                    ! Long range wake fields
    logical mat6_track_symmetric = T           ! symmetric offsets
    logical auto_bookkeeper = T                ! Automatic bookkeeping?
    logical space_charge_on = F                ! Space charge switch
    logical coherent_synch_rad_on = F          ! csr 
    logical spin_tracking_on = F               ! spin tracking?
    logical radiation_damping_on = F           ! Damping toggle.
    logical radiation_fluctuations_on = F      ! Fluctuations toggle.
    logical conserve_taylor_maps = T           ! Enable bookkeeper to set
                                               ! ele%taylor_map_includes_offsets = F?
    logical absolute_time_tracking_default = F ! Default for lat%absolute_time_tracking
    logical debug = F                          ! Used for code debugging.
  end type
\end{example}

\begin{description}
\item[\vn{\%max_aperture_limit}] \Newline 
Sets the maximum amplitude a particle can have
during tracking. If this amplitude is exceeded, the particle is lost
even if there is no element aperture set. Having a maximum aperture
limit helps prevent numerical overflow in the tracking calculations.

\item[\vn{\%d_orb}] \Newline 
Sets the orbit displacement used in the routine that calculates the
transfer matrix through an element via tracking.  \vn{%d_orb} needs to
be large enough to avoid significant round-off errors but not so large
that nonlinearities will affect the results. Also see
\vn{%mat6_track_symmetric}.

\item[\vn{\%default_ds_step}] \Newline
Step size for tracking code \sref{c:methods} that uses a fixed step
size. For example, \vn{symp_lie_ptc} and \vn{boris} tracking.

\item[\vn{\%significant_length}] \Newline
Sets the scale to decide if two length values are significantly
different. For example, The superposition code will not create any
super_slave elements that have a length less then this.

\item[\vn{\%rel_tol_tracking}] \Newline
Relative tolerance to use in tracking. Specifically, Tolerance to use
when finding the closed orbit.

\item[\vn{\%abs_tol_tracking}] \Newline
Absolute tolerance to use in tracking. Specifically, Tolerance to use
when finding the closed orbit.

\item[\vn{\%rel_tol_adaptive_tracking}] \Newline
Relative tolerance to use in adaptive tracking. This is used in
\vn{runge_kutta} and \vn{time_runge_kutta} tracking (\sref{s:integ}).

\item[\vn{\%abs_tol_adaptive_tracking}] \Newline
Absolute tolerance to use in adaptive tracking. This is used in
\vn{runge-kutta} and \vn{time_runge_kutta} tracking (\sref{s:integ}).

\item[\vn{\%init_ds_adaptive_tracking}] \Newline
Initial step to use for adaptive tracking. This is used in
\vn{runge-kutta} and \vn{time_runge_kutta} tracking (\sref{s:integ}).

\item[\vn{\%min_ds_adaptive_tracking}] \Newline
This is used in \vn{runge-kutta} and \vn{time_runge_kutta} tracking
(\sref{s:integ}). Minimum step size to use for adaptive tracking. If
To be useful, \vn{%min_ds_adaptive_tracking} must be set larger than
the value of \vn{%fatal_ds_adaptive_tracking}. In this case,
particles are never lost due to taking too small a step.

\item[\vn{\%fatal_ds_adaptive_tracking}] \Newline
This is used in \vn{runge-kutta} and \vn{time_runge_kutta} tracking
(\sref{s:integ}).  If the step size falls below the value set for
\vn{%fatal_ds_adaptive_tracking}, a particle is considered lost.
This prevents a program from ``hanging'' due to taking a large number
of exremely small steps. The most common cause of small step size is
an ``unphysical'' magnetic or electric field.

\item[\vn{\%taylor_order}] \Newline
Cutoff Taylor order of maps produced by \vn{sym_lie_ptc}.

\item[\vn{\%default_integ_order}] \Newline
Order of the the integrator used by \'Etienne Forest's PTC code (\sref{s:libs}).

\item{ptc_max_fringe_order} \Newline
Maximum order for computing fringe field effects in PTC. 

\item[\vn{\%sr_wakes_on}] \Newline
Toggle for turning on or off short-range higher order mode wake field effects.

\item[\vn{\%lr_wakes_on}] \Newline
Toggle for turning on or off long-range higher order mode wake field effects.

\item[\vn{\%mat6_track_symmetric}] \Newline
Toggle to turn off whether the transfer matrix from tracking routine
(\Hyperref{r:twiss.from.tracking}{twiss_from_tracking}) tracks 12 particles at both plus and
minus \vn{%d_orb} values or only tracks 7 particles to save time.

\item[\vn{\%auto_bookkeeper}] \Newline
Toggles automatic or intelligent bookkeeping. See
section~\sref{s:lat.bookkeeping} for more details.

\item[\vn{\%space_charge_on}] \Newline
Toggle to turn on or off high energy space charge effect in particle tracking.

\item[\vn{\%coherent_synch_rad_on}] \Newline
Toggle to turn on or off the coherent space charge calculation.

\item[\vn{\%spin_tracking_on}] \Newline
Determines if spin tracking is performed or not.

\item[\vn{\%radiation_damping_on}] \Newline
Toggle to turn on or off effects due to radiation dampling in particle tracking.

\item[\vn{\%radiation_fluctuations_on}] \Newline
Toggle to turn on or off effects due to radiation fluctuations in particle tracking.

\item[\vn{\%conserve_taylor_maps}] \Newline
Toggle to determine if the Taylor map for an element include any
element ``misalignments''.  See Section~\sref{s:mapoff} for more
details.

\item[\vn{\%absolute_time_tracking_default}] \Newline
Default setting to be applied to a lattice if
\vn{absolute_time_tracking} (\sref{s:param}) is not specified in a
lattice file. Additionally, if an element that is not associated with a lattice
is tracked, \vn{%absolute_time_tracking_default} will be used to
determine whether absolute time tracking is used.

\item[\vn{\%debug}] \Newline
Used for communication between program units for debugging purposes.

\end{description}

%-----------------------------------------------------------------
\section{Beam Initialization Parameters}
\label{s:beam.init}
\index{beam initialization parameters|hyperbf}

\index{beam_init_struct}
Beams of particles are used for simulating inter-bunch intra-bunch effects.
The \vn{beam_init_struct} structure holds parameters which are used to initialize
the beam. The parameters of this structure are:
\begin{example}
  type beam_init_struct
    character(16) distribution_type(3)         ! "ELLIPSE", "KV", "GRID", "" (default).
    type (ellipse_beam_init_struct) ellipse(3) ! For ellipse beam distribution
    type (kv_beam_init_struct) KV              ! For KV beam distribution
    type (grid_beam_init_struct) grid(3)       ! For grid beam distribution
    !!! The following are for Random distributions
    character(16) random_engine          ! "pseudo" (default) or "quasi". 
    character(16) random_gauss_converter ! "exact" (default) or "quick". 
    real(rp) random_sigma_cutoff = -1    ! -1 => no cutoff used.
    real(rp) center_jitter(6) = 0.0      ! Bunch center rms jitter
    real(rp) emit_jitter(2)   = 0.0      ! %RMS a and b mode bunch emittance jitter
    real(rp) sig_z_jitter     = 0.0      ! bunch length RMS jitter 
    real(rp) sig_e_jitter     = 0.0      ! energy spread RMS jitter 
    integer n_particle = 0               ! Number of simulated particles per bunch.
    logical renorm_center = T            ! Renormalize centroid?
    logical renorm_sigma = T             ! Renormalize sigma?
    !!! The following are used  by all distribution types
    type(beam_spin_struct) spin          ! Spin
    real(rp) a_norm_emit                 ! a-mode normalized emittance (= \(\gamma\,\epsilon\))
    real(rp) b_norm_emit                 ! b-mode normalized emittance (= \(\gamma\,\epsilon\))
    real(rp) a_emit                      ! a-mode emittance (= \(\gamma\,\epsilon\))
    real(rp) b_emit                      ! b-mode emittance (= \(\gamma\,\epsilon\))
    real(rp) dPz_dz = 0                  ! Correlation of Pz with long position.
    real(rp) center(6) = 0               ! Bench center offset.
    real(rp) dt_bunch                    ! Time between bunches.
    real(rp) sig_z                       ! Z sigma in m.
    real(rp) sig_e                       ! dE/E (pz) sigma.
    real(rp) bunch_charge                ! Charge in a bunch.
    integer n_bunch = 1                  ! Number of bunches.
    integer species = not_set\$           ! Species. Default is branch reference species.
    logical init_spin = F                ! initialize beam spinors
    logical full_6D_coupling_calc = F    ! Use 6x6 1-turn mat to match distribution?  
    logical use_t_coords = .false.  ! If true, the distributions will be 
                                    !   calculated using time coordinates  
    logical use_z_as_t   = .false.  ! Only used if  use_t_coords = .true.
                                    !   If true,  particles will be distributed in t
                                    !   If false, particles will be distributed in s
  end type
\end{example}
The number of bunches in the beam is set by \vn{n_bunch}. 
The \vn{%distributeion_type(:)} array determines what algorithms are used to generate
the particle distribution for a bunch. \vn{%distributeion_type(1)} sets the distribution 
type for the $(x, p_x)$ 2D phase space, etc. 
Possibilities for \vn{%distributeion_type(:)} are:
\begin{example}
  "", or "RAN_GAUSS"  ! Random distribution (default).
  "ELLIPSE"           ! Ellipse distribution (\sref{ss:ellipse.init})
  "KV"                ! Kapchinsky-Vladimirsky distribution (\sref{ss:kv.init})
  "GRID"              ! Uniform distribution.
\end{example}
Since the Kapchinsky-Vladimirsky distribution is for a 4D
phase space, if the Kapchinsky-Vladimirsky distribution is used,
\vn{"KV"} must appear exactly twice in the \vn{%distributeion_type(:)}
array. 

Unlike all other distribution types, the \vn{GRID} distribution is
independent of the Twiss parameters at the point of generation.  For
the non-\vn{GRID} distributions, the distributions are adjusted if
there is local $x$-$y$ coupling (\sref{s:coupling}). If
\vn{full_6D_coupling_calc} is set to \vn{True}, the full 6-dimensional
coupling matrix is used. If \vn{False}, which is the default, The
4-dimensional $\bfV$ matrix of \Eq{vgicc1} is used.

The parameters common to all the distribution types are marked in the
\vn{beam_init_struct} above. Either \vn{a_norm_emit} or \vn{a_emit}
may be set but not both. similarly, either \vn{b_norm_emit} or
\vn{b_emit} may be set but not both.

The parameters for the random distribution are:
  \begin{description}
  \item[\%random_engine] \Newline
This component sets the algorithm to use in generating a uniform distribution
of random numbers in the interval [0, 1]. \vn{"pseudo"} is a pseudo random
number generator and "quasi" is a quasi random generator. "quasi random" is
a misnomer in that the distribution generated is fairly uniform.
  \item[\%random_gauss_converter, \%random_sigma_cutoff] \Newline
To generate Gaussian random numbers, a conversion algorithm from the
flat distribution generated according to \vn{%random_engine} is
needed.  \vn{%random_gauss_converter} selects the algorithm. The
\vn{"exact"} conversion uses an exact conversion. The \vn{"quick"}
method is somewhat faster than the \vn{"exact"} method but not as accurate.
With either conversion method, if \vn{%random_sigma_cutoff} is set to a positive number,
this limits the maximum sigma generated. 
  \item[\%n_parcicle] \Newline
Number of random particles generated per bunch.
  \item[\%renorm_center, \%renorm_sigma] \Newline 
If set to True, these components will ensure that the actual beam center 
and sigmas will correspond to the input values. 
Otherwise, there will be fluctuations due to the finite number of 
particles generated. 
  \item[\%center_jitter, \%emit_jitter, \%sig_z_jitter, \%sig_e_jitter] \Newline
These components can be used to provide a bunch-to-bunch 
random variation in the emittance and bunch center.
\end{description}

The \vn{%ellipse(:)} array sets the parameters for the 
\vn{ellipse} distribution (\sref{ss:ellipse.init}). 
Each component of this array looks like
\begin{example}
  type ellipse_beam_init_struct
    integer part_per_ellipse  ! number of particles per ellipse.
    integer n_ellipse         ! number of ellipses.
    real(rp) sigma_cutoff     ! sigma cutoff of the representation.
  end type
\end{example}

The \vn{%kv} component of the \vn{beam_init_struct} sets the parameters for the 
Kapchinsky-Vladimirsky distribution (\sref{ss:kv.init})
\begin{example}
  type kv_beam_init_struct
    integer part_per_phi(2)    ! number of particles per angle variable.
    integer n_I2               ! number of I2
    real(rp) A                 ! A = I1/e
  end type
\end{example}

The \vn{%grid} component of the \vn{beam_init_struct} sets the parameters 
for a uniformly spaced grid of particles.
\begin{example}
  type grid_beam_init_struct
    integer n_x        ! number of columns.
    integer n_px       ! number of rows.
    real(rp) x_min     ! Lower x limit.
    real(rp) x_max     ! Upper x limit.
    real(rp) px_min    ! Lower px limit.
    real(rp) px_max    ! Upper px limit.
  end type
\end{example}

The total number particles generated is the product of the individual
distributions. For example:
\begin{example}
  type (beam_init_struct) bi
  bi%distribution_type = ELLIPSE", "ELLIPSE", "GRID"
  bi%ellipse(1)%n_ellipse = 4
  bi%ellipse(1)%part_per_ellipse = 8
  bi%ellipse(2)%n_ellipse = 3
  bi%ellipse(2)%part_per_ellipse = 100
  bi%grid(3)%n_x = 20
  bi%grid(3)%n_px = 30
\end{example}
The total number of particles per bunch will be $32 \times 300 \times
600$. The exception is that when \vn{RAN_GAUSS} is mixed with other
distributions, the random distribution is overlayed with the other distributions
instead of multiplying. For example:
\begin{example}
  type (beam_init_struct) bi
  bi%distribution_type = RAN_GAUSS", "ELLIPSE", "GRID"
  bi%ellipse(2)%n_ellipse = 3
  bi%ellipse(2)%part_per_ellipse = 100
  bi%grid(3)%n_x = 20
  bi%grid(3)%n_px = 30
\end{example}
Here the number of particle is $300 \times 600$. Notice that when
\vn{RAN_GAUSS} is mixed with other distributions, the value of
\vn{beam_init%n_particle} is ignored.

%\item[\%use_t_coords] \Newline If \vn{use_t_coords} is true, then the
distributions are taken as describing particles in $t$-coordinates
(\sref{s:time.phase.space}).  Furthermore, if \vn{use_z_as_t} is true,
then the $z$ coordinates from the distribution will be taken as
describing the time coordinates. For example, particles may originate
at a cathode at the same $s$, but different times.  If false, then the
$z$ coordinate from the distribution describes particles at the same
time but different $s$ positions, and each particle gets
\vn{%location=inside\$}. In this case, the bunch will need to be
tracked with a tracking method that can handle inside particles, such
as \vn{time_runge_kutta}.  All particles are finally converted to
proper $s$-coordinate distributions for Bmad to use.

%-----------------------------------------------------------------
\section{CSR Parameters}
\label{s:csr.params}
\index{csr parameters|hyperbf}

The Coherent Synchrotron Radiation (CSR) calculation is discussed in
Section~\sref{s:csr}. Besides the parameters discussed below, the
\vn{coherent_synch_rad_on} parameter in Section~\sref{s:bmad.params}
must be set True to enable the CSR calculation.

The CSR parameter structure has a \vn{type name}
of \vn{csr_parameter_struct} and an \vn{instance name} of \vn{csr_param}.
This structure has components
\begin{example}
  type csr_parameter_struct 
    real(rp) ds_track_step = 0        ! Tracking step size
    real(rp) beam_chamber_height = 0  ! Used in shielding calculation.
    real(rp) sigma_cutoff = 0.1       ! Cutoff for the lsc calc. If a bin sigma
                                      !  is < cutoff * sigma_ave then ignore.
    integer n_bin = 0                 ! Number of bins used
    integer particle_bin_span = 2     ! Longitudinal particle length / dz_bin
    integer n_shield_images = 0       ! Chamber wall shielding. 0 = no shielding.
    logical lcsr_component_on = T     ! Longitudinal csr component
    logical lsc_component_on = T      ! Longitudinal space charge component
    logical tsc_component_on = T      ! Transverse space charge component
    logical small_angle_approx = T    ! Use lcsr small angle approximation?
    logical print_taylor_warning = .true. ! Print Taylor element warning?
  end type
\end{example}
The values for the various quantities shown above are their default values. 

\vn{ds_track_step} is the nominal longitudinal distance traveled by
the bunch between CSR kicks. The actual distance between kicks within
a lattice element is adjusted so that there is an integer number of
steps from steps from the element entrance to the element exit.  This
parameter must be set to something positive otherwise an error will
result. Larger values will speed up the calculation at the expense of
accuracy.

\vn{beam_chamber_height} is the height of the beam chamber in
meters. This parameter is used when shielding is taken into account.
See also the description of the parameter \vn{n_shield_images}.

\vn{sigma_cutoff} is used in the longitudinal space charge (LSC)
calculation and is used to prevent bins with only a few particles in
them to give a large contribution to the kick when the computed
transverse sigmas are abnormally low.

\vn{n_bin} is the number of bins used. The bind width is dynamically
adjusted at each kick point so that the bins will span the bunch
length.  This parameter must be set to something positive. Larger
values will slow the calculation while smaller values will lead to
inaccuracies and loss of resolution. \vn{n_bin} should also not be set
so large that the average number of particles in a bin is too small. 
``Typical'' values are in the range 100 --- 1000.

\vn{particle_bin_span} is the width of a particle's triangular density
distribution (cf.~\sref{s:csr}) in multiples of the bin width. A
larger span will give better smoothing of the computed particle
density with an attendant loss in resolution.

\vn{n_shield_images} is the number of shielding current layers used in
the shielding calculation. A value of zero results in no
shielding. See also the description of the parameter
\vn{beam_chamber_height}. The proper setting of this parameter depends
upon how strong the shielding is. Larger values give better accuracy
at the expense of computation speed. ``Typical'' values are in the
range 0 --- 5.

\vn{lcsr_component_on} toggles on or off the (longitudinal) CSR kick.

\vn{lsc_component_on} toggles on or off the transverse space charge
kick. Currently this calculation is not implemented so this parameter
does not have any affect.

\vn{small_angle_approx} toggles whether the small angle approximation
is used in the calculation. This is generally an excellent
approximation.

\vn{Taylor} map elements (\sref{s:taylor}) that have a finite length
cannot be subdivided for the CSR calculaton. \bmad will ignore any
\vn{taylor} elements present in the lattice but will print a warning
that it is doing so. So suppress the warning, \vn{print_taylor_warning}
should be set to False.

%-----------------------------------------------------------------
\section{DE Optimizer Parameters}
\label{s:de.params}
\index{de optimizer parameters|hyperbf}

The Differential Evolution (\vn{DE}) optimizer is used in nonlinear
optimization problems. This optimizer is based upon the work of Storn
and Price\cite{b:de}. There are a number of parameters that can be
varied to vary how the optimizer works. These parameters are are
contained in a structure named \vn{opti_de_param_struct}. the instance
name is \vn{opti_de_param}.  This structure has components
\begin{example}
                         Default
  real(rp) CR               0.8    ! Crossover Probability.
  real(rp) F                0.8    !
  real(rp) l_best           0.0    ! Percentage of best solution used.
  logical  binomial_cross   False  ! IE: Default = Exponential.
  logical  use_2nd_diff     False  ! use F * (x_4 - x_5) term
  logical  randomize_F      False  !
  logical  minimize_merit   True   ! F => maximize the Merit func.
\end{example}

The "perturbed vector" is
  v = x_1 + l_best * (x_best - x_1) + F * (x_2 - x_3) + F * (x_4 - x_5)
The last term F * (x_4 - x_5) is only used if \vn{use_2nd_diff} = T.

The crossover can be either "Exponential" or "Binary". 
Exponential crossover is what is described in the paper.
With Exponential crossover the crossover parameters from a contiguous block
and the average number of crossover parameters is approximately
    average crossovers $\sim$ min(D, CR / (1 - CR))
where D is the total number of parameters.
With Binary crossover the probability of crossover of a parameter is 
uncorrelated with the probability of crossover of any other parameter and
the average number of crossovers is
    average crossovers = D * CR

\vn{randomize_F} = True means that the F that is used for a given 
generation  is randomly chosen to be within the range 
[0, 2*F] with average F.

%-----------------------------------------------------------------
\section{Programming Common Parameters}
\label{s:prog.com}
\index{programming common parameters}

The \vn{global_common_struct} is meant to hold common parameters that should
not be modified by the user. 
\begin{example}
  type global_common_struct
    logical be_thread_safe = .false.    ! Avoid thread unsafe practices?
  end type
\end{example}

\begin{description}
\item[\vn{\%be_thread_safe}] \Newline
Toggle to prevent non thread safe calculational optimizations from
being done.  Currently, converting \bmad to be thread safe is an
active project. Please contact the \bmad maintainers for more details.
\end{description}
