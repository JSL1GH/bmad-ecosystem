\chapter{Tao Concepts}
\label{c:concepts}

\tao stands for ``Tool for Accelerator Optics''. \tao is a general
purpose program for simulating high energy particle beams in
accelerators and storage rings. This manual assumes you are already
familiar with the basics of particle beam dynamics and its
formalism. There are several books that introduce the topics very
well. A good place to start is, for example, \textit{The Physics of Particle
Accelerators} by Klaus Wille\cite{b:wille}.

\index{bmad}
\tao is based on the \bmad\cite{b:bmad} subroutine library. An
understanding of the nitty-gritty details of the routines that
comprise \bmad is not necessary, however, one should be familiar with
the conventions that \bmad uses and this is covered in the \bmad
manual.

So, what is \tao good for? A large variety of applications: Single and
multiparticle tracking, lattice simulation and analysis, lattice
design, machine commissioning and correction, etc. Furthermore, it is
designed to be extensible using interface ``hooks'' built into the
program.  This versatility has been used, for example, to enable \tao
to directly read in measurement data from Cornell's Cesr storage ring
and Jefferson Lab's FEL. Think of \tao as an accelerator design and
analysis environment. But even without any customizations, \tao will
do much analysis.

This chapter discusses how \tao is organized. After you are familiar
with the basics of \tao, there is a hands-on tutorial in
Chapter~\sref{c:tutorial}. After you get more familiar with \tao, you
might be interested to exploit its versatility by extending \tao to do
custom calculations. For this, see Chapter~\ref{c:custom.tao}.

%----------------------------------------------------------------
\section{The Organization of Tao: The Super\_Universe}
\label{s:organization}
\index{super_universe}

Many simulation problems fall into one of three categories: 
\begin{itemize}
\item 
Design a lattice subject to various constraints.
\item
Simulate errors and changes in machine parameters. For example, you want to
simulate what happens to the orbit, beta function, etc., when you change
something in the machine. 
\item 
Simulate machine commissioning including simulating data measurement and
correction. For example, you want to know what steering strength changes will
make an orbit flat.
\end{itemize}
Programs that are written to solve these types of problems have common
elements: You have variables you want to vary in your model of your
machine, you have "data" that you want to view, and, in the first two
categories above, you want to match the machine model to the data (in
designing a lattice the constraints correspond to the data).

With this in mind, \tao was structured to implement the essential
ingredients needed to solve these simulation problems.  
The information that \tao knows about can be divided into five
(overlapping) categories:
\begin{description}
  \index{lattice}
  \item[Lattice] \Newline   
Machine layout and component strengths, and the beam orbit (\sref{s:lattice}).
  \index{data}
  \item[Data] \Newline
Anything that can be measured.
For example: The orbit of a particle or the lattice beta 
functions, etc. (\sref{c:data})
  \index{variable}
  \item[Variables] \Newline
Essentially, any lattice parameter or initial condition that can be varied.
For example: quadrupole strengths, etc. (\sref{s:var}).
  \index{plotting}
  \item[Plotting]  \Newline
Information used to draw graphs, display the lattice 
floor plan, etc. (\sref{s:plotting}).
  \index{global parameters}
  \item[Global Parameters] \Newline
 \tao has a set of parameters to control every aspect of how it behaves from
the random number seed \tao uses to what optimizer is used for fitting data.
\end{description}

%------------------------------------------------------------------------
\section{The Super\_universe}
\label{s:super.uni}
\index{super_universe|hyperbf}

\index{structure|hyperbf}
The information in \tao deals is organized in a hierarchy of
\vn{``structures''}. At the top level, everything known to \tao is
placed in a single structure called the \vn{super_universe}.

\index{universe}
\index{variable}
Within the \vn{super_universe}, lies one or more \vn{universes}
(\sref{s:universe}), each \vn{universe} containing a particular
machine lattice and its associated data. This allows for the user to
do analysis on multiple machines or multiple configurations of a
single machine at the same time. The \vn{super_universe} also contains
the \vn{variable}, \vn{plotting}, and \vn{global parameter} information.

%------------------------------------------------------------------------
\section{The Universe}
\label{s:universe}
\index{universe|hyperbf}

\index{lattice}\index{design lattice}\index{model lattice}
\index{base lattice}\index{data}\index{super_universe}
The \tao \vn{super_universe} (\sref{s:super.uni}) contains one or
more \vn{universes}.  A \vn{universe} contains a \vn{lattice}
(\sref{s:lattice}) plus whatever data (\sref{c:data}) one wishes to
study within this lattice (i.e. twiss parameters, orbit, phase,
etc.). Actually, there are three lattices within each universe: the
\textbf{design} lattice, \textbf{model} lattice and \textbf{base}
lattice. Initially, when \tao is started, all three lattices are
identical and correspond to the lattice read in from the lattice
description file (\sref{s:init.lat}).

There are several situations in which multiple universes are
useful. One case is where there are multiple machines. For example, a
transfer line connected to a storage ring. In this case, one universe
will correspond to the transfer line and another universe will
correspond to the storage ring. 

Another case where multiple universes are useful is where data has
been taken under different machine conditions. For example, suppose
that a set of beam orbits have been measured in a storage ring with
each orbit corresponding to a different steering element being set to some
non-zero value. To determine what
quadrupole settings will best reproduce the data, multiple universes can be
setup, one universe for each of the orbit measurements. Variables can be
defined to simultaneously vary the corresponding quadrupoles in each
universe and \tao's built in optimizer can vary the variables until
the data as determined from the \vn{model} lattice (\sref{s:lattice})
matches the measured data. This \vn{orbit response matrix} (ORM) analysis
is, in fact, a widely used procedure at many laboratories.

If multiple universes are present, it is important to be able to
specify, when issuing commands to tao and when constructing \tao
initialization files, what universe is being referred to when
referencing parameters such as data, lattice elements or other stuff
that is universe specific. [Note: \tao variables are {\em not}
universe specific.]

the syntax used to specify a particular universe or range of universes
is attach a prefix of the form:
\begin{example}
  [<universe_range>]@<parameter>
\end{example}
Commas and colons can be used in the syntax for \vn{<universe_range>},
similar to the \vn{element list} format used to specify lattice
elements (\sref{s:ele.list.format}).  When there is only a single
Universe specified, the brackets \vn{[...]} are optional. When the
universe prefix is not present, the current ``viewed'' (default)
universe (\sref{s:view}) is assumed. The current \vn{viewed} universe
can also be specified using the number \vn{-1}. Additionally, a
``\vn{*}'' can be used as a wild card to denote all of the
universes. Examples:
\begin{example}
  [2:4,7]@orbit.x ! The \vn{orbit.x} data in universes 2, 3, 4 and 7.
  [2]@orbit.x     ! The \vn{orbit.x} data in universe 2. 
  2@orbit.x       ! Same as "2@orbit.x".
  orbit.x         ! The \vn{orbit.x} data in the current viewed universe.
  -1@orbit.x      ! Same as "orbit.x".
  *@orbit.x       ! orbit.x data in all the universes.
  *@*             ! All the data in all the universes. 
\end{example}

%------------------------------------------------------------------------
\section{Lattices}
\index{lattice|hyperbf}
\label{s:lattice}

\index{design lattice}\index{model lattice}
\index{base lattice}
A \vn{lattice} consists of a machine description (the strength and
placement of elements such as quadrupoles and bends, etc.), along with the
beam orbit through them. There are actually three types of lattices:
  \vspace*{-3ex}
  \begin{description}
  \index{design lattice|hyperbf}
  \item[Design Lattice] \Newline 
The \vn{design} lattice corresponds to the lattice read in from the
lattice description file(s) (\sref{s:init.lat}). In many instances, this
is the particular lattice that one wants the actual physical machine
to conform to. The \vn{design} lattice is fixed. Nothing is allowed to
vary in this lattice.
  \index{model lattice|hyperbf}
  \item[Model Lattice] \Newline
Except for some commands that explicitly set the \vn{base} lattice,
all \tao commands to vary lattice variables vary quantities in the
\vn{model} lattice. In particular, things like orbit correction
involve varying \vn{model} lattice variables until the \vn{data},
as calculated from the \vn{model}, matches the \vn{data} as actually measured.
  \index{base lattice|hyperbf}
  \index{base lattice!using set command}
  \item[Base Lattice] \Newline
It is sometimes convenient to designate a reference lattice so that
changes in the \vn{model} from the reference point can be examined.
This reference lattice is called the \vn{base} lattice. The \vn{set}
command (\sref{s:set}) is used to transfer information from the
\vn{design} or \vn{model} lattices to the base lattice.
  \end{description}

%------------------------------------------------------------------------
\section{Variables}
\label{s:var}
\index{variables}

\index{change command}
\index{optimizer!variables}
For the \vn{model} lattice (or lattices if there are multiple
\vn{universes}) the \vn{change} command (\sref{s:change}) can be used
to vary lattice parameters such as element strengths, the initial
Twiss parameters, etc.  Additionally, \vn{variables} can be defined
in the \tao initialization files (\sref{s:init.var})
that can also be used to vary these \vn{model} lattice parameters.  
A given \tao variable may control a single attribute of one element 
in one or more universes.  
There are a few reasons why one would want to setup such variables.
For example, the optimizer (\sref{s:optimizer}) will only work with
\tao variables and blocks of these variables can be plotted for visual
inspection.

\index{variables!v1_var}
Blocks of variables are associated with what is called a \vn{v1_var}
structure and each of these structures has a \vn{name} with which to
refer to them in \tao commands. For example, if \vn{quad_k1} is the
name of a \vn{v1_var}, then \vn{quad_k1[5]} referees to the variable 
with index 5 in the block. 

A set of variables within a \vn{v1_var} block
can be referred to by using using a comma \vn{,} to
separate their indexes. Additionally, a Colon \vn{:} can be use to
specify a range of variables. For example
\begin{example}
  quad_k1[3:6,23]
\end{example}
refers to variables 3, 4, 5, 6, and 23. Instead of a number, the
associated lattice element name can be used so if, in the above
example, the lattice element named \vn{q01} is associated with
\vn{quad_k1[1]}, etc., then the following is equivalent:
\begin{example}
  quad_k1[q03:q06,q23]
\end{example}
Using lattice names instead of numbers is not valid if the same
lattice element is associated with more than one variable in a
\vn{v1_var} array. This can happen, for example, if one variable controls
an element's \vn{x_offset} and another variable controls the same element's
\vn{y_offset}. 

In referring to variables, a ``\vn{*}'' can be used as a wild card to 
denote ``all''. Thus:
\begin{example}
  *                ! All the variables
  quad_k1[*]|model ! All model values of quad_k1.
  quad_k1[]|model  ! No values. That is, the empty set.
  quad_k1|model    ! Same as quad_k1[*]|model
\end{example}

A given variable may control a single attribute of one element in a
\vn{model} lattice of a single universe or it can be configured to
simultaneously control an element attribute across multiple
universes. Any one variable cannot control more than one attribute of
one element. However, a variable may control an overlay or group
element which, in turn, can control numerous elements.

Each individual variable has a number of values associated with it:
  \vspace*{-3ex}
  \index{variable!measured}\index{variable!reference}
  \index{variable!model}\index{variable!design}\index{variable!base}
  \begin{description}
  \item[Measured Value] \Newline
The Value as obtained at the time of the \vn{data} measurement.
  \item[Reference Value] \Newline
The Value as obtained at the time of the \vn{reference} data  measurement.
  \item[Model Value] \Newline
The value as given in the \vn{model} lattice.
  \item[Design Value] \Newline
The value as given in the \vn{design} lattice.
  \item[Base Value] \Newline
The value as given in the \vn{base} lattice.
  \end{description}
These components and others can be refereed to using the notation
\vn{|name} where \vn{name} is the appropriate name for the
component. The list of components that can be set or refereed to are:
\begin{example}
  quad_k1[1]|meas       ! Value at time of data measurement
  quad_k1[1]|ref        ! Value at time of the reference data measurement
  quad_k1[1]|model      ! Value in the model lattice
  quad_k1[1]|base       ! Value in the base lattice
  quad_k1[1]|design     ! Value in  the design lattice
  quad_k1[1]|weight     ! Weight used in the merit function.
  quad_k1[1]|old        ! Scratch value.
  quad_k1[1]|step       ! For fitting/optimization: What is considered a small change.
  quad_k1[1]|exists     ! Logical
  quad_k1[1]|good_var   ! Logical
  quad_k1[1]|good_user  ! Logical
  quad_k1[1]|good_opt   ! Logical
  quad_k1[1]|good_plot  ! Logical
  quad_k1[1]|useit_opt  ! Logical
  quad_k1[1]|useit_plot ! Logical

\end{example}

Use the \vn{show var} (\sref{s:show}) command to view variable information

When using optimization for lattice correction or lattice design
(\sref{c:opti}), Individual datums can be excluded from the process
using the \vn{veto} (\sref{s:veto}), \vn{restore} (\sref{s:restore}),
and \vn{use} (\sref{s:use}) commands. These set the \vn{good_user}
component of a datum. This, combined with the setting \vn{exists},
\vn{good_var}, and \vn{good_opt} determine the setting of
\vn{useit_opt} which is the component that determines if the datum is
used in the computation of the merit function. The settings of
everything but \vn{good_user} is determined by \tao


%-----------------------------------------------------------------
\section{Element List Format}
\label{s:ele.list.format}

The syntax for specifying a set of lattice elements is called
\vn{element list} format. Each item of the list is one of:
\begin{center}
\begin{tabular}{ll}
  {\it Item Type} & {\it Example} \\ \hline     
  An element name.                                & "5@q*"               \\
  An element index.                               & "23", "2>>183"       \\
  A range of elements.                            & "b23w:67"            \\
  A class::name specification.                    & "sbend::b*"          \\
\end{tabular}
\break

\end{center}
Items in a list are separated by a blank character or a comma. Example:
\begin{example}
  23, 45:74 quad::q*
\end{example}

An element name item is the name of an element or elements. The
wild card characters ``*'' and/or ``\%'' can be used. The ``*''wildcard
matches any number of characters, The ``\%'' wildcard matches a single
character. For example, ``q\%1*'' matches any element whose name
begins with ``q'' and whose third character is ``1''.  If there are
multiple elements in the lattice that match a given name, all such
elements are included. Thus ``d12'' will match to all elements of that
name. Element names may be prefixed by the universe number followed by
the ``\vn{\@}'' sign. If a universe is not specified, the current universe
is used. Examples
\begin{example}
  "5@q*"       ! All elements whose name begins with "q" of universe 5.
  "*@sex10w"   ! Element "sex10w" of all universes.
  "b37"        ! Element "b37" of the current universe.
  "0@b37"      ! Same as the previous example.
\end{example}
Note: element names are {\em not} case sensitive.

An element index item is simply the index of the number in the lattice
list of elements. A prefix followed by the string ">>" can be used to
specify a branch. As with element names, a universe prefix can be 
given. Example
\begin{example}
  2@2>>183   ! Element number 183 of branch \# 2 of universe 2.
\end{example}

A range of elements is specified using the format:
\begin{example}
  \{<class>::\}<ele1>:<ele2>
\end{example}
\vn{<ele1>} is the element at the beginning of the range and
\vn{<ele2>} is the element at the end of the range. Either an element
name or index can be used to specify \vn{<ele1>} and \vn{<ele2>}. Both
\vn{<ele1>} and \vn{<ele2>} are part of the range. The optional \vn{<class>} 
prefix can be used to select only those elements in the range that match the class.
Example:
\begin{example}
  quad::sex10w:sex20w
\end{example}
This will select all quadrupoles between elements \vn{sex10w} and \vn{sex20w}.

\index{class::name}
A \vn{class::name} item
selects elements based upon their class (Eg: \vn{quadrupole},
\vn{marker}, etc.), and their name. The syntax is:
\begin{example}
  <element class>::<element name>
\end{example}
where \vn{<element class>} is an element class and \vn{<element
name>} is the element name that can (and generally does) contain the wild card characters
``\%'' and ``*''. Essentially this is an extension of the \vn{element name}
format. As with element names, a universe prefix can be 
given. Example:
\begin{example}
  "4@quad::q*"   ! All quadrupole whose name starts with "q" of universe 4.
\end{example}

%------------------------------------------------------------------------
\section{Arithmetic Expressions}
\index{arithmetic Expressions}
\label{s:arithmetic}

\tao is able to handle arithmetic expressions within commands
(\sref{c:command}) and in strings in a \tao initialization file.
Arithmetic expressions can be used in a place where a real value or an
array of real values are required.  The standard operators are
defined: \hfil\break \hspace*{0.15in}
\begin{tabular}{ll}
  $a + b$           & Addition        \\
  $a - b$           & Subtraction     \\
  $a \, \ast \, b$  & Multiplication  \\
  $a \; / \; b$     & Division        \\
  $a \, \land \, b$ & Exponentiation  \\
\end{tabular} \newline
The following intrinsic functions are also recognized: \hfil\break
\index{intrinsic functions}
\hspace*{0.15in}
\begin{tabular}{ll}
  \vn{sqrt}(x)      & Square Root    \\
  \vn{log}(x)       & Logarithm      \\
  \vn{exp}(x)       & Exponential    \\
  \vn{sin}(x)       & Sine           \\
  \vn{cos}(x)       & Cosine         \\
  \vn{tan}(x)       & Tangent        \\
  \vn{asin}(x)      & Arc sine       \\
  \vn{acos}(x)      & Arc cosine     \\
  \vn{atan}(x)      & Arc Tangent    \\
  \vn{abs}(x)       & Absolute Value \\
  \vn{ran}()        & Random number between 0 and 1 \\
  \vn{ran_gauss}()  & Gaussian distributed random number with unit RMS \\
\end{tabular} \newline
Both \vn{ran} and \vn{ran_gauss} use a seeded random number generator. 
Setting the seed is described in Section~\sref{s:globals}.

Data (\sref{s:data.org}) and variable values
(\sref{s:var}), along with lattice parameters can be
referenced in expressions. The general form of a term for
data and variables is
\begin{example}
  \{[<universe(s)>]@\}<source>::<var_or_dat_name>[<index_list>]\{|<component>\}
\end{example}
For lattice and beam parameters the format is
\begin{example}
  \{[<universe(s)>]@\}<source>::<param_name>[\{<ref_element>&\}<element_list>]\{|<component>\}
\end{example}
And for element parameters the format is
\begin{example}
  \{<universe_range>@\}ele::<element_list>[<param_name>]\{|<component>\}
  \{<universe_range>@\}ele_mid::<element_list>[<param_name>]\{|<component>\}
\end{example}
\vn{lat::} will evaluate the parameter at the exit end of the element and 
\vn{lat_mid::} will evaluate the parameter at the middle of the element.
The components of this syntax are:
\begin{example}
  <universe_range>    Optional universe specification (\sref{s:universe})
  <var_or_dat_name>   Variable or data name.
  <source>            Source of the data.
  <param_name>        Name of the parameter, datum, or variable.
  <index_list>        List of indexes.
  <ref_point>         Optional reference element (with lat or beam source only).
  <eval_points>       Evaluation point or points.
  <component>         Optional component. 
\end{example}
Examples:
\begin{example}
  3@lat::orbit.x[34:37]          Array of orbits at element 34 through 37 in universe 3.
  3@lat::orbit.x[34]|model       Orbit.x model value at element 34
  3@ele::34[orbit_x]             Same as above. 
  beam::sigma.x[q10w]            Beam sigma at element q10w.
  beam::n_particle_loss[2&56]    Particle loss between elements 2 and 56.
  3@lat::quad::q*[k1]            k1 of all quads in the model lattice of universe 3 
                                   with names beginning with "q".
  lat::3[l]|design               Length of the design lattice element #3 
                                   in the viewed universe.
  dat::orbit.x[2:7,8]|model
\end{example}

The \vn{<source>} field may be one of:
\begin{example}
  beam        Value is from beam tracking.
  dat         Value is from a \tao datum in a data array (\sref{s:data.org}).
  ele         Value at exit end of element.
  ele_mid     Value at middle of element.
  lat         Value is from the lattice.
  var         Value is from a \tao variable (\sref{s:var}).
\end{example}

When a term has a \vn{dat} source, The value of the term comes from a 
data structure. With a \vn{dat} source, \vn{<var_or_dat_name>} is the name
of a \vn{d2_name.d1_name} data array (\sref{s:data.org}) and 
\vn{<index_list>} is a list of indexes. \vn{<index_list>} will determine
how many elements are in the array. For example, \vn{orbit.x[10:21,44]} 
represents an array of 13 elements. Finally, the optional \vn {<component>}
indicates what component of the datum is to be used. Possible components are
listed in Section~\sref{s:datum.values}. The default is \vn{model}.

When a term has a \vn{var} source, the value of the term comes from a
\tao variable (\sref{s:var}). With a \vn{var} source,
\vn{<var_or_dat_name>} is the name of a \vn{v1_var} variable array. Like
terms with a \vn{dat} source, \vn{<index_list>} is a list of indexes.
The optional \vn{<component>} indicates what component of the variable
is to be used. Possible components are listed in Section~\sref{s:var}.
The default is \vn{model}.

% Note: when combining components from the same \vn{dat} or \vn{var} source
% in an expression, the common prefix can be eliminated. 
% For example
% \begin{example}
%   orbit.x[2:7,8]|model - 2*orbit.x[2:7,8]|meas
% \end{example}
% is equivalent to
% \begin{example}
%   orbit.x[2:7,8]|model - 2*meas
% \end{example}

When a term has a \vn{lat} or \vn{beam} source, the value of the term
comes from evaluation of the lattice or beam tracking. The
\vn{<param_name>} will be a datum type from Table~\ref{t:data.lattice}
with a \vn{lat} source and Table~\ref{t:data.beam} for a \vn{beam}
source. Element list format (\sref{s:ele.list.format}) is used for the
\vn{element_list}. In this case, a universe specification is not
allowed as part of the element list. For example, the following is not
allowed
\begin{example}
  lat::orbit.x[3@q10w]    ! Bad syntax
\end{example}
The correct syntax is
\begin{example}
  3@lat::orbit.x[q10w]    ! Good syntax
\end{example}

The optional \vn{<ref_element>} specifies a reference
element for the evaluation. For example
\begin{example}
  lat::r.56[q0\&qa:qb]
\end{example}  
is an array of the $r(5,6)$ matrix element of the transport map
between element \vn{q0} and each element in the range from element
\vn{qa} and \vn{qb}. The optional \vn{<component>} indicates what
lattice is to be used. Possible components are
\begin{example}
  model (default)
  base
  design
\end{example}
The default is \vn{model}.

Notice the difference between, say, ``\vn{lat::orbit.x[10]}'' and
``\vn{dat::orbit.x[10]}''. With the ``\vn{lat::}'' source, the element 
index, in this case \vn{10}, refers to the 10th lattice element. With the
``\vn{dat::}'' source, ``\vn{10}'' refers to the 10\Th element in
the \vn{orbit.x} data array which may or may not correspond to the
10\Th lattice element and which may not even refer to orbit data.

Due to historical circumstances, the notation is a bit different for
terms with an \vn{ele} or \vn{ele_mid} source as opposed to terms with
a \vn{lat} or \vn{beam} source. With \vn{ele} or \vn{ele_mid}, the
\vn{<element_list>} comes before the \vn{<param_name>}. Additionally,
With \vn{ele} or \vn{ele_mid}, the \vn{<param_name>} uses the \bmad
naming convention as opposed to the \tao convention. For example, the
\tao name for the horizontal orbit is \vn{orbit.x} while the \bmad
name is \vn{orbit_x}.

Logical attributes of an element can be referred to. For example,
``\vn{ele::Q01W[is_on]}'' gives the on/off status of element
\vn{Q01W}. If used in an expression, True values are converted to a
value of \vn{1} and False value are converted to \vn{0}.

the value of the term comes from an element parameter such as the
element strength.  Element list format (\sref{s:ele.list.format}) is
used for the \vn{<element_list>} so an array of elements can be
defined.  The optional \vn{<component>} indicates what lattice is to
be used and is the same as for terms with a \vn{lat} or \vn{beam}
source (see above).

Generally, if the \vn{<source>} field is not present, for example, 
``\vn{orbit.x[10]}'', \tao will search 
for a match assuming that the source is either \vn{dat} or \vn{var}. 
Exceptions will be noted in the manual.


%------------------------------------------------------------------------
\section{Plotting}\index{plotting}
\label{s:plotting}

\begin{figure}[tb]
  \centering
  \includegraphics{plot.pdf}
  \caption[A plot has a collection of graphs.]
{A plot has a collection of graphs and a graph has a 
collection of curves. A plot becomes visible when it is associated
with some region on the page using the \vn{place} command. Note that
on the actual page the plot/region border is not visible.}
  \label{f:plot}
\end{figure}

Some definitions:
  \vspace*{-3ex}
\begin{description}
\index{curve|hyperbf}
\item[Curve] \Newline
A \vn{curve} is a set of (x,y) points to be plotted.
\index{graph|hyperbf}
\item[Graph] \Newline
A \vn{graph} consists of horizontal and vertical axes along with a set
of \vn{curve}s that are plotted within the graph. 
\index{plot|hyperbf}
\item[Plot] \Newline
A \vn{plot} is essentially a collection of \vn{graphs}.
\index{page|hyperbf}
\item[Page] \Newline
The \vn{page} refers to the X11 window where graphics are displayed or the 
corresponding printed graphics page.
\index{region}
\item[Region] \Newline
The \vn{page} is divided up into a number of rectangles called
\vn{regions}. \vn{Regions} may overlap.
\end{description}

\index{template plot}\index{region}\index{place command}
\index{plot!initialization file}
The plot initialization file (cf.~Chapter~\ref{c:init}) defines a set
of \vn{template plots}. A \vn{template} defines what type of data is
to be plotted (orbit, beta function, etc.), how many \vn{graphs} there are,
what the scales are for the \vn{graph} axes, how the \vn{graph}s are
laid out, etc.  The plot initialization file also defines a set of
\vn{region}s within the \vn{page}. Any \vn{template plot} can be
placed in any region. Using the \vn{place} command (see
Chapter~\ref{c:command} for a full descriptions of all commands) one
can assign a particular \vn{template plot} to a particular region for
plotting.  The relationship between \vn{region}, \vn{plot},
\vn{graph}, and \vn{curve} is shown graphically in
Figure~\ref{f:plot}.

Figures~\ref{f:plot.page1} and \ref{f:plot.page2} show examples of a
plot \vn{page}. Figure~\ref{f:plot.page1} was generated by defining
two regions called \vn{top} and \vn{bottom} in the plot initialization
file. The \vn{top} region was defined to cover the upper half of the
\vn{page} and the \vn{bottom} region was defined to cover the bottom
half. \vn{Template plots} were defined to plot phase and orbit data
from a defined set of detector elements in the lattice. Each
\vn{template plot} defined two graphs which in both cases where
assigned the names \vn{x} and \vn{y}. The orbit \vn{template plot} was
placed in the \vn{top} region and the phase \vn{template plot} was
placed in the \vn{bottom} region. The horizontal axis numbering is by
detector \vn{index}.  Displayed plots are referred to by the
\vn{region} name (\vn{top} and \vn{bottom} in this case). Individual
graphs and curves are referred to using the nomenclature
\vn{region.graph.curve}. Thus, in this example, the horizontal orbit
graph would be referred to as \vn{top.x}.  Using the \vn{plot} command
one can then specify what \vn{components} are plotted. \vn{component}
refers to \vn{measured}, \vn{reference}, \vn{model}, \vn{base}, and/or
\vn{design} data.  Notice that the same \vn{template plot} can be
assigned to different \vn{regions} and the plots in different
\vn{regions} can have different scales for their axes or different
\vn{components}. In the example in Figure~\ref{f:plot.page1}, the
\vn{component} for the \vn{top} plot is \vn{model} and for the
\vn{bottom} plot it is \vn{model - design}.

Plots may be referred to by their template name or by the name of the
region they are placed in. For example, the orbit plot in
Figure~\ref{f:plot.page1} may be referred to using the region name
(\vn{top}) or the template name (\vn{orbit}). A template may be placed
in multiple regions.  For example, you may wish to plot the \vn{model}
data for the orbit in one region and the \vn{design} data for the
orbit in another region. In this case the command \vn{scale orbit}
would scale the plots in both regions while to scale the plot in only
one of the regions you would need to use the region name. 

A graph of a plot is specified using the format
\vn{plot_name.graph_name} where \vn{plot_name} is a template or region
name and \vn{graph_name} is the name of the graph. For example, if the
horizontal orbit graph of the \vn{orbit} plot is named \vn{x} then it
would be referred to as \vn{orbit.x} or \vn{top.x}. If a plot has only
one graph, the graph may be specified by just using the plot name.

A curve within a graph is specified using the format
\vn{plot_name.graph_name.curve_name}. If a graph has only one curve,
the curve may be specified using only the graph name
\vn{plot_name.graph_name}. Additionally, if the there is only one
curve in a plot, the curve can be specified by just using the
\vn{plot_name}.

The \vn{use}, \vn{veto}, \vn{restore}, and \vn{clip} commands are used
to control what data is used in fitting the model to the data in the
optimization process (see Chapter~\ref{c:opti}). The general rule is
that these commands only affect measured and reference data. If
plotting \vn{model}, \vn{design} and/or \vn{base} data then the data
will be displayed irregardless. If plotting \vn{meas} and/or \vn{ref} data
then the data displayed will vary with these commands.  \vn{meas} or
\vn{ref} data vetoed for display is also vetoed for fitting.  However,
measured data that is off the vertical or horizontal scale may still be
used by the optimizer unless vetoed with the \vn{veto} or \vn{clip}
command.  If there are data points off the vertical scale then
``**Limited**'' will appear in the upper right-hand corner of the
graph. If plotting measured data then these points off scale will
still be used by the optimizer.

The \vn{x-axis} and \vn{x-scale} commands are used to set the axis
type and scale for each graph. The axis type can be either \vn{index},
\vn{ele_index} or \vn{s} which corresponds to the data index number,
element index number and longitudinal position in the lattice (from
element 0) respectively.

Figure~\ref{f:plot.page2} shows another example of a plot \vn{page}.
In this case the \vn{page} was generated by again defining two
vertically stacked regions but in this case the regions have different
heights.  A \vn{template plot} with a single graph was placed in the
bottom most \vn{region}.  This \vn{graph} contains a \vn{key_table}.
A \vn{key_table} is used in conjunction with \vn{single mode} and is
explained in Chapter~\ref{c:single}. A \vn{template plot} containing
five \vn{graphs} was placed in the uppermost region. The uppermost
\vn{graph} of this \vn{template plot} contains a \vn{lat_layout} which
shows the placement of lattice elements.  What elements are displayed
in a \vn{lat_layout} and what shapes they are represented by is
specified in the initialization file. The horizontal scale is
longitudinal position (\vn{s}).  The remaining four graphs show
dispersion and beta data from two different universes representing the
low energy and high energy transport in an energy recovery linac. The
individual data points here (hard to see in this example) have been
slaved to the \vn{lat_layout} and represent the beta and dispersion at
the edges of the displayed elements in the \vn{lat_layout}.


\begin{figure}
  \centering
  \includegraphics[width=5in]{plot-page1.pdf}
  \caption{Example of a plot page}
  \label{f:plot.page1}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=5in]{plot-page2.pdf}
  \caption{Another example of a plot page.}
  \label{f:plot.page2}
\end{figure}

\vfill
\break
%------------------------------------------------------------------------
\section{Single Character Input}
\index{single Mode}

Sometimes it is convenient to be able to vary variables using single
key strokes without having to type a carriage return.  With \tao, this
is possible using what is called \vn{single mode}. This is distinct
from \vn{line mode} where commands to \tao are typed at the command
line with a carriage return signaling the end of the command. 

The \vn{single mode} initialization file associates variables with
certain keyboard keys so that when these keys are pressed the value of
the variable is varied. This association between variables and keys is
called a \vn{key table}. See Chapter~\sref{c:single} for more details.

%------------------------------------------------------------------------
\section{Aliases and Command Files}
\label{s:command.files}
\index{command Files}
\index{alias}

Typing repetitive commands can become tedious. \tao has two constructs
to mitigate this: Aliases and Command Files. Aliases are just like
aliases in Unix. See Section~\sref{s:alias} for more details.

Command files are like Unix shell scripts. A series of commands are
put in a file and then that file can be called using the \vn{call}
command (\sref{s:call}).

Do loops are allowed with the following syntax:
\begin{example}
  do <var> = <begin>, <end> \{, <step>\} 
    ...
    tao command [[<var>]]
    ...
  enddo
\end{example}
The \vn{<var>} can be used as a variable in the loop body but must be
bracketed ``[[<var>]]''.  The step size can be any integer positive or
negative but not zero.  Nested loops are allowed and command files can
be called within do loops.

\begin{example}
  do i = 1, 100
    call set_quad_misalignment [[i]] ! command file to misalign quadrupoles
    zero_quad 1e-5*2^([[i]]-1) ! Some user supplied command to zero quad number [[i]]
  enddo
\end{example}

To reduce unnecessary calculations, the logicals \vn{global%lattice_calc_on}
and \vn{global%plot_on} can be toggled from within the command file. Example
\begin{example}
  set global lattice_calc_on = F  ! Turn off lattice calculations
  set global plot_on = F          ! Turn off plot calculations
  ... do some stuff ...
  set global plot_on = T          ! Turn back on 
  set global lattice_calc_on = T  ! Turn back on
\end{example}
Additionally, the \vn{global%command_file_print_on} switch controls
whether printing is suppressed when a command file is called.

A \vn{end-file} command (\sref{s:end.file}) can be used to signal the
end of the command file.

The \vn{pause} command (\sref{s:pause}) can be used to temporarily
pause the command file.

%------------------------------------------------------------------------
\section{Tracking Types}
\index{tracking!types}

\index{track_type}
\index{tao_global_struct}
\index{global%track_type}
The are two types of tracking implemented in \tao: single particle
tracking and many particle multi-bunch tracking.  Single particle
tracking is just that, the tracking of a single particle through the
lattice. Many particle multi-bunch tracking creates a Gaussian
distribution of particles at the beginning of the lattice and tracks
each particle through the lattice, including any wakefields.  Single
particle tracking is used by default. The \vn{global%track_type}
parameter (\sref{s:globals}), which is set in the initialization file,
is used to set the tracking.

Particle spin tracking has also been set up for single particle and many
particle tracking. See Sections~\sref{s:globals} and \sref{s:beam.init} for
details on setting up spin tracking.

%------------------------------------------------------------------------
\section{Lattice Calculation}\index{lattice!calculation of}
\label{s:lat.calc}

After each \tao command is processed, the lattice and ``merit''
function are recalculated and the plot window is regenerated. The
merit function determines how well the \vn{model} fits the measured
data. See Chapter~\ref{c:opti} for more information on the merit
function and its use by the optimizer.

Below are the steps taken after each \tao command execution:
\begin{enumerate}
  \item 
The data and variables used by the optimizer are re-determined. This is
affected by commands such as \vn{use, veto,} and \vn{restore} and any
changes in the status of elements in the ring (e.g. if any elements
have been turned off).
  \item 
If changes have been made to the lattice (e.g. variables changed) then
the model lattice for all universes will be recalculated. The
\vn{model} orbit, linear transfer matrices and Twiss parameters are
recalculated for every element. All data types will also be calculated
at each element specified in the initialization file.  For single
particle tracking the linear transfer matrices and Twiss parameters
are found about the tracked orbit. Tracking is
performed using the tracking method defined for each element
(i.e. Bmad Standard, Symplectic Lie, etc...). See the \bmad Reference
manual for details on tracking and finding the linear transfer
matrices and Twiss parameters.
  \item 
The \vn{model} data is recalculated from the \vn{model} orbit, linear
transfer matrices, Twiss parameters, particle beam information and
global lattice parameters.  Any custom data type calculations are
performed \textit{before} the standard \tao data types are calculated.
  \item 
Any user specified data post-processing is performed in
\vn{tao_hook_post_process_data}.
  \item 
The contributions to the merit function from the variables and data are
computed.
  \item 
Data and variable values are transferred to the plotting structures.
  \item 
The plotting window is regenerated.
\end{enumerate}

