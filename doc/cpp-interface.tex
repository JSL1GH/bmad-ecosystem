\chapter{C++ Interface}
\label{c:cpp.interface}
\index{C++ interface}

To ease the task of using C or \cpp routines with \bmad, the \bmad
library defines a set of \cpp classes in one--to--one correspondence
with the major \bmad structures as given in table~\ref{t:class}. In
addition to the \cpp classes, the \bmad library defines a set of
conversion routines to transfer data values between the \bmad Fortran
structures and the corresponding \cpp classes. 

\begin{table}[hb]
\begin{center}
\index{C++ interface!classes}
\begin{tabular}{|l|l|} \hline
{\em Bmad structure}     & {\em \cpp Class}   \\ \hline
  amode_struct           & C_amode            \\ \hline
  bmad_com_struct        & C_bmad_com         \\ \hline
  control_struct         & C_control          \\ \hline
  coord_struct           & C_coord            \\ \hline
  ele_struct             & C_ele              \\ \hline
  em_field_struct        & C_em_field         \\ \hline
  floor_position_struct  & C_floor_position   \\ \hline
  linac_mode_struct      & C_linac_mode       \\ \hline
  lr_wake_struct         & C_lr_wake          \\ \hline
  modes_struct           & C_modes            \\ \hline
  mode_info_struct       & C_mode_info        \\ \hline
  orbit_struct           & C_orbit            \\ \hline
  param_struct           & C_param            \\ \hline
  lat_struct             & C_lat              \\ \hline
  sr_wake_struct         & C_sr_wake          \\ \hline
  taylor_struct          & C_taylor           \\ \hline
  taylor_term_struct     & C_taylor_term      \\ \hline
  twiss_struct           & C_twiss            \\ \hline
  wake_struct            & C_wake             \\ \hline
  wig_term_struct        & C_wig_term         \\ \hline
\end{tabular}
\label{t:class}
\caption{Bmad structures and their corresponding \cpp classes.}
\end{center}
\end{table}

%----------------------------------------------------------------------------
\section{C++ Classes}
\index{C++ interface!classes}

The \cpp classes are defined in a header file \vn{cpp_and_bmad.h}.
Generally, The \cpp classes have been set up to simply mirror the
corresponding \bmad structures. For example, the \vn{C_lat} class has
a string component named \vn{.version} that mirrors the \vn{%version}
component of the \vn{lat_struct} structure. There are some exceptions
here and \vn{getf} (Section \sref{s:getf} can be used to quickly
examine the definition of any \cpp class. Note that while generally
the same component name is used for both the \bmad structures and the
\cpp classes in the case where a component of a structure has a
trailing underscore \vn{_} the corresponding \cpp structure does
not. For example, the analog on the \cpp side of the \vn{%ele_}
component of a \vn{lat_struct} is \vn{.ele}

All of the \cpp arrays and matrices are zero based so that, for
example, the index of the \vn{.vec[i]} array in a \vn{C_coord} runs
from 0 through 5 and not 1 through 6 as on the Fortran side. Notice
that for a \vn{lat_struct} the \vn{%ele(0:)} component has a
starting index of zero so there is no off--by--one problem here.

A header file \vn{bmad_parameters.h} defines corresponding \bmad
parameters for all \cpp routine. The \bmad parameters are in a
namespace called \vn{Bmad}. The convention is that the name of a
corresponding \cpp parameter is obtained by dropping the ending
\vn{\$} (if there is one) and converting to uppercase. For example,
\vn{electron\$} on the Fortran side converts to \vn{Bmad::ELECTRON} in
\cpp. To keep the conversion of the of parameters like \vn{k1\$} which
are used with the \vn{ele%value(0:n_attrib_maxx)} array, the
corresponding \vn{ele.value[]} array has goes from 0 to
\vn{Bmad::N_ATTRIB_MAXX} with the 0th element being unused.

%----------------------------------------------------------------------------
\section{Fortran calling C++}
\index{C++ interface!Fortran calling C++}

\begin{figure}[tb]
\begin{listing}{1}
  subroutine test
    use bmad
    type (lat_struct) lattice   // lattice on Fortran side 
    ! ... setup lattice ...
    call c_wrapper (lattice)    // Pass lattice to C++ routine
  end subroutine
\end{listing}
\caption{Example Fortran routine calling a \cpp routine.}
\label{f:f/fc}
\end{figure}


\begin{figure}
\begin{listing}{1}
  #include "cpp_and_bmad.h"

  external "C" c_wrapper(lat_struct* f_lat) {
    using namespace Bmad;
    C_lat c_lat;          // Lattice on \cpp side 
    f_lat >> c_lat;        // Transfer info: F -> \cpp
    // ... do calculations ...
    cout << c_lat.name << "  " << c_lat.ele[1].value[K1] << endl;
    c_lat >> f_lat;        // Transfer back: C++ -> F
  }
\end{listing}
\caption{Example \cpp routine callable from a Fortran routine.}
\label{f:c/fc}
\end{figure}

A simple example of a Fortran routine calling a \cpp routine is shown
in figures~\ref{f:f/fc} and \ref{f:c/fc}. The Fortran calling routine
simply passes the \vn{lat_struct} structure to the \cpp routine. On
the \cpp side the \cpp routine must be declared as \vn{external "C"} to
make sure the name mangling between \cpp and Fortran is consistent
and to make sure the arguments are passed correctly. Notice that on
the \cpp side the routine name has a trailing underscore \vn{_} while
on the Fortran side it does not. In the \cpp routine the
\vn{lat_struct} argument is declared as a pointer. The
\vn{lat_struct} class on the \cpp side holds no data and is simply
meant as a place holder. There are corresponding ``dummy'' classes for
each \bmad structure. These classes should never be instantiated like:
\begin{example}
  lat_struct lattice;  // Wrong!
\end{example}
The \cpp compiler would not allocate any storage for this variable and
the use of this variable will (hopefully) lead to the program bombing.

The \vn{>{>}} operator on the \cpp side has been overloaded to do the
Fortran to \cpp conversion.  The only exception is with the
\vn{bmad_common_struct} structure where the data on the Fortran side
comes directly from the \bmad \vn{bmad_common_struct} common block.  In
this case no structure variable is passed to the \cpp routine and the
syntax on the \cpp side for transferring this common block data back and
forth looks like:
\begin{example}
    C_bmad_com c_com;      // Variable to hold Bmad common block data
    bmad_com_to_c(c_com); // Load \cpp variable
    bmad_com_to_f(c_com); // Transfer back to common block
\end{example}


%----------------------------------------------------------------------------
\section{C++ calling Fortran}
\index{C++ interface!calling Fortran}

\begin{figure}
\begin{listing}{1}
  #include "cpp_and_bmad.h"
  external "C" void f_wrapper(C_lat&);

  void test () {
    C_lat c_lat;          // lattice on C++ side 
    f_wrapper(c_lat);     // pass lattice to Fortran side
  }
\end{listing}
\caption{Example \cpp routine calling a Fortran routine.}
\label{f:c/cf}
\end{figure}


\begin{figure}
\begin{listing}{1}
  subroutine f_wrapper (c_lat)
    type (c_dummy_struct) c_lat     ! C++ lattice 
    type (lat_struct) f_lat        ! lattice on Fortran side 
    call lat_to_f (c_lat, f_lat)   ! Transfer info: C++ -> F
    ! ... do some calculations ...
    call lat_to_c (f_lat, c_lat)   ! Transfer back: F -> C++
  end subroutine
\end{listing}
\caption{Example Fortran routine callable from a \cpp routine.}
\label{f:f/cf}
\end{figure}

An example of a \cpp routine calling a Fortran routine is shown in
figures~\ref{f:f/cf} and \ref{f:c/cf}. \vn{lat_to_f} and
\vn{lat_to_c} converts between a \vn{lat_struct} and a \vn{C_lat}.
In general the routines names to convert between a \vn{xyz_struct}
structure and a \vn{C_xyz} class are called \vn{xyz_to_f} and
\vn{xyz_to_c} on the Fortran side.  On the \cpp side these routines
get a trailing underscore \vn{_} and are overloaded by the \vn{>{>}}
operator.

In general it is not possible to call an arbitrary Fortran routine
directly from \cpp or vice versa. There are certain restrictions that
Fortran and \cpp routines must observe to be callable from the other
language. In practice this means that to use bmad from a \cpp main
program the interface routine (in this example \vn{f_wrapper}) will be
written in Fortran and the appropriate \bmad routines are called
directly by the interface.



