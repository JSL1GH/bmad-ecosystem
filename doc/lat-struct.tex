\chapter{The lat_struct}
\label{c:lat.struct}
\index{lat_struct|hyperbf}

The \vn{lat_struct} is the structure that holds of all the information
about a lattice. If \vn{branch} (\sref{s:branch}) and/or
\vn{photon_branch} elements (\sref{s:photon.branch}) are part of the
lattice, the \vn{lat_struct} will include the information on the
branching sections as well as the mail lattice.
The components of a \vn{lat_struct} are shown in
Figure~\ref{f:lat.struct} (\sref{s:component}).
\begin{figure}[htb]
\centering
\begin{verbatim}
type lat_struct
  character(16) name                       ! Name in USE statement
  character(40) lattice                    ! Lattice name
  character(80) input_file_name            ! Lattice input file name
  character(80) title                      ! From TITLE statement
  type (mode_info_struct)  a, b, z         ! tunes, etc.
  type (lat_param_struct) param            ! Lattice parameters
  type (ele_struct), pointer :: ele(:)     ! Array of lattice elements
  type (ele_struct) ele_init               ! For use by any program
  type (branch_struct), allocatable :: branch(:)   ! Branch arrays
  type (control_struct), allocatable :: control(:) ! control list
  type (coord_struct) beam_start           ! Starting coordinates.
  integer version                          ! Digested file version number
  integer n_ele_track                      ! elements in tracking lattice
  integer n_ele_max                        ! Index of last element used
  integer n_control_array                  ! last index used in control(:)
  integer n_ic_max                         ! last index used in ic(:) array
  integer input_taylor_order               ! As set in the input file
  integer, allocatable :: ic(:)            ! index to %control(:)
end type
\end{verbatim}
\caption{Definition of the \vn{lat_struct}.}
\label{f:lat.struct}
\end{figure}

%----------------------------------------------------------------------------
\section{Branches in the lat_struct}
\label {s:lat.struct}

\index{lat_struct!\%branch(:)}
\index{branch}\index{photon_branch}
The lattice is divided up into the ``main'' lattice and, if there are
\vn{branch} or \vn{photon_branch} elements, a number of ``branches''. 
To simpllify the bookkeeping, the main lattice is itself considered a branch.

The \vn{%branch(:)} component holds the branch information. Each
element in the \vn{%branch(:)} array holds the information about one
branch. The \vn{%branch(0:)} array is always indexed from 0 with the $0$
branch being the main lattice.  The upper bound of this array will be
the number of \vn{branch} plus \vn{photon_branch} elements present.

The definition of the \vn{branch_struct} structure is
\begin{example}
  type branch_struct
    character(40) name
    integer key                          ! photon_branch$, branch$, etc.
    integer ix_branch                    ! Index in lat%branch(:) array.
    integer ix_from_branch               ! 0 => Main lattice 
    integer ix_from_ele                  ! Index of branching element
    integer, pointer :: n_ele_track      ! Number of tracking elements
    integer, pointer :: n_ele_max
    type (ele_struct), pointer :: ele(:) ! Element array
    type (lat_param_struct), pointer :: param
  end type
\end{example}
\index{key_name}
The \vn{%key} component is set to either \vn{photon_branch\$} or
\vn{branch\$}. The \vn{key_name()} function will convert the integer
key value to a string for printing. The value of the
\vn{%branch(i)%ix_branch} conponent is the branch index \vn{i}. This
can be useful when passing a branch to a subroutine.  The
\vn{%branch(i)%ix_from_branch} component gives the branch index of the
branch that the $i$\Th branch branched off from.
\vn{%branch(i)%ix_from_ele} gives the index in the
\vn{%branch(j)%ele(:)} array of the \vn{branch} or \vn{photon_branch}
element that marks the beginning of the $i$\Th branch.

\index{lat_struct!\%ele(:)}
\index{lat_struct!\%n_ele_track}
\index{lat_struct!\%n_ele_max}
\index{ele_struct!in lat_struct} 
\index{girder}
\index{overlay}
\index{group}
The \vn{%branch%ele(:)} array holds the array of elements in the
branch. Historically, the \vn{lat_struct} was developed at the start
of the \bmad project and branches were implemented well after that. To
maintain compatibility with older code, the \vn{lat%ele(:)} array, which
is used by older code, is pointed to by the \vn{lat%%branch(0)%ele}
array. Similarly, \vn{%branch(0)%n_ele_track},
\vn{%branch(0)%n_ele_max}, and \vn{%branch(0)%param} point to
\vn{lat%n_ele_track}, \vn{lat%n_ele_max}, \vn{lat%param} respectively.

The \vn{%branch%ele(:)} array is always allocated with zero as the
lower bound.  \vn{%ele(0)} is a marker element with the name
\vn{BEGINNING}. \vn{%ele(0)%mat6} is always the unit matrix. For the
main branch (with branch index 0), \vn{%ele(0:)} is divided up into
two parts: The ``tracking'' part and a ``control'' part (also called
the ``lord'' part). The tracking part of this array holds the elements
that are tracked through. The control part holds elements whose
control attributes of other elements (\sref{s:lat.control}). The bounds
of these two parts is given in Table~\ref{t:part.extent}.
\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
              & \multicolumn{2}{c|} {\em index n}         \\ \hline
{\em section} & {\em min}          & {\em max}            \\ \hline
tracking      & 0                  & \vn{%n_ele_track}     \\ \hline
control       & \vn{%n_ele_track}+1 & \vn{%n_ele_max}      \\ \hline
\end{tabular} 
\caption{Bounds of the tracking and control parts 
of the main lattice \vn{\%ele(:)} array.}
\end{center}
\label{t:part.extent}
\end{table}

Non-main lattice branches do not have a lord section and only have a
tracking section. Here \vn{%branch%n_ele_track} and
\vn{%branch%n_ele_max} have the same value.

\index{lat_struct!\%ele_init}
The \vn{%ele_init} component within the \vn{lat_struct} is not used
by \bmad\ and is available for general program use.

%----------------------------------------------------------------------------
\section{Param_struct Component}
\index{lat_param_struct}

The \vn{%param} component within the \vn{lat_struct} is a
\vn{lat_param_struct} structure whose definition is shown in
Figure~\ref{f:lat.param.struct}
\begin{figure}[htb]
\centering
\begin{verbatim}
  type lat_param_struct
    real(rp) n_part             ! Particles/bunch (for BeamBeam elements).
    real(rp) total_length       ! total_length of lattice
    real(rp) growth_rate        ! growth rate/turn if not stable
    real(rp) t1_with_RF(6,6)    ! Full 1-turn 6x6 matrix
    real(rp) t1_no_RF(6,6)      ! Transverse 1-turn 4x4 matrix (RF off).
    integer particle            ! +1 = positrons, -1 = electrons
    integer ix_lost             ! If lost at what element?
    integer end_lost_at         ! entrance_end$ or exit_end$
    integer plane_lost_at       ! x_plane$ or y_plane$
    integer lattice_type        ! linear_lattice$, circular_lattice$, etc...
    integer ixx                 ! Integer for general use
    logical stable              ! is closed lattice stable?
    logical aperture_limit_on   ! use apertures in tracking?
    logical lost                ! for use in tracking
  end type
\end{verbatim}
\caption{Definition of the \vn{param_struct}.}
\label{f:lat.param.struct}
\end{figure}

\index{lat_param_struct!\%total_length}
\vn{%param%total_length} is the length of the lattice that a beam
tracks through
\begin{example}
  %param%total_length = %ele(n_use)%s - %ele(0)%s
\end{example}
Normally \vn{%ele(0)%s} = 0 so \vn{%param%total_length} =
\vn{%ele(n_use)%s} but this is not always the case.

\index{lat_param_struct!\%n_part}
\index{beambeam}
\index{lcavity}
\vn{%param%n_part} is the number of particles in a bunch and is used
by \vn{BeamBeam} element to determine the strength of the beambeam
interaction. \vn{%param%n_part} is also used by \vn{Lcavity} elements
for wake field calculations.

\index{lat_param_struct!\%lost}
\index{lat_param_struct!\%ix_lost}
\index{lat_param_struct!\%end_lost_at}
\index{lat_param_struct!\%aperture_limit_on}
\index{lat_param_struct!\%plane_lost_at}
When tracking particles through a lattice the variable
\vn{%param%aperture_limit_on} determines if apertures are checked.
\vn{%param%lost} is used to signal if a particle is lost and
\vn{%param%ix_lost} gives the index of the element at which a particle
is lost. Additionally, \vn{%param%end_lost_at} is used to indicate at
which end the particle was lost at and \vn{%plane_lost_at} records whether
the lost particle was lost horizontally, vertically or longitudinally.
See Chapter~\ref{c:tracking} for more details.

\index{lat_param_struct!\%t1_with_RF}
\index{lat_param_struct!\%t1_no_RF}
\index{lat_param_struct!\%stable}
\vn{%param%t1_with_RF} and \vn{%param%t1_no_RF} are the 1--turn transfer
matrices from the start of the lattice to the end. \vn{%param%t1_with_RF}
is the full transfer matrix with RF on. \vn{%param%t1_no_RF} is the
transverse transfer matrix with RF off. \vn{%param%t1_no_RF} is used to
compute the Twiss parameters. When computing the Twiss parameters
\vn{%param%stable} is set according to whether the matrix is stable or
not. If the matrix is not stable the Twiss parameters cannot be
computed. If unstable, \vn{%param%growth_rate} will be set to the
growth rate per turn of the unstable mode.  \vn{%param%t1_with_RF} and
\vn{%param%t1_no_RF} are set by various routines. Other routines use
these matrices as input for calculations.

The \vn{lat%branch(0)%param} component points to \vn{lat%param} and
therefore the two are identical. The other \vn{%bunch%param}
components are not currently used.

%----------------------------------------------------------------------------
\section{Pointers}
\label{s:lat:point}
\index{lat_struct!pointers}

Since the \vn{lat_struct} has pointers within it, there is an extra
burden on the programmer to make sure that allocation and deallocation
is done properly. To this end, the equal sign has been overloaded by
the routine \vn{lat_equal_lat} so that when one writes
\begin{example}
    type (lat_struct) lattice1, lattice2
    ! ... some calculations ...
    lattice1 = lattice2
\end{example}
the pointers in the \vn{lat_struct} structures will be handled
properly. The result will be that lattice1 will hold the same
information as \vn{lattice2} but the pointers in \vn{lattice1} will
point to different locations in physical memory so that changes to one
lattice will not affect the other.

Initial allocation of the pointers in a \vn{lat_struct} variable is
generally handled by the \vnr{bmad_parser} and \vn{lat_equal_lat}
routines.  Once allocated, local \vn{lat_struct} variables must have
the save attribute or the pointers within must be appropriately
deallocated before leaving the routine.
\begin{example}
  type (lat_struct), save :: lattice     ! Either do this at the start or ...
  ...
  call deallocate_lat_pointers (lattice) ! ... Do this at the end.
\end{example}
Using the save attribute will generally be faster but will use more
memory. Typically using the save attribute will be the best choice.

%----------------------------------------------------------------------------
\section{Elements Controlling Other Elements}
\label{s:lat.control}

The \vn{ele_struct} elements in the \vn{lat_struct} structure are
divided into two groups: Those that get tracked through, and those
elements, called \vn{lord} elements} that control attributes of other
\vn{ele_struct} elements. Elements so controlled are called \vn{slave}
elements. While \vn{lord} elements are always situated in the
\vn{control} part of the lattice, \vn{slave} elements may appear in
both the \vn{tracking} or \vn{control} parts of the lattice.
The situation is complicated by the fact that a given
element may simultaneously be a \vn{lord} and a \vn{slave}. For
example, an \vn{overlay} is a lord since it controlls attributes of
other elements but an \vn{overlay} can itself be controlled by other
\vn{overlay} and \vn{group} elements.

\index{free}\index{super_lord}
\index{group_lord}\index{girder_lord}
\index{multipass_lord}
Two components of an \vn{ele_struct} determine the line of control:
\vn{ele%lord_status} and \vn{ele%slave_status}. \vn{ele%lord_status}
determines what type of lord the element is. In the tracking part of
the lattice (\sref{s:lat.struct}), \vn{%lord_status} is always set to
\vn{not_a_lord\$}. In the lord section of the lattice, \vn{ele%lord_status}
can be one of:
\index{girder_lord}
\begin{description}
\item[super_lord\$]\Newline 
An element with \vn{%lord_status} set to \vn{super_lord\$ is called a
\vn{super_lord} element. Such an element is created when elements are
superimposed on top of other elements (\sref{s:super}).
  \item[girder_lord\$]\Newline 
An element with \vn{%lord_status} set to \vn{girder_lord\$} is called a
\vn{girder_lord} element (\sref{s:girder}).  Such
an element will also have \vn{ele%key} = \vn{girder\$}. In this case,
the slave elements are marked by setting the \vn{ele%on_a_girder}
component.
  \item[multipass_lord\$]\Newline
\vn{multipass_lord} elements are created when
multipass lines are present (\sref{s:multipass}). 
  \item[overlay_lord\$]\Newline 
An \vn{overlay_lord} is an \vn{overlay} element(\sref{s:overlay}). 
Such an element will also have \vn{ele%key} = \vn{overlay\$}.
  \item[group_lord\$]\Newline 
A \vn{group_lord} is a \vn{group} element (\sref{s:group}). Such
an element will also have \vn{ele%key} = \vn{group\$}.
  \item[not_a_lord\$]\Newline
This lord element does not control anything. This can be sometimes useful
when manipulating lattices but is not generally used.
\end{description}

The \vn{ele%slave_status} component determines what type of slave an element is.
Possible values for \vn{ele%slave_status} are:
\begin{description}
  \item[super_slave\$]\Newline 
A \vn{super_slave} element is an element in the tracking part of the lattice that 
has one or more \vn{super_lord} lords (\sref{s:super}).
  \item[multipass_slave]\Newline
A \vn{multipass_slave} element is the slave of a \vn{multipass_lord}
(\sref{s:multipass}). \vn{multipass_slave} elements are always in the
tracking part of the lattice.
  \item[overlay_slave\$]\Newline 
An \vn{overlay_slave} is an element that has any number of
\vn{overlay_lord} and/or \vn{girder_lord} elements controlling the
slave's attributes.  An \vn{overlay_slave} can also be controlled by
\vn{group_lord} elements.
  \item[group_slave\$]\Newline
A \vn{group_slave} is an element that has one or more \vn{group_lord}
elements controlling controlling the slave's attributes.  A \vn{group_slave} 
will not have any \vn{overlay_lord} or \vn{girder_lord} lords.
  \item[free\$]\Newline
Free elements do not have any lord elements.
\end{description}

How \bmad 

\begin{tabular}{llccccc} 
\hline
& \multicolumn{6){c}{\vn{ele%lord_status}} \\ \hline
\rule{0pt}{80pt} &
\begin{sideways}\vn{not_a_lord\$}\end{sideways} &
\begin{sideways}\vn{group_lord\$}\end{sideways} &
\begin{sideways}\vn{girder_lord\$}\end{sideways} &
\begin{sideways}\vn{overlay_lord\$}\end{sideways} &
\begin{sideways}\vn{multipass_lord\$}\end{sideways} &
\begin{sideways}\vn{super_lord\$}\end{sideways}
\\ \hline
\multirow{5}*{\begin{sideways}\vn{ele%slave_status}\end{sideways}
%                           NL  GR  GI  O   M   S
& \vn{free\$}             & X & X & X & X & X & X \\ \hline
& \vn{group_slave\$}      & X & X & X & X & X & X \\ \hline
& \vn{overlay_slave\$}    & X & X & X & X & X & X \\ \hline
& \vn{multipass_slave\$}  & X &   &   &   &   & X \\ \hline
& \vn{super_slave\$}      & X &   &   &   &   &   \\ \hline
\end{tabular}


\begin{tabular}{llccccc} 
\hline
& \multicolumn{6){c}{\vn{ele1%lord_status}} \\ \hline
\rule{0pt}{80pt} &
\begin{sideways}\vn{not_a_lord\$\$}\end{sideways} &
\begin{sideways}\vn{group_lord\$}\end{sideways} &
\begin{sideways}\vn{girder_lord\$}\end{sideways} &
\begin{sideways}\vn{overlay_lord\$}\end{sideways} &
\begin{sideways}\vn{multipass_lord\$}\end{sideways} &
\begin{sideways}\vn{super_lord\$}\end{sideways}
\\ \hline
\multirow{5}*{\begin{sideways}\vn{ele2%slave_status}\end{sideways}
%                           NL  GR  GI  O   M   S
& \vn{free\$}             &   &   &   &   &   &   \\ \hline
& \vn{group_slave\$}      &   & X &   &   &   &   \\ \hline
& \vn{overlay_slave\$}    &   & X & X & X &   &   \\ \hline
& \vn{multipass_slave\$}  &   & X &   & X & X &   \\ \hline
& \vn{super_slave\$}      &   &   &   &   &   & X \\ \hline
\end{tabular}



In the example in
\sref{s:multipass}, Element \vn{A} would be a \vn{multipass_lord} and
\vn{A\B1} and \vn{A\B2} would be \vn{multipass_slave}s. When
superposition is combined with multipass, the elements in the tracking
part of the lattice will be \vn{super_slave}s.  These elements will be
controlled by \vn{super_lord}s which will also be
\vn{multipass_slave}s and these \vn{super_lord}/\vn{multipass_slave}
elements will be controlled by \vn{multipass_lord}s.

The possible values for \vn{%slave_status} are:
\index{free}\index{super_slave}
\index{overlay_slave}\index{multipass_slave}
\begin{example}
  free\$               No lords.
  multipass_slave\$    Has a multipass_lord.
  super_slave\$        Has one or more super_lords.
  overlay_slave\$      Has one or more overlay_lords.
  group_slave\$        Has one or more group_lords.
\end{example}


With \vn{%lord_status} equal to \vn{free\$}, the element is is not
controlled by any other element.

With \vn{%lord_status} equal to \vn{free\$}, the element does not have
any elements under its control. 


 



 \vn{lord_status}
(\sref{s:ele.control}) is one of \vn{overlay_lord}, \vn{girder_lord},
\vn{multipass_lord}, \vn{super_lord}, or \vn{Group_lord}.  



\index{routine!get_element_lord_list}
\index{routine!get_element_slave_list}
Generally anyone using \bmad routines will not need to bother with the
details of how elements control other elements. It is always safer to
use the bookkeeping routines provided by \bmad rather than directly
manipulating the control information. To simply find the slaves and
lords of a given element use the routines \vn{get_element_lord_list}
and \vn{get_element_slave_list}.  The following is thus meant for
those unusual situations where knowledge of how \bmad implements
control is needed.


The element control information is stored in the \vn{%control(:)} array, 
Each element of this array is a \vn{control_struct} structure 
\begin{example}
  type control_struct
    real(rp) coef                ! control coefficient
    integer ix_lord                ! index to lord element
    integer ix_slave               ! index to slave element
    integer ix_attrib              ! index of attribute controlled
  end type
\end{example}
\index{girder}
\index{overlay}
\index{group}
\vn{%ix_lord} and \vn{%ix_slave} give the indices in the \vn{%ele(:)}
array of a lord element and an element it controls. A lord element
\vn{%ele(i_lord)} has assigned to it a block \vn{%control(:)}
elements.  The following example prints the names and controlled
attributes of the slaves of a particular lord element. If the lord is
an \vn{Overlay} or \vn{Group} then \vn{%control(:)%ix_attrib} and 
\vn{%control(:)%coef} give the attribute index of the controlled
attribute and the appropriate  coefficient 
\begin{example}
  type (lat_struct) lattice
  ...
  ix1 = lattice%ele(i_lord)%ix1_slave  ! start of block
  ix2 = lattice%ele(i_lord)%ix2_slave  ! end of block
  print *, 'Slaves for lord: ', lattice%ele(i_lord)%name
  do i = ix1, ix2
    i_slave = lattice%control(i)%ix_slave
    if (lattice%ele(i_lord)%lord_status == super_lord$) then
      print *, '  ', i, '  ', lattice%ele(i_slave)%name
    else   ! must be overlay or slave
      ixa = lattice%control(i)%ix_attrib
      attrib_name = attribute_name (lattice%ele(i_slave), ixa)
      print *, '  ', i, '  ', lattice%ele(i_slave)%name, attrib_name
    endif
  enddo
\end{example}

Going backward from a slave to its lords goes through one level of
indirection using the \vn{%ic_} array as shown in the next example
\begin{example}
  ic1 = lattice%ele(i_slave)%ic1_lord
  ic2 = lattice%ele(i_slave)%ic2_lord
  print *, 'Lords for slave: ', lattice%ele(i_slave)%name
  do i = ic1, ic2
    ic = lattice%ic(i)
    i_lord = lattice%control(ic)%ix_lord
    print *, '  ', i, '  ', lattice%ele(i_lord)%name
  enddo
\end{example}
\index{group}
For historical reasons, since a \vn{Group} element only makes changes
in the values of the attributes it controls, \vn{Group} elements are
not included in the list of lords generated by the above example.

%----------------------------------------------------------------------------
\section{Bunch_start Component}
\label{s:lat.beam.start}

The \vn{lat%beam_start} component is a \vn{coord_struct} structure for
holding the information obtained from \vn{beam_start} statements
(\sref{s:beam.start}) in a \bmad lattice file.

This component is not used in any standard \bmad calculation. It is up
to an individual program to use as desired.

%----------------------------------------------------------------------------
\section{Finding Elements and Changing Attribute Values}
\label{s:lat.ele.change}

The routine \vn{lat_ele_locator} can be used to search for an element
in a lattice by name or key type or a combination of both. Example:
\begin{example}
  type (lat_struct) lat
  type (ele_pointer_struct), allocatable :: eles(:)
  integer n_loc;    logical err
  ...
  call lat_ele_locator ("quad:skew*", lat, eles, n_loc, err)
  do i = 1, n_loc  ! Loop over all elements found to match the search string.
    !! eles(i)%ele is a pointer to the i^th element found to match.
  enddo
\end{example}
This example finds all elements where \vn{ele%key} is \vn{quadrupole\$} 
and \vn{ele%name} starts with ``\vn{skew}''. See the documentation on 
\vn{lat_ele_locator} for more details on the syntax of the search string.

The \vn{ele_pointer_struct} array returned by \vn{lat_ele_locator} is
an array of pointers to \vn{ele_struct) elements
\begin{example}
  type ele_pointer_struct
    type (ele_struct), pointer :: ele => null()
  end type
\end{example}
The \vn{n_loc} argument is the number of elements found and the \vn{err} argument
is set True on a decode error of the search string.

Once an element (or elements) is identified in the lattice,
it's attributes can be altered. Care however, must be taken that an element's attribute
can be modified. Reasons why an attribute may not be modified include ...
Programs where attributes If the attribute 

changing an element attribute generally involves changing values in the 
\vn{%ele(i)%value(:)} array. This is done using the 
\vnr{set_ele_attribute} routine. For example:
\begin{example}
  type (lat_struct) lat
  logical err_flag, make_xfer_mat
  ...
  call element_locator ('Q01W', lat, ix_ele)
  call set_ele_attribute (lat, ix_ele, 'K1', 0.1_rp, err_flag, make_xfer_mat)
\end{example}
\index{overlay}
This example sets the \vn{K1} attribute of an element named \vn{Q01W}.
\vn{set_ele_attribute} checks whether this element is actually free to
be varied and sets the \vn{err_flag} logical accordingly. An element's
attribute may not be freely varied if, for example, the attribute is
controlled via an \vn{Overlay}.

\index{bmad_common_struct!auto_bookkeeper}
There is a global variable \vn{bmad_com%auto_bookkeeper} that 
controls whether bookkeeping routines are called by routines that do tracking
and routines that calculate transfer matrices. 
This is done to make sure that the control 
and attribute information in a lattice is
up--to--date. Since this bookkeeping needs only be done when element attributes
are changed, this can lead to a significant waste of time. Setting 
\vn{bmad_com%auto_bookkeeper} to \vn{.false.} turns off this
automatic bookkeeping.
As a result, if an attribute value is changed directly the appropriate bookkeeping
routines need to be called:
\begin{example}
  type (lat_struct) lat
  bmad_com%auto_bookkeeper = .false.
  lat%ele(ix_ele)%value(k1$) = 0.1
  call control_bookkeeper (lat, ix_ele)
\end{example}
Alternatively, if multiple elements are modified, then \vn{lattice_bookkeeper} can be
used to do bookkeeping for the entire lattice:
\begin{example}
  type (lat_struct) lat
  ... set some attributes ...
  call lattice_bookkeeper (lat)
\end{example}
