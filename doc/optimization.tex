\chapter{Optimization}
\label{c:opti}


%------------------------------------------------------------------------
\section{Lattice Corrections}

Examples of lattice corrections include flattening the orbit and
adjusting quadrupoles to correct the measured betatron phase. The
general idea is to vary an appropriate set of \vn{variables} with the
aim of minimizing a merit function \vn{M} that is a measure of how well the
model data fits the measured data
\Begineq
  {\cal M} = \sum_{\data:i} w_i 
    (\data\_\model(i) -  \data\_\meas(i))^2 + 
  \sum_{\var:j} w_j 
    (\var\_\model(j) - \var\_\meas(j))^2
  \label{m1}
\Endeq
\vn{data_model} is data as calculated from the model and
\vn{data_meas} is the actual measured data. \vn{var_model} is the
value of a variable in the \vn{model} and \vn{var_meas} is the value
as measured at the time the data was taken. The second term in the
merit function helps prevent degeneracies, or near degeneracies,
allowing \tao to find solutions where \vn{data_model} matches
\vn{data_measured} with the \vn{var_model} having ``unphysical''
values. The weights \vn{w_i} and \vn{w_j} need to be set depending
upon how accurate the data is and how accurate the calibrations for
measuring the \vn{var_measured} values are. With the second term in
the merit function the number of constraints (number of terms in the
merit function) is always larger than the number of variables so
degeneracies can never appear. The algorithm used for minimizing
\vn{M} is called an \vn{optimizer} and the \vn{run} command is used to
invoke a, \vn{optimizer}.

presumably, once a ``fit'' has been made, by varying the appropriate
\vn{variables} in the \vn{model} to minimize the merit function, the
model values of the \vn{variables} are the true values that existed
when the measurement is taken. Thus, if \vn{M} is reasonably small we 
believe:
\begin{example}
  var_model = var_actual
\end{example}
What is wanted is to have the \vn{variable} values equal to the
design. Therefore, to correct the lattice, the \vn{variables} need to
be changed by
\begin{example}
  var_change = var_final  - var_start
             = var_design - var_model
\end{example}
In other words
\begin{example}
  var_final = var_start + (var_design - var_model)
\end{example}
Notice that the fitting process is independent of the \vn{design}
lattice. It is only when calculating the corrections to the
\vn{variables} that the \vn{design} lattice plays a roll. 

Sometimes it is desired to fit to changes in data as opposed to the
absolute value of the data. For example, when closing an orbit bump
knob what is important is the difference in orbits before and
after the bump knob is varied. In this case the merit function becomes
\begin{alignat}{1}
  {\cal M} = &\sum_{\data:i} w_i 
    \left[ (\data\_\model(i) - \data\_\design(i)) - 
      (\data\_\meas(i) - \data\_\reference(i)) \right]^2 + \CRNO
  &\sum_{\var:j} w_j 
    \left[ (\var\_\model(j) - \var\_\design(j)) -
     (\var\_\meas(i) - \var\_\reference(i)) \right]^2 
  \label{m2}
\end{alignat}
This merit function is acceptable if the reference data is taken with
the machine reasonably near the design setup so that nonlinearities
can be ignored. If this is not the case then the fitting becomes a two
step process: The first step is to fit the \vn{model} to the \vn{reference}
data using the merit function of \Eq{m1}. The \vn{base} lattice is then
set equal to the \vn{model} lattice. The second
step is to fit the model using the merit function
\begin{alignat}{1}
  {\cal M} = &\sum_{\data: i} w_i 
    \left[ (\data\_\model(i) - \data\_\base(i)) - 
      (\data\_\meas(i) - \data\_\reference(i)) \right]^2 + \CRNO
  &\sum_{\var: j} w_j 
    \left[ (\var\_\model(j) - \var\_\base(j)) -
     (\var\_\meas(i) - \var\_\reference(i)) \right]^2 
  \label{m3}
\end{alignat}

Control of what data and what variables are to be used in the fitting
process is controlled by the \vn{use}, \vn{veto}, \vn{restore}, and
\vn{clip} commands.

%------------------------------------------------------------------------
\section{Lattice Design}

Lattice design is the process of calculating \vn{variable} strengths
to meet a number of criteria (called constraints). For example, one
constraint could be that the beta function in some part of the lattice
not exceed a certain value. In this case we can proceed as was done
for lattice correction and define a merit function to be minimized:
\Begineq
  {\cal M} = \sum_{\mbox{constraints} i} w_i \, C_i^2
\Endeq
\vn{C_i} is the constraint value which is dependent upon the \vn{class} of
the constraint:
\begin{description}
\item[target]
\Begineq
  C = (\mbox{Model} - \mbox{Target})
\Endeq
\item[min, abs\_min]
\Begineq
  C = 
    \begin{cases}
    0                               & \mbox{Model} > \mbox{Target} \\
    (\mbox{Model} - \mbox{Target})  & \mbox{Model} < \mbox{Target} 
    \end{cases}
\Endeq
\item[max, abs\_max]
\Begineq
  C = 
    \begin{cases}
    (\mbox{Model} - \mbox{Target})  & \mbox{Model} > \mbox{Target} \\ 
    0                               & \mbox{Model} < \mbox{Target}
    \end{cases}
\Endeq
\end{description}

%------------------------------------------------------------------------
\section{Constraints}
\label{s:cons}

To start the optimization either set \vn{p%opimizer_on} = T in the first section of
the input file or type 'X' while in manual mode. '.' (a period) will get you
out of auto mode back into manual mode. TOAD only checks once each loop to see
what you have typed so there will be a delay between typing '.' and getting
back to manual mode.

Optimization with TOAD is a lot like optimization with BMADZ.
There are two things that need to be set for optimization: The constraints
that determine the merit function and the variables that the optimizer can
vary in order to try to minimize the merit function.

The forth section of the input file gives the constrains. See the above
example. Valid constraints are given in Table~\ref{t:cons}.
In order to use a custom constraint someone must write the appropriate routine
and link it with the Toad program.


\begin{table}[h]
\centering
{\tt
\begin{tabular}{|l|l|} \hline
  {\it Constraint\_name}  & {\it Description} \\ \hline 
    beta           & Twiss parameter                        \\ \hline 
    alpha          & Twiss parameter                        \\ \hline 
    eta            & Dispersion                             \\ \hline 
    etap           & Dispersion derivative                  \\ \hline 
    phase          & Betatron phase                         \\ \hline 
    orbit          & Particle orbit                         \\ \hline 
    r56            & Term in linear transfer matrix         \\ \hline 
    t566           & Term in 2nd order transfer matrix      \\ \hline 
    var\_limit     & Variable outside set bounds            \\ \hline 
    inside\_wall   & Inside CESR tunnel wall                \\ \hline 
    outside\_wall  & Outside CESR tunnel wall               \\ \hline 
    tangent        & Floor position                         \\ \hline 
    position       & Floor position                         \\ \hline 
    s              & Longitudinal length constraint         \\ \hline 
    custom         & Custom constraint                      \\ \hline 
\end{tabular}
}
\caption{Constraint List.}
\label{t:cons}
\end{table}

The contribution to the merit function if a given constraint has a non-zero
contribution is
\Begineq
  \merit = \weight \cdot (\actual - \target)^2
\Endeq
Valid constraint types are given in Table~\ref{t:con_type}.
\begin{table}[h]
\centering
{\tt
\begin{tabular}{|l|l|} \hline
  {\it Constraint\_type}  & {\it Condition for non-zero contribution} \\ \hline 
    min           & $\actual < \target$      \\ \hline 
    max           & $\actual > \target$      \\ \hline 
    target        & $\actual \ne \target$    \\ \hline 
    abs\_min      & $|\actual| < \target$    \\ \hline 
    abs\_max      & $|\actual| > \target$    \\ \hline 
\end{tabular}
}
\caption{Constraint Type List.}
\label{t:con_type}
\end{table}

Note: For \vn{tangent_angle}, \vn{x_position}, \vn{z_position}, and
\vn{s_position} constraints: If there is a 2nd "where" then it is
assumed that the 1st "where" corresponds to an element of ring1 and
the 2nd "where" corresponds to an element of ring2.  The constraint is
evaluated by taking the difference of the constraint (\vn{tangent_angle},
\vn{x_position}, \vn{z_position}, or \vn{s_position}) between the two.
